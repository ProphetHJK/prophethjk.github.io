---
title: "MISRA C:2012 嵌入式C规范解读"
author: Jinkai
date: 2023-06-16 09:00:00 +0800
published: true
categories: [技术]
tags: [misra, MISRA C:2012]
---

## 总览

MISRA C 指南定义了一个 C 语言的子集，在这个子集中，犯错的机会被消除或减少，程序可靠性得到提高。

MISRA C 发展历史:

1. `MISRA C:1998` – 第一版（汽车行业的原始指南）
2. `MISRA C:2004` – 第二版（考虑了用户反馈和跨行业应用）
3. `MISRA C:2012` – 第三版（包含对 C99 语言功能的支持，改进的强类型模型，分析关键字）
   - `MISRA C:2012` (Feb 2019) – 第三版第一次修订（纳入了额外的安全准则），纳入了第 1 次修正案（AMD1）和技术更正 1（TC1） – 也称为 `MISRA C:2019`
   - `MISRA C:2023` (Apr 2023) – 第三版第二次修订（包含对 C11 和 C18 语言功能的支持），纳入了第 2 次（AMD2）、第 3 次（AMD3）和第 4 次（AMD4）修正案，以及技术更正 2（TC2）。

本文将介绍第三版的初稿，也就是`MISRA C:2012`。

## 背景

### C 语言优势

C 编程语言很受欢迎，因为：

- C 语言编译器可用于**许多处理器**；
- C 语言程序可被编译为**高效**的机器代码；
- 它由**国际标准**（ISO）定义；
- 它提供了访问目标处理器的输入/输出能力的机制，无论是**直接访问**还是通过**语言扩展**；
- 在关键系统中使用 C 语言有大量的**经验**；
- 它被**静态分析**和**测试工具**广泛支持。

### C 语言缺陷

#### 语言定义

ISO 标准并没有完全规范 C 语言，而是故意将某些方面放到**实现时**由程序员(编译器)自己去定义，从而让 C 语言变得更加灵活以支持不同的处理器。

这会导致某些行为变得不可预测，这对嵌入式领域的可靠性要求是致命的。

例子：

```c
if ( ishigh && (x == i++))
```

在上面这个例子中，该语句的执行会因编译器的不同产生不同的结果：

- `ishigh` 为否时，后一个表达式不判断，`i`不变
- `ishigh` 为否时，后一个表达式也判断，`i`增加 1

这就需要程序员对编译器特性非常熟悉(但还是避免不了失误)，且该代码的**可移植性**也会很差

#### 语言误用

编程过程中可能会出现连程序员自己也没发觉的失误：

```c
if (a == b) /* 判断a和b是否相等 */
if (a = b) /* 将b赋值给a，并判断a是否为非0 */
```

这种情况一般是把 `a == b` 误写成 `a = b` 了，但对编译器来说它们都合法，无法判断错误。

> 不过现在的静态检查工具在编程时就能检查出这种情况，给出 warning

#### 语言误解

C 语言有很多运算符，虽然标准规定了运算符的优先级，但比较难记忆，可能在编程中混淆了部分运算符的优先级。

C 语言不是强类型语言，其类型可以隐式转换，也就是操作产生的数据类型和操作数类型可能不同。

#### 运行时(Run-time)错误检查

C 语言程序可以被编译成小而有效的机器代码，但其代价是运行时检查的程度非常有限。

C 语言程序一般不提供对常见问题的运行时检查，如算术异常（如除以 0）、溢出、指针的有效性或数组边界错误。

C 语言的理念是，程序员有责任明确地进行这种检查。

## 工具选择

### C 标准和编译器选择

`MISRA C:2012` 基于`ISO/IEC 9899:2011 [14]`(C99)和`ISO/IEC 9899:1990 [2]`(C90)标准编写

根据项目需求选择 C99 或 C90 标准

> 写者注：原文的一些介绍已经过时，这里就不写了，比如他认为当前编译器对 C99 的支持普遍不好，实际上现在(2023 年)大多数的编译器都已经能较好的支持 C99 了，对于新项目，建议无脑选 `GCC` 就行

### 代码分析工具

> 写者注：本节将由写者根据项目经验列出推荐的工具

这里推荐使用开源的[cppcheck](https://cppcheck.sourceforge.io/)搭配[misra 插件](https://cppcheck.sourceforge.io/misra.php)，只需在安装 cppcheck 时勾选安装 addons，然后搭配 vscode 中的[cpp-check-lint](https://marketplace.visualstudio.com/items?itemName=QiuMingGe.cpp-check-lint)插件和规则描述文件(规则描述文件可以在 github 上找找，毕竟有版权不能随便共享)

当然如果有充足的资金可以选择购买专业的静态检查工具，[List of tools for static code analysis - Wikipedia](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis)网站上列出了所有主流的静态检查工具，搜索`"misra"`即可找到支持 misra 的检查工具。

## 必备知识

开发者应具备嵌入式、高集成、高安全性编程基础，并了解使用的编译器和静态检查工具。

## 使用 MISRA C

MISRA C 应该从项目一开始便使用，如果是为了符合 MISRA C 而对已有项目大规模修改会造成不可预估的问题，注意评估好这么做的风险。

因在代码审核和单元测试前检查代码是否符合 MISRA C。

MISRA C 不提供任何与**编程风格**相关的建议。

注意编译器优化选项，平衡目标文件大小和缺陷风险。

### 偏离标准

允许为了某些特殊情况偏离标准，比如将 int 类型值强制转为指针来实现访问内存地址空间映射的 I/O 端口:

```c
// 内存中的0x0002地址内数据映射了某一I/O端口数据
#define PORT (*(volatile unsigned char *)0x0002)
// 修改该位置数据就相当于修改了该I/O端口数据
PORT = 0x10u;
```

需要有专门的方式记录这种不得不违反 MISRA C 的地方。最好不要有这种地方。

## 准则介绍

每项 MISRA C `准则(guidelines)`都被分为 "`规则(Rule)`"或 "`指示(Directive)`":

指示是指无法提供必要的完整描述来进行合规性检查的准则。为了能够执行检查，需要额外的信息，如设计文档或需求规格中可能提供的信息。静态分析工具可以帮助检查是否符合指示，但不同的工具对不符合指示的解释可能大相径庭。

规则是对要求进行完整描述的准则。检查源代码是否符合规则应该是可能的，而不需要任何其它信息。特别是，静态分析工具应该能够检查规则的合规性，但必须遵守第 6.5 节中描述的限制。

> 注意后续的准则、规则、指示名词

### 准则分类

每条准则被分为:

- `强制(mandatory)`：不允许违反
- `必要(required)`：只有在有明确限制、要求和预防措施的偏离情况下才能违反
- `建议(advisory)`：在合理可行的范围内遵循建议

他们的重要程度相同，区别只是是否允许[偏离标准](#偏离标准)

### 可判定性(Decidability)

规则(Rule)分为`可判定的(decidable)`和`不可判定的(undecidable)`:

- 可判定的: 可由静态分析工具明确给出是否符合 MISRA C 的结论(是或否)
- 不可判定的: 不能给出明确结论，比如有些需要在编译、连接阶段或运行时才能分析出

### 分析的作用域(Scope)

规则(Rule)的分析的作用域分为`单一翻译单元(Single Translation Unit)`和`系统(System)`

也就是根据各种变量、函数的作用域来确定规则分析时的作用域。

```c
extern void f(uint16_t *p);
uint16_t y;
void g(void)
{
    uint16_t x; /* x is not given a value */
    f(&x);      /* f might modify the object pointed to by its parameter */
    y = x;      /* x may or may not be unset */
}
```

### 多来源项目

项目中的代码来源于多个公司(组织)：

- 标准库来源于编译器
- 底层驱动来源于设备厂家
- 操作系统和上层驱动来源于特定供应厂家
- 应用代码来自于其他厂家

特别是标准库和底层代码为了高性能会用到很多汇编以及偏离准则部分，这部分不需要不用符合 MISRA C 规范。

其他代码尽可能符合 MISRA C，如果推动第三方厂家配合较为困难，至少头文件(接口)要符合 MISRA C。

### 自动生成的代码

项目中自动生成的代码也需要遵守 MISRA C

### 准则格式

| Ident      | Requirement text   |            |
| :--------- | :----------------- | ---------: |
|            |                    | Source ref |
| Category   | Category           |            |
| Aanalysis  | Decidability,Scope |            |
| Applies to | Cxx                |            |

- Ident: 准则的唯一序号
- Requirement text: 准则文本
- Source ref: 参考来源
- Category: [准则分类](#准则分类)
- Decidability: [可判定性(Decidability)](#可判定性decidability)，指示(Directive)无该选项
- Scope: [分析的作用域(Scope)](#分析的作用域scope)，指示(Directive)无该选项
- Cxx: C 标准(C90、C99)

### 引用来源

#### ISO C

MISRA C 引用了 C90 和 C99，注意以下的一些行为：

- `Unspecified`: **未明确行为**是指在 C 语言标准中**没有明确**规定其具体行为的情况。这意味着编译器可以根据实现的特定规则来定义其行为，但在不同的编译器或平台上可能会有不同的结果。如 `x=f(&a)+g(&a)`，f 与 g 的执行顺序是`未明确的`，而且其执行顺序可能影响到 x 的最终结果。
- `Undefined`: **未定义行为**是指当程序**违反**了 C 语言标准规范，导致编译器无法确定其具体行为时发生的情况。例如，对指针进行未初始化的解引用、数组越界访问、除以零等操作都属于未定义行为。最重要的是编译器没有责任去检查这些错误，导致这些问题无法在编译阶段暴露。
- `Implementation-defined"`: **实现定义行为**是指 C 语言标准规定了**多个**可能的行为，但具体的行为由编译器或平台的实现决定。这意味着在不同的编译器或平台上，同一段代码可能会有不同的行为，但这些行为都是符合标准的。应尽量避免该行为来保证代码在不同编译器上的一致性和可移植性。
- `Locale`: 本地化行为，和 C 语言的本地化相关，比如字符的使用习惯、日期格式等，这里不涉及。

## 指示(Directives)

TODO

## 规则(Rule)

### 组别 1: 标准 C 环境

#### Rule 1.1

(必要) 程序不得违反标准 C 语法和约束，并且不得超出具体实现的编译限制

一般不做静态检查，由编译器保证

#### Rule 1.2

(建议) 不应该使用语言扩展

但是嵌入式领域中一般都需要用到语言扩展，因为其对于性能的要求可能会高于可移植性，如果需要偏离标准，需要在文档中列出所使用的所有语言扩展。

#### Rule 1.3

(必要) 不得发生未定义或严重的未指定行为

见[ISO C](#iso-c)，这些行为都由后续的准则来避免，不需要特意检查本准则。

### 组别 2: 未使用的代码

关于 Rule 2.3-2.7 对于未使用的一些声明，审核者难以判断到底是真的没用到，还是该用到的时候误用了其他的声明。为了避免歧义，直接禁止使用未用到的声明，这样就可以直接判断所有未用到的声明都是因为误用导致的。

#### Rule 2.1

(必要) 项目不得包含不可达代码(unreachable code)

原因是这些代码会占用资源：

- 它占用了目标机器内存中的空间(包括代码空间)；
- 它的存在可能导致编译器在围绕不可达代码传输控制时选择更长、更慢的跳转指令；
- 在循环中，它可能导致整个循环无法驻留在指令缓存中。

以下是原则：

1. 如果代码属于预编译前的，预编译后不存在，则无需适用本规则。
2. 如果这类代码是防御性编程的一部分，目的是防御未定义行为，那根本不需要防御这种错误，因为这由[Rule 1.3](#rule-13)所要求的程序中不能存在未定义行为的准则保证。
3. 如果是为了防御其他重要故障(如硬件故障、内存被意外覆盖)，那是有必要存在的，有两种措施：

   - [偏离标准](#偏离标准)
   - 让编译器认为该分支可达从而防止部分 case 语句被优化掉，一般通过将参数转为易失性访问(volatile access)的左值(lvalue)：

   观察下面代码，可以确定“x”永远不会具有“Err_2”的值，可能编译器也可以识别到，甚至可能识别到也不会具有 “Err_1”的值，f(5)返回的值将始终具有 “Success” 的值。所以 case Err_2 和 case Err_1 可能会被部分编译器优化掉。

   ```c
   #include "stdafx.h"
   typedef enum ErrStatus {
       Success = 0,
       Err_1,
       Err_2
   } ErrStatus;

   ErrStatus f(int x) {
       if (x < 0) {
           return Err_1;
       }
       else
       {
           return Success;
       }
   }

   int main()
   {
       ErrStatus x = f(5);
       switch (x)
       {
       case Err_1:
           printf("err 1"); break;
       case Err_2:
           printf("err 2 "); break;  /* Is this dead code ? */
       default:
           printf("Success"); break;
       }
   }
   ```

   虽然逻辑上不可达，但为了防御可能产生的硬件错误导致的值的变更，或者 x 所在的内存地址的数据被意外覆盖，该分支不能被优化，所以通过使用`*(volatile ErrStatus *)&x`的方式将 x 转为 vollatile 类型的左值，强制编译器不对该值做任何假定(让编译器认为 switch 的参数是一段 volatile 内存空间而不是 x 变量，作为内存空间其就有可能为任何值，而不是与变量 x 的逻辑关系绑定。)

   ```c
   switch (*(volatile ErrStatus *)&x)
   ```

#### Rule 2.2

(必要) 不得有无效代码(dead code)

也可以叫冗余的代码，也就是删除后不会对程序产生任何影响的代码。

语言扩展不属于无效代码，因为其总是有明确意义的。

注意未使用代码不是无效代码，区别是未使用代码本身就不会被执行到，而无效代码是能被执行到的。

```c
void g(void)
{
    // 空操作，但g()函数不是无效代码，因为它会被h()调用到
    // 删除后程序编译就无法通过
}
void h(void)
{
    g(); // 无效代码，因为其没有明确意义，删除对程序无影响
    __asm("NOP"); // 有效，虽然和g()一样是空操作，但这是语言扩展，其有明确意义(一个延迟操作)。
}
```

```c
extern volatile uint16_t v;
extern char *p;
void f(void)
{
    uint16_t x;
    (void)v;     /* Compliant - 这种方式用于抑制编译器的未使用告警，是有意义的
                              ，如果删除就会产生编译器告警，不视为dead code */
    (int32_t) v; /* Non-compliant - the cast operator is dead */
    v >> 3;      /* Non-compliant - the >> operator is dead */
    x = 3;       /* Non-compliant - the = operator is dead
                * - x is not subsequently read */
    *p++;        /* Non-compliant - result of * operator is not used */
    (*p)++;      /* Compliant - *p is incremented */
}
```

#### Rule 2.3

(建议) 项目不应包含未被使用的类型(type)声明

```c
int16_t unusedtype(void)
{
    typedef int16_t local_Type; /* Non-compliant */
    return 67;
}
```

#### Rule 2.4

(建议) 项目不应包含未被使用的类型标签(tag)声明

```c
void unusedtag(void)
{
    enum state { S_init, S_run, S_sleep }; /* Non-compliant,一个匿名 enum，但 state 标签未被使用 */
}
```

```c
typedef struct record_t /* Non-compliant，因为record_t这个标签后面没用到 */
{
    uint16_t key;
    uint16_t val;
} record1_t;
typedef struct
{
    uint16_t key;
    uint16_t val;
} record2_t;

// 如果想要上面的示例合规：
// 方式一：需要修改record2_t声明用到这个tag
typedef struct record_t record2_t;
// 方式二：去掉record1_t声明时的标签
typedef struct
{
    uint16_t key;
    uint16_t val;
} record1_t;
```

> 关于标签的使用方式，可见[C 语言中结构体标签的使用](https://blog.csdn.net/skysky97/article/details/122730127)

#### Rule 2.5

(建议) 项目不应包含未被使用的宏(macro)声明

```c
void use_macro(void)
{
#define SIZE 4
/* Non-compliant - DATA not used */
#define DATA 3
    use_int16(SIZE);
}
```

#### Rule 2.6

(建议) 函数不应包含未被使用的执行标签(label)声明

```c
void unused_label(void)
{
    int16_t x = 6;
label1: /* Non-compliant */
    use_int16(x);
}
```

#### Rule 2.7

(建议) 函数中不应有未使用的参数

大多数函数都会指定使用每个参数。如果函数参数未被使用，则可能是函数的实现与其规格不符。本规则强调了这种潜在的不匹配。

```c
void withunusedpara(uint16_t * para1,
                    int16_t unusedpara) /* Non-compliant - unused */
{
    *para1 = 42U;
}
```

### 组别 3

#### Rule 3.1

(必要) 字符序列“`/*`”和“`//`”不得在注释中使用

如果在 `/* */`风格注释中出现“`/*`”和“`//`”，可能原因是确实需要，还有可能是因为漏写了'`*/`'，为了避免混淆就禁止该写法。

例外情况是允许在“`//`”风格注释中使用“`//`”

错误，漏写了`*/`，导致函数被注释无法执行：

```c
/* some comment, end comment marker accidentally omitted
Perform_Critical_Safety_Function( X );
/* this comment is non-compliant */
```

修正：

```c
/* some comment, end comment marker accidentally omitted */
Perform_Critical_Safety_Function( X );
/* this comment is non-compliant */
```

错误，产生歧义，`+ z`这行可能被注释掉：

```c
x = y // /*
    + z
    // */
    ;
```

#### Rule 3.2

(必要) “`//`”注释中不得使用换行(即“`//`”注释中不得使用行拼接符“`\`”)

错误，`if(b)`这行直接变成了注释：

```c
extern bool_t b;
void f(void)
{
    uint16_t x = 0; // comment \
    if (b)
    {
        ++x; /* This is always executed */
    }
}
```

### 组别 4

#### Rule 4.1

(必要) 八进制和十六进制转译序列应有明确的终止识别标识

防止混淆如'`\x1f`'和'`\x1`'+'`f`'。

```c
const char *s1 = "\x41g"; /* Non-compliant */
const char *s2 = "\x41" "g"; /* Compliant - 使用分隔的方式终止 */
const char *s3 = "\x41\x67"; /* Compliant - 使用\x终止 */
int c1 = '\141t';            /* Non-compliant */
int c2 = '\141\t';           /* Compliant - 使用\t终止 */
```

#### Rule 4.2

(建议) 禁止使用三字符组(trigraphs)

trigraphs 的定义见[C99] 5.2.1.1，代码中由 3 个字符表示，由编译器在预处理阶段转义为特定单个字符：

```console
??= #   ??( [   ??/ \
??) ]   ??' ˆ   ??< {
??! |   ??> }   ??- ˜
```

比如想用`??-??-??`表示一个日期的示例，但编译器会将这个字符串转义：

```c
const char * datestring = "(Date should be in the form ??-??-??)";
```

### 组别 5

#### Rule 5.1

(必要) 全局标识符不得重名

在 C99 中规定全局标识符的有效识别长度为 31 个字符(是否大小写敏感取决于编译器)，也就是前 31 个字符需要唯一，才能区分两个全局标识符表示不同的项。

当前 31 个字符相同时(即使后面字符不同)，行为未定义。

```c
/*      1234567890123456789012345678901********* Characters */
int32_t engine_exhaust_gas_temperature_raw;
int32_t engine_exhaust_gas_temperature_scaled; /* Non-compliant,两个变量名的前31个字符相同 */
/*      1234567890123456789012345678901********* Characters */
int32_t engine_exhaust_gas_temp_raw;
int32_t engine_exhaust_gas_temp_scaled; /* Compliant */
```

大小写不敏感时以下示例也不合法：

```c
/* file1.c */
int32_t abc = 0;

/* file2.c */
int32_t ABC = 0;
```

#### Rule 5.2

(必要) 同作用域(scope)和命名空间内的标识符不得重名

和 Rule 5.1 中的全局标识符情况类似，只不过全局标识符的作用域为全局，包含了所有非全局作用域。

C99 中非全局(包括局部全局和局部)标识符的有效识别字符数量为 63 个，C90 为 31 个。

为了和 C90 兼容，建议在使用中有效识别字符规定降为 31 个，后面都以 31 个字符上限为例。

```c
/*             1234567890123456789012345678901********* Characters */
extern int32_t engine_exhaust_gas_temperature_raw;
static int32_t engine_exhaust_gas_temperature_scaled; /* Non-compliant，和 engine_exhaust_gas_temperature_raw
                                                       * 位于同一个命名空间，前31个字符相同违规 */
void f(void)
{
    /*      1234567890123456789012345678901********* Characters */
    int32_t engine_exhaust_gas_temperature_local; /* Compliant，本局部作用域内其唯一，但其实覆盖了其他外面的标识符，
                                                   * 符合5.2但不符合5.3 */
}
/*             1234567890123456789012345678901********* Characters */
static int32_t engine_exhaust_gas_temp_raw;
static int32_t engine_exhaust_gas_temp_scaled; /* Compliant */
```

参考：<https://blog.csdn.net/qq_30867841/article/details/90170446>

#### Rule 5.3

(必要) 内部声明的标识符不得隐藏外部声明的标识符

如果在内层作用域中声明了标识符，但该标识符与外层作用域中已存在的标识符不一致，那么最内层的声明将 "**隐藏**"外层的声明。这可能会引起开发人员的混淆。

注意：在一个命名空间中声明的标识符**不会隐藏**在另一个命名空间中声明的标识符（但违反 Rule 5.9）。所以隐藏只发生在有层次包含关系的作用域中。编写本规则的原因不同于 Rule 5.1 和 Rule 5.2 的未定义行为，只是为了防止这种隐式的覆盖导致的混淆。

外作用域和内作用域的定义如下：

- 具有文件作用域的标识符可视为具有最外层的作用域；
- 具有块作用域的标识符具有更内层的作用域；
- 连续嵌套的块引入了更多的内层作用域

```c
void fn1(void)
{
    int16_t i; /* Declare an object "i" */
    {
        int16_t i; /* Non-compliant - hides previous "i" ，第三种情况连续嵌套块*/
        i = 3;     /* Could be confusing as to which "i" this refers */
    }
}
struct astruct
{
    int16_t m;
};
extern void g(struct astruct *p);
int16_t xyz = 0;             /* Declare an object "xyz" */
void fn2(struct astruct xyz) /* Non-compliant - outer "xyz" is
                              * now hidden by parameter name */
{
    g(&xyz);
}
uint16_t speed;
void fn3(void)
{
    typedef float32_t speed; /* Non-compliant - type hides object */
}
```

#### Rule 5.4

(必要) 宏名称不得重名

如果两个宏名称仅在非标识字符上（类似 Rule 5.2 在 C99 中也是 63 个字符）存在差异，则行为未定义。

下面也是以 31 个标识字符为例：

```c
/*      1234567890123456789012345678901********* Characters */
#define engine_exhaust_gas_temperature_raw egt_r
#define engine_exhaust_gas_temperature_scaled egt_s /* Non-compliant */
/*      1234567890123456789012345678901********* Characters */
#define engine_exhaust_gas_temp_raw egt_r
#define engine_exhaust_gas_temp_scaled egt_s /* Compliant */
```

#### Rule 5.5

(必要) 宏名称与其他标识符不得重名

该规则要求**预处理前**存在的宏名称必须与**预处理后**存在的标识符不同(因为预编译后宏本来就不存在了)。该规则的原因并非之前 5.1、5.2 和 5.4 提到的重名未定义问题，主要是为了避免产生混淆

下面的不合规，本规则中宏名称指的是不包含括号的部分，也就是宏名称是`Sum`而不是`Sum(x, y)`，所以它们重名了：

```c
#define Sum(x, y) ( ( x ) + ( y ) )
int16_t Sum;
```

以下不合规，因为它们重名(按照 31 个字符的标准)了：

```c
/*             1234567890123456789012345678901********* Characters */
#define        low_pressure_turbine_temperature_1 lp_tb_temp_1
static int32_t low_pressure_turbine_temperature_2;
```

#### Rule 5.6

(必要) typedef 名称应是唯一标识符

typedef 名称在所有名称空间和翻译单元中都必须是唯一的。只有当 typedef 是在头文件中进行的，且该头文件被包含在多个源文件中时，本规则才允许重复声明同一 typedef 名。

包括和另一个 typedef 名称相同，以及和其他的标识符(见 Rule 5.2)名称相同，目的是防止重复的命名产生混淆。

例外：typedef 名称可以与与本 typedef 相关的 struct、union 或 enum 的 tag 名称相同。

```c
void func(void)
{
    {
        typedef unsigned char u8_t;
    }
    {
        typedef unsigned char u8_t; /* Non-compliant - reuse */
    }
}
typedef float mass;
void func1(void)
{
    float32_t mass = 0.0f; /* Non-compliant - reuse */
}
typedef struct list
{
    struct list *next;
    uint16_t element;
} list; /* Compliant - 例外 */
typedef struct
{
    struct chain
    {
        struct chain *list;
        uint16_t element;
    } s1;
    uint16_t length;
} chain; /* Non-compliant - tag "chain" not
          * associated with typedef */
```

#### Rule 5.7

(必要) 标签(tag)名称应是唯一标识符

同 Rule 5.6

例外：tag 名可以和与之相关的 typedef 名称相同(见 Rule 5.6 例外)

```c
struct stag
{
    uint16_t a;
    uint16_t b;
};
struct stag a1 = {0, 0}; /* Compliant - compatible with above */
union stag a2 = {0, 0};  /* Non-compliant - declares different type
                          * from struct stag.
                          * Constraint violation in C99 */
```

```c
struct deer
{
    uint16_t a;
    uint16_t b;
};
void foo(void)
{
    struct deer
    {
        uint16_t a;
    }; /* Non-compliant - tag "deer" reused */
}
typedef struct coord
{
    uint16_t x;
    uint16_t y;
} coord; /* Compliant by Exception */
struct elk
{
    uint16_t x;
};
struct elk /* Non-compliant - declaration of different type
            * Constraint violation in C99 */
{
    uint32_t x;
};
```

#### Rule 5.8

(必要) 全局(external linkage)对象和函数的标识符应是唯一的

作为全局标识符使用的标识符不得在任何名称空间或翻译单元中用于任何**其他目的**，即使该标识符表示的对象没有任何联系

与 Rule 5.1 的区别是这个针对于全局标识符和局部标识符之间的冲突，而不是全局和全局之间的冲突(未定义行为)。

```c
/* file1.c */
int32_t count; /* "count" has external linkage，全局变量 */
void foo(void) /* "foo" has external linkage，全局函数 */
{
    int16_t index; /* "index" has no linkage */
}

/* file2.c */
static void foo(void) /* Non-compliant - "foo" is not unique
                       * (it is already defined with external
                       * linkage in file1.c)，将全局函数foo用于
                       * 了其他目的 */
{
    int16_t count; /* Non-compliant - "count" has no linkage
                    * but clashes with an identifier with
                    * external linkage */
    int32_t index; /* Compliant - "index" has no linkage */
}
```

#### Rule 5.9

(建议) 局部全局(internal linkage)对象和函数的标识符应是唯一的

其实类似于 Rule 5.8，局部全局的意思就是用`static`修饰的对象或函数。两种情况：

- 两个文件中的局部全局对象或函数重名
- 同个文件中局部全局对象或函数名称被用于其他目的，如函数内声明的变量。

本条规则属于**建议**，因为不同于 Rule 5.8，实际上两个文件之间的局部全局对象或函数并没有实际关系，发生混淆的情况并不会多。

```c
/* file1.c */
static int32_t count; /* "count" has internal linkage */
static void foo(void) /* "foo" has internal linkage */
{
    int16_t count; /* Non-compliant - "count" has no linkage
                    * but clashes with an identifier with
                    * internal linkage */
    int16_t index; /* "index" has no linkage */
}
void bar1(void)
{
    static int16_t count; /* Non-compliant - "count" has no linkage
                           * but clashes with an identifier with
                           * internal linkage */
    int16_t index;        /* Compliant - "index" is not unique but
                           * has no linkage */
    foo();
}
/* End of file1.c */

/* file2.c */
static int8_t count;  /* Non-compliant - "count" has internal
                       * linkage but clashes with other
                       * identifiers of the same name */
static void foo(void) /* Non-compliant - "foo" has internal
                       * linkage but clashes with a function of
                       * the same name */
{
    int32_t index;  /* Compliant - both "index" and "nbytes" */
    int16_t nbytes; /* are not unique but have no linkage */
}
void bar2(void)
{
    static uint8_t nbytes; /* Compliant - "nbytes" is not unique but
                            * has no linkage and the storage class is
                            * irrelevant */
}
/* End of file2.c */
```

### 组别 6

#### Rule 6.1

(必要) 位域(Bit-fields)仅允许使用适当的类型来声明(位域成员类型限制)

允许的位域类型是

- C90: 无符号 int 或有符号 int；
- C99: 以下类型之一：
  - 无符号 int 或有符号 int；
  - 实现允许的另一种显式有符号或显式无符号整数类型；
  - \_Bool。

注意：允许使用 typedef 来指定适当的类型

int 是由**实现定义**的，因为 int 类型的位可以是有符号或无符号的，所以不能直接使用 int 作为位域类型。

在 C90 中，不允许在位元组中使用 enum、short、char 或任何其他类型，因为其行为是未定义的；在 C99 中，实现可以定义其他允许在位元组声明中使用的整数类型。

```c
typedef unsigned int UINT_32;

struct s
{
    unsigned int b1:2; /* Compliant */
    int          b2:2; /* Non-compliant - plain int not permitted */
    UINT_32      b3:2; /* Compliant     - typedef designating unsigned int */
    signed long  b4:2; /* Non-compliant - even if long and int are the same size */
                        /* C90: always non-compliant                              */
                        /* C99: non-compliant if "signed long" is not a permitted
                                by implementation                                 */
};
```

#### Rule 6.2

(必要) 单比特(single-bit)位域成员不可声明为有符号类型

有符号类型的首位用于表示符号，单 bit 情况下无法表示有符号类型(符号+值至少两 bit)

注意：本规则不适用于未命名的位字段，因为无法访问它们的值。

### 组别 7

#### Rule 7.1

(必要) 禁止使用八进制常数

C 语言中表示八进制就是在数字前加个`0`，比如`052`表示十进制的`42`。但编程时可能误认为是十进制的，产生混淆。

注意：此规则不适用于八进制转义序列，因为使用前导 `\` 字符意味着混淆的范围较小

例外：单个数字 0 在定义上是八进制的 0，当然理解成十进制的 0 也没什么关系，所以允许这种情况。

```c
extern uint16_t code[10];
code[1] = 109; /* Compliant - decimal 109 */
code[2] = 100; /* Compliant - decimal 100 */
code[3] = 052; /* Non-Compliant - decimal 42 */
code[4] = 071; /* Non-Compliant - decimal 57 */
```

#### Rule 7.2

(必要) 后缀“u”或“U”应使用于所有无符号的整数常量

> 注意：常量不是常变量(const 修饰的叫常变量)

本规则适用于：

- 出现在 `#if` 和 `#elif` 预处理指令控制表达式中的整数常量；
- 预处理后存在的任何其他整数常量

注意：预处理期间，整数常量的类型的确定方式与预处理后相同，只是：

- 所有有符号整数类型的行为就像它们是 long(C90)或 intmax_t(C99)；
- 所有无符号整数类型的行为就像它们是 unsigned(C90)或 uintmax_t(C99)。

整数常量的类型可能会引起混淆，因为它取决于一系列复杂的因素，包括：

- 常量的大小；
- 整数类型的实现大小；
- 是否存在任何后缀；
- 表示值的数基（即十进制、八进制或十六进制）

例如，整数常量 40000 在 32 位环境中属于带符号 int 类型，但在 16 位环境中属于 signed long 类型。数值 0x8000 在 16 位环境中属于 unsigned int 类型，但在 32 位环境中属于 signed int 类型。

在 2-bit int 和 64-bit long 环境中：

```c
void R_7_2(void)
{
    use_int32(2147483647);   /* int constant */
    use_int32(0x7FFFFFFF);   /* int constant */
    use_int64(2147483648);   /* long constant */
    use_uint32(2147483648U); /* unsigned int constant */
    use_uint32(0x80000000);  /* unsigned int constant -  Non-compliant */
    use_uint32(0x80000000U); /* unsigned int constant */
}
```

#### Rule 7.3

(必要) 小写字符“l”不得作为常量的后缀使用(仅可使用“L”)

避免与“l”(字母)与“1”(数字)产生歧义。

```c
const int64_t a = 0L;
const int64_t b = 0l;        /* Non-compliant */
const uint64_t c = 0Lu;
const uint64_t d = 0lU;      /* Non-compliant */
const uint128_t e = 0ULL;
const uint128_t f = 0Ull;     /* Non-compliant */
const int128_t g = 0LL;
const int128_t h = 0ll;      /* Non-compliant */
const float128_t m = 1.2L;
const float128_t n = 2.4l;   /* Non-compliant */
```

#### Rule 7.4

(必要) 除非对象的类型为“指向 const char 的指针”，否则不得将字符串常量赋值给该对象

常量存放在不可修改的内存区域，如果被可修改的 char 指针指向，如果对其修改，就会产生错误。

```c
extern void f1(char *s1);

extern void f2(const char *s2);

static void g2(void)
{
    f1("string"); /* Non-compliant，形参为非const，实参是字符串常量 */
    f2("string"); /* Compliant     */
}

static char *name1(void)
{
    return ("MISRA"); /* Non-compliant，返回参数类型非const */
}

static const char *name2(void)
{
    return ("MISRA"); /* Compliant*/
}

void R_7_4(void)
{
    char *s = "string"; /* Non-compliant */

    const volatile char *p = "string"; /* Compliant     */

    "0123456789"[0] = '*'; /* Non-compliant，未定义行为 */

    g2();
    (void)name1();
    (void)name2();

    use_const_char_ptr(s);
    use_const_volatile_char_ptr(p);
}
```

### 组别 8

#### Rule 8.1

(必要) 类型须明确声明

C90 标准允许在某些情况下省略类型，在这种情况下，int 类型是隐式指定的。可能使用隐式 int 的情况举例如下：

- 对象声明；
- 参数声明；
- 成员声明；
- 类型定义声明；
- 函数返回类型。

但省略会引起混淆。

```c
extern x;            /* Non-compliant - implicit int type */
extern int16_t x_ok; /* Compliant - explicit type */

extern f(void);            /* Non-compliant - implicit int return type */
extern int16_t f_ok(void); /* Compliant */

extern void g(char c, const k);              /* Non-compliant - implicit int for parameter k */
extern void g_ok(char c2, const int16_t k2); /* Compliant */

typedef (*pfi)(void);            /* Non-compliant - implicit int return type */
typedef int16_t (*pfi_ok)(void); /* Compliant */

typedef void (*pfv)(const x);       /* Non-compliant  - implicit int for parameter x */
typedef void (*pfv_ok)(int16_t xx); /* Compliant */

void R_8_1(void)
{
    const y;            /* Non-compliant - implicit int type */
    const int16_t y_ok; /* Compliant     - explicit type */

    struct
    {
        int16_t x1; /* Compliant */
        const y1;   /* Non-compliant - implicit int for member y */
    } s =
        {1, 2};

    pfi F1 = &get_int32;
    pfi_ok F2 = &get_int16;

    pfv F11 = &use_int32;
    pfv_ok F22 = &use_int16;

    F11(F1() + s.y1);
    F22(F2() + s.x1);
}
```

#### Rule 8.2

(必要) 函数类型应为带有命名形参的原型形式

C 语言的早期版本通常被称为 K&R C [30]，它没有提供根据相应参数检查参数个数或参数类型的机制。对象或函数的类型在 K&R C 中无需声明，因为对象的默认类型和函数的默认返回类型都是 int。

C90 标准引入了**函数原型**，这是一种声明参数类型的函数声明器。这样就可以根据参数类型检查参数类型。它还允许对参数个数进行检查，除非函数原型规定参数个数是可变的。出于与现有代码向后兼容的考虑，C90 标准没有要求使用函数原型。出于同样的原因，它继续允许省略类型，在这种情况下，类型默认为 int

C99 标准从语言中删除了默认的 int 类型，但继续允许 K&R 风格的函数类型，即在声明中不提供参数类型信息，而在定义中提供参数类型信息则是可选的。

参数数量、参数类型以及函数的预期返回类型和实际返回类型之间的不匹配有可能导致未定义的行为。本规则以及规则 8.1 和规则 8.4 的目的是通过要求明确说明参数类型和函数返回类型来避免这种未定义的行为。规则 17.3 确保在函数调用时可以获得这些信息，从而要求编译器对检测到的任何不匹配进行诊断。

该规则还要求为声明中的所有参数**指定名称**。参数名称可以提供有关函数接口的有用信息，如果声明和定义不匹配，则可能表明存在编程错误。

注意：空参数列表在原型中无效。如果函数类型没有参数，其原型形式将使用关键字 void。所以不允许空参数情况，函数原型至少加上 void。

```c
/* Compliant */
extern int16_t func1(int16_t n);
/* Non-compliant - parameter name not specified */
extern void func2(int16_t);
/* Non-compliant - not in prototype form */
static int16_t func3();
/* Compliant - prototype specifies 0 parameters */
static int16_t func4(void);
/* Compliant */
int16_t func1(int16_t n)
{
    return n;
}
/* Non-compliant - old style identifier and declaration list */
static int16_t func3(vec, n)
int16_t *vec;
int16_t n;
{
    return vec[n - 1];
}
```

```c
/* Non-compliant - no prototype */
int16_t (*pf1)();
/* Compliant - prototype specifies 0 parameters */
int16_t (*pf1)(void);
/* Non-compliant - parameter name not specified */
typedef int16_t (*pf2_t)(int16_t);
/* Compliant */
typedef int16_t (*pf3_t)(int16_t n);
```

#### Rule 8.3

(必要) 对象或函数的所有声明均应使用相同的名称和类型限定符

> 这个规定不包括存储类说明符(Storage-class specifier)。
>
> 见 [C99] 6.7.1 Storage-class specifiers
>
> storage-class-specifier:
>
> - typedef
> - extern
> - static
> - auto
> - register

在同一对象或函数的声明中一致地使用类型和限定符，可以加强类型化。在函数原型中指定参数名，可以检查函数**定义**与其**声明**的接口是否一致

例外：同一基本类型的兼容版本可以互换使用。例如，int、signed 和 signed int 都是**等价**的，它们被视为同名。

```c
extern void f(signed int);
void f(int); /* Compliant - Exception ，但违反8.2，没有参数名*/
extern void g(int *const);
void g(int *); /* Non-compliant - type qualifiers */

extern int16_t func(int16_t num, int16_t den);
/* Non-compliant - parameter names do not match */
int16_t func(int16_t den, int16_t num)
{
    return num / den;
}
```

```c
typedef uint16_t width_t;
typedef uint16_t height_t;
typedef uint32_t area_t;
extern area_t area(width_t w, height_t h);
// 不合规，虽然height和width_t对应的类型相同，但类型名称不一样
area_t area(width_t w, width_t h)
{
    return (area_t)w * h;
}
```

本规则不要求**函数指针**声明使用与函数声明相同的名称。因此，下面的示例符合要求：

```c
extern void f1(int16_t x);
extern void f2(int16_t y);
void f(bool_t b)
{
    void (*fp1)(int16_t z) = b ? f1 : f2;
}
```

#### Rule 8.4

(必要) 全局(external linkage)的对象和函数，应有显式的合规的声明

如果对象或函数的声明在定义该对象或函数时是可见的，编译器必须检查声明和定义是否兼容。在有函数原型的情况下，根据规则 8.2 的要求，检查范围扩展到函数参数的数量和类型。

建议使用的外部链接对象和函数声明方法是在**头文件**中声明，然后将头文件包含在所有需要它们的代码中，包括定义它们的代码（见规则 8.5）。

下面代码独立，没有表示声明的头文件：

```c
extern int16_t count;
int16_t count = 0;             /* Compliant */
extern uint16_t speed = 6000u; /* Non-compliant - no declaration
                                * prior to this definition，声明不合规 */
uint8_t pressure = 101u;       /* Non-compliant - no declaration
                                * prior to this definition，没有声明 */
```

```c
extern void func1(void);
extern void func2(int16_t x, int16_t y);
extern void func3(int16_t x, int16_t y);
void func1(void)
{
    /* Compliant */
}
void func2(int16_t x, int16_t y)
{
    /* Compliant */
}
void func3(int16_t x, uint16_t y)
{
    /* Non-compliant - parameter types different，违反规则8.3 */
}
void func4(void)
{
    /* Non-compliant - no declaration of func4 before this definition */
}
static void func5(void)
{
    /* Compliant - rule does not apply to objects/functions with internal
     * linkage */
}
```

#### Rule 8.5

(必要) 全局对象或函数应在且只在一个文件中声明一次

通常情况下，只需在头文件中作出一项声明，该声明将包含在定义或使用标识符的任何翻译单元中。这样可以确保：

- 声明和定义的一致性；
- 不同翻译单元中的声明的一致性。

注意：一个项目中可能有多个头文件，但每个外部对象或函数只能在一个头文件中声明。（只声明一次原则）

```c
/* featureX.h */
extern int16_t a; /* Declare a */

/* file.c */
#include "featureX.h"

int16_t a = 0; /* Define a */
```

#### Rule 8.6

(必要) 全局标识符应在且只在一处定义

如果使用的标识符存在多个定义（在不同文件中）或根本不存在定义，则行为未定义。此规则不允许**不同文件**中存在多个定义，即使定义完全相同。如果声明不同，或者将标识符初始化为不同的值，则这是未定义的行为。

```c
/* file1.c */
int16_t i = 10;

/* file2.c */
int16_t i = 20; /* Non-compliant - two definitions of i */
```

因为两个 j 在同一文件中，也就是同一翻译单元中，下一个 j 的定义会覆盖上一个临时定义，这个文件翻译完后实际只有一个定义，合规：

```c
/* file3.c */
int16_t j;     /* Tentative definition，临时定义 */
int16_t j = 1; /* Compliant - external definition */
```

两个 k 在不同的翻译单元中，file4 翻译完后有了 k 的定义(没初始值可能会初始化为 0)，而 file5 翻译完后也有一个定义，产生未定义行为，不合规：

```c
/* file4.c */
int16_t k; /* Tentative definition - becomes external */

/* file5.c */
int16_t k = 0; /* External definition */
```

#### Rule 8.7

(建议) 仅在本编译单元中调用的对象和函数，应定义成局部属性

通过将对象的链接属性设置为内部链接(TODO:加上 static?)或无链接，可以降低其被误访问的可能性。同样地，通过将函数的链接属性设置为内部链接，可以减少其被误调用的机会。

遵循这条规则还可以避免在其他翻译单元或库中发生标识符与相同标识符的混淆。

#### Rule 8.8

(必要) “static”修饰符应用在所有局部全局对象和局部函数(internal linkage)的声明中

由于定义本身也是声明，所以这个规则同样适用于定义。

标准规定，如果一个对象或函数被声明为 extern 存储类说明符，但之前已经存在另一个可见的声明，则连接性(内部或外部)应遵循先前声明中指定的方式，而不是当前这个的连接性(extern 外部)。这可能会让人感到混淆，因为人们可能会期望当前 extern 存储类说明符创建外部连接性，而不是先前的那个连接性。因此，应始终将 static 存储类说明符应用于具有内部连接性的对象和函数。

```c
static int32_t x = 0;   /* definition: internal linkage */
extern int32_t x;       /* Non-compliant,先前已存在x的定义(包括声明)，
                         * 导致这个x的连接性就是内部的，
                         * 而不是我们平常认为的用extern修饰的是全局变量 */
static int32_t f(void); /* declaration: inte rnal linkage */
int32_t f(void)         /* Non-compliant */
{
    return 1;
}
static int32_t g(void); /* declaration: internal linkage */
extern int32_t g(void)  /* Non-compliant */
{
    return 1;
}
```

#### Rule 8.9

(建议) 若一个对象的标识符仅在一个函数中出现，则应将它定义在块范围内

在块作用域内定义一个对象可以减少意外访问该对象的可能性，并清楚地表明它不应在其他地方被访问的意图。

在函数内部，对象是在最外层块还是最内层块中定义，很大程度上取决于个人风格。

> 承认有一些情况下可能无法遵守这个规则。例如，在块作用域中声明的具有静态存储期限的对象无法直接从块外部访问。这使得在不使用对该对象进行间接访问的情况下，无法设置和检查**单元测试用例**的结果。在这种情况下，一些项目可能选择不应用此规则。

```c
void func(void)
{
    int32_t i; /* i仅作为循环用临时变量，其他函数用不到，
                * 所以声明为块内局部变量合规 */
    for (i = 0; i < N; ++i)
    {
    }
}
```

在下面这个合规示例中，函数"count"会追踪它被调用的次数，并返回这个数字。其他函数不需要知道"count"的具体实现细节，所以计数器使用块级作用域进行定义：

```c
uint32_t count(void)
{
    static uint32_t call_count = 0;
    ++call_count;
    return call_count;
}
```

#### Rule 8.10

(必要) 内联函数应使用静态(static)存储类(Storage-class)声明

如果一个内联函数声明具有外部链接但在同一翻译单元中没有定义，那么它的行为是未定义的：

```c
/* file1.c */
inline int32_t max(int32_t val1, int32_t val2)
{
    return (val1 > val2) ? val1 : val2;
}

/* file2.c */
extern inline int32_t max(int32_t val1, int32_t val2);
void R_8_10(void)
{
    int32_t xmax = max(3, 5);/* 未定义行为 */
    use_int32(xmax);
}
```

对于一个声明具有外部链接的内联函数的调用，可能会调用函数的外部定义(使用正常函数调用的方式)，也可能使用内联定义(使用内联方式在编译时直接加入函数)。尽管这不应该影响被调用函数的行为，但它可能会影响执行时序(使用内联定义时会比函数调用的方式更快)，从而对实时程序产生影响。

> 注意：通过将内联函数的定义放在头文件中，可以使其在多个翻译单元中可用。

#### Rule 8.11

(建议) 声明具有外部链接的数组时，应明确指定其大小

> 只适用于非定义声明

尽管可以声明一个具有不完整类型的数组并访问其元素，但在可以明确确定数组大小时，最好这样做。为每个声明提供大小信息可以确保它们在一致性方面进行检查。这也可以使**静态分析器**在不需要分析多个翻译单元的情况下执行一些数组**边界分析**。

```c
extern int32_t array1[10]; /* Compliant */
extern int32_t array2[];   /* Non-compliant */
```

#### Rule 8.12

(必要) 在枚举列表中，隐式指定的枚举常量的值应唯一

标准定义：

- 一个隐式指定的枚举常量的值比其前面的枚举常量大 1。
- 如果第一个枚举常量是隐式指定的，则其值为 0。
- 一个显式指定的枚举常量具有与关联常量表达式相同的值。

如果隐式指定和显式指定的常量在枚举列表中混合使用，则可能会出现值的重复。这种重复可能是无意的，并可能导致意外行为。此规则要求对枚举常量的任何重复都要明确表达，从而使意图明确。

```c
/* Non-compliant - yellow replicates implicit green */
enum colour
{
    red = 3,
    blue,
    green,
    yellow = 5
};
/* Compliant */
enum colour
{
    red = 3,
    blue,
    green = 5, // 明确 green 和 yellow 值相同
    yellow = 5
};
```

#### Rule 8.13

(建议) 指针应尽可能指向 const 限定类型

指针应该指向一个 const 限定类型，除非以下情况之一：

- 用于修改对象
- 或被复制到另一个指向非 const 限定类型的指针，通过以下方式实现：
  - 赋值
  - 内存移动或复制函数

为了简便起见，此规则以指针及其指向的类型来表述。然而，该规则同样适用于数组及其所包含的元素类型。数组的元素应具有 const 限定的类型，除非以下情况之一：

- 数组的任何元素被修改过，或
- 它被复制到一个通过上文描述方式指向非 const 限定类型的指针。

该规则通过确保指针不会意外地用于修改对象来促进最佳实践。从概念上讲，它等同于默认认为：

- 所有数组的元素具有 const 限定类型，以及
- 所有指针指向 const 限定类型

然后只在需要符合语言标准的限制时才去除 const 限定。

```c
static uint16_t f13(uint16_t *p) /* Non-compliant */
{
    return *p;
}

static uint16_t g13(const uint16_t *p) /* Compliant */
{
    return *p;
}

static char last_char(char *const s) /* Non-compliant,s内元素没有被修改，优先使用const */
{
    return s[strlen(s) - 1u];
}

static char last_char_ok(const char *const s) /* Compliant */
{
    return s[strlen(s) - 1u];
}

static int16_t first(int16_t a5[5]) /* Non-compliant，同上 */
{
    return a5[0];
}

static int16_t first_ok(const int16_t a5[5]) /* Compliant */
{
    return a5[0];
}
```

#### Rule 8.14

(必要) 不得使用类型限定符“restrict”

当小心使用时，限制(restrict)类型限定符可以提高编译器生成的代码的效率。它还可以改进静态分析。然而，要使用限制类型限定符，程序员必须确保两个或多个指针操作的内存区域不重叠。如果限制使用不正确，则存在编译器生成不按预期运行的代码的重大风险

```c
#include <string.h>
void f(void)
{
    /* memcpy has restrict-qualified parameters，但misra规范不检测标准库，所以合规 */
    memcpy(p, q, n);
}
```

```c
// 不能用restrict,不合规
void user_copy(void *restrict p, void *restrict q, size_t n)
{
}
```

### 组别 9

#### Rule 9.1

(强制) 具有自动存储持续时间的对象(自动变量)的值在设置前不得读取

> cppcheck 无法检查本错误，GCC 开启`-Wall`可以检查

注意：就本规则而言，数组元素或结构成员应视为一个离散对象

根据 ANSI C 标准：

- 除非明确初始化，否则`静态`存储时间的对象(static)会自动初始化为零。
- 具有`自动`存储时间的对象(auto 自动变量)不会自动初始化，因此可能具有**不确定**的值。

注意：有时自动对象的显式初始化可能会被忽略。当使用 goto 或 switch 语句 "绕过"对象的带显式初始化的声明跳转到标签时，就会出现这种情况：

```c
#include <stdio.h>
int main(void)
{
    goto L1;
    int x = 10;
L1:
    x = x + 1u;
    printf("x = %d\n", x);
}
```

但是 x 会被正常声明，此时 GCC 会报警告，不会报错：

```console
format.c:7:11: warning: ‘x’ is used uninitialized in this function [-Wuninitialized]
     x = x + 1u;
         ~~^~~~
```

```c
static void f(bool_t b, uint16_t *p)
{
    if (b)
    {
        *p = 3U;
    }
}

static void g(void)
{
    uint16_t u; /* Non-compliant declaration，u未被显式赋值 */

    f(false, &u);

    if (u == 3U) /* Non-compliant use - "u" has not been assigned a value. */
    {
        use_uint16(u); /*  */
    }
}

static void jmp_over_init(void)
{
    goto L1; /* violates R.15.1 */
    uint16_t x = 10u;
L1:
    // 此处的x声明虽然被跳过，但x还是被正常声明了，可编译通过
    x = x + 1u; /* Non-compliant - x has not been been assigned a value */
    use_uint16(x);
}

void R_9_1(void)
{
    bool_t b = get_bool();
    uint16_t val = 3u;

    f(b, &val);
    use_uint16(val);

    g();
    jmp_over_init();
}
```

#### Rule 9.2

(必要) 集合(n 维数组或结构体)或联合体(union)的初始化应括在花括号“{}”中

这条规则适用于对象和子对象的初始化器。

形式为 `{ 0 }` 的初始化器可用于初始化任意结构。

注意：此规则本身并不要求对对象或子对象进行显式初始化

**原因：**

使用大括号表示子对象的初始化可以提高代码的清晰度，并迫使程序员考虑复杂数据结构（如多维数组或结构数组）中元素的初始化。

**例外：**

- 数组可以用字符串字面(String Literal)形式初始化，如`char str[6] = "Hello"`
- 自动结构体或联合体可以使用与结构体或联合体类型兼容的表达式进行初始化。
- 可以使用指定的初始化器初始化子对象的一部分。

```c
int16_t y1[3][2] = {1, 2, 0, 0, 5, 6};       /* Non-compliant，符合C标准但未表现出期望的数据结构(二维数组) */
int16_t y2[3][2] = {{1, 2}, {0}, {5, 6}};    /* Compliant，{0}可以用于初始化一个对象，无论其结构如何     */
int16_t y3[3][2] = {{1, 2}, {0, 0}, {5, 6}}; /* Compliant     */

int16_t z1[2][2] = {{0}, [1][1] = 1}; /* Compliant,例外2      */
int16_t z2[2][2] = {{0},
                    [1][1] = 1,
                    [1][0] = 0};         /* Compliant，例外2      */
int16_t z3[2][2] = {{0}, [1][0] = 0, 1}; /* Non-compliant，不符合二维数组的定义方式  */
int16_t z4[2][2] = {[0][1] = 0, {0, 1}}; /* Compliant      */

float32_t a1[3][2] = {0};             /* Compliant      */
float32_t a2[3][2] = {{0}, {0}, {0}}; /* Compliant      */
float32_t a3[3][2] = {{0.0f, 0.0f},
                      {0.0f, 0.0f},
                      {0.0f, 0.0f}}; /* Compliant     */

union /* breaks R.19.2 */
{
    int16_t i16;
    float32_t f32;
} u = {0}; /* Compliant     */

struct
{
    uint16_t len;
    char buf[8];
} s[3] = {
    {5u, {'a', 'b', 'c', 'd', 'e', '\0', '\0', '\0'}},
    {2u, {0}},
    {.len = 0u} /* Compliant - buf initialized implicitly */
};              /* Compliant - s[ ] fully initialized     */
```

#### Rule 9.3

(必要) 数组不得部分初始化

如果一个 array 对象或子对象的任何元素被显式初始化，则整个对象或子对象都应被显式初始化。

为数组中的每个元素提供一个明确的初始化，可以清楚地表明每个元素都被考虑到了

- 可以使用 `{ 0 }` 形式的初始化器显式地初始化数组对象或子对象的所有元素。
- 可以使用仅指定部分明确的初始化项的初始化器来初始化数组，例如执行稀疏初始化
- 使用字符串字面(String Literal)初始化的数组不需要为每个元素都指定初始化符。

```c
int32_t x[3] = {0, 1, 2}; /* Compliant   */
int32_t y[3] = {0, 1};    /* Non-compliant: y[ 2 ] is implicitly initialised  */

float32_t t[4] = {[1] = 1.0f, 2.0f};         /* Non-compliant: t[ 0 ] and t[ 3 ] are implicitly initialised */
float32_t z[50] = {[1] = 1.0f, [25] = 2.0f}; /* 例外2：指定且仅指定特定的两个初始化项，没有其他隐式的指定  */

float32_t arr[3][2] =
    {
        {0.0f, 0.0f},
        {PI / 4.0f, -PI / 4.0f},
        {0} /* { 0 } initialises all elements of array subobject arr[ 3 ]  */
};

char_t ac_5[5] = {'\0'}; /* Non-compliant */

uint16_t au_3_2[3][2] = {0U}; /* Non-compliant */

uint16_t au_3[3] = {0U}; /* Non-compliant */

float32_t af_3_2[3][2] = {0.0F}; /* Non-compliant */

float32_t arr2[3][2] = {0}; /* Compliant by exception 1 */

char h[10] = "Hello"; /* Compliant by exception 3 */
```

#### Rule 9.4

(必要) 数组的元素不得被初始化超过一次

这条规则适用于对象和子对象的初始化器。

C99 允许通过指定适用的数组索引或结构体成员名称，以任何顺序初始化对象的元素（没有初始化值的元素默认为未初始化对象）。重复初始化带来的副作用是未明确的。

为了允许使用稀疏数组和结构，只初始化应用程序所需的数组和结构是可以接受的。

```c
static uint16_t glob_arr[3] = {0u};
static uint16_t *glob_p = glob_arr;

static void f4(void)
{
    uint16_t a[2] = {[0] = *glob_p++, [0] = 1u}; /* Non-compliant, also breaks R.13.3, R.13.4 */
    use_uint16(a[0]);
    use_uint16_ptr(glob_p);
}

void R_9_4(void)
{
    /* Required behaviour using positional initialisation                                                                 */
    int32_t a1[5] = {-5, -4, -3, -2, -1}; /* Compliant: a1 is  -5, -4, -3, -2, -1        */

    /* Similar behaviour using designated initialisers                                                                    */
    int32_t a2[5] = {[0] = -5, [1] = -4, [2] = -3, [3] = -2, [4] = -1}; /* Compliant: a2 is  -5, -4, -3, -2, -1        */

    /* Repeated designated initialiser element values overwrite earlier ones                                              */
    int32_t a3[5] = {[0] = -5, [1] = -4, [2] = -3, [2] = -2, [4] = -1}; /* Non-compliant: a3 is -5, -4, -2, 0, -1      */

    struct mystruct
    {
        int32_t a;
        int32_t b;
        int32_t c;
        int32_t d;
    };

    /* Required behaviour using positional initialisation                                                                 */
    struct mystruct s1 = {100, -1, 42, 999}; /* Compliant: s1 is 100, -1, 42, 999           */

    /* Similar behaviour using designated initialisers                                                                    */
    struct mystruct s2 = {.a = 100, .b = -1, .c = 42, .d = 999}; /* Compliant: s2 is 100, -1, 42, 999           */

    /* Repeated designated initialiser element values overwrite earlier ones                                              */
    struct mystruct s3 = {.a = 100, .b = -1, .a = 42, .d = 999}; /* Non-compliant: s3 is 42, -1, 0, 999         */
}
```

#### Rule 9.5

(必要) 在使用指定初始化方式初始化数组对象的情况下，应明确指定数组的大小

为了明确意图，应明确声明数组的大小。如果在程序开发过程中改变了初始化元素的索引，这将提供一定的保护，因为在数组边界之外初始化元素是违反约束的（C99 第 6.7.8 节）。

```c
int32_t a1[] = {[0] = 1};   /* Non-compliant - probably unintentional to have single element */
int32_t a2[10] = {[0] = 1}; /* Compliant */
```

### 组别 10: 基本类型模型

**该组规则的作用**：

- 更有效的类型检查
- 控制隐式和显示类型转换
- 提高代码可移植
- 解决在 ISO C 中发现的一些类型转换异常

**基本类型**：

表中第一行表示大类，第二行是具体基本类型

| Boolean | character | signed                                                                       | unsigned                                                                               | enum\<i\>  | floating                       |
| :------ | :-------- | :--------------------------------------------------------------------------- | :------------------------------------------------------------------------------------- | :--------- | :----------------------------- |
| \_Bool  | char      | signed char<br>signed short<br>signed int<br>signed long<br>signed long long | unsigned char<br>unsigned short<br>unsigned int<br>unsigned long<br>unsigned long long | named enum | float<br>double<br>long double |

- 只有非匿名的 enum 是`enum<i>`基本类型，匿名的 enum 的元素视为有符号(signed)基本类型。
- `enum<i>`中的 i 表示 enum 的元素所属的类型。例外是 C90 中没有标准 Boolean 基本类型，用来表示布尔类型的`enum{False=0,True=1}`本质上属于 Boolean 基本类型而不是整数类型。
- C99 引入了 extended signed integer type 扩展类型，注意它们和基本类型间的优先级(rank)

**复合运算符和表达式**：

> _适用于 10.6，10.7，10.8_

根据附录 C 介绍，ISO C 允许进行大量隐式类型转换，因此可以认为它的**类型安全性**较差。这些类型转换可能会损害安全性，因为它们的实现定义方面可能会引起开发人员的困惑。

通过限制可能应用于非简单表达式(也就是复合表达式)的隐式和显式转换，可以避免。这些问题包括附录 C 中提到的一些问题：

- 整数表达式的求值类型的混淆，因为这取决于任何**整型提升**(integer promotion)后的操作数的类型(算术运算时会将小于 int 宽度的整型自动提升到 int 宽度。见[C99] 6.3.1.8 Usual arithmetic conversions 和[c 语言数据类型提升](https://blog.csdn.net/weixin_42164528/article/details/80660753))。算术运算的结果类型取决于 int 的实现大小；
- 程序员中普遍存在的误解：进行计算的类型会受到结果所分配或转换的类型的影响（如`f32a = 10u / 3u;`或`f32a = (float)(10u / 3u);`，可能会误认为先将 10u 和 3u 转为 float 后再计算，但实际是`10u/3u`计算得到整型后再转换，丢失了精度）。这种错误的期望可能导致意外的结果。

本文档将以下运算符定义为复合运算符：

- 乘法（`*`，`/`，`%`）
- 加法（二元 `+`，二元 `-`）(不包括一元的`+`和`-`)
- 位运算（`&`，`|`，`^`）
- 移位（`<<`，`>>`）
- 条件运算（`?:`）如果第二个或第三个操作数是一个复合表达式

#### Rule 10.1

(必要) 操作数不得为不适当的基本类型

1. float 不能用于仅限整型作为操作数的操作，如取下标`[ ]`、移位`>>`操作
2. 所有仅限 Boolean 类型作为操作数的操作必须使用 Boolean，如非`!`、与`&&`、条件运算符`?:`的第一个操作数
3. Boolean 不能被视为数值(numeric value)，比如 False 不能被视为 0 作为 int 类型操作数
4. 字符基本类型不能视为数值，同 3
5. 枚举基本类型不能用于算术运算，因为其具体类型由实现定义。(匿名的枚举类型属于有符号基本类型，可以用于算术运算)
6. 移位和位运算只能在无符号基本类型的操作数上执行。
7. 移位运算符的右侧操作数必须为无符号基本类型
8. 不能为无符号基本类型添加一元运算符负号`-`，让其成为有符号的，因为这有可能超出其原来的范围限制，比如最大的一个 u32_t 加负号就超出 s32_t 的限制了。

#### Rule 10.2

(必要) 字符基本类型的表达式不得在加减运算中不当使用

使用加减运算来处理字符基本类型一般有几个用途：

- 两个字符基本类型相减用于获取字符对应的序号(使用'0'-'9'共 10 个字符)，比如表示星期中的某一天，用字符'1'到'7'表示，通过字符相减操作`'7'-'0'`来将字符值转为一个序数(ordinal)值 7，表示一周的第 7 天。
- 一个字符基本类型和一个基本无符号类型相加可以用来将序数值转为字符值，如`'0'+9`输出`'9'`。
- 从一个字符基本类型中减去一个基本无符号类型可用于将一个字符从小写转换为大写，如`'d'-32`(32 可以通过`'a'-'A'`得到)输出'D'。
- 减去一个基本类型等效于加上这个基本类型的负数，来适用上面第二个用途。

以下合法:

```c
'0' + u8a /* 用途2 */
s8a + '0' /* 用途2 */
cha - '0' /* 用途1 */
'0' - s8a /* 用途4 */
```

以下不合法:

```c
s16a - 'a' /* 用途不明 */
'0' + f32a /* 加浮点数不符合上述用途 */
cha + ':' /* 两个都是字符基本类型，不符合用途2 */
```

争议项:

```c
cha - ena /* 字符基本类型减去enum类型（enum可能就是基本无符号类型），而且有可能违反了10.1,不过cppcheck不能判断 */
```

#### Rule 10.3

(必要) 表达式的值不得赋值给同类别的较窄基本类型或不同类别的基本类型的对象

> 表达式包含了简单表达式和复合表达式

本规则涵盖以下操作：

- 术语表中定义的赋值(`=`)；
- 将 switch 语句的 case 标签中的**常量表达式**转换为**控制表达式**的提升类型：

  ```c
  switch (dayOfWeek) { // dayOfWeek属于控制表达式
      case 0: // 0属于常量表达式
          // SUNDAY
          break;
      case 1:
          // MONDAY
          break;
      case 2:
          // TUESDAY
          break;
      // ...
      }
  ```

C 语言允许程序员有相当大的自由度，并允许自动执行不同算术类型之间的赋值。不过，使用这些**隐式转换**可能会导致意外结果，有可能造成数值、符号或精度的损失。有关 C 类型系统的更多详情，请参阅附录 C。

使用 MISRA 基本类型模型强制执行的更强类型，可降低出现这些问题的可能性

**例外：**

1. 如果非负整数常量表达式(0,1,2 之类的)在可以用无符号整数类型表示(比如在 uint8_t 允许的 0-255 之内)，则可将其赋值给该无符号整数类型变量。
2. 初始化器 { 0 } 可用来初始化聚合或联合类型

```c
u8a = 2;      /* Compliant By 例外1 */
u8a = 2 * 24; /* Compliant By 例外1 */

uint8_t u8f = 1.0f; /* Non-compliant - unsigned and floating */
bool_t bla = 0;     /* Non-compliant - boolean and signed，不符合例外1，因为bla不是无符号整型 */
cha = 7;            /* Non-compliant - character and signed */
u8a = 'a';          /* Non-compliant - unsigned and character */
u8b = 1 - 2;        /* Non-compliant - unsigned and signed，不符合例外1，因为1-2不是非负的 */
u8c += 'a';         /* Non-compliant - u8c = u8c + 'a' assigns character to unsigned */

s8a = K2;    /*  Non-compliant - Constant value does not fit */
u16a = u32a; /*  Non-compliant - uint32_t to uint16_t */

s8a = -123L; /*  Non-compliant - signed long to int8_t */

u8a = 6L; /* Non-compliant - signed long to uint8_t，不符合例外1 */
          /* Standard Type has rank greater than int,
           * so exception does not apply */

/* integer constant expression from + with value 5U and UTLR of unsigned char */
u8a = (uint16_t)2U + (uint16_t)3U; /* Compliant，例外1？ */

/* integer constant expression from + with value 100000U and UTLR of unsigned int */
u16a = (uint16_t)50000U + (uint16_t)50000U; /*  Non-compliant，不符合例外1，超过了u16的最大值 */

/* Top-level cast returns C standard type of unsigned short */
u8a = (uint16_t)(2U + 3U); /*  Non-compliant，经过转换后不再是常量表达式，不符合例外1 */
```

#### Rule 10.4

(必要) 执行常规算术转换的运算符的两个操作数应有相同类别的基本类型

本规则适用于常规算术转换中描述的运算符（见 C90 第 6.2.1.5 节，C99 第 6.3.1.8 节），另外：

- 包括除了移位、逻辑 `&&`、逻辑 `||` 和逗号运算符外所有二进制运算符
- 包括**三元运算符**的第二和第三操作数。
- 不包含递增和递减运算符。

原因类似 Rule 10.3

例外：

允许使用 Rule 10.2 规定的例外字符操作形式

```c
enum enuma
{
    A1,
    A2,
    A3
} ena;
enum enumb
{
    B1,
    B2,
    B3
} enb;

if (ena > A1) /*  Compliant  - same essential type  */
{
    ; /*no action */
}
u16b = u8a + u16b; /* Compliant - same essential type */
use_uint16(u16b);

cha += u8a; /*  Compliant by exception */
use_char(cha);

s8a += u8a; /* Non-compliant - Signed and unsigned,
                               also breaks R.10.3*/
use_int8(s8a);

u8b = u8b + 2; /* Non-compliant - unsigned and signed,
                                  returns standard type  */
use_uint8(u8b);

if (enb > A1) /* Non-compliant - Enum<enuma> to enum<enumb>    */
{
    ; /* no action */
}
if (ena == enb) /* Non-compliant - Enum<enumb> to enum<enuma>      */
{
    ; /* no action */
}

u8a += cha; /* Compliant by exception, but breaks R.10.3 */
use_uint8(u8a);
```

#### Rule 10.5

(建议) 表达式的值不应被(强制)转换为不适当的基本类型

下表列出了应**避免**的类型转换:

|            | from/Boolean | character |  enum   | signed | unsigned | floating |
| :--------: | :----------: | :-------: | :-----: | :----: | :------: | :------: |
| to/Boolean |              |   Avoid   |  Avoid  | Avoid  |  Avoid   |  Avoid   |
| character  |    Avoid     |           |         |        |          |  Avoid   |
|    enum    |    Avoid     |   Avoid   | Avoid\* | Avoid  |  Avoid   |  Avoid   |
|   signed   |    Avoid     |           |         |        |          |          |
|  unsigned  |    Avoid     |           |         |        |          |          |
|  floating  |    Avoid     |   Avoid   |         |        |          |          |

\*注意：只有相同的 enum 间可以转换(虽然这种转换没什么意义)，其他情况都应避免转换。

不允许从 `void` 转换为任何其他类型，因为这会导致未定义的行为。Rule 1.3 涵盖了这一点。

**原因：**

可以出于合法的功能原因引入显式转换，例如：

- 为了改变后续算术运算所使用的类型；
- 故意截断数值；
- 为清晰起见，使类型转换显式化

然而，有些显式转换被认为是不合适的：

- 在 C99 中，转换或赋值给`_Bool`(C99 自带的布尔型)的结果总是 0 或 1。在转换为另一种定义为**基本 Boolean 类型**的类型时(如 C90 不自带布尔型，需要`#typedef int _Bool`)不一定是这样；
- 转换为基本 enum 的类型可能会产生一个不在该类型的枚举常量集合内的值；
- 从基本 Boolean 类型转换为任何其他类型都不太有意义；
- 在浮点和字符类型之间转换没有意义，因为两种表示之间没有精确的映射

**例外：**

一个有符号的值为 0 或 1 的整数常量表达式，可以被转换为 Boolean 基本类型(非 C99 定义的)。这样就可以实现非 C99 布尔运算模型。

```c
typedef _Bool bool_t;
typedef enum enum_tag { ENUM_0, ENUM_1, ENUM_2 } enum_t;

char cha;
enum_t ena = ENUM_1;
enum_t enc;
int32_t si;

bool_t bna = (bool_t) false; /* Compliant - C99 'false' is essentially Boolean */
si = (int32_t)3U;            /* Compliant */
bna = (bool_t)0;             /* Compliant  - by exception */
bna = (bool_t)3U;            /* Non-compliant  */
bna = (bool_t)ENUM_0;        /* Non-compliant - ENUM_0 has essentially enum type */

si = (int32_t)ena; /* Compliant */
enc = (enum_t)3;   /* Non-compliant，不允许将有符号整型转为enum */
cha = (char)enc;   /* Compliant */
```

#### Rule 10.6

(必要) 复合表达式的值不得赋值给具有**较宽**基本类型的对象

涵盖条件同 [Rule 10.3](#rule-103)

由于不同实现的结果可能不同，因此不允许向更宽的类型转换：

```c
u32a = u16a + u16b;
```

在 16 位机器上，加法将以 16 位执行，如果产生超过 16 位范围的进位，则会丢弃。然而，在 32 位机器上，加法将以 32 位进行，并且会保留在 16 位机器上会丢失的高位。

由于结果的显式截断总是导致同样的信息丢失，因此将结果转换为具有相同类别的**较窄类型**是可以接受的，但这不符合 Rule 10.3，所以和 Rule 10.3 结合起来就是复合表达式只能赋值给**相同宽度、相同类别**的基本类型的对象，也就是同一个种基本类型。

```c
u16c = u16a + u16b; /* Same essential type */

u32a = (uint32_t)u16a + u16b; /* Cast causes addition in uint32_t */

u32a = u16a + u16b; /* Non-compliant - Implicit conversion on assignment  */
use_uint32(u32a);
use_uint32(u16a + u16b); /* Non-compliant - Implicit conversion of fn argument */

u32a = ++u8a; /* Compliant，不是复合表达式，不适用 - but breaks R.13.3 */

u8a = ~u8a;  /* Compliant  */
u16a = ~u8a; /* Non-compliant - ~ is a composite operator */

u16a = ~(uint16_t)u8a; /* Compliant  */

u16a = (uint8_t)(~u8a); /* Compliant，强制转换复合表达式的值后视为一个简单表达式，不适用  */

u64a = +(u32a * u32a); /* Non-compliant - unary + operator */
                       /* on composite expression          */

u64a = +u32a; /* Compliant - unary + operator    */
              /* on non-composite expression，+u32a不是一个复合表达式，不适用本规则 */
```

#### Rule 10.7

(必要) 如果将复合表达式用作执行常规算术转换的运算符的一个操作数，则另一个操作数不得具有**更宽**的基本类型

理由在上面的**复合运算符和表达式**中有说明。

限制复合表达式上的隐式转换意味着表达式中的算术运算序列必须在**同一种基本类型**中进行。这样可以减少开发者的可能混淆。

```c
u32a = u32a * u16a + u16b;             /* No composite conversion,u16b比复合表达式窄， but breaks R.12.1 */
u32a = (u32a * u16a) + u16b;           /* No composite conversion */
u32a = u32a * ((uint32_t)u16a + u16b); /* Cast means no conversion */
u32a += (u32b + u16b);                 /* No composite conversion */

u32a = u32a * (u16a + u16b); /* Non-compliant - Implicit conversion of ( u16a + u16b ) */
u32a += (u16a + u16b);       /* Non-compliant - Implicit conversion of ( u16a + u16b ) */
```

#### Rule 10.8

(必要) 复合表达式的值不得转换为其他类别的基本类型或本类别中更宽的基本类型

理由在上面的**复合运算符和表达式**中有说明。

由于不同实现的结果可能不同，因此不允许向更宽的类型转换：

```c
(uint32_t)(u16a + u16b);
```

在 16 位机器上，加法将以 16 位执行，如果产生超过 16 位范围的进位，则会丢弃。然而，在 32 位机器上，加法将以 32 位进行，并且会保留在 16 位机器上会丢失的高位。

由于结果的显式截断总是导致同样的信息丢失，因此将结果转换为具有相同类别的**较窄**基本类型是可以接受的。

```c
u16a = (uint16_t)(u32a + u32b); /* Compliant，转为同一类别更窄的基本类型 */

u16a = (uint16_t)(s32a + s32b); /* Non-compliant - different essential
                                 * type category,其他类别的基本类型，有符号类别转无符号类别 */

u16a = (uint16_t)s32a; /* Compliant - s32a is not composite，非复合表达式，不适用 */

u32a = (uint32_t)(u16a + u16b); /* Non-compliant - cast to wider
                                 * essential type，同意类别更宽 */

u32a = (uint32_t)(uint16_t)(u16a + u16b); /* Compliant - uint32_t cast is
                                           * not on a composite expression，要转为uint32_t的不是复合表达式*/
```

### 组别 11：指针

指针类型可分类如下：

- 指向对象的指针；
- 指向函数的指针；
- 指向不完整的指针(当一个指针指向一个尚未完整定义的数据类型时，如仅声明了一个结构体、仅声明了一个未定义大小的数组)；
- 指向 `void` 的指针；
- 空指针常量(NULL)，即值 0，可选择转换为 `void *`。

《标准》允许的涉及指针的转换只有以下几种：

- 从指针类型转换为 void；
- 从指针类型转换为算术类型；
- 从算术类型转换为指针类型；
- 从一种指针类型转换为另一种指针类型

尽管语言限制允许指针与整数类型以外的任何算术类型之间的转换，但这种转换是未定义的。

以下允许的指针转换不需要显式转换：

- 从指针类型转换为 `_Bool`（仅适用于 C99）；
- 从空指针常量转换为指针类型；
- 从指针类型转换为兼容的指针类型，条件是目标类型具有源类型的所有类型限定符(const 之类的)；
- 指向对象或不完整类型的指针与 `void *` 或其限定版本之间的转换，条件是目标类型具有源类型的所有类型限定符。

在 C99 中，任何不属于指针转换子集的隐式转换都违反了约束（C99 第 6.5.4 和 6.5.16.1 节）。

在 C90 中，任何不属于指针转换子集的隐式转换都会导致未定义的行为（C90 第 6.3.4 和 6.3.16.1 节）。

指针类型和整数类型之间的转换由实现定义。

#### Rule 11.1

(必要) 不得在指向函数的指针和任何其他类型的指针之间进行转换

将指向函数的指针和以下任何一种情况互相转换，都会导致未定义的行为：

- 指向对象的指针；
- 指向不完整对象的指针；
- `void *`

如果通过指针调用函数，而该指针的类型与被调用函数的类型不兼容，则该函数的行为是未定义的。《标准》允许将指向函数的指针转换为指向不同类型函数的指针。《标准》也允许将整数转换为指向函数的指针。但是，为了避免使用不兼容的指针类型调用函数时产生未定义的行为，本规则禁止这两种转换。

**例外**：

1. 空指针常量可转换为指向函数的指针；
2. 指向函数的指针可转换为 void；
3. 函数类型可隐含转换为指向该函数类型的指针。

   包括 C90 第 6.2.2.1 节和 C99 第 6.3.2.1 节所述的隐式转换。通常发生在以下情况:

   - 直接调用函数，即使用函数标识符表示要调用的函数；
   - 将函数赋值给函数指针

```c
typedef void (*fp16)(int16_t n);
typedef void (*fp32)(int32_t n);

static fp16 get_fp16(void)
{
    return &use_int16;
}

extern void f1(int16_t n);

void R_11_1(void)
{
    fp16 fp1 = NULL; /* Compliant - exception 1 */
    fp32 fp2 = (fp32)fp1; /* Non-compliant - function pointer to
                                           different function pointer */

    if (fp2 != NULL) /* Compliant - exception 1,将空指针常量NULL转为函数指针类型与fp2对比， also breaks R.14.3  */
    {
    }

    fp16 fp3 = (fp16)0x8000; /* Non-compliant  - integer to function pointer */
    fp16 fp4 = (fp16)1.0e6F; /* Non-compliant  -   float to function pointer */

    typedef fp16 (*pfp16)(void);
    pfp16 pfp1 = &get_fp16;

    (void)(*pfp1()); /* Compliant - exception 2，调用pfp1并将返回的函数指针转为void */

    f1(1);         /* Compliant - exception 3 - implicit conversion
                    * of f1 into pointer to function */
    fp16 fp5 = f1; /* Compliant - exception 3 */
}
```

#### Rule 11.2

(必要) 不得在指向不完整类型的指针和其他任何类型间进行转换

将指针转换为不完整类型或从不完整类型转换，可能导致指针未正确对齐，从而产生未定义的行为。

将不完整类型的指针转 ​​ 换为浮点类型或从浮点类型转换总是会导致未定义的行为。

指向不完整类型的指针有时用于隐藏对象的表示。如果将指向不完整类型的指针转换成指向对象的指针，就会破坏这种封装。

**例外**：

1. 空指针常量可转换为指向不完整类型的指针。
2. 指向不完整类型的指针可转换为 void。

```c
struct s; /* Incomplete type                        */
struct t; /* A different incomplete type            */
extern void use_structs_ptr(struct s *ps);
extern void use_structt_ptr(struct t *pt);

extern struct s *f2(void);

void R_11_2(void)
{
    struct s *sp;
    struct t *tp;
    int16_t *ip;

    sp = (struct s *)1234; /* Non-compliant                          */
    ip = (int16_t *)sp;    /* Non-compliant                          */
    tp = (struct t *)sp;   /* Non-compliant - casting pointer to a
                              different incomplete type              */

    sp = NULL; /* Compliant - exception 1                */

    (void)f2(); /* Compliant - exception 2               */
}
```

#### Rule 11.3

(必要) 不得在指向不同对象类型的指针之间执行强制转换

将指向对象的指针转换为指向不同对象的指针，可能导致指针不能正确**对齐**，从而产生未定义的行为。即使已知转换产生的指针是正确对齐的，但如果使用该指针访问对象，其行为也可能是未定义的。例如，如果一个类型为 int 的对象被当作 short 访问，即使 int 和 short 具有相同的表示和对齐要求，行为也是未定义的。详见 C90 第 6.3 节、C99 第 6.5 节第 7 段

允许将对象类型指针转换为对象类型 char——有符号 char 或无符号 char 的指针。该标准保证，指向这些类型的指针可用于访问对象的各个字节

```c
uint8_t *p1 = get_uint8_ptr();
uint32_t *p2;

p2 = (uint32_t *)p1; /* Non-compliant  - possible incompatible alignment */

extern uint32_t read_value(void);
extern void print(uint32_t n);
void f(void)
{
    uint32_t u = read_value();
    uint16_t *hi_p = (uint16_t *)&u; /* Non-compliant even though
                                      * probably correctly aligned */
    *hi_p = 0;                       /* Attempt to clear high 16-bits on big-endian machine */
    print(u);                        /* Line above may appear not to have been performed */
}

const short *p;
const volatile short *q;
q = (const volatile short *)p; /* Compliant，本规则并没有规定不能为指针加限定符，除了const限定符外 */

int *const *pcpi;
const int *const *pcpci;
pcpci = (const int *const *)pcpi; /* Non-compliant，TODO:指针类型不同，一个使用了const修饰 */
```

#### Rule 11.4

(建议) 不得在指向对象的指针和整数类型之间进行转换

- 指针类型不应转换为整型:

  将指向对象的指针转换为整数，可能会产生一个无法用所选整数类型表示的值，从而导致未定义行为。

- 整型不应转换为指针类型:

  将整型变量转换为对象指针可能导致指针未正确对齐，进而导致未定义行为。

注意：C99 中的数据类型 intptr_t 和 uintptr_t（在`<stdint.h>`中声明）分别是有符号和无符号整数类型，能够表示指针值。尽管如此，根据此规则，对象指针与这些类型之间的转换是不被允许的，因为它们的使用并不能避免与不对齐指针相关的未定义行为。

应尽可能避免在指针和整数类型之间进行转换，但在寻址内存映射寄存器或其他硬件特性时，可能有必要这样做。如果要在整数和指针之间进行转换，应注意确保产生的指针不会导致规则 11.3 中讨论的未定义行为。

**例外**：

空指针常量(0 也算整数类型)可转换为对象指针

```c
uint8_t *PORTA = (uint8_t *)0x0002; /* Non-compliant */
uint16_t *p;
int32_t addr = (in t32_t)&p;  /* Non-compliant */
uint8_t *q = (uint8_t *)addr; /* Non-compliant */
bool_t b = (bool_t)p;         /* Non-compliant */
enum etag
{
    A,
    B
} e = (enum etag)p; /* Non-compliant */
```

#### Rule 11.5

(建议) 不得将指向 void 的指针转换为指向对象的指针

将指向 void 的指针转换为指向对象的指针，可能会导致指针未正确对齐，从而产生未定义的行为。在可能的情况下应避免使用这种方法，但在使用内存分配功能时，这种方法可能是必要的。如果使用将对象指针转换为 void 指针的方法，应注意确保产生的指针不会导致规则 11.3 中讨论的未定义行为。

**例外**：

指向 void 的空指针常量可转换为指向对象的指针

```c
uint32_t *p32 = get_uint32_ptr();
void *p;
uint16_t *p16;

p = p32; /* Compliant - pointer to uint32_t -> pointer to void */
p16 = p; /* Non-compliant */

p = (void *)p16; /* Compliant     */

p32 = (uint32_t *)p; /* Non-compliant */
```

#### Rule 11.6

(必要) 不得在指向 void 的指针和算术类型之间执行强制转换

将整数转换为指向 void 的指针可能导致指针未正确对齐，从而产生未定义的行为。

将指向 void 的指针转换为整数，可能会产生一个无法用所选整数类型表示的值，从而导致未定义的行为。

任何非整数算术类型和指向 void 的指针之间的转换都是未定义的。

**例外**：

值为 0 的整数常量表达式可被转换为指向 void 的指针。

```c
void *p;
uint32_t u;

p = (void *)0x1234u; /* Non-compliant - implementation-defined */
use_void_ptr(p);

p = (void *)1024.0f; /* Non-compliant - undefined              */

u = (uint32_t)p; /* Non-compliant - implementation-defined */
```

#### Rule 11.7

(必要) 不得在指向对象的指针和非整数算术类型之间执行强制转换

就本规则而言，非整数运算类型指以下类型之一：

- 布尔基本类型；
- 字符基本类型；
- 枚举基本类型；
- 浮点基本类型；

见[组别 10: 基本类型模型](#组别-10-基本类型模型)

- 将指向对象的指针和**浮点基本类型**相互转换会产生未定义的行为。
- 将**其余类型**的指针转换为对象指针，可能导致指针未正确对齐，从而产生未定义的行为。将对象指针转换为其余类型的指针，可能会产生一个无法用所选整数类型表示的值，从而导致未定义的行为。

```c
int16_t *p = get_int16_ptr();
float32_t f;

if (p != NULL)
{
    f = (float32_t)p; /* Non-compliant，未定义行为 */
    p = (int16_t *)f; /* Non-compliant，未定义行为 */
}
```

> 和 Rule 11.4 结合看，将对象指针和整型指针单独划为另一条**建议**型规则

#### Rule 11.8

(必要) 强制转换不得从指针指向的类型中删除任何 const 或 volatile 限定符

任何试图通过转换来重新移动与寻址类型相关的限定符的行为，都是对类型限定原则的违反。

注意：这里的限定符指的是`const int *`这种修饰的是指针指向的内容，而不是`int * const`修饰的是指针

如果从寻址对象中移除限定符，可能会出现以下问题：

- 删除 const 限定符可能会规避对象的只读状态，导致对象被修改；
- 删除 const 限定符可能会导致在访问对象时出现异常；
- 删除 volatile 限定符可能会导致对对象的访问被优化。

注意：删除 C99 restrict 类型限定符是无害的，但 Rule 8.14 规定不得使用 restrict 限定符

```c
const uint16_t cx = 3U;
volatile uint16_t vx = 3U;

uint16_t x = 3U;
uint16_t *const cpi = &x;     /* const pointer               */
uint16_t *const *pcpi = &cpi; /* pointer to const pointer    */
uint16_t **ppi;
const uint16_t *pci = &cx;    /* pointer to const            */
volatile uint16_t *pvi = &vx; /* pointer to volatile         */
uint16_t *pi;

pi = cpi; /* Compliant - no conversion
                         no cast required */

pi = (uint16_t *)pci; /* Non-compliant               */

pi = (uint16_t *)pvi; /* Non-compliant               */

ppi = (uint16_t **)pcpi; /* Non-compliant               */
```

> cppcheck 无法识别 volatile 限定符

#### Rule 11.9

(必要) 宏“NULL”是整数型空指针常量的唯一允许形式

如果数值为 0 的整数常量出现在以下任何一种情况下，则应通过扩展宏 NULL 得出：

- 作为指针的赋值；
- 作为另一个操作数为指针的 `==` 或 `!=`的操作数；
- 作为第三个操作数为指针的 `?:`的第二个操作数；
- 作为第二个操作数为指针的 `?:`的第三个操作数。

忽略空格和任何括号，任何这样的整数常量表达式都应该表示 NULL 的完整扩展。

注意：允许使用 `(void *)0` 形式的空指针常量，无论它是否从 NULL 扩展而来

使用 NULL 而不是 0，可以清楚地表明想要使用一个空的指针而不是整数 0。

```c
#define MY_NULL_1 0
#define MY_NULL_2 (void *)0
#define MY_NULL_3 NULL

extern void f9(uint8_t *p);

int32_t *p1 = 0;         /* Non-compliant */
int32_t *p2 = (void *)0; /* Compliant     */
int32_t *p3 = MY_NULL_3; /* Compliant     */

if (p1 == MY_NULL_1) /* Non-compliant - also breaks R.14.3 */
{
}
if (p2 == MY_NULL_2) /* Compliant - but breaks R.14.3 */
{
}

f9(NULL); /* Compliant for any conforming definition of
           * NULL, such as:
           *       0
           *       (void *)0
           *       (((0)))
           *       (((1 - 1)))
           */
```

### 组别 12

#### Rule 12.1

(建议) 表达式中运算符的优先级应明确

|    Description     |                                                  Operator or Operand                                                  | Precedence |
| :----------------: | :-------------------------------------------------------------------------------------------------------------------: | :--------: |
|      Primary       |                                 identifier, constant, string literal, `(`...`)`(括号)                                 | 16 (high)  |
|   Postfix(后缀)    | `[]` `()` (function call) <br>`. -> ++` (post-increment)<br> `--` (post-decrement)<br> `(){}` (C99: compound literal) |     15     |
|    Unary(一元)     |         `++` (pre-increment) <br>`--` (pre-decrement) <br>`& * + - ~ !` <br>`sizeof` `defined` (preprocessor)         |     14     |
| Cast(强制类型转换) |                                                         `()`                                                          |     13     |
|   Multiplicative   |                                                        `* / %`                                                        |     12     |
|      Additive      |                                                         `+ -`                                                         |     11     |
|   Bitwise shift    |                                                        `<< >>`                                                        |     10     |
|     Relational     |                                                      `< > <= >=`                                                      |     9      |
|      Equality      |                                                        `== !=`                                                        |     8      |
|    Bitwise AND     |                                                          `&`                                                          |     7      |
|    Bitwise XOR     |                                                          `^`                                                          |     6      |
|     Bitwise OR     |                                                          \|                                                           |     5      |
|    Logical AND     |                                                         `&&`                                                          |     4      |
|     Logical OR     |                                                         \|\|                                                          |     3      |
|    Conditional     |                                                         `?:`                                                          |     2      |
|     Assignment     |                                         `= *= /= %= += -= <<= >>= &= ^=` \|=                                          |     1      |
|    Comma(逗号)     |                                                          `,`                                                          |  0 (low)   |

例如，`a << b + c`的解析树，优先级越低的越靠近根部:

```console
    <<
   / \
  a   +
     / \
    b   c
```

建议如下：

- 操作符 sizeof 的操作数应该用圆括号括起来；
- 优先级在 2 到 12 之间的表达式，应该在满足以下两个条件的任何操作数周围加上括号：

  - 优先级小于 13，且
  - 优先级大于表达式的优先级

  例子：

  `a == b ? a : a - b`这个表达式的优先级取决于`?:`为 2，其中有操作数`a==b`、`a`、`a-b`，其中`a==b`优先级为 8，符合小于 13 且大于整个表达式的优先级 2，加括号；其中`a`由于优先级为 16 不符合，不加括号；其中`a-b`优先级为 11 且大于整个表达式优先级 2，加括号。最终为`(a == b) ? a : (a - b)`。

**原因**：

C 语言有相对较多的运算符，而它们的相对优先级并不直观。这可能导致经验不足的程序员犯错。使用括号明确运算符的优先级，就不会出现程序员的预期不正确的情况。它还能让代码的审核者或维护者清楚地了解原始程序员的意图。

我们认识到，过度使用括号会使代码杂乱无章，降低代码的可读性。本规则的目的是在因括号过多或过少而导致代码难以理解之间达成折衷。

```c
/* Operands are primary_expressions or top-level operator level 15 */
arr[i]->n = 0U;    /* Compliant no need to write ( arr[ i ] )->n */
*p++;              /* Compliant no need to write *(p++),
                    * ++后导运算符优先级为15，*取值操作符为14，
                    *  but breaks R.2.2 */
sz = sizeof x + y; /* Non-compliant - write sizeof (x)+y or sizeof (x+y) */

/* Same precedence - all are compliant */
x = a + b;
x = a + b + c;
x = (a + b) + c;
x = a + (b + c);
x = a + b - c + d;
x = (a + b) - (c + d);

/* Different precedence */
x = f(a + b, c); /* Compliant - no need to write f ((a + b), c)，逗号操作符优先级为1 */

/* Operands of conditional operator (precedence 2) are:
 * "==":precedence 8 needs parentheses
 * "a": precedence 16 does not need parentheses
 * "-":precedence 11 needs parentheses
 */
x = a == b ? a : a - b; /* Non-compliant */
x = (a == b) ? a : (a - b); /* Compliant */

/* Operands of << operator (precedence 10) are:
 * "a": precedence 16 does not need parentheses
 * "(...)": precedence 16 already parenthesised
 */
x = a << (b + c); /* Compliant */

/* Operands of && operator (precedence 4) are:
 * "bj bk bl": precedence 16 does not need parentheses
 * "&&": precedence 4 does not need parentheses
 */
if (bj && bk && bl) /* Compliant */
{
}


/* Operands of && operator (precedence 4) are:
 * defined(XX) precedence 14 does not need parentheses
 * (E) precedence 16 already parenthesised
 */
#if defined(XX) && ((XX + YY) > ZZ) /* Compliant */
use_bool(bj);
#endif

/* Compliant
 * Operands of && operator (precedence 4) are:
 *   !defined(XZ) precedence 14 does not need parentheses
 *    defined(YZ) precedence 14 does not need parentheses
 * Operand of ! operator (precedence 14) is:
 *    defined(XZ) precedence 14 does not need parentheses
 */
#if !defined(XZ) && defined(YZ) /* Compliant */
use_bool(bj);
#endif

x = a, b; /* Compliant - parsed as (x = a) , b - violates R.2.2 and R.12.3 */
```

#### Rule 12.2

(必要) 移位运算符的右操作数应在范围：[0,左操作数基本类型的位宽度减 1]

如果右侧操作数为负数，或者大于或等于左侧操作数的宽度，则行为未定义。

举例来说，如果左移或右移的左操作数是一个 16 位整数，那么必须确保它只被 0 至 15 范围内的数字移位。

有关移位操作符操作数的基本类型和基本类型限制的说明，请参见第 8.10 节。

有多种方法可以确保这一规则得到遵守：

- 最简单的方法是将右边的操作数设为**常量**（可以静态检查其值）。
- 使用无符号整数类型可以确保操作数为非负(保证下限 0)，因此只需检查上限（运行时动态检查或审查）。
- 否则，上限和下限都需要检查。

```c
u8a = u8a << 7; /* Compliant */

u8a = u8a << 8; /* Non-compliant，只能0-7 */

u16a = (uint16_t)u8a << 9; /* Compliant */

u8a = 1u << 10u; /* Non-compliant */

u16a = (uint16_t)1u << 10u; /* Compliant     */

u64a = 1UL << 10u; /* Compliant     */
```

#### Rule 12.3

(建议) 不得使用逗号(,)运算符

使用逗号操作符通常不利于代码的可读性，通常可以通过其他方法达到同样的效果。

```c
/* also violates R.14.2 */
for (i = 0, p = &a[0]; /* Non-compliant */
     i < N;
     ++i, ++p) /* Non-compliant */
{
}
```

#### Rule 12.4

(建议) 常量表达式的求值不应导致无符号整数的回绕

无符号整数表达式严格来说不会溢出，而是回绕。

平时在编程时会用取余操作来模拟特定的回绕，如 `i=(i+1)%3` 表示每到 3 回绕一次。但在常量表达式中并不需要这种回绕。

```c
// 与 case 标签关联的表达式必须是常量表达式。
// 如果在 case 表达式求值期间发生无符号环绕，则很可能是无意的。
// 在具有 16 位 int 类型的计算机上会导致以下示例中的回绕：
#define BASE 65024u
switch (x)
{
case BASE + 0u:
     f();
     break;
case BASE + 1u:
     g();
     break;
case BASE + 512u: /* Non-compliant - wraps to 0 */
     h();
     break;
}

// #if 或 #elif 预处理器指令的控制表达式必须是常量表达式。
#if 1u + (0u - 10u) /* Non-compliant as ( 0u - 10u ) wraps */

// 在本例中，表达式 DELAY + WIDTH 的值为 70 000，
// 但在使用 16 位 int 类型的机器上，这个值会被绕成 4 464。
#define DELAY 10000u
#define WIDTH 60000u
void fixed_pulse(void)
{
     uint16_t off_time16 = DELAY + WIDTH; /* Non-compliant */
}

// c是一个对象不是常量表达式，因此不符合常量表达式的约束条件：
const uint16_t c = 0xffffu;
void f(void)
{
     uint16_t y = c + 1u; /* Compliant */
}

// 在下面的示例中，子表达式 ( 0u - 1u ) 导致无符号整数回绕。
// 在 x 的初始化过程中，子表达式不会被求值，因此表达式符合要求。
// 然而，在初始化 y 时，子表达式可能会被求值，因此表达式不符合要求。
bool_t b;
void g(void)
{
     uint16_t x = (0u == 0u) ? 0u : (0u - 1u); /* Compliant，
                                                * 0u==0u恒成立，0u-1u是不会被执行的 */
     uint16_t y = b ? 0u : (0u - 1u);          /* Non-compliant */
}
```

### 组别 13

#### Rule 13.1

(必要) 初始化程序列表不得包含持久性副作用

#### Rule 13.2

(必要) 在所有合法的评估命令下，表达式的值应与其持续的副作用相同

#### Rule 13.3

(建议) 包含自增(++)或自减(--)运算符的完整表达式，除由自增或自减运算符引起的副作用外，不应有其他潜在的副作用

#### Rule 13.4

(建议) 不得使用赋值运算符的结果

#### Rule 13.5

(必要) 逻辑与(`&&`)和逻辑或(`||`)的右操作数不得含有持久性副作用

#### Rule 13.6

(强制) sizeof 运算符的操作数不得包含任何可能产生副作用的表达式

### 组别 14

#### Rule 14.1

(必要) 循环计数器的基本类型不能为浮点型

#### Rule 14.2

(必要) for 循环应为良好格式

#### Rule 14.3

(必要) 控制表达式不得是值不变的

#### Rule 14.4

(必要) if 语句和循环语句的控制表达式的基本类型应为布尔型

### 组别 15

#### Rule 15.1

(建议) 不应使用 goto 语句

#### Rule 15.2

(必要) goto 语句仅允许跳到在同一函数中声明的稍后位置的标签

#### Rule 15.3

(必要) goto 语句引用的标签必须在 goto 语句所在代码块或包含该代码块的上级代码块中声明

#### Rule 15.4

(建议) 最多只能有一个用于终止循环语句的 break 或 goto 语句

#### Rule 15.5

(建议) 应仅在函数的末尾有单个函数出口

#### Rule 15.6

(必要) 循环语句和选择语句的主体应为复合语句

#### Rule 15.7

(必要) 所有的 if…else if 构造都应以 else 语句结束

### 组别 16

#### Rule 16.1

(必要) switch 语句应格式正确

#### Rule 16.2

(必要) switch 标签只能出现在构成 switch 语句主体的复合语句的最外层

#### Rule 16.3

(必要) 每一个 switch 子句(switch-clause)都应以无条件 break 语句终止

#### Rule 16.4

(必要) 每个 switch 语句都应具有 default 标签

#### Rule 16.5

(必要) Default 标签应作为 switch 语句的第一个或最后一个 switch 标签

#### Rule 16.6

(必要) 每个 switch 语句应至少有两个 switch 子句

#### Rule 16.7

(必要) switch 语句的控制表达式(switch-expression)的基本类型不得是布尔型

### 组别 17

#### Rule 17.1

(必要) 不得使用<stdarg.h>的功能

#### Rule 17.2

(必要) 函数不得直接或间接调用自身(不得使用递归函数)

#### Rule 17.3

(强制) 禁止隐式声明函数

#### Rule 17.4

(强制) 具有非 void 返回类型的函数的所有退出路径都应为具有带有表达式的显式 return 语句

#### Rule 17.5

(建议) 与数组型函数形参对应的函数入参应具有适当数量的元素

#### Rule 17.6

(强制) 数组形参的声明不得在[]之间包含 static 关键字

#### Rule 17.7

(必要) 非 void 返回类型的函数的返回值应该被使用

#### Rule 17.8

(建议) 不应更改函数形参

### 组别 18

#### Rule 18.1

(必要) 指针操作数的算术运算应仅用于寻址与该指针操作数相同数组的元素

#### Rule 18.2

(必要) 指针之间的减法应仅用于寻址同一数组元素的指针

#### Rule 18.3

(必要) 关系运算符>，> =，<和<=不得应用于指针类型的对象，除非它们指向同一对象

#### Rule 18.4

(建议) +，-，+=和-=运算符不得应用于指针类型的表达式

#### Rule 18.5

(建议) 声明中最多包含两层指针嵌套

#### Rule 18.6

(必要) 具有自动存储功能的对象的地址不得复制给在它的生命周期结束后仍会存在的另一个对象

#### Rule 18.7

(必要) 不得声明灵活数组成员

#### Rule 18.8

(必要) 不得使用可变长数组类型

### 组别 19

#### Rule 19.1

(强制) 不得将对象赋值或复制给重叠的对象

#### Rule 19.2

(必要) 不得使用 union 关键字

### 组别 20

#### Rule 20.1

(建议) #include 指令之前仅允许出现预处理指令或注释

#### Rule 20.2

(必要) 头文件名中不得出现“'”、“"”、“\”、字符以及“/\*”或“//”字符序列

#### Rule 20.3

(必要) #include 指令后须跟随`<filename>`或`"filename"`序列

#### Rule 20.4

(必要) 宏不得与关键字同名

#### Rule 20.5

(建议) 不应使用#undef

#### Rule 20.6

(必要) 看起来像预处理指令的符号不得出现在宏参数内

#### Rule 20.7

(必要) 宏参数展开产生的表达式应放在括号内

#### Rule 20.8

(必要) #if 或#elif 预处理指令的控制表达式的计算结果应为 0 或 1

#### Rule 20.9

(必要) #if 或#elif 预处理指令的控制表达式中使用的所有标识符应在其评估前被#define 定义

#### Rule 20.10

(建议) 不应使用“#”和“##”预处理运算符

#### Rule 20.11

(必要) 紧跟在“#”运算符之后的宏参数后面不得紧随“##”运算符 operator

#### Rule 20.12

(必要) 用作“#”或“##”运算符的操作数的宏参数，不得是本身需要进一步宏替换的操作数

#### Rule 20.13

(必要) 以“#”作为第一个字符的一行代码应为有效的预处理指令

#### Rule 20.14

(必要) 所有#else，#elif 和#endif 预处理程序指令都应和与其相关的#if，#ifdef 或#ifndef 指令位于同一文件中

### 组别 21

#### Rule 21.1

(必要) 不得将#define 和#undef 用于保留的标识符或保留的宏名称

#### Rule 21.2

(必要) 不得声明保留的标识符或宏名称

#### Rule 21.3

(必要) 不得使用<stdlib.h>中的内存分配和释放函数

#### Rule 21.4

(必要) 不得使用标准头文件<setjmp.h>

#### Rule 21.5

(必要) 不得使用标准头文件<signal.h>

#### Rule 21.6

(必要) 不得使用标准库输入/输出函数

#### Rule 21.7

(必要) 不得使用<stdlib.h>中的 atof、atoi、atol 和 atoll 函数

#### Rule 21.8

(必要) 不得使用<stdlib.h>中的 abort, exit, getenv 和 system 函数

#### Rule 21.9

(必要) 不得使用<stdlib.h>中的 bsearch 和 qsort 函数

#### Rule 21.10

(必要) 不得使用标准库时间和日期功能

#### Rule 21.11

(必要) 不得使用标准头文件<tgmath.h>

#### Rule 21.12

(建议) 不得使用<fenv.h>的异常处理功能

### 组别 22

#### Rule 22.1

(必要) 通过标准库功能动态获取的所有资源均应明确释放

#### Rule 22.2

(强制) 只有通过标准库函数分配的内存块才能释放

#### Rule 22.3

(必要) 不得在不同的数据流上同时打开同一文件以进行读写访问

#### Rule 22.4

(强制) 禁止尝试对以只读方式打开的流执行写操作

#### Rule 22.5

(强制) 禁止反引用指向 FILE 对象的指针

#### Rule 22.6

(强制) 关联的流关闭后，禁止再使用指向 FILE 的指针值
