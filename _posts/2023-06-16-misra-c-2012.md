---
title: "MISRA C:2012 嵌入式C规范解读"
author: Jinkai
date: 2023-06-16 09:00:00 +0800
published: true
categories: [技术]
tags: [misra, MISRA C:2012]
---

## 总览

MISRA C 指南定义了一个 C 语言的子集，在这个子集中，犯错的机会被消除或减少，程序可靠性得到提高。

MISRA C 发展历史:

1. `MISRA C:1998` – 第一版（汽车行业的原始指南）
2. `MISRA C:2004` – 第二版（考虑了用户反馈和跨行业应用）
3. `MISRA C:2012` – 第三版（包含对 C99 语言功能的支持，改进的强类型模型，分析关键字）
   - `MISRA C:2012` (Feb 2019) – 第三版第一次修订（纳入了额外的安全准则），纳入了第 1 次修正案（AMD1）和技术更正 1（TC1） – 也称为 `MISRA C:2019`
   - `MISRA C:2023` (Apr 2023) – 第三版第二次修订（包含对 C11 和 C18 语言功能的支持），纳入了第 2 次（AMD2）、第 3 次（AMD3）和第 4 次（AMD4）修正案，以及技术更正 2（TC2）。

本文将介绍第三版的初稿，也就是`MISRA C:2012`。

## 背景

### C 语言优势

C 编程语言很受欢迎，因为：

- C 语言编译器可用于**许多处理器**；
- C 语言程序可被编译为**高效**的机器代码；
- 它由**国际标准**（ISO）定义；
- 它提供了访问目标处理器的输入/输出能力的机制，无论是**直接访问**还是通过**语言扩展**；
- 在关键系统中使用 C 语言有大量的**经验**；
- 它被**静态分析**和**测试工具**广泛支持。

### C 语言缺陷

#### 语言定义

ISO 标准并没有完全规范 C 语言，而是故意将某些方面放到**实现时**由程序员(编译器)自己去定义，从而让 C 语言变得更加灵活以支持不同的处理器。

这会导致某些行为变得不可预测，这对嵌入式领域的可靠性要求是致命的。

例子：

```c
if ( ishigh && (x == i++))
```

在上面这个例子中，该语句的执行会因编译器的不同产生不同的结果：

- `ishigh` 为否时，后一个表达式不判断，`i`不变
- `ishigh` 为否时，后一个表达式也判断，`i`增加 1

这就需要程序员对编译器特性非常熟悉(但还是避免不了失误)，且该代码的**可移植性**也会很差

#### 语言误用

编程过程中可能会出现连程序员自己也没发觉的失误：

```c
if (a == b) /* 判断a和b是否相等 */
if (a = b) /* 将b赋值给a，并判断a是否为非0 */
```

这种情况一般是把 `a == b` 误写成 `a = b` 了，但对编译器来说它们都合法，无法判断错误。

> 不过现在的静态检查工具在编程时就能检查出这种情况，给出 warning

#### 语言误解

C 语言有很多运算符，虽然标准规定了运算符的优先级，但比较难记忆，可能在编程中混淆了部分运算符的优先级。

C 语言不是强类型语言，其类型可以隐式转换，也就是操作产生的数据类型和操作数类型可能不同。

#### 运行时(Run-time)错误检查

C 语言程序可以被编译成小而有效的机器代码，但其代价是运行时检查的程度非常有限。

C 语言程序一般不提供对常见问题的运行时检查，如算术异常（如除以 0）、溢出、指针的有效性或数组边界错误。

C 语言的理念是，程序员有责任明确地进行这种检查。

## 工具选择

### C 标准和编译器选择

`MISRA C:2012` 基于`ISO/IEC 9899:2011 [14]`(C99)和`ISO/IEC 9899:1990 [2]`(C90)标准编写

根据项目需求选择 C99 或 C90 标准

> 写者注：原文的一些介绍已经过时，这里就不写了，比如他认为当前编译器对 C99 的支持普遍不好，实际上现在(2023 年)大多数的编译器都已经能较好的支持 C99 了，对于新项目，建议无脑选 `GCC` 就行

### 代码分析工具

> 写者注：本节将由写者根据项目经验列出推荐的工具

这里推荐使用开源的[cppcheck](https://cppcheck.sourceforge.io/)搭配[misra 插件](https://cppcheck.sourceforge.io/misra.php)，只需在安装 cppcheck 时勾选安装 addons，然后搭配 vscode 中的[cpp-check-lint](https://marketplace.visualstudio.com/items?itemName=QiuMingGe.cpp-check-lint)插件和规则描述文件(规则描述文件可以在 github 上找找，毕竟有版权不能随便共享)

当然如果有充足的资金可以选择购买专业的静态检查工具，[List of tools for static code analysis - Wikipedia](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis)网站上列出了所有主流的静态检查工具，搜索`"misra"`即可找到支持 misra 的检查工具。

## 必备知识

开发者应具备嵌入式、高集成、高安全性编程基础，并了解使用的编译器和静态检查工具。

## 使用 MISRA C

MISRA C 应该从项目一开始便使用，如果是为了符合 MISRA C 而对已有项目大规模修改会造成不可预估的问题，注意评估好这么做的风险。

因在代码审核和单元测试前检查代码是否符合 MISRA C。

MISRA C 不提供任何与**编程风格**相关的建议。

注意编译器优化选项，平衡目标文件大小和缺陷风险。

### 偏离标准

允许为了某些特殊情况偏离标准，比如将 int 类型值强制转为指针来实现访问内存地址空间映射的 I/O 端口:

```c
// 内存中的0x0002地址内数据映射了某一I/O端口数据
#define PORT (*(volatile unsigned char *)0x0002)
// 修改该位置数据就相当于修改了该I/O端口数据
PORT = 0x10u;
```

需要有专门的方式记录这种不得不违反 MISRA C 的地方。最好不要有这种地方。

## 准则介绍

每项 MISRA C `准则(guidelines)`都被分为 "`规则(Rule)`"或 "`指示(Directive)`":

指示是指无法提供必要的完整描述来进行合规性检查的准则。为了能够执行检查，需要额外的信息，如设计文档或需求规格中可能提供的信息。静态分析工具可以帮助检查是否符合指示，但不同的工具对不符合指示的解释可能大相径庭。

规则是对要求进行完整描述的准则。检查源代码是否符合规则应该是可能的，而不需要任何其它信息。特别是，静态分析工具应该能够检查规则的合规性，但必须遵守第 6.5 节中描述的限制。

> 注意后续的准则、规则、指示名词

### 准则分类

每条准则被分为:

- `强制(mandatory)`：不允许违反
- `要求(required)`：只有在有明确限制、要求和预防措施的偏离情况下才能违反
- `建议(advisory)`：在合理可行的范围内遵循建议

他们的重要程度相同，区别只是是否允许[偏离标准](#偏离标准)

### 可判定性(Decidability)

规则(Rule)分为`可判定的(decidable)`和`不可判定的(undecidable)`:

- 可判定的: 可由静态分析工具明确给出是否符合 MISRA C 的结论(是或否)
- 不可判定的: 不能给出明确结论，比如有些需要在编译、连接阶段或运行时才能分析出

### 分析的作用域(Scope)

规则(Rule)的分析的作用域分为`单一翻译单元(Single Translation Unit)`和`系统(System)`

也就是根据各种变量、函数的作用域来确定规则分析时的作用域。

```c
extern void f(uint16_t *p);
uint16_t y;
void g(void)
{
    uint16_t x; /* x is not given a value */
    f(&x);      /* f might modify the object pointed to by its parameter */
    y = x;      /* x may or may not be unset */
}
```

### 多来源项目

项目中的代码来源于多个公司(组织)：

- 标准库来源于编译器
- 底层驱动来源于设备厂家
- 操作系统和上层驱动来源于特定供应厂家
- 应用代码来自于其他厂家

特别是标准库和底层代码为了高性能会用到很多汇编以及偏离准则部分，这部分不需要不用符合 MISRA C 规范。

其他代码尽可能符合 MISRA C，如果推动第三方厂家配合较为困难，至少头文件(接口)要符合 MISRA C。

### 自动生成的代码

项目中自动生成的代码也需要遵守 MISRA C

### 准则格式

| Ident      | Requirement text   |            |
| :--------- | :----------------- | ---------: |
|            |                    | Source ref |
| Category   | Category           |            |
| Aanalysis  | Decidability,Scope |            |
| Applies to | Cxx                |            |

- Ident: 准则的唯一序号
- Requirement text: 准则文本
- Source ref: 参考来源
- Category: [准则分类](#准则分类)
- Decidability: [可判定性(Decidability)](#可判定性decidability)，指示(Directive)无该选项
- Scope: [分析的作用域(Scope)](#分析的作用域scope)，指示(Directive)无该选项
- Cxx: C 标准(C89、C99)

### 引用来源

#### ISO C

MISRA C 引用了 C90 和 C99，注意以下的一些行为：

- `Unspecified`: **未明确行为**是指在 C 语言标准中**没有明确**规定其具体行为的情况。这意味着编译器可以根据实现的特定规则来定义其行为，但在不同的编译器或平台上可能会有不同的结果。如 `x=f(&a)+g(&a)`，f 与 g 的执行顺序是`未明确的`，而且其执行顺序可能影响到 x 的最终结果。
- `Undefined`: **未定义行为**是指当程序**违反**了 C 语言标准规范，导致编译器无法确定其具体行为时发生的情况。例如，对指针进行未初始化的解引用、数组越界访问、除以零等操作都属于未定义行为。最重要的是编译器没有责任去检查这些错误，导致这些问题无法在编译阶段暴露。
- `Implementation-defined"`: **实现定义行为**是指 C 语言标准规定了**多个**可能的行为，但具体的行为由编译器或平台的实现决定。这意味着在不同的编译器或平台上，同一段代码可能会有不同的行为，但这些行为都是符合标准的。应尽量避免该行为来保证代码在不同编译器上的一致性和可移植性。
- `Locale`: 本地化行为，和 C 语言的本地化相关，比如字符的使用习惯、日期格式等，这里不涉及。

## 指示(Directives)

TODO

## 规则(Rule)

### Rule 1.1

(必要) 程序不得违反标准 C 语法和约束，并且不得超出具体实现的编译限制

### Rule 1.2

(建议) 不应该使用语言扩展

### Rule 1.3

(必要) 不得发生未定义或严重的未指定行为

### Rule 2.1

(必要) 项目不得包含不可达代码(unreachable code)

### Rule 2.2

(必要) 不得有无效代码(dead code)

### Rule 2.3

(建议) 项目不应包含未被使用的类型(type)声明

### Rule 2.4

(建议) 项目不应包含未被使用的类型标签(tag)声明

### Rule 2.5

(建议) 项目不应包含未被使用的宏(macro)声明

### Rule 2.6

(建议) 函数不应包含未被使用的执行标签(label)声明

### Rule 2.7

(建议) 函数中不应有未使用的变量

### Rule 3.1

(必要) 字符序列“/\*”和“//”不得在注释中使用

### Rule 3.2

(必要) “//”注释中不得使用换行(即“//”注释中不得使用行拼接符“\”)

### Rule 4.1

(必要) 八进制和十六进制转译序列应有明确的终止识别标识

### Rule 4.2

(建议) 禁止使用三字母词(trigraphs)

### Rule 5.1

(必要) 外部标识符不得重名

### Rule 5.2

(必要) 同范围和命名空间内的标识符不得重名

### Rule 5.3

(必要) 内部声明的标识符不得隐藏外部声明的标识符

### Rule 5.4

(必要) 宏标识符不得重名

### Rule 5.5

(必要) 宏标识符与其他标识符不得重名

### Rule 5.6

(必要) typedef 名称应是唯一标识符

### Rule 5.7

(必要) 标签(tag)名称应是唯一标识符

### Rule 5.8

(必要) 全局(external linkage)对象和函数的标识符应是唯一的

### Rule 5.9

(建议) 局部全局(internal linkage)对象和函数的标识符应是唯一的

### Rule 6.1

(必要) 位域(位带)仅允许使用适当的类型来声明(位域成员类型限制)

### Rule 6.2

(必要) 单比特(single-bit)位域成员不可声明为有符号类型

### Rule 7.1

(必要) 禁止使用八进制常数

### Rule 7.2

(必要) 后缀“u”或“U”应使用于所有无符号的整数常量

### Rule 7.3

(必要) 小写字符“l”不得作为常量的后缀使用(仅可使用“L”)

### Rule 7.4

(必要) 除非对象的类型为“指向 const char 的指针”，否则不得将字符串常量赋值给该对象

### Rule 8.1

(必要) 类型须明确声明

### Rule 8.2

(必要) 函数类型应为带有命名形参的原型形式

### Rule 8.3

(必要) 对象或函数的所有声明均应使用相同的名称和类型限定符

### Rule 8.4

(必要) 全局(external linkage)的对象和函数，应有显式的合规的声明

### Rule 8.5

(必要) 全局对象或函数应在且只在一个文件中声明一次

### Rule 8.6

(必要) 全局标识符应在且只在一处定义

### Rule 8.7

(建议) 仅在本编译单元中调用的对象和函数，应定义成局部属性

### Rule 8.8

(必要) “static”修饰符应用在所有局部全局对象和局部函数(internal linkage)的声明中

### Rule 8.9

(建议) 若一个对象的标识符仅在一个函数中出现，则应将它定义在块范围内

### Rule 8.10

(必要) 内联函数应使用静态存储类声明

### Rule 8.11

(建议) 声明具有外部链接的数组时，应明确指定其大小

### Rule 8.12

(必要) 在枚举列表中，隐式指定的枚举常量的值应唯一

### Rule 8.13

(建议) 指针应尽可能指向 const 限定类型

### Rule 8.14

(必要) 不得使用类型限定符“restrict”

### Rule 9.1

(强制) 具有自动存储持续时间的对象(临时变量)的值在设置前不得读取

### Rule 9.2

(必要) 集合或联合体的初始化应括在花括号“{}”中

### Rule 9.3

(必要) 数组不得部分初始化

### Rule 9.4

(必要) 数组的元素不得被初始化超过一次

### Rule 9.5

(必要) 在使用指定初始化方式初始化数组对象的情况下，应明确指定数组的大小

### Rule 10.1

(必要) 操作数不得为不适当的基本类型

### Rule 10.2

(必要) 字符类型的表达式不得在加减运算中使用不当

### Rule 10.3

(必要) 表达式的值不得赋值给具有较窄基本类型或不同基本类型的对象

### Rule 10.4

(必要) 执行常规算术转换的运算符的两个操作数应有相同的基本类型

### Rule 10.5

(建议) 表达式的值不应(强制)转换为不适当的基本类型

### Rule 10.6

(必要) 复合表达式的值不得赋值给具有较宽基本类型的对象

### Rule 10.7

(必要) 如果将复合表达式用作执行常规算术转换的运算符的一个操作数，则另一个操作数不得具有更宽的基本类型

### Rule 10.8

(必要) 复合表达式的值不得转换为其他基本类型或更宽的基本类型

### Rule 11.1

(必要) 不得在指向函数的指针和任何其他类型的指针之间进行转换

### Rule 11.2

(必要) 不得在指向不完整类型的指针和其他任何类型间进行转换

### Rule 11.3

(必要) 不得在指向不同对象类型的指针之间执行强制转换

### Rule 11.4

(建议) 不得在指向对象的指针和整数类型之间进行转换

### Rule 11.5

(建议) 不得将指向 void 的指针转换为指向对象的指针

### Rule 11.6

(必要) 不得在指向 void 的指针和算术类型之间执行强制转换

### Rule 11.7

(必要) 不得在指向对象的指针和非整数算术类型之间执行强制转换

### Rule 11.8

(必要) 强制转换不得从指针指向的类型中删除任何 const 或 volatile 限定符

### Rule 11.9

(必要) 宏“NULL”是整数型空指针常量的唯一允许形式

### Rule 12.1

(建议) 表达式中运算符的优先级应明确

### Rule 12.2

(必要) 移位运算符的右操作数应在零到比左操作数基本类型的位宽度小一的范围内

### Rule 12.3

(建议) 不得使用逗号(,)运算符

### Rule 12.4

(建议) 常量表达式的求值不应导致无符号整数的回绕

### Rule 13.1

(必要) 初始化程序列表不得包含持久性副作用

### Rule 13.2

(必要) 在所有合法的评估命令下，表达式的值应与其持续的副作用相同

### Rule 13.3

(建议) 包含自增(++)或自减(--)运算符的完整表达式，除由自增或自减运算符引起的副作用外，不应有其他潜在的副作用

### Rule 13.4

(建议) 不得使用赋值运算符的结果

### Rule 13.5

(必要) 逻辑与(&&)和逻辑或(||)的右操作数不得含有持久性副作用

### Rule 13.6

(强制) sizeof 运算符的操作数不得包含任何可能产生副作用的表达式

### Rule 14.1

(必要) 循环计数器的基本类型不能为浮点型

### Rule 14.2

(必要) for 循环应为良好格式

### Rule 14.3

(必要) 控制表达式不得是值不变的

### Rule 14.4

(必要) if 语句和循环语句的控制表达式的基本类型应为布尔型

### Rule 15.1

(建议) 不应使用 goto 语句

### Rule 15.2

(必要) goto 语句仅允许跳到在同一函数中声明的稍后位置的标签

### Rule 15.3

(必要) goto 语句引用的标签必须在 goto 语句所在代码块或包含该代码块的上级代码块中声明

### Rule 15.4

(建议) 最多只能有一个用于终止循环语句的 break 或 goto 语句

### Rule 15.5

(建议) 应仅在函数的末尾有单个函数出口

### Rule 15.6

(必要) 循环语句和选择语句的主体应为复合语句

### Rule 15.7

(必要) 所有的 if…else if 构造都应以 else 语句结束

### Rule 16.1

(必要) switch 语句应格式正确

### Rule 16.2

(必要) switch 标签只能出现在构成 switch 语句主体的复合语句的最外层

### Rule 16.3

(必要) 每一个 switch 子句(switch-clause)都应以无条件 break 语句终止

### Rule 16.4

(必要) 每个 switch 语句都应具有 default 标签

### Rule 16.5

(必要) Default 标签应作为 switch 语句的第一个或最后一个 switch 标签

### Rule 16.6

(必要) 每个 switch 语句应至少有两个 switch 子句

### Rule 16.7

(必要) switch 语句的控制表达式(switch-expression)的基本类型不得是布尔型

### Rule 17.1

(必要) 不得使用<stdarg.h>的功能

### Rule 17.2

(必要) 函数不得直接或间接调用自身(不得使用递归函数)

### Rule 17.3

(强制) 禁止隐式声明函数

### Rule 17.4

(强制) 具有非 void 返回类型的函数的所有退出路径都应为具有带有表达式的显式 return 语句

### Rule 17.5

(建议) 与数组型函数形参对应的函数入参应具有适当数量的元素

### Rule 17.6

(强制) 数组形参的声明不得在[]之间包含 static 关键字

### Rule 17.7

(必要) 非 void 返回类型的函数的返回值应该被使用

### Rule 17.8

(建议) 不应更改函数形参

### Rule 18.1

(必要) 指针操作数的算术运算应仅用于寻址与该指针操作数相同数组的元素

### Rule 18.2

(必要) 指针之间的减法应仅用于寻址同一数组元素的指针

### Rule 18.3

(必要) 关系运算符>，> =，<和<=不得应用于指针类型的对象，除非它们指向同一对象

### Rule 18.4

(建议) +，-，+=和-=运算符不得应用于指针类型的表达式

### Rule 18.5

(建议) 声明中最多包含两层指针嵌套

### Rule 18.6

(必要) 具有自动存储功能的对象的地址不得复制给在它的生命周期结束后仍会存在的另一个对象

### Rule 18.7

(必要) 不得声明灵活数组成员

### Rule 18.8

(必要) 不得使用可变长数组类型

### Rule 19.1

(强制) 不得将对象赋值或复制给重叠的对象

### Rule 19.2

(必要) 不得使用 union 关键字

### Rule 20.1

(建议) #include 指令之前仅允许出现预处理指令或注释

### Rule 20.2

(必要) 头文件名中不得出现“'”、“"”、“\”、字符以及“/\*”或“//”字符序列

### Rule 20.3

(必要) #include 指令后须跟随`<filename>`或`"filename"`序列

### Rule 20.4

(必要) 宏不得与关键字同名

### Rule 20.5

(建议) 不应使用#undef

### Rule 20.6

(必要) 看起来像预处理指令的符号不得出现在宏参数内

### Rule 20.7

(必要) 宏参数展开产生的表达式应放在括号内

### Rule 20.8

(必要) #if 或#elif 预处理指令的控制表达式的计算结果应为 0 或 1

### Rule 20.9

(必要) #if 或#elif 预处理指令的控制表达式中使用的所有标识符应在其评估前被#define 定义

### Rule 20.10

(建议) 不应使用“#”和“##”预处理运算符

### Rule 20.11

(必要) 紧跟在“#”运算符之后的宏参数后面不得紧随“##”运算符 operator

### Rule 20.12

(必要) 用作“#”或“##”运算符的操作数的宏参数，不得是本身需要进一步宏替换的操作数

### Rule 20.13

(必要) 以“#”作为第一个字符的一行代码应为有效的预处理指令

### Rule 20.14

(必要) 所有#else，#elif 和#endif 预处理程序指令都应和与其相关的#if，#ifdef 或#ifndef 指令位于同一文件中

### Rule 21.1

(必要) 不得将#define 和#undef 用于保留的标识符或保留的宏名称

### Rule 21.2

(必要) 不得声明保留的标识符或宏名称

### Rule 21.3

(必要) 不得使用<stdlib.h>中的内存分配和释放函数

### Rule 21.4

(必要) 不得使用标准头文件<setjmp.h>

### Rule 21.5

(必要) 不得使用标准头文件<signal.h>

### Rule 21.6

(必要) 不得使用标准库输入/输出函数

### Rule 21.7

(必要) 不得使用<stdlib.h>中的 atof、atoi、atol 和 atoll 函数

### Rule 21.8

(必要) 不得使用<stdlib.h>中的 abort, exit, getenv 和 system 函数

### Rule 21.9

(必要) 不得使用<stdlib.h>中的 bsearch 和 qsort 函数

### Rule 21.10

(必要) 不得使用标准库时间和日期功能

### Rule 21.11

(必要) 不得使用标准头文件<tgmath.h>

### Rule 21.12

(建议) 不得使用<fenv.h>的异常处理功能

### Rule 22.1

(必要) 通过标准库功能动态获取的所有资源均应明确释放

### Rule 22.2

(强制) 只有通过标准库函数分配的内存块才能释放

### Rule 22.3

(必要) 不得在不同的数据流上同时打开同一文件以进行读写访问

### Rule 22.4

(强制) 禁止尝试对以只读方式打开的流执行写操作

### Rule 22.5

(强制) 禁止反引用指向 FILE 对象的指针

### Rule 22.6

(强制) 关联的流关闭后，禁止再使用指向 FILE 的指针值
