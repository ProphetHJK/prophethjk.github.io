---
title: "littlefs技术介绍"
author: Jinkai
date: 2023-01-04 09:00:00 +0800
published: true
math: true
categories: [学习笔记]
tags: [嵌入式, 文件系统]
---

## 目标

- **断电恢复能力** - 在嵌入式系统上，`随时可能断电`。 如果断电损坏了任何持久性数据结构，这可能会导致设备变得不可恢复。嵌入式文件系统必须设计为从任何写入操作期间的断电中恢复。
- **磨损均衡** - 写入闪存具有破坏性。如果文件系统`反复写入`同一个块，最终该块将磨损。 不考虑磨损的文件系统很容易烧毁用于存储频繁更新的元数据的块并导致设备过早死亡。
- **有界 RAM/ROM** - 如果上述要求还不够，这些系统的内存量也非常有限。这可以防止许多现有的文件系统设计，可以依赖于相对大量的 RAM 用于临时存储文件系统元数据。

## 概念

### 基于块

存储被划分为块，每个文件都存储在一个块的集合。

```plaintext
               .--------.
               |  root  |
               |        |
               |        |
               '--------'
               .-'    '-.
              v          v
         .--------.  .--------.
         |   A    |  |   B    |
         |        |  |        |
         |        |  |        |
         '--------'  '--------'
         .-'         .-'    '-.
        v           v          v
   .--------.  .--------.  .--------.
   |   C    |  |   D    |  |   E    |
   |        |  |        |  |        |
   |        |  |        |  |        |
   '--------'  '--------'  '--------'
```

### 日志文件系统

存储位置不绑定到一块数据，而是整个存储用于循环日志，即附加对文件系统所做的每次更改。

但这带来一个问题，读取时需要遍历日志以重建文件。一些日志记录文件系统`缓存`文件以避免读取成本，这就需要与 RAM 的占用做权衡。

日志记录文件系统非常优雅。使用`校验和`，我们可以轻松地检测断电并通过忽略失败回退到以前的状态。同时`只写一次`策略让磨损均衡变得自然。

```plaintext
                                                            v
.--------.--------.--------.--------.--------.--------.--------.--------.
|        C        | new B  | new A  |                 |   A    |   B    |
|                 |        |        |->               |        |        |
|                 |        |        |                 |        |        |
'--------'--------'--------'--------'--------'--------'--------'--------'
```

图中显示了一种日志循环的情况，A、B、C 写入完成后接下来修改 A、B，新的文件内容就存在于 C 之后了。

### 写时复制(CoW)技术

不去更新原位置的内容，需要修改时复制一份并在修改后写入新的位置。很适合用于实现磨损均衡

```plaintext
               .--------.                  .--------.
               |  root  |       write      |new root|
               |        |        ==>       |        |
               |        |                  |        |
               '--------'                  '--------'
               .-'    '-.                    |    '-.
              |  .-------|------------------'        v
              v v        v                       .--------.
         .--------.  .--------.                  | new B  |
         |   A    |  |   B    |                  |        |
         |        |  |        |                  |        |
         |        |  |        |                  '--------'
         '--------'  '--------'                  .-'    |
         .-'         .-'    '-.    .------------|------'
        |           |          |  |             v
        v           v          v  v        .--------.
   .--------.  .--------.  .--------.      | new D  |
   |   C    |  |   D    |  |   E    |      |        |
   |        |  |        |  |        |      |        |
   |        |  |        |  |        |      '--------'
   '--------'  '--------'  '--------'
```

在上图中对 D 的修改导致 D 的位置发生变化，导致目录 B 的指针发生变化，需要修改，对 B 的修改又导致了 B 位置的变化，继而引起 root 位置的变化。

## 设计

### 总览

![overview](/assets/img/2023-01-04-little-fs/overview.png)

### 元数据对

每次对数据的修改都会同步修改元数据，由于写时复制技术，元数据所在块的修改也会使用新的块，很自然的就会被放在被修改的块后面。

每个元数据理论上占用一个块，由于采用主备互切的方式，实际上需要占用两个块。

```plaintext
metadata pair pointer: {block 0, block 1}
                           |        '--------------------.
                            '-.                           |
disk                           v                          v
.--------.--------.--------.--------.--------.--------.--------.--------.
|                 |        |metadata|                 |metadata|        |
|                 |        |block 0 |                 |block 1 |        |
|                 |        |        |                 |        |        |
'--------'--------'--------'--------'--------'--------'--------'--------'
                               '--.                  .----'
                                   v                v
             metadata pair .----------------.----------------.
                           |   revision 11  |   revision 12  |
             block 1 is    |----------------|----------------|
             most recent   |       A        |       A''      |
                           |----------------|----------------|
                           |    checksum    |    checksum    |
                           |----------------|----------------|
                           |       B        |       A'''     | <- most recent A
                           |----------------|----------------|
                           |       A''      |    checksum    |
                           |----------------|----------------|
                           |    checksum    |       |        |
                           |----------------|       v        |
                           '----------------'----------------'
```

上图中，metadata block 0 和 block 1 实际上表示同一份 metadata，不过是两个不同的版本，以新的一份为准，上图中就是以 block 1 表示的 revision 12 为准。

每个元数据块包含若干条记录，每若干条记录后有一个 CRC32 checksum 用于校验:

```plaintext
  .---------------------------------------.
.-|  revision count   |      tag ~A       |        \
| |-------------------+-------------------|        |
| |                 data A                |        |
| |                                       |        |
| |-------------------+-------------------|        |
| |      tag AxB      |       data B      | <--.   |
| |-------------------+                   |    |   |
| |                                       |    |   +-- 1st commit
| |         +-------------------+---------|    |   |
| |         |      tag BxC      |         | <-.|   |
| |---------+-------------------+         |   ||   |
| |                 data C                |   ||   |
| |                                       |   ||   |
| |-------------------+-------------------|   ||   |
| |     tag CxCRC     |        CRC        |   ||   /
| |-------------------+-------------------|   ||
| |     tag CRCxA'    |      data A'      |   ||   \
| |-------------------+                   |   ||   |
| |                                       |   ||   |
| |              +-------------------+----|   ||   +-- 2nd commit
| |              |     tag CRCxA'    |    |   ||   |
| |--------------+-------------------+----|   ||   |
| | CRC          |        padding         |   ||   /
| |--------------+----+-------------------|   ||
| |     tag CRCxA''   |      data A''     | <---.  \
| |-------------------+                   |   |||  |
| |                                       |   |||  |
| |         +-------------------+---------|   |||  |
| |         |     tag A''xD     |         | < |||  |
| |---------+-------------------+         |  ||||  +-- 3rd commit
| |                data D                 |  ||||  |
| |                             +---------|  ||||  |
| |                             |   tag Dx|  ||||  |
| |---------+-------------------+---------|  ||||  |
| |CRC      |        CRC        |         |  ||||  /
| |---------+-------------------+         |  ||||
| |           unwritten storage           |  ||||  more commits
| |                                       |  ||||       |
| |                                       |  ||||       v
| |                                       |  ||||
| |                                       |  ||||
| '---------------------------------------'  ||||
'---------------------------------------'    |||'- most recent A
                                             ||'-- most recent B
                                             |'--- most recent C
                                             '---- most recent D
```

每个元数据类型都有 tag 标记用于识别，连 CRC 也有一个单独的标记。支持`事务`，每次 commit 以一个 CRC 结束。

### 元数据 tag

一个 tag 用 32 位表示，可以表示所有类型的元数据

```plaintext
[----            32             ----]
[1|--  11   --|--  10  --|--  10  --]
 ^.     ^     .     ^          ^- length
 |.     |     .     '------------ id
 |.     '-----.------------------ type (type3)
 '.-----------.------------------ valid bit
  [-3-|-- 8 --]
    ^     ^- chunk
    '------- type (type1)
```

元数据 tag 字段：

- **有效位（1 位）**- 指示标签是否有效。
- **Type3（11 位）**- 标签的类型。 该字段进一步细分为 3 位 type 类型和 8 位 chunk 字段。 请注意，值 0x000 无效且未分配类型。

  - **Type1（3 位）**- 标签的抽象类型。 将标记分为 8 个类别，以促进位掩码查找。
  - **chunk（8 位）**- 不同抽象类型用于各种目的的 chunk 字段。 type1+chunk+id 构成元数据块中每个标签的`唯一标识符`。

- **Id（10 位）**- 与标签关联的文件 ID。 元数据块中的每个文件都有一个唯一的 ID，用于将标签与该文件相关联。 特殊值 0x3ff 用于与文件无关的任何标记，例如目录和全局元数据。
- **长度（10 位）**- 以字节为单位的数据长度。 特殊值 0x3ff 表示该标签已被删除。

### 超级块

superblock 使用元数据对的方式存储，可能会通过 tail 占用多个元数据对，但起始元数据对总是位于 block 0 和 block 1，方便初始化时重构文件系统信息。

根目录信息保存在 superblock 中。

超级块包含了一个`超级块 tag`:

```plaintext
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][---              64               ---]
 ^    ^     ^    ^- size (8)           ^- magic string ("littlefs")
 |    |     '------ id (0)
 |    '------------ type (0x0ff)
 '----------------- valid bit

```

其中`魔术字符串`始终为"littlefs"

超级块还包含了一个`内联结构`，用于保存文件系统基本配置信息：

```plaintext
        tag                          data
[--      32      --][--      32      --|--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][--      32      --|--      32      --|--      32      --]
 ^    ^     ^    ^            ^- version         ^- block size      ^- block count
 |    |     |    |  [--      32      --|--      32      --|--      32      --]
 |    |     |    |  [--      32      --|--      32      --|--      32      --]
 |    |     |    |            ^- name max        ^- file max        ^- attr max
 |    |     |    '- size (24)
 |    |     '------ id (0)
 |    '------------ type (0x201)
 '----------------- valid bit
```

### 日志整理

当某一个 block 写满时，需要删除不需要的条目来腾出空间，如下图，对文件 B 修改后，对 B 的本身来说 B'才是有效记录，记录 B 已经没用了，同时对 A 来说 A'是最新记录，记录 A 也 2 没用了，这时就可以整理为 revision2 的形式。

这就是为什么元数据需要成对的原因，成对后两份元数据可以交替更新，保证写入时的一致性。

```plaintext
                        commit B', need to compact
.----------------.----------------.    .----------------.----------------.
|   revision 1   |   revision 0   | => |   revision 1   |   revision 2   |
|----------------|----------------|    |----------------|----------------|
|       A        |                |    |       A        |       A'       |
|----------------|                |    |----------------|----------------|
|    checksum    |                |    |    checksum    |       B'       |
|----------------|                |    |----------------|----------------|
|       B        |                |    |       B        |    checksum    |
|----------------|                |    |----------------|----------------|
|       A'       |                |    |       A'       |       |        |
|----------------|                |    |----------------|       v        |
|    checksum    |                |    |    checksum    |                |
|----------------|                |    |----------------|                |
'----------------'----------------'    '----------------'----------------'
```

#### 日志扩展

如果没有垃圾数据无法腾出空间，就要对元数据块做扩展，扩展块也是以元数据对的方式呈现，通过 tail 指针指向性的扩展元数据对。

```plaintext
                        commit C and D, need to split
.----------------.----------------.    .----------------.----------------.
|   revision 1   |   revision 2   | => |   revision 3   |   revision 2   |
|----------------|----------------|    |----------------|----------------|
|       A        |       A'       |    |       A'       |       A'       |
|----------------|----------------|    |----------------|----------------|
|    checksum    |       B'       |    |       B'       |       B'       |
|----------------|----------------|    |----------------|----------------|
|       B        |    checksum    |    |      tail    ---------------------.
|----------------|----------------|    |----------------|----------------| |
|       A'       |       |        |    |    checksum    |                | |
|----------------|       v        |    |----------------|                | |
|    checksum    |                |    |       |        |                | |
|----------------|                |    |       v        |                | |
'----------------'----------------'    '----------------'----------------' |
                                                .----------------.---------'
                                                v                v
                                        .----------------.----------------.
                                        |   revision 1   |   revision 0   |
                                        |----------------|----------------|
                                        |       C        |                |
                                        |----------------|                |
                                        |       D        |                |
                                        |----------------|                |
                                        |    checksum    |                |
                                        |----------------|                |
                                        |       |        |                |
                                        |       v        |                |
                                        |                |                |
                                        |                |                |
                                        '----------------'----------------'
```

### CTZ skip-lists 跳跃链表

littlefs 通过`链表`方式管理文件对应的块

#### 前序链表

每个节点存放执行新节点的指针，最大的问题是每增加一个节点（写入新数据，节点就是 block）都要修改原来的节点。因为 COW 策略被修改的节点必须挪动到新位置，导致该节点的上一个节点也要修改指针用于指向该节点的新位置，最终导致所有节点都被挪动。

```plaintext
A linked-list
.--------.  .--------.  .--------.  .--------.  .--------.  .--------.
| data 0 |->| data 1 |->| data 2 |->| data 4 |->| data 5 |->| data 6 |
|        |  |        |  |        |  |        |  |        |  |        |
|        |  |        |  |        |  |        |  |        |  |        |
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
```

#### 后序链表

每个节点存放前一个节点的指针，此时增加节点不会导致之前节点的改动。

```plaintext
A backwards linked-list
.--------.  .--------.  .--------.  .--------.  .--------.  .--------.
| data 0 |<-| data 1 |<-| data 2 |<-| data 4 |<-| data 5 |<-| data 6 |
|        |  |        |  |        |  |        |  |        |  |        |
|        |  |        |  |        |  |        |  |        |  |        |
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
```

但是`遍历方向`变为了和前序链表相反。如果要`按顺序`读取该文件的所有块，就需要从 6 遍历到 0 来读取 0，从 6 遍历到 1 来读取 1，以此类推，复杂度为 $O(n^2)$ 。

#### 后序跳跃链表

为了避免后序遍历情况下顺序读取性能差的问题，littlefs 使用了跳跃链表的方式。若一个数据块在 CTZ skip-list 链表内的索引值 N 能被 $2^x$ 整除，那么他就存在指向 $N – 2^x$ 的指针，指针的数目为 $ctz(N)+1$。如表 1，对于 block 2,包含了 2 个指针，分别指向 block 0 和 block 1，其它块也是采用相同的规则

```plaintext
A backwards CTZ skip-list
.--------.  .--------.  .--------.  .--------.  .--------.  .--------.
| data 0 |<-| data 1 |<-| data 2 |<-| data 3 |<-| data 4 |<-| data 5 |
|        |<-|        |--|        |<-|        |--|        |  |        |
|        |<-|        |--|        |--|        |--|        |  |        |
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
```

![F1-1](/assets/img/2023-01-04-little-fs/F1-1.png)

以此类推，6 为 3 个，8 为 4 个，非 2 的幂的偶数的指针数和上一个 2 的幂的偶数的指针数相同，平均下来每个块包含了大约两个指针。

> 汇编中 CTZ 指令的意思是求 $log_2{x}$，计算方法是取数字二进制格式末尾 0 的数量，这里用 CTZ 作为名字的意思是每个节点的指针数量为 CTZ(x)+1，如 8 末尾 0 的数量是 3，CTZ(x)就是 3，指针数量就是 3+1=4 个。

这样一来反向遍历的速度大约能提升一倍。顺序遍历时间复杂度变为 $O(nlogn)$

### 块分配器

用于为 COW 系统分配新的块和管理空闲块。

#### 空闲位图

可以在 RAM 中保存一份`位图`用于表示空闲的块，加速分配

```plaintext
.----.----.----.----.----.----.----.----.----.----.----.----.
| A  |    |root| C  | B  |         | D  |    | E  |         |
|    |    |    |    |    |         |    |    |    |         |
'----'----'----'----'----'----'----'----'----'----'----'----'
  1    0    1    1    1    0    0    1    0    1    0    0
 \---------------------------+----------------------------/
                             v
               bitmap: 0xb94 (0b101110010100)
```

#### 优化位图容量

使用位图表示整个磁盘会带来大量的 RAM 消耗，littlefs 中的块分配器是位图和暴力遍历之间的折衷。

我们跟踪一个小的、`固定大小`的位图，称为`先行缓冲区`，而不是存储整个磁盘的位图。 在块分配期间，我们从先行缓冲区中获取块。 如果先行缓冲区为空，我们将`扫描`文件系统以寻找更多空闲块，填充我们的先行缓冲区。在每次扫描中，我们使用递增的偏移量，在分配块时循环存储。

```plaintext
boot...         lookahead:
                fs blocks: fffff9fffffffffeffffffffffff0000
scanning...     lookahead: fffff9ff
                fs blocks: fffff9fffffffffeffffffffffff0000
alloc = 21      lookahead: fffffdff
                fs blocks: fffffdfffffffffeffffffffffff0000
alloc = 22      lookahead: ffffffff
                fs blocks: fffffffffffffffeffffffffffff0000
scanning...     lookahead:         fffffffe
                fs blocks: fffffffffffffffeffffffffffff0000
alloc = 63      lookahead:         ffffffff
                fs blocks: ffffffffffffffffffffffffffff0000
scanning...     lookahead:         ffffffff
                fs blocks: ffffffffffffffffffffffffffff0000
scanning...     lookahead:                 ffffffff
                fs blocks: ffffffffffffffffffffffffffff0000
scanning...     lookahead:                         ffff0000
                fs blocks: ffffffffffffffffffffffffffff0000
alloc = 112     lookahead:                         ffff8000
                fs blocks: ffffffffffffffffffffffffffff8000
```

上图中 lookahead 就表示当前的缓冲位图，对于分配块来说，这样一个缓冲区就能实现找到最近一个空闲块的功能了。当缓冲区内找不到可用空闲块时就`扫描`下一个区域并构建新的缓冲区。

通过调整缓冲区大小来达到 RAM 占用和扫描效率之间的平衡

### 磨损均衡

#### 坏块检测

写入后立刻`回读`

```plaintext
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .
.    .                   | C  |    .
.    .                   |    |    .
.    .                   '----'    .
.    .                   .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              | C  | B  |              |
|    |    |              |    |    |              |
'----'----'----'----'----'----'----'----'----'----'

update C
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .
.    .                   |bad |    .
.    .                   |blck|    .
.    .                   '----'    .
.    .                   .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad | B  |              |
|    |    |              |blck|    |              |
'----'----'----'----'----'----'----'----'----'----'

oh no! bad block! relocate C
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .
.    .                   |bad |    .
.    .                   |blck|    .
.    .                   '----'    .
.    .                   .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad | B  |bad |         |
|    |    |              |blck|    |blck|         |
'----'----'----'----'----'----'----'----'----'----'
                            --------->
oh no! bad block! relocate C
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .    .----.
.    .                   |bad |    .    | C' |
.    .                   |blck|    .    |    |
.    .                   '----'    .    '----'
.    .                   .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad | B  |bad | C' |    |
|    |    |              |blck|    |blck|    |    |
'----'----'----'----'----'----'----'----'----'----'
                            -------------->
successfully relocated C, update B
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        |bad |
|    |                        |blck|
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .    .----.
.    .                   |bad |    .    | C' |
.    .                   |blck|    .    |    |
.    .                   '----'    .    '----'
.    .                   .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad |bad |bad | C' |    |
|    |    |              |blck|blck|blck|    |    |
'----'----'----'----'----'----'----'----'----'----'

oh no! bad block! relocate B
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.         .----.
| A  |                        |bad |         |bad |
|    |                        |blck|         |blck|
'----'                        '----'         '----'
.    .                      v---'  .         .    .
.    .                   .----.    .    .----.    .
.    .                   |bad |    .    | C' |    .
.    .                   |blck|    .    |    |    .
.    .                   '----'    .    '----'    .
.    .                   .    .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad |bad |bad | C' |bad |
|    |    |              |blck|blck|blck|    |blck|
'----'----'----'----'----'----'----'----'----'----'
                                 -------------->
oh no! bad block! relocate B
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.    .----.              .----.
| A  |    | B' |              |bad |
|    |    |    |              |blck|
'----'    '----'              '----'
.    .    .  | .            .---'  .
.    .    .  '--------------v-------------v
.    .    .    .         .----.    .    .----.
.    .    .    .         |bad |    .    | C' |
.    .    .    .         |blck|    .    |    |
.    .    .    .         '----'    .    '----'
.    .    .    .         .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root| B' |         |bad |bad |bad | C' |bad |
|    |    |    |         |blck|blck|blck|    |blck|
'----'----'----'----'----'----'----'----'----'----'
------------>                    ------------------
successfully relocated B, update root
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '--v
.----.    .----.
| A  |    | B' |
|    |    |    |
'----'    '----'
.    .    .   '---------------------------v
.    .    .    .                        .----.
.    .    .    .                        | C' |
.    .    .    .                        |    |
.    .    .    .                        '----'
.    .    .    .                        .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root| B' |         |bad |bad |bad | C' |bad |
|    |    |    |         |blck|blck|blck|    |blck|
'----'----'----'----'----'----'----'----'----'----'
```

#### ECC 纠错

另一个方法是通过 ECC 算法为每个块纠错，但 littlefs 并不提供该功能。

#### 静态磨损均衡

考虑已经使用的块和空闲块，让所有块的擦写次数都能达到均衡。也就是需要定时去挪动未被修改但已经使用的块，防止`冷数据`占用过长时间。

littlefs 不使用静态磨损均衡

#### 动态磨损均衡

仅考虑空闲块，对已经有数据的块不做考虑。为了简化操作，littlefs 不会去跟踪每个块的磨损情况

设备启动后`随机`确定开始位置，在运行过程中`线性`的寻找并分配空闲块，达到近似动态磨损均衡的效果。随机熵可以从当前所有文件的 CRC 中获取

> 通过和 FTL 层结合可以实现完全的静态磨损均衡。

### 文件

littlefs 使用 metadata 块（元数据块）来保存文件信息，每个条目包含了`文件名`和文件`跳跃链表`的头指针。如果文件占用多个块，就可以通过跳跃链表访问所有块。如果文件仅占用`极小空间`，那么为其单独分配一个块以及单独分配一个指针都是很浪费的，可以直接把数据内容写在元数据中，littlefs 将占用空间小于`1/4`个块大小的文件放置于元数据块中，称为`内联文件`。

```plaintext
inline files stored in metadata pair, 4 bytes costs ~16 bytes

 .----------------.
.|    revision    |
||----------------|
||    A name      |
||   A skiplist  ---.
||----------------| |  \
||    B name      | |  +- data
||    B data      | |  |  4x4 bytes
||----------------| |  /  16 bytes
||    checksum    | |
||----------------| |
||       |        | |
||       v        | |
|'----------------' |
'----------------'  |
          .---------'
         v
 .----------------.
 |     A data     |
 |                |
 |                |
 |                |
 |                |
 |                |
 |                |
 |                |
 |----------------|
 |                |
 |                |
 |                |
 '----------------'
```

其中 A 为外联文件，B 为内联文件

文件名占用空间为可变长空间：

```plaintext
        tag                          data
[--      32      --][---        variable length        ---]
[1| 3| 8 | 10 | 10 ][---          (size * 8)           ---]
 ^  ^  ^    ^    ^- size                   ^- file name
 |  |  |    '------ id
 |  |  '----------- file type
 |  '-------------- type1 (0x0)
 '----------------- valid bit
```

#### 内联文件

内联文件直接存储在元数据块中

![inlinefile](/assets/img/2023-01-04-little-fs/inlinefile.png)

内联文件也需要有一个单独的 tag，用来和外联文件区分：

```plaintext
        tag                          data
[--      32      --][---        variable length        ---]
[1|- 11 -| 10 | 10 ][---           (size * 8)          ---]
 ^    ^     ^    ^- size                    ^- inline data
 |    |     '------ id
 |    '------------ type (0x201)
 '----------------- valid bit
```

#### 外联文件

外联文件不存于元数据块，元数据块中仅保存跳跃链表头指针。

![outlinefile](/assets/img/2023-01-04-little-fs/outlinefile.png)

#### CTZ skip-list tag 结构

只需要 4 字节的`头指针`和 4 字节的`文件大小`信息

```plaintext
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][--      32      --|--      32      --]
 ^    ^     ^    ^            ^                  ^- file size
 |    |     |    |            '-------------------- file head
 |    |     |    '- size (8)
 |    |     '------ id
 |    '------------ type (0x202)
 '----------------- valid bit
```

## 参考

- [OpenHarmony littlefs 文件系统存储结构与 IO 性能优化分析](https://ost.51cto.com/posts/14734)
