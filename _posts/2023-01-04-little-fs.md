---
title: "littlefs技术介绍"
author: Jinkai
date: 2023-01-04 09:00:00 +0800
published: true
math: true
categories: [学习笔记]
tags: [嵌入式, 文件系统]
---

## 特性

- **断电恢复能力** - 在嵌入式系统上，`随时可能断电`。 如果断电损坏了任何持久性数据结构，这可能会导致设备变得不可恢复。嵌入式文件系统必须设计为从任何写入操作期间的断电中恢复。
- **磨损均衡** - 写入闪存具有破坏性。如果文件系统`反复写入`同一个块，最终该块将磨损。 不考虑磨损的文件系统很容易烧毁用于存储频繁更新的元数据的块，并导致设备过早死亡。
- **有限 RAM/ROM** - 嵌入式设备的内存量也非常有限。许多现有的文件系统设计无法适应这种情况，比如依赖于相对大量的 RAM 用于临时存储文件系统元数据。

## 概念

### 基于块

存储被划分为块，每个文件都存储在一个块的集合。

```plaintext
               .--------.
               |  root  |
               |        |
               |        |
               '--------'
               .-'    '-.
              v          v
         .--------.  .--------.
         |   A    |  |   B    |
         |        |  |        |
         |        |  |        |
         '--------'  '--------'
         .-'         .-'    '-.
        v           v          v
   .--------.  .--------.  .--------.
   |   C    |  |   D    |  |   E    |
   |        |  |        |  |        |
   |        |  |        |  |        |
   '--------'  '--------'  '--------'
```

### 日志文件系统

对文件系统的各个操作通过`追加日志`的形式记录，而不是直接修改元数据

但这带来一个问题，读取时需要遍历日志以重建文件系统。可以使用`缓存`以避免读取成本，这就需要与 RAM 的占用做权衡。

日志记录文件系统可以保证文件系统操作的一致性。使用`校验和`，我们可以轻松地检测断电并通过忽略失败回退到以前的状态。

```plaintext
                                                            v
.--------.--------.--------.--------.--------.--------.--------.--------.
|        C        | new B  | new A  |                 |   A    |   B    |
|                 |        |        |->               |        |        |
|                 |        |        |                 |        |        |
'--------'--------'--------'--------'--------'--------'--------'--------'
```

图中显示了一种日志循环的情况，A、B、C 写入完成后接下来修改 A、B，新的日志内容就存在于 C 之后了。

### 写时复制(CoW)技术

不去更新原位置的内容，需要修改时复制一份并在修改后写入新的位置。很适合用于实现磨损均衡

```plaintext
               .--------.                  .--------.
               |  root  |       write      |new root|
               |        |        ==>       |        |
               |        |                  |        |
               '--------'                  '--------'
               .-'    '-.                    |    '-.
              |  .-------|------------------'        v
              v v        v                       .--------.
         .--------.  .--------.                  | new B  |
         |   A    |  |   B    |                  |        |
         |        |  |        |                  |        |
         |        |  |        |                  '--------'
         '--------'  '--------'                  .-'    |
         .-'         .-'    '-.    .------------|------'
        |           |          |  |             v
        v           v          v  v        .--------.
   .--------.  .--------.  .--------.      | new D  |
   |   C    |  |   D    |  |   E    |      |        |
   |        |  |        |  |        |      |        |
   |        |  |        |  |        |      '--------'
   '--------'  '--------'  '--------'
```

在上图中对 D 的修改导致 D 的位置发生变化，导致目录 B 的指针发生变化，需要修改，对 B 的修改又导致了 B 位置的变化，继而引起 root 位置的变化。

### 元数据

元数据是用于描述数据的数据，在大多数文件系统中，元数据和文件内容是分开的，元数据用于记录文件的大小，文件名，存放文件的物理位置等信息。同时文件系统的一些基本信息也属于元数据。

## 设计

### 总览

![overview](/assets/img/2023-01-04-little-fs/overview.png)

数据的存储默认是小端序（除 tag 外），采用元数据+数据的形式，使用 tag 标识元数据

### 元数据对

每次对数据的修改都会同步修改元数据，由于写时复制技术，元数据所在块的修改也会使用新的块，很自然的就会被放在被修改的块后面。

每个元数据理论上占用一个块，由于采用主备互切的方式，实际上需要占用两个块。

```plaintext
metadata pair pointer: {block 0, block 1}
                           |        '--------------------.
                            '-.                           |
disk                           v                          v
.--------.--------.--------.--------.--------.--------.--------.--------.
|                 |        |metadata|                 |metadata|        |
|                 |        |block 0 |                 |block 1 |        |
|                 |        |        |                 |        |        |
'--------'--------'--------'--------'--------'--------'--------'--------'
                               '--.                  .----'
                                   v                v
             metadata pair .----------------.----------------.
                           |   revision 11  |   revision 12  |
             block 1 is    |----------------|----------------|
             most recent   |       A        |       A''      |
                           |----------------|----------------|
                           |    checksum    |    checksum    |
                           |----------------|----------------|
                           |       B        |       A'''     | <- most recent A
                           |----------------|----------------|
                           |       A''      |    checksum    |
                           |----------------|----------------|
                           |    checksum    |       |        |
                           |----------------|       v        |
                           '----------------'----------------'
```

上图中，metadata block 0 和 block 1 实际上表示同一份 metadata，不过是两个不同的版本，以新的一份为准，上图中就是以 block 1 表示的 revision 12 为准。

每个元数据块包含若干条记录，每若干条记录后有一个 CRC32 checksum 用于校验:

```plaintext
  .---------------------------------------.
.-|  revision count   |      tag ~A       |        \
| |-------------------+-------------------|        |
| |                 data A                |        |
| |                                       |        |
| |-------------------+-------------------|        |
| |      tag AxB      |       data B      | <--.   |
| |-------------------+                   |    |   |
| |                                       |    |   +-- 1st commit
| |         +-------------------+---------|    |   |
| |         |      tag BxC      |         | <-.|   |
| |---------+-------------------+         |   ||   |
| |                 data C                |   ||   |
| |                                       |   ||   |
| |-------------------+-------------------|   ||   |
| |     tag CxCRC     |        CRC        |   ||   /
| |-------------------+-------------------|   ||
| |     tag CRCxA'    |      data A'      |   ||   \
| |-------------------+                   |   ||   |
| |                                       |   ||   |
| |              +-------------------+----|   ||   +-- 2nd commit
| |              |     tag CRCxA'    |    |   ||   |
| |--------------+-------------------+----|   ||   |
| | CRC          |        padding         |   ||   /
| |--------------+----+-------------------|   ||
| |     tag CRCxA''   |      data A''     | <---.  \
| |-------------------+                   |   |||  |
| |                                       |   |||  |
| |         +-------------------+---------|   |||  |
| |         |     tag A''xD     |         | < |||  |
| |---------+-------------------+         |  ||||  +-- 3rd commit
| |                data D                 |  ||||  |
| |                             +---------|  ||||  |
| |                             |   tag Dx|  ||||  |
| |---------+-------------------+---------|  ||||  |
| |CRC      |        CRC        |         |  ||||  /
| |---------+-------------------+         |  ||||
| |           unwritten storage           |  ||||  more commits
| |                                       |  ||||       |
| |                                       |  ||||       v
| |                                       |  ||||
| |                                       |  ||||
| '---------------------------------------'  ||||
'---------------------------------------'    |||'- most recent A
                                             ||'-- most recent B
                                             |'--- most recent C
                                             '---- most recent D
```

每个元数据类型都有 tag 标记用于识别，连 CRC 也有一个单独的标记。支持`事务`，每次 commit 以一个 CRC 结束。

tag 在磁盘上的存储使用了`异或`方式，也就是当前 tag 和上一个 tag 的异或值，第一个 tag 为自身和 0xFFFFFFFF 的异或值(也就是自身的反码)。使用该方式实现错误检查。

```plaintext
 Forward iteration                        Backward iteration

.-------------------.  0xffffffff        .-------------------.
|  revision count   |      |             |  revision count   |
|-------------------|      v             |-------------------|
|      tag ~A       |---> xor -> tag A   |      tag ~A       |---> xor -> 0xffffffff
|-------------------|      |             |-------------------|      ^
|       data A      |      |             |       data A      |      |
|                   |      |             |                   |      |
|                   |      |             |                   |      |
|-------------------|      v             |-------------------|      |
|      tag AxB      |---> xor -> tag B   |      tag AxB      |---> xor -> tag A
|-------------------|      |             |-------------------|      ^
|       data B      |      |             |       data B      |      |
|                   |      |             |                   |      |
|                   |      |             |                   |      |
|-------------------|      v             |-------------------|      |
|      tag BxC      |---> xor -> tag C   |      tag BxC      |---> xor -> tag B
|-------------------|                    |-------------------|      ^
|       data C      |                    |       data C      |      |
|                   |                    |                   |    tag C
|                   |                    |                   |
|                   |                    |                   |
'-------------------'                    '-------------------'
```

### 元数据 tag

tag 为 4 字节大小的整体，用于标识元数据，使用大端序存储，因为要保证第一个写入的位为 valid bit。

```plaintext
[----            32             ----]
[1|--  11   --|--  10  --|--  10  --]
 ^.     ^     .     ^          ^- length
 |.     |     .     '------------ id
 |.     '-----.------------------ type (type3)
 '.-----------.------------------ valid bit
  [-3-|-- 8 --]
    ^     ^- chunk
    '------- type (type1)
```

元数据 tag 字段：

- **有效位（1 位）**- 指示标签是否有效。
- **Type3（11 位）**- 标签的类型。 该字段进一步细分为 3 位 type 类型和 8 位 chunk 字段。 请注意，值 0x000 无效且未分配类型。

  - **Type1（3 位）**- 标签的抽象类型。 将标记分为 8 个类别，以促进位掩码查找。
  - **chunk（8 位）**- 不同抽象类型用于各种目的的 chunk 字段。 type1+chunk+id 构成元数据块中每个标签的`唯一标识符`。

- **Id（10 位）**- 与标签关联的文件 ID。 元数据块中的每个文件都有一个唯一的 ID，用于将标签与该文件相关联。 特殊值 0x3ff 用于与文件无关的任何标记，例如目录和全局元数据。
- **长度（10 位）**- 以字节为单位的数据长度。 特殊值 0x3ff 表示该标签已被删除。

### 超级块

superblock 使用元数据对的方式存储，可能会通过 tail 占用多个元数据对，但起始元数据对总是位于 block 0 和 block 1，方便初始化时重构文件系统信息。

根目录信息保存在 superblock 中。

超级块包含了一个`超级块 tag`:

```plaintext
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][---              64               ---]
 ^    ^     ^    ^- size (8)           ^- magic string ("littlefs")
 |    |     '------ id (0)
 |    '------------ type (0x0ff)
 '----------------- valid bit

```

其中`魔术字符串`始终为"littlefs"

超级块还包含了一个`内联结构`，用于保存文件系统基本配置信息：

```plaintext
        tag                          data
[--      32      --][--      32      --|--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][--      32      --|--      32      --|--      32      --]
 ^    ^     ^    ^            ^- version         ^- block size      ^- block count
 |    |     |    |  [--      32      --|--      32      --|--      32      --]
 |    |     |    |  [--      32      --|--      32      --|--      32      --]
 |    |     |    |            ^- name max        ^- file max        ^- attr max
 |    |     |    '- size (24)
 |    |     '------ id (0)
 |    '------------ type (0x201)
 '----------------- valid bit
```

#### 超级块实例

```hex
// 元数据对其一，块大小为128字节，这是块0
// 03 00 00 00为大端序下的版本号，标识元数据版本。
// F0 0F FF F7的反码为0FF00008，也就是实际的tag，0x0FF表示
// 超级块type,后面的id为0，长度为8，也就是魔术字符串长度。
// 6C 69 74 74 6C 65 66 73 为data内容，就是魔术字符串"littlefs"
03 00 00 00 F0 0F FF F7 6C 69 74 74 6C 65 66 73
// 至此，第一个tag结束，下面为第二个tag
// 第一个tag 0FF00008和2F E0 00 10的异或为20100018，也就是
// 第二个tag。0x201为内联结构type，长度为24字节，包含了文件系统信息
2F E0 00 10 00 00 02 00 80 00 00 00 00 01 00 00
// 第三个tag为601FFC08，就是40 0F FC 10和20100018的异或。
// type为0x601表示hardtail，长度为8，保存了一对元数据对指针
// hardtail表示下个元数据对属于本目录，这里就表示超级块的扩展
FF 00 00 00 FF FF FF 7F FE 03 00 00 40 0F FC 10
// 有00000007和00000008两个指针，使用小端序保存。
// 601FFC08和30 10 00 0C异或为500FFC04，0x5xx表示CRC，长度4字节
07 00 00 00 08 00 00 00 30 10 00 0C FD 32 76 C4
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF

// 元数据对其二，块大小为128字节，这是块1
02 00 00 00 F0 0F FF F7 6C 69 74 74 6C 65 66 73
2F E0 00 10 00 00 02 00 80 00 00 00 00 01 00 00
// 这里的tag和上面的不同，70 1F FC 08和20100018异或为500FFC10
// 0x5xx表示CRC，长度为16字节，
FF 00 00 00 FF FF FF 7F FE 03 00 00 70 1F FC 08
// 实际CRC占用4字节，其他的是padding。
C5 D0 7E 55 FF FF FF FF FF FF FF FF FF FF FF FF
// 10 1F F8 10和500FFC10异或为40100400，0x401表示LFS_TYPE_CREATE，
// 也就是文件创建，长度为0。
// 下一个tag为0010040A（4000000A），0x001表示LFS_TYPE_REG常规文件，长度为10，
// 表示文件名长度，data域为文件名"boot_count"。
10 1F F8 10 40 00 00 0A 62 6F 6F 74 5F 63 6F 75
// 下个tag为20100400（2000000A），0x201表示内联结构，跟在
// 常规文件后的内联结构表示内联文件，初始长度为0，表示空文件。
// 下个tag为500FFC06（701FF806），0x5xx表示CRC,带padding共6字节。
6E 74 20 00 00 0A 70 1F F8 06 E8 5E F3 2D FF FF
// 下个tag为40100400（101FF806）， 创建文件。
// 下个tag为0010040B（4000000B），LFS_TYPE_REG
10 1F F8 06 40 00 00 0B 62 6F 6F 74 5F 63 6F 75
// 下个tag为20100400（2000000B），内联结构
// 下个tag为500FFC05（701FF805），CRC
6E 74 30 20 00 00 0B 70 1F F8 05 6C 44 5F 4B FF
// 可以发现这个块没有hardtail，也就是说没有后续块，也就是说超级块已经结束了，
// 这个情况发生在仅创建了两个文件的情况下，在创建第三个文件时会发现不够用了，
// 就会重新整理超级块内容，将多余的日志通过hardtail连接到其他块来实现
// 对超级块的扩展，也就是上面那个版本3的块的内容

...

// 块7，块0的hardtail
// 第一个tag为0010000B（FFEFFFF4），因为重新整理后可以去掉create tag，
// 所以相较于版本2，这里没有了LFS_TYPE_CREATE，直接就是LFS_TYPE_REG
03 00 00 00 FF EF FF F4 62 6F 6F 74 5F 63 6F 75
// 下个tag为20100004（2000000F），内联结构，长度为4，
// data值为0，和测试程序相符。
// 下个tag为0010040C（20000408），表示文件"boot_count10"
6E 74 30 20 00 00 0F 00 00 00 00 20 00 04 08 62
// 下个tag为20100404（20000008），内联结构，长度为4，
// data值为0x0A，和测试程序相符。
6F 6F 74 5F 63 6F 75 6E 74 31 30 20 00 00 08 0A
00 00 00 40 0F F8 0C 11 00 00 00 12 00 00 00 30
10 00 05 10 A6 F0 25 FF FF FF FF FF FF FF FF FF
10 1F F8 0D 40 00 00 0D 62 6F 6F 74 5F 63 6F 75
6E 74 31 30 30 20 00 00 0D 70 1F F8 13 D5 83 93
2E FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF

// 块8，块0的hardtail
04 00 00 00 FF EF FF F4 62 6F 6F 74 5F 63 6F 75
// 601FFC08(400FFC0C)表示hardtail
6E 74 30 20 00 00 0F 00 00 00 00 40 0F FC 0C 77
// 500FFC05(3010000D)表示CRC
00 00 00 78 00 00 00 30 10 00 0D AE E2 47 DD FF
// 后面这些不知道什么意义，照理说hardtail后不应该有数据
70 1F FC 01 00 00 00 00 70 1F FC 00 5D 1A 29 44
70 1F FC 00 00 00 00 00 70 1F FC 00 1E 0E 52 53
70 1F FC 00 00 00 00 00 70 1F FC 00 1E 0E 52 53
70 1F FC 00 00 00 00 00 70 1F FC 00 1E 0E 52 53
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
```

### 日志整理

当某一个 block 写满时，需要删除不需要的条目来腾出空间，如下图，对文件 B 修改后，对 B 的本身来说 B'才是有效记录，记录 B 已经没用了，同时对 A 来说 A'是最新记录，记录 A 也 2 没用了，这时就可以整理为 revision2 的形式。

这就是为什么元数据需要成对的原因，成对后两份元数据可以交替更新，保证写入时的一致性。

```plaintext
                        commit B', need to compact
.----------------.----------------.    .----------------.----------------.
|   revision 1   |   revision 0   | => |   revision 1   |   revision 2   |
|----------------|----------------|    |----------------|----------------|
|       A        |                |    |       A        |       A'       |
|----------------|                |    |----------------|----------------|
|    checksum    |                |    |    checksum    |       B'       |
|----------------|                |    |----------------|----------------|
|       B        |                |    |       B        |    checksum    |
|----------------|                |    |----------------|----------------|
|       A'       |                |    |       A'       |       |        |
|----------------|                |    |----------------|       v        |
|    checksum    |                |    |    checksum    |                |
|----------------|                |    |----------------|                |
'----------------'----------------'    '----------------'----------------'
```

#### 日志扩展

如果没有垃圾数据无法腾出空间，就要对元数据块做扩展，扩展块也是以元数据对的方式呈现，通过 tail 指针指向性的扩展元数据对。

```plaintext
                        commit C and D, need to split
.----------------.----------------.    .----------------.----------------.
|   revision 1   |   revision 2   | => |   revision 3   |   revision 2   |
|----------------|----------------|    |----------------|----------------|
|       A        |       A'       |    |       A'       |       A'       |
|----------------|----------------|    |----------------|----------------|
|    checksum    |       B'       |    |       B'       |       B'       |
|----------------|----------------|    |----------------|----------------|
|       B        |    checksum    |    |      tail    ---------------------.
|----------------|----------------|    |----------------|----------------| |
|       A'       |       |        |    |    checksum    |                | |
|----------------|       v        |    |----------------|                | |
|    checksum    |                |    |       |        |                | |
|----------------|                |    |       v        |                | |
'----------------'----------------'    '----------------'----------------' |
                                                .----------------.---------'
                                                v                v
                                        .----------------.----------------.
                                        |   revision 1   |   revision 0   |
                                        |----------------|----------------|
                                        |       C        |                |
                                        |----------------|                |
                                        |       D        |                |
                                        |----------------|                |
                                        |    checksum    |                |
                                        |----------------|                |
                                        |       |        |                |
                                        |       v        |                |
                                        |                |                |
                                        |                |                |
                                        '----------------'----------------'
```

### CTZ skip-lists 跳跃链表

littlefs 通过`链表`方式管理文件对应的块

#### 前序链表

每个节点存放执行新节点的指针，最大的问题是每增加一个节点（写入新数据，节点就是 block）都要修改原来的节点。因为 COW 策略被修改的节点必须挪动到新位置，导致该节点的上一个节点也要修改指针用于指向该节点的新位置，最终导致所有节点都被挪动。

```plaintext
A linked-list
.--------.  .--------.  .--------.  .--------.  .--------.  .--------.
| data 0 |->| data 1 |->| data 2 |->| data 4 |->| data 5 |->| data 6 |
|        |  |        |  |        |  |        |  |        |  |        |
|        |  |        |  |        |  |        |  |        |  |        |
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
```

#### 后序链表

每个节点存放前一个节点的指针，此时增加节点不会导致之前节点的改动。

```plaintext
A backwards linked-list
.--------.  .--------.  .--------.  .--------.  .--------.  .--------.
| data 0 |<-| data 1 |<-| data 2 |<-| data 4 |<-| data 5 |<-| data 6 |
|        |  |        |  |        |  |        |  |        |  |        |
|        |  |        |  |        |  |        |  |        |  |        |
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
```

但是`遍历方向`变为了和前序链表相反。如果要`按顺序`读取该文件的所有块，就需要从 6 遍历到 0 来读取 0，从 6 遍历到 1 来读取 1，以此类推，复杂度为 $O(n^2)$ 。

#### 后序跳跃链表

为了避免后序遍历情况下顺序读取性能差的问题，littlefs 使用了跳跃链表的方式。若一个数据块在 CTZ skip-list 链表内的索引值 N 能被 $2^x$ 整除，那么他就存在指向 $N – 2^x$ 的指针，指针的数目为 $ctz(N)+1$。如表 1，对于 block 2,包含了 2 个指针，分别指向 block 0 和 block 1，其它块也是采用相同的规则

```plaintext
A backwards CTZ skip-list
.--------.  .--------.  .--------.  .--------.  .--------.  .--------.
| data 0 |<-| data 1 |<-| data 2 |<-| data 3 |<-| data 4 |<-| data 5 |
|        |<-|        |--|        |<-|        |--|        |  |        |
|        |<-|        |--|        |--|        |--|        |  |        |
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
```

![F1-1](/assets/img/2023-01-04-little-fs/F1-1.png)

以此类推，6 为 3 个，8 为 4 个，非 2 的幂的偶数的指针数和上一个 2 的幂的偶数的指针数相同，平均下来每个块包含了大约两个指针。

> 汇编中 CTZ 指令的意思是求 $log_2{x}$，计算方法是取数字二进制格式末尾 0 的数量，这里用 CTZ 作为名字的意思是每个节点的指针数量为 CTZ(x)+1，如 8 末尾 0 的数量是 3，CTZ(x)就是 3，指针数量就是 3+1=4 个。

这样一来反向遍历的速度能加快。顺序遍历时间复杂度变为 $O(nlogn)$。

### 块分配器

用于为 COW 系统分配新的块和管理空闲块。

#### 空闲位图

可以在 RAM 中保存一份`位图`用于表示空闲的块，加速分配

```plaintext
.----.----.----.----.----.----.----.----.----.----.----.----.
| A  |    |root| C  | B  |         | D  |    | E  |         |
|    |    |    |    |    |         |    |    |    |         |
'----'----'----'----'----'----'----'----'----'----'----'----'
  1    0    1    1    1    0    0    1    0    1    0    0
 \---------------------------+----------------------------/
                             v
               bitmap: 0xb94 (0b101110010100)
```

#### 优化位图容量

使用位图表示整个磁盘会带来大量的 RAM 消耗，littlefs 中的块分配器是位图和暴力遍历之间的折衷。

我们跟踪一个小的、`固定大小`的位图，称为`先行缓冲区`，而不是存储整个磁盘的位图。 在块分配期间，我们从先行缓冲区中获取块。 如果先行缓冲区为空，我们将`扫描`文件系统以寻找更多空闲块，填充我们的先行缓冲区。在每次扫描中，我们使用递增的偏移量，在分配块时循环存储。

```plaintext
boot...         lookahead:
                fs blocks: fffff9fffffffffeffffffffffff0000
scanning...     lookahead: fffff9ff
                fs blocks: fffff9fffffffffeffffffffffff0000
alloc = 21      lookahead: fffffdff
                fs blocks: fffffdfffffffffeffffffffffff0000
alloc = 22      lookahead: ffffffff
                fs blocks: fffffffffffffffeffffffffffff0000
scanning...     lookahead:         fffffffe
                fs blocks: fffffffffffffffeffffffffffff0000
alloc = 63      lookahead:         ffffffff
                fs blocks: ffffffffffffffffffffffffffff0000
scanning...     lookahead:         ffffffff
                fs blocks: ffffffffffffffffffffffffffff0000
scanning...     lookahead:                 ffffffff
                fs blocks: ffffffffffffffffffffffffffff0000
scanning...     lookahead:                         ffff0000
                fs blocks: ffffffffffffffffffffffffffff0000
alloc = 112     lookahead:                         ffff8000
                fs blocks: ffffffffffffffffffffffffffff8000
```

上图中 lookahead 就表示当前的缓冲位图，对于分配块来说，这样一个缓冲区就能实现找到最近一个空闲块的功能了。当缓冲区内找不到可用空闲块时就`扫描`下一个区域并构建新的缓冲区。

通过调整缓冲区大小来达到 RAM 占用和扫描效率之间的平衡

### 磨损均衡

#### 坏块检测

通过写入后立刻`回读`进行坏块检测

```plaintext
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .
.    .                   | C  |    .
.    .                   |    |    .
.    .                   '----'    .
.    .                   .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              | C  | B  |              |
|    |    |              |    |    |              |
'----'----'----'----'----'----'----'----'----'----'

update C
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .
.    .                   |bad |    .
.    .                   |blck|    .
.    .                   '----'    .
.    .                   .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad | B  |              |
|    |    |              |blck|    |              |
'----'----'----'----'----'----'----'----'----'----'

oh no! bad block! relocate C
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .
.    .                   |bad |    .
.    .                   |blck|    .
.    .                   '----'    .
.    .                   .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad | B  |bad |         |
|    |    |              |blck|    |blck|         |
'----'----'----'----'----'----'----'----'----'----'
                            --------->
oh no! bad block! relocate C
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        | B  |
|    |                        |    |
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .    .----.
.    .                   |bad |    .    | C' |
.    .                   |blck|    .    |    |
.    .                   '----'    .    '----'
.    .                   .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad | B  |bad | C' |    |
|    |    |              |blck|    |blck|    |    |
'----'----'----'----'----'----'----'----'----'----'
                            -------------->
successfully relocated C, update B
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.
| A  |                        |bad |
|    |                        |blck|
'----'                        '----'
.    .                      v---'  .
.    .                   .----.    .    .----.
.    .                   |bad |    .    | C' |
.    .                   |blck|    .    |    |
.    .                   '----'    .    '----'
.    .                   .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad |bad |bad | C' |    |
|    |    |              |blck|blck|blck|    |    |
'----'----'----'----'----'----'----'----'----'----'

oh no! bad block! relocate B
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.                        .----.         .----.
| A  |                        |bad |         |bad |
|    |                        |blck|         |blck|
'----'                        '----'         '----'
.    .                      v---'  .         .    .
.    .                   .----.    .    .----.    .
.    .                   |bad |    .    | C' |    .
.    .                   |blck|    .    |    |    .
.    .                   '----'    .    '----'    .
.    .                   .    .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root|              |bad |bad |bad | C' |bad |
|    |    |              |blck|blck|blck|    |blck|
'----'----'----'----'----'----'----'----'----'----'
                                 -------------->
oh no! bad block! relocate B
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '----------------------v
.----.    .----.              .----.
| A  |    | B' |              |bad |
|    |    |    |              |blck|
'----'    '----'              '----'
.    .    .  | .            .---'  .
.    .    .  '--------------v-------------v
.    .    .    .         .----.    .    .----.
.    .    .    .         |bad |    .    | C' |
.    .    .    .         |blck|    .    |    |
.    .    .    .         '----'    .    '----'
.    .    .    .         .    .    .    .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root| B' |         |bad |bad |bad | C' |bad |
|    |    |    |         |blck|blck|blck|    |blck|
'----'----'----'----'----'----'----'----'----'----'
------------>                    ------------------
successfully relocated B, update root
=>
     .----.
     |root|
     |    |
     '----'
   v--'  '--v
.----.    .----.
| A  |    | B' |
|    |    |    |
'----'    '----'
.    .    .   '---------------------------v
.    .    .    .                        .----.
.    .    .    .                        | C' |
.    .    .    .                        |    |
.    .    .    .                        '----'
.    .    .    .                        .    .
.----.----.----.----.----.----.----.----.----.----.
| A  |root| B' |         |bad |bad |bad | C' |bad |
|    |    |    |         |blck|blck|blck|    |blck|
'----'----'----'----'----'----'----'----'----'----'
```

#### ECC 纠错

另一个方法是通过 ECC 算法为每个块纠错，但 littlefs 并不提供该功能。

#### 静态磨损均衡

考虑已经使用的块和空闲块，让所有块的擦写次数都能达到均衡。也就是需要定时去挪动未被修改但已经使用的块，防止`冷数据`占用过长时间。

littlefs 不使用静态磨损均衡

#### 动态磨损均衡

仅考虑空闲块，对已经有数据的块不做考虑。为了简化操作，littlefs 不会去跟踪每个块的磨损情况

设备启动后`随机`确定开始位置，在运行过程中`线性`的寻找并分配空闲块，达到近似动态磨损均衡的效果。随机熵可以从当前所有文件的 CRC 中获取

> 通过和 FTL 层结合可以实现完全的静态磨损均衡。

### 文件

littlefs 将文件信息作为元数据保存在元数据块中，包含了`文件名`和文件`跳跃链表`的头指针。如果文件占用多个块，就可以通过跳跃链表访问该文件的所有块。如果文件仅占用`极小空间`，那么为其单独分配一个跳跃链表都是很浪费的，此时可以直接把数据内容也写在元数据中，littlefs 将占用空间小于`1/4`个块大小的文件放置于元数据块中，称为`内联文件`。

```plaintext
inline files stored in metadata pair, 4 bytes costs ~16 bytes

 .----------------.
.|    revision    |
||----------------|
||    A name      |
||   A skiplist  ---.
||----------------| |  \
||    B name      | |  +- data
||    B data      | |  |  4x4 bytes
||----------------| |  /  16 bytes
||    checksum    | |
||----------------| |
||       |        | |
||       v        | |
|'----------------' |
'----------------'  |
          .---------'
         v
 .----------------.
 |     A data     |
 |                |
 |                |
 |                |
 |                |
 |                |
 |                |
 |                |
 |----------------|
 |                |
 |                |
 |                |
 '----------------'
```

其中 A 为外联文件，B 为内联文件

#### 文件名

littlefs 使用一个文件 tag 标识一个文件，data 域是文件名，文件名占用空间为可变长空间：

```plaintext
        tag                          data
[--      32      --][---        variable length        ---]
[1| 3| 8 | 10 | 10 ][---          (size * 8)           ---]
 ^  ^  ^    ^    ^- size                   ^- file name
 |  |  |    '------ id
 |  |  '----------- file type
 |  '-------------- type1 (0x0)
 '----------------- valid bit
```

#### 内联文件

内联文件使用`内联结构(type:0x201)`来保存文件内容，紧跟在文件 tag 之后：

![inlinefile](/assets/img/2023-01-04-little-fs/inlinefile.png)

```plaintext
        tag                          data
[--      32      --][---        variable length        ---]
[1|- 11 -| 10 | 10 ][---           (size * 8)          ---]
 ^    ^     ^    ^- size                    ^- inline data
 |    |     '------ id
 |    '------------ type (0x201)
 '----------------- valid bit
```

#### 外联文件

外联文件的内容不存于元数据块，元数据块中仅保存跳跃链表头指针。

![outlinefile](/assets/img/2023-01-04-little-fs/outlinefile.png)

#### CTZ skip-list 结构

只需要 4 字节的`文件指针`和 4 字节的`文件大小`信息，其中文件指针指向一个单独的块，也就是说该文件`至少`会占用一个完整块。

```plaintext
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][--      32      --|--      32      --]
 ^    ^     ^    ^            ^                  ^- file size
 |    |     |    |            '-------------------- file head
 |    |     |    '- size (8)
 |    |     '------ id
 |    '------------ type (0x202)
 '----------------- valid bit
```

## 实现

### 挂载

```c
static int lfs_rawmount(lfs_t *lfs, const struct lfs_config *cfg) {
    // 使用默认配置初始化lfs结构
    int err = lfs_init(lfs, cfg);
    if (err) {
        return err;
    }

    // scan directory blocks for superblock and any global updates
    // 扫描所有目录，因为根目录信息在超级块中，所以先从超级块所在的块0和块1开始扫描
    lfs_mdir_t dir = {.tail = {0, 1}};
    lfs_block_t cycle = 0;
    while (!lfs_pair_isnull(dir.tail)) {
        // 回环检测
        if (cycle >= lfs->cfg->block_count/2) {
            // loop detected
            err = LFS_ERR_CORRUPT;
            goto cleanup;
        }
        cycle += 1;

        // fetch next block in tail list
        // 从tail找下一个元数据对（属于超级块）
        // lfs_dir_fetchmatch用于找出dir(元数据块)中tag和data都符合参数描述条件的tag，这里是为了查找当前块是否是超级块，也就是是否有超级块tag和包含魔术字符串的data。还有将元数据对中信息赋值到dir内的功能，比如版本号，offset偏移，tail指针等等
        // lfs_dir_find_match用于比较两个tag内的data是否相同，这里是要找到data为"littlefs"的tag，也就是超级块标志。
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,
                LFS_MKTAG(0x7ff, 0x3ff, 0),
                LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8),
                NULL,
                lfs_dir_find_match, &(struct lfs_dir_find_match){
                    lfs, "littlefs", 8});
        // lfs：文件系统信息实例，dir：需要搜索的元数据块（包含两个元数据对），pair：对应的元数据对（其实正常情况dir->pair就包含了对应的pair数据，不用单独的参数，这里应该是有dir初始化后填充pair的功能，这里还有自动查找两个元数据对中最新的那个的功能），fmask：tag的mask（表示tag的32位中需要比较的部分），ftag：需要搜索的tag，id：需要搜索的id，cb：data部分比较函数，data：需要搜索的data
        // static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
        // lfs_mdir_t *dir, const lfs_block_t pair[2],
        // lfs_tag_t fmask, lfs_tag_t ftag, uint16_t *id,
        // int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data)
        if (tag < 0) {
            err = tag;
            goto cleanup;
        }

        // has superblock?
        if (tag && !lfs_tag_isdelete(tag)) {
            // update root
            // 更新lfs的超级块信息对应的元数据对，一般就是物理块的块0和块1
            lfs->root[0] = dir.pair[0];
            lfs->root[1] = dir.pair[1];

            // grab superblock
            lfs_superblock_t superblock;
            // 获取超级块内的内联结构，包含了文件系统配置信息
            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
                    &superblock);
            if (tag < 0) {
                err = tag;
                goto cleanup;
            }
            lfs_superblock_fromle32(&superblock);

            // 检测文件系统配置信息是否合法，并更新到内存实例中

            // check version
            uint16_t major_version = (0xffff & (superblock.version >> 16));
            uint16_t minor_version = (0xffff & (superblock.version >>  0));
            if ((major_version != LFS_DISK_VERSION_MAJOR ||
                 minor_version > LFS_DISK_VERSION_MINOR)) {
                LFS_ERROR("Invalid version v%"PRIu16".%"PRIu16,
                        major_version, minor_version);
                err = LFS_ERR_INVAL;
                goto cleanup;
            }

            // check superblock configuration
            if (superblock.name_max) {
                if (superblock.name_max > lfs->name_max) {
                    LFS_ERROR("Unsupported name_max (%"PRIu32" > %"PRIu32")",
                            superblock.name_max, lfs->name_max);
                    err = LFS_ERR_INVAL;
                    goto cleanup;
                }

                lfs->name_max = superblock.name_max;
            }

            if (superblock.file_max) {
                if (superblock.file_max > lfs->file_max) {
                    LFS_ERROR("Unsupported file_max (%"PRIu32" > %"PRIu32")",
                            superblock.file_max, lfs->file_max);
                    err = LFS_ERR_INVAL;
                    goto cleanup;
                }

                lfs->file_max = superblock.file_max;
            }

            if (superblock.attr_max) {
                if (superblock.attr_max > lfs->attr_max) {
                    LFS_ERROR("Unsupported attr_max (%"PRIu32" > %"PRIu32")",
                            superblock.attr_max, lfs->attr_max);
                    err = LFS_ERR_INVAL;
                    goto cleanup;
                }

                lfs->attr_max = superblock.attr_max;
            }

            if (superblock.block_count != lfs->cfg->block_count) {
                LFS_ERROR("Invalid block count (%"PRIu32" != %"PRIu32")",
                        superblock.block_count, lfs->cfg->block_count);
                err = LFS_ERR_INVAL;
                goto cleanup;
            }

            if (superblock.block_size != lfs->cfg->block_size) {
                LFS_ERROR("Invalid block size (%"PRIu32" != %"PRIu32")",
                        superblock.block_size, lfs->cfg->block_size);
                err = LFS_ERR_INVAL;
                goto cleanup;
            }
        }

        // has gstate?
        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);
        if (err) {
            goto cleanup;
        }
    }

    // found superblock?
    if (lfs_pair_isnull(lfs->root)) {
        err = LFS_ERR_INVAL;
        goto cleanup;
    }

    // update littlefs with gstate
    if (!lfs_gstate_iszero(&lfs->gstate)) {
        LFS_DEBUG("Found pending gstate 0x%08"PRIx32"%08"PRIx32"%08"PRIx32,
                lfs->gstate.tag,
                lfs->gstate.pair[0],
                lfs->gstate.pair[1]);
    }
    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);
    lfs->gdisk = lfs->gstate;


    // 更新空闲块位图的lookahead信息，seed表示随机种子，在lfs_dir_fetchmatch函数内通过CRC计算
    // setup free lookahead, to distribute allocations uniformly across
    // boots, we start the allocator at a random location
    lfs->free.off = lfs->seed % lfs->cfg->block_count;
    lfs_alloc_drop(lfs);

    return 0;

cleanup:
    lfs_rawunmount(lfs);
    return err;
}
```

### 格式化

```c
static int lfs_rawformat(lfs_t *lfs, const struct lfs_config *cfg) {
    int err = 0;
    {
        // 使用入参的默认配置
        err = lfs_init(lfs, cfg);
        if (err) {
            return err;
        }

        // create free lookahead
        memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
        lfs->free.off = 0;
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size,
                lfs->cfg->block_count);
        lfs->free.i = 0;
        lfs_alloc_ack(lfs);

        // create root dir
        lfs_mdir_t root;
        // lfs_dir_alloc用于分配元数据块，每个元数据块都有两个块，用于表示元数据对
        err = lfs_dir_alloc(lfs, &root);
        if (err) {
            goto cleanup;
        }

        // write one superblock
        lfs_superblock_t superblock = {
            .version     = LFS_DISK_VERSION,
            .block_size  = lfs->cfg->block_size,
            .block_count = lfs->cfg->block_count,
            .name_max    = lfs->name_max,
            .file_max    = lfs->file_max,
            .attr_max    = lfs->attr_max,
        };

        lfs_superblock_tole32(&superblock);
        // 创建一个元数据提交，包含create,superblock和内联结构
        err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
                {LFS_MKTAG(LFS_TYPE_CREATE, 0, 0), NULL},
                {LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8), "littlefs"},
                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
                    &superblock}));
        if (err) {
            goto cleanup;
        }

        // force compaction to prevent accidentally mounting any
        // older version of littlefs that may live on disk
        root.erased = false;
        err = lfs_dir_commit(lfs, &root, NULL, 0);
        if (err) {
            goto cleanup;
        }

        // sanity check that fetch works
        err = lfs_dir_fetch(lfs, &root, (const lfs_block_t[2]){0, 1});
        if (err) {
            goto cleanup;
        }
    }

cleanup:
    lfs_deinit(lfs);
    return err;

}
```

### 打开文件

```c
static int lfs_file_rawopencfg(lfs_t *lfs, lfs_file_t *file,
        const char *path, int flags,
        const struct lfs_file_config *cfg) {
#ifndef LFS_READONLY
    // deorphan if we haven't yet, needed at most once after poweron
    if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {
        int err = lfs_fs_forceconsistency(lfs);
        if (err) {
            return err;
        }
    }
#else
    LFS_ASSERT((flags & LFS_O_RDONLY) == LFS_O_RDONLY);
#endif

    // setup simple file details
    int err;
    file->cfg = cfg;
    file->flags = flags;
    file->pos = 0;
    file->off = 0;
    file->cache.buffer = NULL;

    // allocate entry for file if it doesn't exist
    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);
    if (tag < 0 && !(tag == LFS_ERR_NOENT && file->id != 0x3ff)) {
        err = tag;
        goto cleanup;
    }

    // get id, add to list of mdirs to catch update changes
    file->type = LFS_TYPE_REG;
    lfs_mlist_append(lfs, (struct lfs_mlist *)file);

#ifdef LFS_READONLY
    if (tag == LFS_ERR_NOENT) {
        err = LFS_ERR_NOENT;
        goto cleanup;
#else
    if (tag == LFS_ERR_NOENT) {
        if (!(flags & LFS_O_CREAT)) {
            err = LFS_ERR_NOENT;
            goto cleanup;
        }

        // check that name fits
        lfs_size_t nlen = strlen(path);
        if (nlen > lfs->name_max) {
            err = LFS_ERR_NAMETOOLONG;
            goto cleanup;
        }

        // get next slot and create entry to remember name
        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
                {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},
                {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},
                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));

        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will
        // not fit in a 128 byte block.
        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;
        if (err) {
            goto cleanup;
        }

        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, 0);
    } else if (flags & LFS_O_EXCL) {
        err = LFS_ERR_EXIST;
        goto cleanup;
#endif
    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {
        err = LFS_ERR_ISDIR;
        goto cleanup;
#ifndef LFS_READONLY
    } else if (flags & LFS_O_TRUNC) {
        // truncate if requested
        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);
        file->flags |= LFS_F_DIRTY;
#endif
    } else {
        // try to load what's on disk, if it's inlined we'll fix it later
        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),
                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);
        if (tag < 0) {
            err = tag;
            goto cleanup;
        }
        lfs_ctz_fromle32(&file->ctz);
    }

    // fetch attrs
    for (unsigned i = 0; i < file->cfg->attr_count; i++) {
        // if opened for read / read-write operations
        if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
                    LFS_MKTAG(0x7ff, 0x3ff, 0),
                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,
                        file->id, file->cfg->attrs[i].size),
                        file->cfg->attrs[i].buffer);
            if (res < 0 && res != LFS_ERR_NOENT) {
                err = res;
                goto cleanup;
            }
        }

#ifndef LFS_READONLY
        // if opened for write / read-write operations
        if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {
            if (file->cfg->attrs[i].size > lfs->attr_max) {
                err = LFS_ERR_NOSPC;
                goto cleanup;
            }

            file->flags |= LFS_F_DIRTY;
        }
#endif
    }

    // allocate buffer if needed
    if (file->cfg->buffer) {
        file->cache.buffer = file->cfg->buffer;
    } else {
        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);
        if (!file->cache.buffer) {
            err = LFS_ERR_NOMEM;
            goto cleanup;
        }
    }

    // zero to avoid information leak
    lfs_cache_zero(lfs, &file->cache);

    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {
        // load inline files
        file->ctz.head = LFS_BLOCK_INLINE;
        file->ctz.size = lfs_tag_size(tag);
        file->flags |= LFS_F_INLINE;
        file->cache.block = file->ctz.head;
        file->cache.off = 0;
        file->cache.size = lfs->cfg->cache_size;

        // don't always read (may be new/trunc file)
        if (file->ctz.size > 0) {
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
                    LFS_MKTAG(0x700, 0x3ff, 0),
                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,
                        lfs_min(file->cache.size, 0x3fe)),
                    file->cache.buffer);
            if (res < 0) {
                err = res;
                goto cleanup;
            }
        }
    }

    return 0;

cleanup:
    // clean up lingering resources
#ifndef LFS_READONLY
    file->flags |= LFS_F_ERRED;
#endif
    lfs_file_rawclose(lfs, file);
    return err;
}
```

### 完整实例

```c
#include "lfs.h"

// variables used by the filesystem
lfs_t lfs;
lfs_file_t file;

// configuration of the filesystem is provided by this struct
const struct lfs_config cfg = {
    // block device operations
    .read  = user_provided_block_device_read,
    .prog  = user_provided_block_device_prog,
    .erase = user_provided_block_device_erase,
    .sync  = user_provided_block_device_sync,

    // block device configuration
    .read_size = 16,
    .prog_size = 16,
    .block_size = 4096,
    .block_count = 128,
    .cache_size = 16,
    .lookahead_size = 16,
    .block_cycles = 500,
};

// entry point
int main(void) {
    // mount the filesystem
    int err = lfs_mount(&lfs, &cfg);

    // reformat if we can't mount the filesystem
    // this should only happen on the first boot
    if (err) {
        lfs_format(&lfs, &cfg);
        lfs_mount(&lfs, &cfg);
    }

    // read current count
    uint32_t boot_count = 0;
    lfs_file_open(&lfs, &file, "boot_count", LFS_O_RDWR | LFS_O_CREAT);
    lfs_file_read(&lfs, &file, &boot_count, sizeof(boot_count));

    // update boot count
    boot_count += 1;
    lfs_file_rewind(&lfs, &file);
    lfs_file_write(&lfs, &file, &boot_count, sizeof(boot_count));

    // remember the storage is not updated until the file is closed successfully
    lfs_file_close(&lfs, &file);

    // release any resources we were using
    lfs_unmount(&lfs);

    // print the boot count
    printf("boot_count: %d\n", boot_count);
}
```

## 参考

- [OpenHarmony littlefs 文件系统存储结构与 IO 性能优化分析](https://ost.51cto.com/posts/14734)
