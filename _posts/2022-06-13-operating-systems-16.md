---
title: "《Operating Systems: Three Easy Pieces》学习笔记(十六) 分页：较小的表"
author: Jinkai
date: 2022-06-13 11:00:00 +0800
published: false
categories: [学习笔记]
tags: [Operating Systems, 操作系统导论]
---

假设一个 32 位地址空间（232 字节）， 4KB（212 字节）的页和一个 4 字节的页表项。一个地址空间中大约有`一百万个虚拟页面`（232/212）。乘以页表项的大小，你会发现`页表`大小为`4MB`。回想一下：通常系统中的`每个进程`都有`一个页表`！有`一百个`活动进程（在现代系统中并不罕见），就要为页表分配`数百兆`的内存！

## 简单的解决方案：更大的页

再以 32 位地址空间为例，但这次假设用 `16KB` 的页。因此，会有 18 位的 VPN 加上 14 位的偏移量。假设每个页表项（4 字节）的大小相同，现在线性页表中有 218 个项，因此每个页表的总大小为 1MB，页表`缩到四分之一`。

> **补充：多种页大小**
>
> 另外请注意，许多体系结构（例如 MIPS、SPARC、x86-64）现在都支持多种页大小。通常使用一个小的（4KB 或 8KB）页大小。但是，如果一个“聪明的”应用程序请求它，则可以为地址空间的特定部分使用一个大型页（例如，大小为 4MB），从而让这些应用程序可以将常用的（大型的）数据结构放入这样的空间，同时只占用一个 TLB 项。这种类型的大页在数据库管理系统和其他高端商业应用程序中很常见。然而，多种页面大小的主要原因并不是为了节省页表空间。这是为了减少 TLB 的压力，让程序能够访问更多的地址空间而不会遭受太多的 TLB 未命中之苦。然而，正如研究人员已经说明[N+02]一样，采用多种页大小，使操作系统虚拟内存管理程序显得更复杂，因此，有时只需向应用程序暴露一个新接口，让它们直接请求大内存页，这样最容易。

这种方法的主要问题在于，大内存页会导致每页内的浪费，这被称为`内部碎片`（internal fragmentation）问题（因为浪费在分配单元内部）。

## 混合方法：分页和分段

一个进程只使用了部分页，大部分页表都没有使用，充满了无效的（invalid）项。浪费了页表空间

`分段`见[《Operating Systems: Three Easy Pieces》学习笔记(十二) 分段](/posts/operating-systems-12/)，有一个`基址（base）寄存器`，告诉我们每个段在物理内存中的`位置`，还有一个`界限（bound）`或`限制（limit）寄存器`，告诉我们该段的`大小`。

`基址`不是指向段本身，而是保存该段的`页表`的`物理地址`。`界限寄存器`用于指示`页表的结尾`（即它有多少有效页）。

假设 32 位虚拟地址空间包含 4KB 页面，并且地址空
间分为 4 个段。在这个例子中，我们只使用 3 个段：一个用于`代码`，另一个用于`堆`，还有 一个用于`栈`。

用`地址空间`的`前两位`确定地址引用哪个段,假设 00 是未使用的段，01 是代码段，10 是堆段，11 是栈段。因此，虚拟地址如下所示：

![F1](/assets/img/2022-06-13-operating-systems-16/F1.jpg)



## 参考

- [Operating Systems: Three Easy Pieces 中文版](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/20.pdf)
