---
title: "DLMS/COSEM Blue Book学习笔记"
date: 2022-03-08 09:00:00 +0800
published: true
categories: [技术]
tags: [C++, DAO, database]
---

## s4.1 基本概念

### s4.1.2 Referencing methods

`logical names` (`LN` referencing):The reference for an `attribute` is: `class_id`, value of the `logical_name` attribute, `attribute_index`.The reference for a `method` is: `class_id`, value of the `logical_name` attribute, `method_index`

> 关于index，`规范`内的属性或方法为`1开始`的`正数`，`专有`的属性或方法应该设置为`负数`
>
> logical names中的OBIS的每个字段，A,B,C,D,E,F都有各自含义，在blue book1中给出
{: .prompt-tip }

`Short names`(`SN` referencing)：COSEM对象的每个属性和方法都用一个`13位整数`标识。短名称的语法与DLMS命名变量名称的语法相同。为了方便使用SN引用访问设备，一些`short_name`被保留为特殊COSEM对象的`base_name(objectName)`。保留base_names的范围是0xFA00到0xFFF8。这里的`base_name`就是cosem类的`不包含偏移`的短名，相当于每个类表格中的x，对应每个属性的短名叫short_name，是包含偏移的

### s4.1.4.6 Attributes

(dyn.)
:对带有流程值的属性进行分类，流程值由`仪表本身更新`。

(static)
:对一个属性进行分类，该属性`不会由仪表本身更新`(例如`配置数据`，**但可通过外部通信方式修改**)。

### s4.1.4.14 m/o

m (mandatory)
:The method is mandatory`强制的`.

o (optional)
:The method is optional`可选的`.

#### s4.1.4.17 Selective access

部分属性支持`选择性访问`

- “`Profile generic`” objects, `buffer` attribute;
- “`Association SN`” objects, `object_list` and `access_rights_list` attribute;
- “`Association LN`” objects, `object_list` attribute;
- “`Compact data`”, objects, `compact_buffer` attribute;
- “`Push`” objects, `push_object_list` attribute;
- “`Data protection`” objects, `protection_object_list` attribute `get_protected_attributes` method and `set_protected_attributes` method.

#### s4.1.6.3 Null-data and delta-value encoding

用于array内`数据压缩`

`空值`表示该值可以从前一条记录中恢复，比如和上一条值相同

`增量值`表示该值可以从前一条记录中通过递增方式恢复，第一条值必须是 integer 或 unsigned 类型，后面就可以一条条递增了

### s4.1.8 The COSEM logical device

#### s4.1.8.2 COSEM logical device name (LDN)

每个COSEM逻辑设备都可以由其唯一的COSEM LDN来标识。LDN定义为最多16个字节的字符串。`前三个字节`应携带`制造商标识符`。制造商应确保`LDN`，从标识制造商的`3个字节开始`，`后面是最多13个字节`，对每个制造的逻辑设备是`唯一`的。

#### s4.1.8.3 The “association view” of the logical device

为了访问服务器中的COSEM对象，首先要与客户端建立应用关联(AA，application association)。AAs标识partners，并描述AA将在其中通信的`上下文`。上下文主要内容是:

- the application context;
- the authentication mechanism;认证机制
- the xDLMS context.

根据客户端和服务器之间建立的AA关系，服务器可能会授予不同的`访问权限`。访问权限涉及一组COSEM对象(`可见对象`)，这些对象可以在`给定的AA`中被访问(“可见”)。此外，对这些COSEM对象的`属性和方法`的访问也可能在AA中受到限制(例如，某种类型的客户端`只能读取`COSEM对象的`特定属性`，但`不能写入`它)。访问权也可以规定所需的密码保护。

#### s4.1.8.4 Mandatory contents of a COSEM logical device

每个逻辑设备都应有：

- COSEM LDN对象
- “Association” (LN or SN)对象

> 如果SAP Assignment对象存在，“Association” (LN or SN)对象非必选

识别固件必选对象：

- active firmware identifier
- active firmware signature

每个固件对应以上两个对象各一个

#### s4.1.8.5 Management logical device

用于管理的逻辑设备，每个物理设备必须要有一个。

可以通过`public client`使用lowest level securty访问，作用是揭示物理设备`内部结构`以及`上报事件`

需要包含一个“SAP assignment” object，可以被public client读取，包含物理设备内所有的`逻辑设备`对应的`SAP信息`，如果物理设备只有一个逻辑设备，则可以省略

## s4.3 参数和测量数据的接口类Interface classes for parameters and measurement data

### 4.3.1 Data (class_id = 1, version = 0)

value 可以使用任何 Choice 中可选类型，和 DLMS green book 中定义的 Data 相同，但具体类型在实例化后就确定下来，与对象的逻辑设备名绑定，不允许动态改变。

### s4.3.2 Register (class_id = 3, version = 0)

包含`值`（value）和`量纲`（scaler_unit,包括`精度`(scaler)、`单位`(unit)）

清除方法

### s4.3.3 Extended register (class_id = 4, version = 0)

包含`值`、`量纲`、`状态`（厂家自定义）、`寄存器捕获时间`

清除方法

### s4.3.4 Demand register (class_id = 5, version = 0)

`需量寄存器`

周期性测量某个值得到当前平均值与上次平均值,`滑差式`统计，`统计窗口`可以是`1个或多个周期`

![demand](/assets/img/2022-03-17-dlms-blue2/demand.jpg)

E3表示第三个周期内的电量增量,`假设`当前时间`大于`E3统计`结束时间`（第三周期结束时间），`小于`E4统计`结束时间`，电量记录值比E3统计结束时大`Δe`

- current_average_value `当前平均值`，energy/3t,energy=E2+E3+Δe,t=period,3=周期个数
- last_average_value `上一平均值`，energy/3t,energy=E1+E2+E3,t=period,3=周期个数
- scaler_unit 量纲
- status 状态
- capture_time `last_average_value`计算时间
- start_time_current `current_average_value`统计开始时间, TODO:这个start_time必须是周期开始时间吗？图里显示这个值会跳变，说明start_time在跳变,结合next_period好像说得通，每到新的周期开始点执行next_period，start_time加一个周期的时间，导致分子急剧变小
- period `周期`
- number_of_periods `周期个数`，用于`last_average_value`计算，为`1表示区间式`(block)，`大于1表示滑差式`(sliding)

方法：

- reset (data) 清除
- next_period (data) 该方法用于触发一个时间段的正常终止(和重新启动)。关闭(终止)当前测量周期。`更新capture_time和start_time`，拷贝current_average_value到last_average_value，设置current_average_value为默认值。开始下一个测量周期。

### s4.3.5 Register activation (class_id = 6, version = 0)

该 IC 允许对不同收费结构的处理进行建模。 为每个“Register activation”对象分配“Register”, “Extended register”或“Demand register”对象组，对不同类型的量（例如`有功电量`、`有功需量`、`无功电量`等）进行建模。 由激活标记定义的这些寄存器的子组定义了不同的`收费结构`（例如，`白天`收费、`夜间`收费）。 这些激活标记之一，active_mask，定义了分配给“Register activation”对象实例的寄存器子集是活动的。 默认情况下，未包含在任何“Register activation”对象的 register_assignment 属性中的寄存器始终处于启用状态。

- register_assignment `寄存器列表`，包括Register”,“Extended register” or “Demand register”等的类id和OBIS
- mask_list `标记列表`，有多个register_act_mask，每个register_act_mask包含唯一的mask_name，每个register_act_mask中的index_list中的值顺序与register_assignment中的对象顺序一一对应，TODO:示例
- active_mask 激活的标记，`mask_list`中的`某个标记`，使用mask_name决定，用于表示当前`启用`的mask，进一步表示`启用`的register

方法：

- add_register (data) 向register_assignment中添加一个项，添加在数组尾部
- add_mask (data) 添加或更新mask_list
- delete_mask (data) 从mask_list删除一个mask，使用mask_name

### s4.3.6 Profile generic (class_id = 7, version = 1)

允许`存储、排序和访问`称为`捕获对象`的数据组或数据系列。捕获对象是几个`COSEM对象`的几个适当`属性`或几个属性的几个`元素`的组合。捕获对象`定期或不定期收集`。

曲线包含`捕获对象`，可通过值的范围或输入范围`检索范围`内所有记录

`捕获对象列表`定义了要保存在buffer中的值，列表是静态的，保证`每个记录`都拥有`相同的长度和结构`

修改捕获列表必须清空buffer中所有记录，buffer被其他profile使用也必须清空buffer。以保证它们的缓冲区条目的同质性

记录可以按`某个字段`进行`排序`，如`时间`，或是按先进后出的栈的方式排序。例，按照Demand register中的last_average_value值来从小到大排序获得最大需量register

#### s曲线数据大小限制参数

- 记录数entries_in_use
- 最大保留条数。当记录数满时，新捕获数据会覆盖`最不重要`的一条数据，重要度根据`排序方式`获得，如根据时间排序，最不重要的数据就是时间最早的数据
- 缓冲区物理限制

#### s选择性访问

- 按照值的范围：

    值可以是时间，或是某个**捕获对象**的值，仅允许简单类型。

- 按照排序后记录存储的顺序范围：

    如从第一条记录（`重要性`最高）到第三条

    如从某个值最大的记录到第三大的记录，需要重新临时排序

#### s属性

- buffer 包含记录序列，每个记录包含若干捕获对象
- capture_objects 捕获对象列表，数组形式
- capture_period 自动捕获周期，以秒为单位，大于1表示达到周期捕获，等于0表示不自动捕获，需要手动触发
- sort_method `排序方式`，默认为`先进先出`排序。如果profile已经排序，插入新的记录时，将记录插入适当位置，移动该位置之后所有记录，最不重要记录可能在buffer满后丢失。如果新记录的重要度最低且buffer已满，则该记录不插入
- sort_object 排序依据（对象）,此属性指定排序所基于的寄存器或时钟
- entries_in_use 当前记录总数
- profile_entries 记录上限

#### s方法

- reset (data) 清空buffer，entries_in_use清零，其他配置不变
- capture (data) 手动触发捕获，`读取`每个捕获对象的`值`，`生成记录插入buffer`,同样不会改变捕获对象列表

#### s修改捕获对象列表后行为

`调用`使用了该捕获对象列表的profile的`reset操作`，需要清空buffer

#### s限制

定义捕获对象列表时，避免`相互或循环引用`。（实现时可以静态检查出来）

### s4.3.7 Utility tables (class_id = 26, version = 0)

允许封装 ANSI C12.19:2012 table 数据

ANSI C12.19 是一个标准，它定义了用于电表和其他设备的数据传输的表格（tables）格式。这些表格格式允许电力公司和其他机构标准化设备之间的数据交换。ANSI C12.19 主要用于智能电表（smart meters）和先进的计量基础设施（Advanced Metering Infrastructure，AMI）系统中。

其实和 COSEM 非常像，不过它是根据表格来表示和传递数据。所以该类的功能就是提供两种数据格式标准之间的转换。

#### 表格 0（Table 0）：制造商信息表

| 字段名称         | 数据类型 | 长度（字节） | 描述         |
| ---------------- | -------- | ------------ | ------------ |
| Manufacturer ID  | String   | 4            | 制造商标识符 |
| Model Number     | String   | 8            | 型号编号     |
| Firmware Version | String   | 4            | 固件版本     |

#### 表格 1（Table 1）：配置表

| 字段名称          | 数据类型 | 长度（字节） | 描述       |
| ----------------- | -------- | ------------ | ---------- |
| Meter ID          | String   | 8            | 电表标识符 |
| Installation Date | Date     | 4            | 安装日期   |
| Meter Type        | String   | 2            | 电表类型   |

#### 表格 2（Table 2）：电能数据表

| 字段名称        | 数据类型 | 长度（字节） | 描述            |
| --------------- | -------- | ------------ | --------------- |
| Reading Date    | Date     | 4            | 读取日期        |
| Energy Consumed | Float    | 4            | 消耗电能（kWh） |
| Peak Demand     | Float    | 4            | 最大需量（kW）  |

### s4.3.8 Register table (class_id = 61, version = 0)

对`同构`条目、多个对象的`相同属性`进行`分组`，这些对象都是`相同IC`的实例,并且在它们的logical_name (OBIS代码)中，值组`A到D`和`F`中的值是`相同`的。

用处就是不需要定义一大堆的相似的 Register 对象。不过本类仅用于保存这些值，访问这些值依然是通过具体对象的 logical_name，一般不会直接读取本类对象。

属性：

- logical_name 当逻辑名为A.B.C.D.255.F时，只能捕获`一个属性`，如value（见table_cell_definition，此时其中的logical_name就和本值相同）。当逻辑名为A.B.98.10.X.255时，可以捕获有关对象的不同属性
- table_cell_values 保存捕获属性的值（可选CHOICE种类就是register对象的value属性的类型，因为保存的是多个对象，所以是一个数组），可压缩

  压缩条件：

  如果捕获的属性是attribute_0（index 0,表示捕获所有属性），如果它们的值是相同的(例如`scaler_unit`)，则这些`冗余值`可以被“`null-data`”替换，后续可以无损恢复。
- table_cell_definition
  - class_id定义捕获属性的对象的公共Class_id;
  - logical_name包含对象的通用逻辑名，E = 255(通配符);
  - group_E_values包含单元标识符列表，类型为unsigned，在DLMS UA 1000-1 Ed 15 Part 1:2021的相应表中定义;
  - attribute_index是指向对象内属性的指针。Attribute_index 0表示所有公共属性。（按照本类中的 logical_name 的描述，当格式为 A.B.C.D.255.F ，强制仅能捕获一个属性，也就是说此时不能为 0）

  特殊情况：当本类的 logical_name 格式为 A.B.C.D.255.F 时，本属性的值会被强制：

  - class_id 必须为  1 “Data”, 3 “Register” or 4 “Extended register”
  - logical_name 必须和本类的 logical_name 相同
  - attribute_index 必须为 2(仅捕获 value 属性)
- scaler_unit 量纲，当“Register”或“Extended Register”对象的“value”属性被捕获时，scaler_unit应为所有对象的`公共属性`。如果是其他属性或是其他IC，则`该属性无用且禁止访问`

方法：

- reset (data) 清空table_cell_values
- capture (data) 捕获，将原IC对象中的值拷贝到table_cell_values中，如果table_cell_definition中的attribute_index为0，则捕获所有属性

table_cell_definition被写入时的动作：

自动调用reset方法清空原数据，如果需要捕获的属性的占用空间过大，table_cell_definition的写入会被拒绝

### s4.3.9 Status mapping (class_id = 63, version = 0)

该IC允许将`状态字(status_word)中的位`映射到`引用表`中的`项`。

- status_word 状态字，n*8比特，最大65536比特
- mapping_table 包含status_word到引用表中位置的映射。
  - ref_table_id 表示引用表的id
  - ref_table_mapping（choice：long-unsigned或long-unsigned数组）：该值对应`引用表`(reference table，见 6.2.46, 6.2.49, 6.2.50, 6.2.55 and 6.3.7)中的`一条记录`，该记录对应status_word中的第一位，该记录的下一条记录对应status_word中的第二位，直到status_word的最后一位

    - 如果该值选择`long-unsigned`，则表示对于引用表的引用起始索引(index)

      假设status_word为10000001，ref_table_mapping的long-unsigned值为3，对于引用表的第3条记录

      |status_word位值|引用表索引|
      |:---:|:---:|
      |1|3|
      |0|4|
      |0|5|
      |...|...|
      |1|10|

    - 如果该值选择`array`：array中的每个值都是引用表的一个索引(index)，对应引用表中的一条记录，如array第一个值为8，表示引用表的第9条记录对应status中的第1位。

### s4.3.10 Compact data (class_id: 62, version = 1)

紧凑数据

Compact data IC 的实例允许捕获由capture_objects属性确定的COSEM对象属性值。捕获可以发生在:

- 在外部触发器上(显式捕捉);
- 在读取compact_buffer属性时(隐式捕获)。

由capture_method属性确定

值保存在compact_buffer attribute中，以octet-string形式

这组数据类型由template_id属性标识。捕获的每个属性的数据类型由template_description属性保存。

客户端可以用未压缩的形式重新构造数据(解压)，即包括COSEM属性描述符、数据类型和使用capture_objects、template_id和template_description属性的数据值。

属性：

- compact_buffer 捕获的属性的值，octet-string形式，当类型为octet-string, bit-string, visible-string, utf8-string or array时，长度也包含在内。（不同于profile，这个类中的compact_buffer就是个octet-string，不是array，也就是只有一条）
- capture_objects 指定分配给“Compact data”对象实例的`COSEM对象属性列表`，两种选择性访问方式：
  - `相对选择性访问`：相对当前的日期或当前的记录返回记录，由data_index元素控制
  - `绝对选择性访问`：根据明确的时间范围或记录范围返回记录，由restriction_element控制，列（columns）是由data_index的MS byte(Most Significant byte,意为最高有效字节)的低半字节（右边4位）决定的

  - data_index:是一个指针，它`选择`具有复杂数据类型(结构或数组)的属性的一个或几个`特定元素`:
    - 如果属性的数据类型是简单类型，则该值无意义
    - 如果属性的数据类型是结构体或数组（非profile generic对象的buffer），则该值指向该结构体或数组中的一个或多个特定元素
    - 如果属性的数据类型是profile generic对象的buffer，该值包含相对选择性访问的参数，如当前日期或记录
  
    |data-index:|MS-Byte|MS-Byte|LS-Byte|
    |:---:|:---:|:---:|:---:|
    ||Upper nibble|`Lower nibble`||
    |例子:|0000|0000|00000000|
  
    - 0x0000: 标识整个属性;
    - 0x0001到0x0FFF: 标识复杂属性中的一个元素。复杂属性中的第一个元素由data_index 1(0x0001)标识;
    - 0x1000到0xFFFF: 对保存Profile generic对象的buffer的数组进行相对选择性访问。数据索引选择最近(最近)时间段内的条目，或最近(最近)条目内的条目，以及数组中的列。
      - 参考Table 9 – Encoding of selective access parameters with data_index。例，0x830C，MS-Byte中的高4位为0x8，表示包括当前小时在内的最后一个完整小时数，低4位为0x3，表示前3列，LS-Byte为0x0C,表示12小时，综上，该值表示选择最后12个小时内的前3列数据
  - restriction_element：当属性的数据类型是profile generic对象时，该值用于表示`绝对选择性访问`的参数，时间范围，记录序号范围，
    - 此时的data_index条件：
      - MS Byte高4位为0（为1的话表示相对选择性访问）
      - MS Byte低4位为0x0到0xF
      - Lower byte为0
    - restriction_type表示选择性访问的方式
    - restriction_value表示选择性访问范围

- template_id 包含模板的`标识符`。它应唯一标识“Compact data”IC的实例和 template_description。
- template_description 每个被捕获的属性的`数据类型`，由服务端自动生成，是一个类似于 AXDR 编码后的 OCTET-STRING，根据capture_objects，包含以下内容：
  - 第一个字节是0x02结构体tag
  - 后面是数量，变长，和capture_objects数量相同
  - 后面是每个属性的数据类型，与capture_objects一一对应:
    - 对于具有简单数据类型的属性，该值一个字节，包含类型tag，如`bit-string[4]`(不含长度，长度在 compact_buffer 中(本类的设计思路就是把变化的数据放在 compact_buffer 中，如长度、value；不变的数据，如类型等，放在 template_description 作为共享的常量))
    - 对于`array[1]`，该值为0x01，后面是元素的类型（数组内所有元素都相同，所以就一个）。数组长度也是放在 compact_buffer 中
    - 对于`structure[2]`，该值为0x02,后面是元素数目，后面是每个元素的类型
- capture_method 定义compact_buffer更新的方式：
  - 0：在调用Capture (data)方法时捕获。这可能发生在远程或本地(显式捕获)
  - 1：读取compact_buffer属性时捕获(隐式捕获)

方法：

- reset(data) 仅清空compact_buffer
- capture(data) 将捕获对象的值填充至compact_buffer中，**不会触发捕获对象内的任何其他操作**，如capture()或reset()

对capture_objects的任何修改，必须`重置`compact_buffer以及`自动更新`template_description

### s4.3.11 Measurement data monitoring objects (class_id = 66, version = 0) (新增)

> 本类中提到的触发(trigger)就是指调用本类的 trigger(data) 方法

用于采样数据，使用环形缓冲分别保存触发前的几次采样结果和触发后的几次采样结果，本类型的参数包含采样周期和采样保留条数。

- waveform_data 保存的采样数据，使用 compact-array，数组元素类型为简单类型(只能采样简单类型)。一旦对象实例化，类型便确定，无法改变。保存了触发前和触发后的数据，所以总条数为这两者之和(属性7+属性8, number_of_samples_before_trigger+number_of_samples_after_trigger)。
- trigger_time 调用触发方法的时间，单位为微秒。通过该属性就能区分保存在 waveform_data 内的数据哪些属于触发前，哪些属于触发后。
- trigger_source 触发源和原因，触发源分为本地 script 和远程调用。仅为本地 script 时才需要触发原因。
- status 提供有关波形测量状态的信息。它可指示以下情况：波形阵列中数据缺失、测量错误、测量进行中。
- sampling_rate 采样频率（建议出厂就配置，之后不再修改）。值为一个周期内的采样次数。TODO：周期是什么
- number_of_samples_before_trigger 触发前的采样数据的保留条数
- number_of_samples_after_trigger 触发后的采样数据的保留条数
- scaler_uint 量纲

方法：

- reset(data) 终止采样过程
- trigger(data) 将调用该方法的时间点前和后的对应条数的采样数据保存到 waveform_data 中，同时更新其他相关属性。为了保存调用该方法后一定条数的采样数据，该调用将会持续一定时间(方法应该是立即返回，执行会持续一段时间)，直到达到所需的采样条数。当一个 trigger 在进行中时，本对象将会锁定(内部定时器)，此时无法再次调用该方法。所以如果要强制开始新的采样，必须先调用 reset(data) 结束采样过程，再调用 trigger(data)

## s4.4 用于访问控制和管理的接口类Interface classes for access control and management

按照 4.4.8.2 Push setup 所述，Push setup 对象和 Association 对象通过 client_sap 绑定，是否意味着 client_sap 是主键，一个逻辑设备中对于每个 client 只能同时存在一个 AA。

### s4.4.3 Association SN (class_id = 12, version = 4)

COSEM logical devices能够在COSEM context中`使用SN引用建立AAs`，使用“Association SN”IC的实例建模AAs。一个COSEM logical devices可以对`每个`设备能够支持的`AA`拥有`一个`该IC的`实例`。

属性：

- object_list 对象列表，数组形式，包含base_name,class_id,version,logical_name，base_name定义见*文章开头*
  >实际这里base_name和logical_name的含义重复了，不过base_name是是用来作为和access_rights_list关联的外键的

  TODO:logical_name和base_name重复了
- access_rights_list 包含对属性和方法的`权限`，数组形式，和object_list间通过`base_name`管理，相当于外键，元素数量需要相同，元素顺序最好也相同。包含base_name，attribute_access(可选)，method_access(可选)
  >object_list支持以class_id，logical_name或base_name为条件选择性访问，access_rights_list支持以base_name为条件选择性访问
- security_setup_reference 引用`Security setup`的logical_name，被引用的对象管理给定的"Association SN"对象实例的安全性
- user_list `允许使用`本对象管理的`AA`的用户列表
  - user_id表示user的id（`AARQ`中的`calling-AE-invocation-id`携带）
  - user_name是用户的名字

  >如果数组`为空`，则`任何用户`都能使用AA；如果数组不为空，则仅有列表内用户可以建立AA，也就是AARQ中的calling-AE-invocation-id字段必须匹配列表中的user_id。

  ```asn1
    array user_list_entry
    user_list_entry ::= structure
    {
        user_id:    unsigned,
        user_name   CHOICE {
                    visible-string  [10],
                    UTF-8-string    [12]
                    }
    }
  ```

- current_user 当前用户，若user_list为空，该值的user_id和user_name都为0（空）

方法：

- read_by_logicalname (data) 读取指定对象的属性值，对象由class_id和logical_name指定，attribute_index表示索引，0表示全部属性，1表示第一个属性。回复的数据由属性类型决定
- change_secret (data) 修改LLS密码或HLS密钥（不包括认证），可能包含校验信息或本身被加密，HLS with GMAC认证的密钥由Security setup管理。
- reply_to_HLS_authentication (data) 此方法的`远程调用`将`服务端对客户端`的`质询`(change) f(`StoC`) 的客户端`secret 处理的结果`传递回服务端，作为通过参数化访问调用的 Read.request 原语的数据服务参数

  |服务端S|客户端C|
  |:---:|:---:|
  |StoC->||
  ||<-f(StoC)加密处理后的结果|

  参数：
  
  服务端对 f(StoC) 的处理结果

  返回值：

  如果认证被接受，则响应（Read.confirm 原语）包含 Result == OK 和服务器对客户端质询服务器的 secret 处理结果，在 Read 的数据服务参数中 f(CtoS) 响应服务。如果认证不被接受，则返回non-OK值，不再包含其他数据。

  见 [G9.2.2.2 Identification and authentication](/posts/dlms-green-1/#s9222-identification-and-authentication)

- add_user (data) 向user_list添加一个用户
- remove_user (data) 从user_list移除一个用户

### s4.4.4 Association LN (class_id = 15, version = 3)

COSEM logical devices能够使用 LN 引用在 COSEM context中建立 AA，通过“Association LN”IC 的实例对 AA 建模。 一个 COSEM logical devices 对于其能够支持的每个 AA 都有一个该 IC 的实例。

属性：

- object_list 同Association SN中object_list和access_rights_list的整合

  选择性访问支持null(所有),class_list,object_id_list,object_id(class_id+logical_name)
- associated_partners_id 包含COSEM客户端和服务端(逻辑设备，物理设备包含若干个逻辑设备)，属于由Association LN对象建模的AA。客户端范围为0x0-0x7F,服务端范围为0x0-0x3FFF
- application_context_name 在COSEM环境中，希望预先存在一个`application context`，并在AA建立期间通过其名称引用它。此属性包含该AA的application context的名称。见*Green Book 4.5.2 application context*，*9.4.2.2.2 The COSEM application context*。TODO:查看文档
- xDLMS_context_info 包含关于给定AA的`xDLMS context`的所有必要信息
  - conformance element: 包含服务器支持的xDLMS一致性块,TODO:一致性块是什么 更新：见Gp322 Table 85，表示双方支持的功能列表，用于协商。位串的长度为24位;
  - max_receive_pdu_size：包含xDLMS APDU的`最大长度`，客户端可以发送的字节数在AA过程中协商，受xDLMS initiateResponse APDU的server-max-receive-pdu-size参数的限制;
  - max_send_pdu_size：在这个AA中服务器可以发送的xDLMS APDU的`最大长度`，以字节表示。它受到xDLMS initiateRequest APDU的client-max-receive-pdu-size参数的限制;
  - dlms_version_number：包含服务端支持的DLMS版本
  - quality_of_service：未使用
  - cyphering_info：在一个活动的AA中，包含xDLMS initiateRequest APDU的专用关键参数，见*GREEN BOOK 9.5*

- authentication_mechanism_name AA认证机构名称
- secret LLS或HLS密钥，同上SN
- association_status AA当前状态
- security_setup_reference 引用Security setup对象的logical name.该对象用于表示本对象的高级加密(HLS)参数
- user_list 同上SN
- current_user 同上SN

方法：

- reply_to_HLS_authentication (data) 同上SN
- change_HLS_secret (data) 同上SN
- add_object (data) 同上SN
- remove_object (data) 同上SN
- add_user (data) 同上SN
- remove_user (data) 同上SN

### s4.4.5 SAP assignment (class_id = 17, version = 0)

该 IC 允许通过提供有关将逻辑设备分配给其 SAP 的信息来对物理设备的逻辑结构进行建模。 参见 DLMS UA 1000-2 Ed.11:2021，第 10 条。

一般在一个物理设备内，仅有 Management logical device 拥有该对象实例，见 4.1.8.5 Management logical device。

属性：

- SAP_assignment_list 包含物理设备上所有`逻辑设备(的名称)`和他们的`sap`
  - 逻辑设备(的名称)
  - sap

方法：

- connect_logical_device (data) 将`逻辑设备`连接到`SAP`。连接到`SAP 0`表示`断开`设备连接。一个SAP不能连接多个设备(SAP 0除外)。

  逻辑设备：物理设备中的`抽象实体`，表示用COSEM对象建模的`功能子集`

### s4.4.6 Image transfer (class_id = 18, version = 0)

 Image 传输 IC 模型的实例是将`二进制文件`(称为image)传输到`COSEM服务器`的过程。

1. 步骤1：(可选)获取ImageBlockSize
2. 步骤2：客户端启动image传输
3. 步骤3：客户端传输imageBlocks
4. 步骤4：客户端检查确认传输完成
5. 步骤5：服务端校验image完整性（客户端发起或服务端自行完成）
6. 步骤6：（可选）客户端检查要激活的image上的信息
7. 步骤7：服务端激活image（客户端发起或服务端自行完成）

属性：

- image_block_size 保存ImageBlockSize，一个 Image 被分为若干块，这里是每个块大小，用八位字节表示，不能超过协商的ServerMaxReceivePduSize
- image_transferred_blocks_status `位图`，提供关于每个ImageBlock的传输状态的信息。bit-string中的每一位提供了一个单独的ImageBlock的信息，0为未传输，1为已传输。
- image_first_not_transferred_block_number 第一个`未传输`的块的编号，如果传输全部完成，该编号应该等于或大于image_block_size
- image_transfer_enabled `控制`是否`启用` Image 传输`过程`，只有置为true才能执行image transfer相关方法，为false是禁用所有方法的执行，返回错误
- image_transfer_status `传输状态`，表示传输过程所在的阶段和该阶段的执行结果（如，校验阶段校验失败 Image verification failed）
- image_to_activate_info 提供有关准备`激活的映像的信息`。这是一个`数组`，每个待激活的 Image 都有`独立`信息，它是作为 Image 验证过程的结果生成的。客户端可以在激活映像之前检查这些信息（从服务端的这个属性中读出来后检查）。包括`大小、标识（identification）和签名`

方法：

- image_transfer_initiate (data) `初始化`传输过程，参数包括identifier和ImageSize（不是image block size）。在此之后，将image_transfer_status（传输状态）属性置为1，image_first_not_transferred_block_number置为0，对于该方法的调用会重置整个传输流程
- image_block_transfer (data) 传输`一个块`到服务端，包括块序号和块内容，之后将image_transferred_blocks_status对应位置1，image_first_not_transferred_block_number更新
- image_verify (data) 在激活之前验证映像的完整性(触发服务端自校验)。

  调用这个方法的结果可能是`success、temporary_failure`或`other_reason`。如果`不成功`，则可以通过检索`image_transfer_status`属性的值来找到验证的结果。

  如果`成功`，image_to_activate_info属性将保存要激活的 Image 的信息。
- image_activate (data) `激活 Image`。

  如果传输的Image之前没有经过`验证`（没执行image_verify），那么这将作为Image_activate的一部分完成。
  调用此方法的结果可能是`success、temporary_failure`或`other_reason`。如果不是成功，那么可以通过检索`image_transfer_status`属性的值来了解激活的结果。

如果客户端不知道 Image 传输目标服务器可以处理的 Image 块的大小，那么在开始处理之前，客户端需要读取 Image 传输到的每个服务器的相关“image transfer”对象的`image_block_size`属性。客户端可以传输`合适大小`的ImageBlocks。

如果 Image 块通过`广播`发送给一组COSEM服务端， Image 块大小在组中的每个成员中应该是相同的。

`校验临时失败`不是真正失败，可能是校验还未完成，客户端可以通过获取image_transfer_status属性的值来检查Image验证的结果。

服务端内可以保存多个待激活的 Image

#### sImage transfer for M-Bus devices

TODO

### s4.4.7 Security setup (class_id = 64, version = 1)

“Security setup”IC的实例包含有关当前正在使用的`安全套件(security suite)`的必要信息，以及在客户机和服务器之间适用的`安全策略(security policy)`(由它们各自的系统标题标识)。它们还提供了提高安全性级别和管理`对称密钥`、`非对称密钥对`和`证书`的方法

属性：

- security_policy `安全策略`，标识是否使用安全套件中可用的安全算法执行**身份验证(authenticate)**和/或**加密(encrypt)**和/或**数字签名(digitally sign)**。它独立地应用于请求和响应。
- security_suite 安全套件，明确安全算法(认证、加密、数字签名、密钥协商、哈希、压缩、key wrap)，参考[NSA Suite B 和 CNSA](https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography)
  
  - (0) AES-GCM-128 authenticated encryption and AES-128 key wrap
  - (1) AES-GCM-128 authenticated encryption, ECDSA P-256 digital signature, ECDH P-256 key agreement, SHA-256 hash, V.44 compression and AES-128 key wrap
  - (2) AES-GCM-256 authenticated encryption, ECDSA P-384 digital signature, ECDH P-384 key agreement, SHA-384 hash, V.44 compression and AES-256 key wrap
  - (3) … (15) reserved
- client_system_title 携带（当前）`客户端`system title，在已确认或未确认的AA建立过程中，由AARQ APDU的calling-AP-title字段承载;
- server_system_title 携带`服务端`的system_title，在确认AA建立时，由AARE APDU的response-AP-title字段进行
- certificates 携带可用的X.509 v3`证书信息`，并存储在服务器中。服务端可以保存服务端证书、每个客户端的证书、CA证书。

方法：

- security_activate (data) 激活和`加强安全策略`security_policy，新的值安全性必须高于或等于原值，也就是只能加强，不能减弱
- key_transfer (data) 用于`传输`一个或多个`密钥`(EK,AK,BK,MK),包括密钥标识和封装后的密钥（key wrapped）。可以是数组，一次多个密钥。`key wrap`算法由加密套件指定
- key_agreement (data) 用于使用安全套件指定的`密钥协商算法`对一个或多个`对称密钥`达成一致。在套件1和套件2的情况下，ECDH密钥协商算法与临时统一模型(Ephemeral Unified Model) C(2e, 0s, ECC CDH)方案一起使用。
- generate_key_pair (data) 根据`安全套件`的要求生成`非对称密钥对`。data`参数`标识要生成的密钥对的`用法`:
  - digital signature key pair 数字签名
  - key agreement key pair 密钥协商
  - TLS key pair TLS通信

  以上每个用法的密钥对`最多同时`只能有`一个`，也就是最多有三个密钥对
- generate_certificate_request (data) 当调用此方法时，服务器发送`证书签名请求`(`CSR`)数据，这是CA为服务器公钥生成证书所必需的。data参数为请求证书的密钥对类型

  响应为CSR数据，PKCS #10格式DER编码的octet-string
- import_certificate (data) `导入X.509 V3格式证书`，DER编码octet-string，无需指定类型，TODO：如何区分证书类型,自动识别？
- export_certificate (data) `导出证书`，根据类型或序列号
- remove_certificate (data) `移除证书`，参数同上导出证书

  TODO: 新版本蓝皮书写了服务端的证书只能更新，不能删除。意思是不是不能在没有调用过 generate_certificate_request 或 import_certificate 生成或导入新证书的情况下直接调用 remove_certificate？

### s4.4.8 Push interface class

DLMS消息可以在未经明确请求的部分情况下“`推送`”到目的地，例如:

- 计划的时间到达
- 本地监控的值`超过阈值`;
- 由`本地事件`触发(如开机/关机，按下按钮，表盖打开)。

DLMS/COSEM推送机制遵循`发布/订阅(publish/subscribe)`模式。

在DLMS/COSEM中，发布是由“Association”对象的object_list属性建模的，该属性提供了给定AA中可访问的COSEM对象列表和它们的属性。订阅是通过编写“Push setup”对象的适当属性来建模的。使用xDLMS DataNotification服务(在指定的触发器上)发送所需的数据。

![push](/assets/img/2022-03-17-dlms-blue2/push.png)

### s4.4.8.2 Push setup (class_id = 40, version = 3)

"Push setup"IC包含要推送的`COSEM对象属性`的`引用列表`。它还包含推送`目的地`和`方法`，以及`通信时间窗口`和`重试处理`

Push在*push*方法被调用时启动，由`push: Single action schedule对象`、`alarm: Register monitor对象`、`专用的内部事件`或`外部事件`触发。push操作被`触发`后，根据给定的`push setup`对象中的设置执行。根据`通信窗口`的设置，push会在`随机延迟`后立即执行，或者在通信窗口激活后立即执行。如果push不成功，则会`重试`。重试可能在提示支持协议层失败或缺少确认时发生。

属性：

- push_object_list 定义要推送的`属性列表`，在调用`push (data)`方法时，内容被发送到`send_destination_and_method`属性中定义的目标。
  - class_id 类
  - logical_name 对象
  - attribute_index 属性序号，0表示全部，如果attribute_index是0，则下面的data_index为0且无意义，其他值也为空或null
  - data_index 当属性是数组或结构体时(除profile generic)，0表示所有元素，0x0001-0x0FFF表示元素序号，其他值为空或null
  - restriction,columns 当属性是profile generic对象的时，和data_index一起表示选择性访问参数

  携带推送数据的`DataNotification APDU`受到*安全套件suit*、*安全策略policy*和*安全材料material*的保护，这些安全配置包含在"Security setup"对象中，由AA应用上下文中的`Association SN/Association LN`对象的`security_setup_reference`属性引用，"Association"对象和本对象通过`push_client_SAP`属性相关联；以及push_protection_parameters属性也是如此。对于在该AA中没有被授予**读取访问权**的属性，或者由于任何其他原因不能被访问的属性，应该返回空数据（如果客户端没有读取权限，服务端当然也不会把数据推送给它）。
- send_destination_and_method 包含`目标地址`和`传输服务`(例如电话号码，电子邮件地址，IP地址)，用于发送push_object_list指定的数据
  - transport_service 传输服务类型，如TCP,HDLC,Gateway等
  - destination 目的地址，取决于transport_service，比如CoAP协议的目的地址时一个CoAP URI,
  - message APDU编码类型
    - (0) A-XDR encoded xDLMS APDU
    - (1) XML encoded xDLMS APDU
    - (128...255) manufacturer specific

  一个Push setup对象仅支持一个transport_service和destination，如果同一个内容需要上报给多个目的地，则需要多个不同对象
- communication_window `通信窗口`，包含开始时间和结束时间的区间，是个数组，每个元素为一个区间。如果没有元素，则不限制窗口，随时可以推送
- randomisation_start_interval 发送第一包前的`随机等待`时间的`最大值`，为了防止大量位于同一个网络下的设备同时推送产生碰撞。
  - 随机等待时间从0到最大值随机
  - 仅在活动窗口内调用push生效，`不在重试时生效`（push失败后等待固定延迟时间重试，不应用随机等待时间）
  - 在活动窗口外时push，到达窗口开始时间时计算随机值
  - 随机延迟超出窗口结束时间，那要到下一个窗口才能push，见上一节的图片
  - 未定义窗口时，所有push和重试都会应用随机等待
- number_of_retries 最大重试次数
- repetition_delay 重发延迟
  - 最小时间
  - 指数，用于计算下次延迟
  - 最大时间

  >𝑟𝑒𝑝𝑒𝑡𝑖𝑡𝑖𝑜𝑛_𝑑𝑒𝑙𝑎𝑦 = 𝑟𝑒𝑝𝑒𝑡𝑖𝑡𝑖𝑜𝑛_𝑑𝑒𝑙𝑎𝑦_𝑚𝑖𝑛 × (𝑟𝑒𝑝𝑒𝑡𝑖𝑡𝑖𝑜𝑛_𝑑𝑒𝑙𝑎𝑦_𝑒𝑥𝑝𝑜𝑛𝑒𝑛𝑡 × 0.01)^(𝑛−1)

  n表示第几次，n=1表示第一次重试

  >**push内容没有缓存，每次push重试，内容应该要重新组装，就可能和上次的不同**

- port_reference 通信端口引用，引用"communication port setup"对象,TODO:查看对应章节
- push_client_SAP 客户端SAP,推送目标，绑定对应的AA。和 "Association"对象内的 client SAP 相关联。因为上报时不知道当前通信的 AA，所以必须通过这种方式绑定。
- push_protection_parameters 数据保护参数，见Data Protection IC
- push_operation_method 定义是否使用 `Service_Class` == `Unconfirmed` 或 `Confirmed` 调用 DataNotification.request 服务原语以及推送`重试`的操作`方式`。

  - (0) unconfirmed, retry on `supporting protocol layer failure`。AL层无需确认（发送结果不用给AL层），也不会超时重发，只在支持层回失败时重发，条件最宽松
  - (1) unconfirmed, retry on `missing supporting protocol layer confirmation`。AL层无需确认（发送结果不用给AL层），但会在支持层超时未回confirm原语时重发，包含0的情况，失败也重发
  - (2) confirmed, retry on `missing confirmation`。必须由AL层确认，否则都会超时重发（即使支持层回了成功也一样），包含0和1的情况

- confirmation_parameters 当上报对象是一个数组时，本参数用于选择其中部分已经被上报并确认的条目，避免这些条目也被上报。相对选择性访问时（见本节push_object_list中的data_index和restriction），该值定义选择的条件（即已经被确认的条目，已经被确认的不再推送）。如果没有条目被本属性表示的范围包含则所有条目都会被选择，全部推送：
  - 开始时间：范围的起点
  - 偏移时间(秒)。TODO:按我理解这里的 "current date" 应该是指相较于开始时间的向后偏移(而不是当前时间的意思)，这样才能表示一个范围。
- last_confirmation_date_time 保存 `AL` 最近调用 `DataNotification.confirm 服务原语`并收到 `Result == CONFIRMED` 的日期和时间。当AL收到支持层发来的确认时，会将根据Service_Class以及本地还是远程确认来调用 DataNotification.confirm 通知 AP，Result == CONFIRMED 的情况为 (Service_Class == Unconfirmed 且本地确认) 以及 (Service_Class == Confirmed 且远程确认) 。见 Green Book 9.4.6.7 Protocol of the DataNotification service

方法：

- push (data) 激活一次推送，发送携带推送数据的DataNotification APDU
- reset (data) 重置为初始状态

### s4.4.9 COSEM data protection (class_id = 30, version = 0)

该 IC 的实例允许对`COSEM 数据`，即`属性值`、`方法`调用和`返回参数`应用`加密保护`。这是通过本接口类的实例间接访问(访问可以指读/写/捕获/推送以及对 method 的调用等)其他 COSEM 对象的属性和/或方法来实现的，本接口类提供必要的机制和参数来应用/验证/移除对COSEM数据的保护。

保护可包括认证、加密和数字签名的任何组合，并可以分层方式应用。应用和移除保护的双方是 DLMS 服务器和另一方（可以是 DLMS 客户端或第三方）。在 DLMS 服务器和第三方之间应用数据保护，可以对用于中继的客户端(第三方->客户端->服务器)保持关键/敏感数据的机密性。由第三方签名的 COSEM 数据可支持不可抵赖性(non-repudiation，该消息由私钥持有者签名，其不可否认，同时也保证未被其他人篡改)。

`保护参数`总是由`客户端`控制，一些元素由服务器适当地填充。`安全套件`由“`Security setup`”对象决定，该对象来自当前的“Association SN”/“Association LN”对象。

![dataprotection](/assets/img/2022-03-17-dlms-blue2/dataprotection.jpg)

可能的使用场景：

- 当 protection_buffer 属性被读取/捕获(Profile对象)/推送时：
  1. protection_object_list 内定义的内容被捕获(暂存在内存中)
  2. 根据 protection_parameters_get 属性描述的保护方式对上一步的内容进行保护，然后写入 protection_buffer 内。
  3. 将 protection_buffer 内的内容返回给需要的源(get调用者/profile对象/push setup对象)
  ![dataprotection2](/assets/img/2022-03-17-dlms-blue2/dataprotection2.jpg)
  图中应用了两层保护，加密和数字签名。
- 当 protection_buffer 被写入时：
  1. 此时 protection_buffer 内的数据应该是被保护后的数据
  2. 根据 protection_parameters_set 属性描述的保护方式解除保护，然后将结果(结果应该在内存里)写入 protection_object_list 描述的位置。
- 当 get_protected_attributes 方法被调用时：
  1. 参数 get_protected_attributes_request 内的 object_list 内描述的属性被捕获
  2. 参数 get_protected_attributes_request 内的 protection_parameters 描述的保护方式被应用到上一步捕获到的内容中(TODO: 原文写的是 response 的 protection_parameters，应该是错误的)。注意如果 protection_parameters 和本对象的 required_protection 属性描述不一致，本方法将调用失败。
  3. 返回被保护后的内容(注意整个过程都没有用到 protection_buffer)
- 当 set_protected_attributes 方法被调用时：
  1. 参数 set_protected_attributes_request 中的 protected_attributes 所添加的保护将通过使用 protection_parameters 被验证并移除。注意也必须和本对象的 required_protection 属性描述一致，否则调用将失败。
  2. 将上一步内容写入 object_list 描述的对象中。
- 当 invoke_protected_method 被调用时：
  1. 根据该方法的请求参数中的 protection_parameters 验证并移除要调用的方法的被保护的参数。注意也必须和本对象的 required_protection 属性描述一致，否则调用将失败。
  2. 请求参数中的 object_method 对应的方法将被调用，参数为上一步中解除保护后的参数。
  3. 根据 response protection parameters 保护返回值。注意也必须和本对象的 required_protection 属性描述一致，否则调用将失败。
  4. 将保护后的返回值返回。

属性：

- protection_buffer 包含`受保护的数据`。读取时，捕获由protection_object_list指定的属性，然后根据protection_parameters_get应用保护。写入时，受保护的数据被放入protection_buffer中，然后根据protection_parameters_set验证/删除保护，并设置由protection_object_list指定的属性。
- protection_object_list 定义在`读取`protection_buffer时要`捕获`的属性列表，或者在`写入`protection_buffer时要`设置`的属性列表。
  
  关于选择性访问的描述见Compact data
- protection_parameters_get 包含所有必要的`参数`，用于指定`读取`protection_buffer时应用的`保护`。这个属性首先由`客户端`写入。服务器可能需要填写一些额外的元素，在这种情况下，客户端必须读回这个属性——如果需要的话，转发给第三方——以便他们可以使用这些参数来验证/删除保护
- protection_parameters_set 包含所有`必要的参数`，用于在`写入`protection_buffer时`验证/删除`应用的保护。参数与get相同。此属性由客户端编写，并由服务器使用它来验证和删除保护。
- required_protection 规定了通过“Data protection”对象访问的`属性值/调用`和`方法的返回参数`所需的保护。

  对于request和response的保护方式

方法：

- get_protected_attributes (data) 获取 protection_object_list 元素指定的属性的值，并应用get_protected_attributes_response中根据protection_parameters设置的保护

  get_protected_attributes_response中的protection_parameters值是根据请求参数get_protected_attributes_request中的同名元素得到的，服务端可能会有修改，所以不只是拷贝，可能会有不同
- set_protected_attributes (data) 根据protection_parameters元素，在验证并移除protected_attributes元素上的保护之后，设置 protection_object_list 元素指定的属性值。
- invoke_protected_method (data) 以保护方式执行特定方法，方法的参数和返回值被保护。在根据invoke_protected_method_request中的protection_parameters验证并移除protected_method_invocation_parameters上的`保护后`，`调用`object_method元素`指定的方法`。

  在调用由 object_method 元素指定的方法后，根据 invoke_protected_method_response 中的 protection_parameters 的保护（必须满足 required_protection）应用于返回参数，并且由 protection_parameters 和 protected_method_return_parameters 组成的 invoke_protected_method_response 返回。
  
  ```asn.1
  invoke_protected_method_request ::= structure {
    object_method 要执行的方法
    protection_parameters: 保护参数
    object_method_definition： 被保护的参数
    }

  invoke_protected_method_response ::= structure {
    protection_parameters: 保护参数
    protected_method_return_parameters: 被保护的返回值（参数）
    }
  ```

注意：上面三个方法中的 protection_parameters 都必须满足 required_protection，否则视为调用失败。

### s4.4.10 Function control (class_id: 122, version: 0)

IC“Function control”的实例允许启用和禁用服务端中的`功能`（Function）。每个可以启用/禁用的功能都由一个名称标识，并由引用的一组特定对象标识符定义。

可以借助“Single action schedule”和“Script table”对象来实现按时间控制功能的禁用和启用

属性：

- activation_status 显示function_list属性中定义的每个功能块的`当前状态`(启用或禁用)
- function_list 定义一个`功能列表`，可以通过调用set_function_status方法启用或禁用这些功能。通过class_id和logical_name指定，当功能不能对应特定的COSEM对象时，class_id为0，logical_name为特定描述文本。

  这里的`功能`包含了若干个具体的`关联对象`，也就是是个抽象的概念，由不同的对象的合作实现的一个`功能`

方法：

- set_function_status (data) 启用或禁用一个或多个功能
- add_function (data) 添加一个新功能，必须是服务端支持的
- remove_function (data) 移除一个新功能

### s4.4.11 Array manager (class_id = 123, version = 0)

"Array manager"IC的实例允许管理`其他`接口对象的具有`数组类型`的`属性`：

- 检索条目的数量;
- 选择性地读取一定范围内的条目;
- 插入新条目或更新现有条目;
- 删除一个范围的条目

`每个`实例允许管理分配给它的数组类型的`几个`属性

TODO：该对象有权限访问修改其他对象的属性？

属性：

- array_object_list 定义可由该IC的实例管理的数组类型的属性列表

方法：

- retrieve_number_of_entries(data) 返回一个数组中已标识的条目`总数`

- retrieve_entries (data) 检索array_object_list数组中的一个数组项的`范围`数据。

  m表示记录总数，from_entry和to_entry表示数组序号，序号为1到m

  - from_entry < to_entry < m，返回from_entry 到 to_entry记录
  - from_entry < to_entry，to_entry > m，返回from_entry到m的记录
  - from_entry < to_entry，from_entry>m，返回元素个数为0的空数组
  - from_entry > to_entry，返回错误
- insert_entry (data) 向一个数组插入一条新记录,插入到参数id标识的序号之后，之后所有记录顺位后延，如果已满则插入失败。其中：
  - id为0表示插入后变为第一个，其他所有记录顺位后延
  - id大于m表示在末尾追加
- update_entry (data) 更新一个数组中的一条记录
- remove_entries (data) 按范围删除数组，同retrieve_entries

当已存在的记录的顺位变化时，比如 insert 和 remove 都会可能导致部分条目的序号的变化，所有按序号对它们的引用都必须更新(比如有些对象属性通过 data_index 引用了某条记录)。

### s4.4.12 Communication port protection (class_id = 124, version = 0)

`保护通信端口`，防止恶意通信，如暴力破解

属性：

- protection_mode `保护模式`，

  - 锁定
  - 失败尝试后锁定
  - 无锁定
- allowed_failed_attempts 触发锁定机制之前允许的失败通信`尝试次数`。
- initial_lockout_time 第一次触发锁定的`锁定时间`
- steepness_factor 锁定时间`递增步长`

  NCA=failed_attempts-allowed_failed_attempts
  
  CLT=initial_lockout_time x (steepness_factor^(NCA-1))

- max_lockout_time `最大锁定时间`,避免拒绝服务攻击(DDoS)
- port_reference 被保护端口对象的逻辑名
- protection_status 当前保护状态，未锁定、临时锁定、已锁定
- failed_attempts 失败总数，与保护机制触发无关，会被reset重置
- cumulative_failed_attempts `失败总数`，与保护机制触发无关，不会被重置

方法：

- reset (data) 重置failed_attempts、current lockout time、protection_status

## s4.5 时间和事件绑定控件的接口类Interface classes for time- and event bound control

### s4.5.1 Clock (class_id = 8, version = 0)

该IC为设备时钟建模，管理所有与`日期和时间`相关的信息，包括由于时区和`夏令时`方案而导致的本地时间与通用时间参考(UTC)的偏差。IC还提供了各种调整时钟的方法

日期信息包括`“年”、“月”、“日”、“周”`。时间信息包括`小时、分钟、秒、百分之一秒`以及本地时间与UTC的`偏差`。夏令时功能根据属性修改本地时间与UTC的偏差;参见图20所示。该函数的起始点和结束点通常设置一次。内部算法根据这些设置计算出真正的开关点

属性：

- time 包含仪表的本地日期和时间、与UTC的偏差(时区？)、状态。格式为date-time。可只修改部分字段，如只修改date相关字节。
  如果只修改date，此时参数中保存time的字节需标记为"not specified"。比如 0x07DE081302FFFFFFFF 中表示 time 的后四个字节为 0xFF(not specified)，这段数据写入本属性时就不会修改原来的 time 部分。
- time_zone 时区
- status 状态
- daylight_savings_begin 夏令时开始日期时间
- daylight_savings_end 夏令时结束日期时间
- daylight_savings_deviation 夏令时偏移（分钟）
- daylight_savings_enabled 夏令时功能是否启用（注意是该功能是否启用，不是表示是否处于夏令时）
- clock_base 时钟信息依据
  - 无
  - 内部晶振
  - 市电频率50Hz
  - 市电频率60Hz
  - GPS
  - 无线电控制

方法：

- adjust_to_quarter (data) 将时间调整为最近(+/-)的整刻钟(\*:00,\*:15,\*:30,\*:45)
- adjust_to_measuring_period (data) 将时间调整为最近(+/-)`测量周期`的起点
- adjust_to_minute (data) 将时间调整为最近(+/-)整分钟
- adjust_to_preset_time (data) 和preset_adjusting_time配合，激活preset_time，执行时的时间必须是时间范围内的
- preset_adjusting_time (data) 定义一个预设时间preset_time和一个允许执行生效时间范围
- shift_time (data) 将时间移动 n (-900 <= n <= 900) 秒。n为long类型

### s4.5.2 Script table (class_id = 9, version = 0)

通过脚本执行一系列动作

脚本可由同一个逻辑设备内其他COSEM对象或从外部激活

同时执行时索引小的优先执行

属性：

- scripts 脚本，操作列表，是一个数组
  - action_specification指向引用对象的动作（限制为`不产生响应`的动作）
    - service_id，表示执行的动作的类型，目前有两种：
      - 写属性
      - 执行方法（仅限无需响应的方法，也就是服务端方法，这类方法都是被客户端调用，而不是主动发起，TODO:有需要响应的方法吗？）

方法：

- execute (data) 执行对应的脚本，参数为 script_identifier

### s4.5.3 Schedule (class_id = 10, version = 0)

计划时间表，可以配合 Special days 和 Script table 对象，实现日期驱动的定时任务执行，类似于 Linux 中的 crontab

属性：

- entries 给定时间执行的脚本
  - schedule_table_entry
    - index:本条目的索引
    - enable:本条目是否启用
    - script_logical_name `Script table`对象的逻辑名
    - script_selector 选择`Script table`对象中的script_identifier，表示要执行的脚本
    - switch_time 执行时间，支持通配符，time格式，不含 date 信息
    - Validity_window 有效窗口（执行宽容时间），一个以分钟为单位的`时间段`，用于执行时间在掉电期间无法执行时，允许的延后执行时间，如果在这个时间内上电，就依然允许执行。(**触发时间switch_time到达后在这个时间范围内必须执行，如果未及时上电导致执行不了，则不执行**)。0xFFFF:无限宽容时间，脚本无论被延后多长时间，都必须被处理;
    - exec_weekdays 定义每周中哪些天有效（比如仅定义周四有效，脚本就只能在周四执行）
    - exec_specdays 见节日表“Special days table”, day_id
    - Begin_date和end_date 定义了条目有效的日期范围(允许通配符)

方法：

- enable/disable (data) 参数有A和B两个范围，A范围内的条目禁用，B范围内的启用
- insert (data) 插入一条新记录，已存在时覆盖
- delete (data) 按索引范围删除记录

相同的脚本同时执行时，规则为仅执行其中一条。

时间调整处理：

- Time setting `forward`：向后调整时间，调整至更晚的时间，此时操作和掉电相同，根据Validity_window补执行
- Time setting `backward`：向前调整时间，调整至更早时间，会出现重复执行的情况
- Time synchronization：时间校准操作是对时间的一种自动微调（向前或向后调整一个很短的时间），它因保证所有应该执行一次的脚本都仅执行一次，不会出现遗漏或重复执行。和上面两种情况相比更加严格。
- 夏令时向后调整时间则执行所有因此错过的脚本(无视 switch_time)，向前则不执行重复的脚本

### s4.5.4 Special days table (class_id = 11, version = 0)

定义特殊日期，特殊日期行为会覆盖通常的，与“Schedule" 或 "Activity calendar"(通常日历表) 同时执行

为给定日期指定特殊的日期标识符。日期可能具有重复特殊日子的通配符，如圣诞节(圣诞节每年都有，所以年份就是通配符)。

属性：

- entries 数组，每个条目表示一个特殊日期，如圣诞节
  - spec_day_entry
    - index 条目序号
    - specialday_date 节日的日期
    - day_id 标识节日（比如有的节日每年的时间不同，又不能用通配符表示，就会出现多条spec_day_entry的day_id相同的情况，每年都有一条），用来和 Schedule 类的 exec_specdays 关联。

方法：

insert (data) 向entires插入一条记录，index 和 specialday_date 都是唯一键，任意一个重复都会覆盖
delete (data) 删除一条，用 index 索引

### s4.5.5 Activity calendar (class_id = 20, version = 0)

按计划执行脚本，遵循日历时间表方式，（和费率相关？）TODO：和Schedule的区别

可与`Schedule`对象`共存`，重叠时`Schedule`对象`优先执行`。上电时，和 Schedule 操作不太一样，仅执行错过的最后一个动作(Schedule的话只要在窗口时间内全部都要恢复执行)，同时本次执行时要和 Schedule 的执行序列配合（按期望触发时间排序）。

被Special days table覆盖

属性：

- calendar_name_active 标识符，表示当前日历表方案的名称，*_active* 后缀表示当前启用的方案。
- season_profile_active 季节方案，包含季节开始时间和对应的 week 方案（week_name 选择 week_profile_table 数组中的条目）
- week_profile_table_active 周方案，包括一周中每天(星期一到星期七)的方案（day_id 选择 day_profile_table 数组中的条目）
- day_profile_table_active 日方案，包含一天内所有脚本的执行时间、Script table 对象内脚本的引用
- calendar_name_passive 备用方案，*_passive* 后缀表示备用的方案。
- season_profile_passive 备用方案
- week_profile_table_passive 备用方案
- day_profile_table_passive 备用方案
- activate_passive_calendar_time 调用activate_passive_calendar的时间

TODO:一个季节只能启用一个周表？是不是意味着一个季节内，每周的动作都是相同的。

方法：

- activate_passive_calendar (data) `激活备用方案`，将passive属性复制到active中

### s4.5.6 Register monitor (class_id = 21, version = 0)

这个IC允许对 “Data” , “Register”, “Extended register” or “Demand register”对象的值进行建模`监控`。

它允许指定阈值、被监测的值和一组脚本，当监测的值超过阈值时，这些脚本将被执行。

依赖于同一逻辑设备内的 Script table 对象

属性：

- thresholds 提供将引用寄存器的属性与之比较的`阈值`。
- monitored_value 定义监视对象的哪个`属性`。只允许具有`简单数据类型`的值
- actions 定义被引用对象的监视属性`超过`或`低于`相应`阈值`时要执行的`脚本`。属性操作具有与 thresholds 属性完全`相同`的`元素数量`。action_items的顺序与阈值的`顺序对应`

### s4.5.7 Single action schedule (class_id = 22, version = 0)

执行周期性的单个定时任务。和schedule的区别是一个对象仅对应一个脚本，可能的用途应该是临时添加一个定时任务，就不用去修改 schedule 对象了。

- executed_script Script table对象的引用
- type execution_time 的类型。定义时间是否相同，是否允许通配符
- execution_time 脚本执行日期和时间

### s4.5.8 Disconnect control (class_id = 70, version = 1)

拉合闸控制，管理电表的内部或外部`断开装置`（例如继电器、燃气阀门），以便部分或全部地连接或断开用户的电源。

三种控制方式：

  1. `远程`Remotely，通过通信端口
  2. `手动`Manually，如按按钮
  3. `本地`Locally，电表内部功能触发，如limiter对象

属性：

- output_state 设备supply(供给开关)实际的物理连接状态：Connected 和 Disconnected
- control_state 内部控制连接状态
  - (0) Disconnected
  - (1) Connected
  - (2) Ready_for_reconnection

- control_mode 控制模式，每一条对应3种控制方式的控制权限

方法：

- remote_disconnect (data) `远程断开连接`，需要有权限
- remote_reconnect (data) `远程恢复连接`，需要有权限

### s4.5.9 Limiter (class_id = 71, version = 0)

限制器，当“Data”, “Register”, “Extended Register”,“Demand Register”对象超过阈值一定时间时执行动作

TODO:和4.5.6 Register monitor的区别，应该是比后者更加详细，这个是超过一定时间加上更多种阈值。

阈值包括`正常阈值`和`紧急阈值`。`紧急阈值`通过emergency profile id, emergency activation time, and emergency duration定义的`emergency_profile`激活。emergency profile id元素与emergency profile group id匹配:这种机制只允许针对特定的emergency group激活紧急阈值。

- monitored_value 定义`要监控`的对象的`属性`。只允许具有`简单数据类型`的属性。
- threshold_active 当前使用的活动阈值（可能是正常阈值或紧急阈值）
- threshold_normal 正常阈值，和被监控的属性的类型相同
- threshold_emergency 紧急阈值
- min_over_threshold_duration 超过阈值最小持续时间，秒
- min_under_threshold_duration 低于阈值的最小持续时间
- emergency_profile 紧急配置,用于紧急阈值激活，当emergency_profile_id和emergency_profile_group_id_list中的匹配，且当前时间在从emergency_activation_time开始emergency_duration范围内时激活
- emergency_profile_group_id_list emergency_profile_id列表
- emergency_profile_active emergency_profile激活状态
- actions 超过或低于阈值超过最小持续时间时的`动作(script)`

### s4.5.10 Parameter monitor (class_id = 65, version = 1)

本 IC 用于监控参数修改（某些COSEM对象的属性用于表示配置参数）

每个可以访问服务器的客户端都必须知道当前的参数设置，以便能够正确地与服务器交换数据。参数可以分组，每个组可以有一个名称。

尽管最初的参数可能是已知的，但在电表的生命周期内可能会`发生变化`，例如它可能`被另一个客户端`（如现场服务设备）改变。

当前的配置可能总是通过在交换开始时`读取所有需要的配置参数`来检索，这并`不高效`。也可以通过推送操作，但这也不是一个好的方式。

需要一个解决方案，允许客户验证服务器的配置是否符合预期，或`检测是否发生了任何变化`: 客户端配置服务器时，可以检索本类这些属性并与其他客户端共享。当客户端开始与服务器进行数据交换时，它可以读取 parameter_value_digest 属性，并将其与自己存储的值进行比较。如果两者匹配，则说明配置符合预期；如果不匹配，客户端可以读取 parameter_values 属性，以确定哪个属性发生了变化。这些属性(parameter_values)也可以捕获到 Profile generic 对象缓冲区属性中，以确保捕获数据的有效性。使用**空数据编码**可最大限度地减少由此产生的开销

属性：

- changed_parameter 保存最近更新的参数及其值（一个属性和一个值）
- capture_time 捕获时间，记录何时捕获
- parameter_list 本对象管理的参数列表
- parameter_list_name 参数列表名
- hash_algorithm_id 摘要算法
- parameter_value_digest 参数`值`摘要（整个parameter_list内属性的值需要先`转octet-string`（如果不是octet-string），使用 Green Book Data conversion一节方法）。可能的方式：本hash通过parameter_values参数计算
- parameter_values parameter_list内属性的值,一个结构体，包含A-XDR编码的每个属性值

方法：

- add_parameter (data) 向parameter_list添加一个
- delete_parameter (data) 从parameter_list删除一个

### s4.5.11 Sensor manager (class_id = 67, version = 0)

传感器和测量值监控（除了电表之外的其他计量设备用得比较多）

- 传感器装置的识别
- 传感器的连接和密封状态
- 传感器的配置
- 监测传感器的运行情况
- 对处理后的结果的监控

本 IC 的实例管理与传感器相关的复杂信息。它们还可以监控原始数据和处理后的值，这些值是根据特定应用的要求使用适当算法处理原始数据后得出的。该集成电路具有以下功能:

- 传感器的铭牌数据（传感器上铭牌所列出的数据和信息。这些通常包括制造商、型号、序列号、工作范围、额定电压、电流等技术规格和识别信息）和现场信息（这是指传感器所在位置的相关信息。这可能包括地理位置、安装环境、使用条件、设备配置等。）（属性 2 至 6）；
- 对于原始值(直接采样值)的"Extened register"中的功能（属性 7 至 10）；
- 对于原始值(直接采样值)的"Register monitor"中的功能（属性 11 至 12）；
  > 注 1 并非每个原始数据（如压力传感器的电压输出）都有自己的 OBIS 代码/对象。这就是在传感器管理器类中包含原始数据的原因。
- 对于处理值(原始值处理后的值)的"Register monitor"中的功能（属性 13 至 15）

属性：

- serial_number 序列号，标识传感器设备
- metrological_identification 描述传感器的计量相关信息，如计量标识符、校准日期。
- output_type 输出类型
- adjustment_method 调整方法
- sealing_method 密封（保护）方式
  - 物理方式（铅封、密封贴纸等）
  - 电气方式（电子检测装置，比如开盖检测用的按钮）
  - 软件方式（密码）
- raw_value 原始记录值
- scaler_unit 原始记录值的单位
- status 状态（失败/启用/禁用）
- capture_time raw_value捕获时间
- raw_value_thresholds raw_value阈值
- raw_value_actions 超过阈值执行的脚本，参考Register monitor类
- processed_value raw_value处理后的值
- processed_value_thresholds processed_value阈值
- processed_value_actions 超过阈值执行的脚本(如告警位置位)

方法：

- reset (data) 重置raw_value

### s4.5.12 Arbitrator (class_id = 68, version = 0)

仲裁者，允许根据由`权限`和`权重`组成的预先配置的规则，在`多个参与者`可能请求可能`相互冲突`的操作来控制`同一资源`时，执行特定`操作`。

- `配置`可能被请求的、潜在冲突的`动作`;
- `配置`每个参与者请求可能操作的`权限`;
- 为每个可能的请求`配置`每个参与者的`权重`。

`资源`的`例子`是`供应(supply)控制开关`或仪表的`气体阀门`。可能的`动作`包括`断开电源`、`使能重新连接`、重新连接电源、防止断开连接、防止重新连接。

每个需要处理**竞争**操作请求的资源都应该有一个 "Arbitrator" 对象实例。

TODO: actor到底是什么，是客户端吗？

属性：

- actions 动作，是个数组，一个元素是对`script table`对象的某一个条的引用
- permissions_table 每个参与者`权限`，数组每个元素对应每个用户的权限，用户的权限是个位串，其中的位串中每一位对应每个动作权限（与actions对应）
- weightings_table 每个参与者`权重`，和permissions_table结构顺序一样，不过把`位串换成了数组`，元素是long-unsigned（最好使用2的幂作为权重值，而且要保证对于同一个action没有多个用户的权重是相同的，不然两个用户同时触发执行时就不知道该谁执行了(此时按规定大家都不执行)）
- most_recent_requests_table 记录每个用户的最近请求，与permissions_table结构相同，位串中已执行的置位，不一定只有一个(应该是一次request_action时同时触发两个以上动作)。位的清除在下一次的request_action发生
- last_outcome 最近一次请求结果，标识actions中的元素的序号，只针对actions，不针对用户。这意味着一次 request_action 只能执行一个 action

方法：

- request_action (data) `封装动作执行请求`，request_actor表示请求用户(上述数组的序号，1表示第一个用户)，request_action_list表示请求动作列表，一次可请求多个，但最终一次请求只能有一个 action(最高权重) 执行。

  TODO: 为什么可以一次请求多个操作

- reset (data) 重置位（权限位，权重元素，最近执行位，最近请求结果）

  当权限位都是0时，request_action调用总是不会成功，因为都没权限

当`request_action`方法被`actor`调用时，`AP`执行以下活动:

  1. 它检查给定actor的`permissions_table`属性条目，以确定请求的动作`是否允许`;
  2. 它`更新most_recent_requests_table`属性，通过`设置或清除`该actor的每个动作的位串中被允许的`位`(位设置);或者没有请求/不允许(位被清除);*相当于request_action请求参数和permissions_table的交集，有请求且允许才置位*
  3. 它为most_recent_requests_table应用`weightings_table`:对于most_recent_requests_table中设置的每个位，每个actor的相应权重被应用;
  4. 对于每个 action，各个用户的权重相加。
  5. 如果某个动作拥有一个`唯一`的`最高权重值`，这个值会被写入`last_outcome`属性并执行相应的脚本。如果没有最高的`唯一`权重，那么`什么也不会发生`（最高权重不唯一，就全部不执行）。

## s4.6 支付计量相关接口类Payment metering related interface classes

### s4.6.2 Account (class_id = 111, version = 0)

用于计费，每个Account可以关联数个“Credit”,“Charge” and the “Token gateway”对象

比如入口消耗电网的电用一个账户Account，家里有发电出口给电网是第二个账户Account，单独计费

`Credit`: `信用额度`，比如一个对象用来做token额度，一个用于紧急额度

`Charge`：`费用统计`，比如一个用于能源使用，一个用于固定收费（月费），一个用于安装费用。

统计方式：

1. 基于能量消耗量和费率的
2. 基于时间的，如月固定费用
3. 手续费，每次充值时收取

属性：

- account_mode_and_status `付费模式`（`后付费`credit和`预付费`prepayment）和账户状态（未激活、已激活、已关闭），只有账户状态为已激活时，关联的 credit 和 charge 对象才会运行。
- current_credit_in_use 正在使用（`In use`）的`credit对象`的`引用`
- current_credit_status 正在使用的`credit对象状态`
- available_credit `总可用额度`，本对象的 credit_reference_list 属性关联的且状态为可用的 Credit 对象(属性credit_status为Selected/Invoked(2)或In use(3))中属性`current_credit_amount`(可用额度)的总和（只计算`正值`）
- amount_to_clear 和available_credit类似，是负值的总和

  - Credit对象中的所有`current_credit_amount负值`（credit_status = (4) Exhausted且credit_configuration bit 2(标志 credit 是否需要偿还)未置位）
  - Credit对象中的credit_configuration bit 2置位（credit 需要偿还）的`额度的差值`(preset_credit_amount和current_credit_amount的差值)的负值（value * -1）
  - `clearance_threshold`的负值（value * -1）
- clearance_threshold amount_to_clear的阈值
- aggregated_debt `合计欠款`，Charge对象的`total_amount_remaining`的简单合计
- credit_reference_list credit对象关联列表
- charge_reference_list charge对象关联列表
- credit_charge_configuration 这个属性映射出哪些`Charge`将`从哪些Credits`中收取。

  无条目表示无限制

  Credit必须搭配一个或多个Charge采集使用，否则不会被消耗

  包含credit和charge对象的引用

  collection_configuration 规定了特殊情况下的行为：

  - Bit 0 允许电源断开时采集
  - Bit 1 允许在负载限制期间采集
  - Bit 2 允许在友好信用期内采集
- token_gateway_configuration 此属性用于配置如何`分配`来自“`token_gateway`”的新的`充值token`，以便将token数量的`可配置百分比`分配给每个“Credit”对象。
- account_activation_time 调用activate_account的时间
- account_closure_time 调用close_account的时间
- currency 本对象的所有方法使用的单位，可以为货币单位、时间、计量单位等
- low_credit_threshold `低额度阈值`，引用credit的warning_threshold属性，可以用于低额度时告警
- next_credit_available_threshold `下一个优先级`(如果是优先级顺序)credit对象的available_credit阈值 TODO：等Credit看完
- max_provision 最大规定，当Charge为(2) payment_event_based_collection TODO：什么意思
- max_provision_period 最大规定周期

方法：

- activate_account (data) 激活账户，本对象的account_mode_and_status和account_activation_time修改
- close_account (data) 本对象的account_mode_and_status和account_closure_time修改
- reset_account (data) account_status为close状态下重置所有属性,为1或2时不操作

### s4.6.3 Credit (class_id = 112, version = 0)

可用额度，激活时用于抵扣Charge

属性：

- current_credit_amount 本对象当前可用额度
- credit_type 类型
  - (0) token_credit `预付费`方式`充值的余额`，一般是`token`方式
  - (1) reserved_credit `特定情况`可使用的信用额度
  - (2) emergency_credit `紧急额度`，紧急额度使用后在下次重置的时候抵扣补充
  - (3) time_based_credit `按照时间`产生的额度
  - (4) consumption_based_credit `预定义`信用额度
- priority `激活优先级`，1为最高，255最低，1-255不允许重复，0表示永不激活，可重复。优先级为0的不会出现在Account对象的credit_reference_list中
- warning_threshold `警告阈值`，监控current_credit_amount，与Account对象中的low_credit_theshold关联
- limit `耗尽阈值`，当`current_credit_amount`小于阈值时credit_status变为耗尽`Exhausted`
- credit_configuration 配置本对象行为
  - Bit0 需要`视觉指示`(如液晶屏)
  - Bit1 在credit_status切换到Selected/Invoked之前`需要确认`（如按键）
  - Bit2 `需要偿还`的信用额度
  - Bit3 `可重置`
  - Bit4 能够从`token`接收信用额度
- credit_status 预付费应用使用，指示状态
  - Enable: `启用`，但还不能使用，会在credit_reference_list中
  - Selectable: `可选择的`，需要其他`命令`才能`激活`，还不能使用
  - Selected/Invoked：`已选择`，`已激活`，处于排队状态
  - In use：`正在使用中`
  - Exhausted：额度已`耗尽`
  ![creditstate](/assets/img/2022-03-17-dlms-blue2/creditstate.jpg)
- preset_credit_amount `初始额度`

  会`累加`到`current_credit_amount`属性的情况：

  - credit_status转换为(2)`Selected/Invoked`，且credit_configuration `bit 1`(切换需确认)置位，且被`确认`
  - credit_status从不为(4)`Exhausted`状态转换为(3)`In use`，且credit_configuration `bit 1`置位未置位
  - 当调用`invoke_credit`方法时，且credit_configuration `bit 2`置位
  - `period` 里date_time发生时，这是隐式的

  如果`不需要`初始额度就设置为0，这种情况下可以通过`token充值`或`调用方法`方式增加`current_credit_amount`
  
  如果credit_type是`emergency_credit`：

  - 该值preset_credit_amount需要被使用
  - 只在以下情况可用token充值

    - status为(3) `In use` or (4) `Exhausted`
    - 且部分或全部额度`被使用`
    - 且credit_configuration `bit 2`(需要偿还)置位
  
  > 当`current_credit_amount`达到`limit`时，`credit_status`属性将变成`（4）Exhausted`。如果`credit_configuration bit 2`（需要偿还）被`设置`，那么实际已经使用了的信用额度是`preset_credit_amount`和`current_credit_amount`之间的`差值`（我们可以假设电表初始preset_credit_amount是10块钱,如果此时current_credit_amount是6块钱，说明已经使用了4块钱，需要还4块钱，意思应该就是保证金是10块钱，如果preset_credit_amount被设置为0块钱，说明没有保证金），通常是通过增加一个`token充值`或通过`调用一个方法`来偿还。在偿还所有欠款后，`current_credit_amount`将变`0`（下次激活前会在0的基础上加上preset_credit_amount），当amount_to_clear=0时`credit_status`将变`（0）Enabled`（还清了）;当amount_to_clear小于0时，`credit_status`将变`（4）Exhausted`(没还清)
- credit_available_threshold 与“Account”对象`available_credit`相关联的`阈值`。

  当“Account”对象的`available_credit`缩减到下一个优先级的Credit对象的credit_available_threshold时（此时该对象还是enable状态，不在credit_reference_list属性里，不计入available_credit），credit_status设置为：

  - Selectable (1) if the credit_configuration bit 1 (Requires confirmation) is set
  - Selected/Invoked (2) if the credit_configuration bit 1 (Requires confirmation) is cleared
- period 在`credit_type = 3` (time_based_credit)或`credit_type = 4` (consumption_based_credit)时，该属性`保存`将`current_credit_amount`自动设置为`preset_credit_amount`的`时间`。比如包月模式每月1号自动获得200元余额。

方法：

- update_amount (data) 调整`current_credit_amount`属性的值,`主要是正值`(充值)，负值也允许
- set_amount_to_value (data) 设置`current_credit_amount`属性的值，返回值为配置前的值
- invoke_credit (data) 将“Credit”对象的credit_status改为(2)Selected/Invoked或(1) Selectable（取决于credit_configuration bit 1）

### s4.6.4 Charge (class_id = 113, version = 0)

- total_amount_paid 本对象`总金额`，一般不重置
- charge_type 收费类型

  - (0) consumption_based_collection `按量计费`
  - (1) time_based_collection `时间计费`
  - (2) payment_event_based_collection `支付事件计费`（`手续费`，比如用新的token充值需要手续费）
- priority 优先级和Credit类相同,大于0的必须出现在“Account”对象charge_reference_list中
- unit_charge_active 根据相关的“`Account`”实例的`货币`属性，以及相关的由`commodities _reference`结构标识的对象的`scaler_unit`属性，定义`有效价格`，即每`消耗量`、每`时间`或每`收到的付款`所收取的金额。

  - charge_per_unit_scaling_type `每单位收费缩放`，包含消耗量单位缩放（`10的指数`，如10^3kWh为一单位），`单位价格缩放`（关联Account中的currency_scale属性中currency元素，10的指数）
  - commodity_reference_type `消耗量依据`，只在charge_type = (0) consumption_based_collection时生效，标识一个Register对象的scaler_unit（量纲）属性的引用，如电量
  - charge_table charge_per_unit是基于charge_per_unit_scaling_type的缩放生成的`每单位价格值`，index表示在按量计费模式下不同的**费率模式**，其他模式为0
- unit_charge_passive unit_charge的`备用方案`，和unit_charge_active结构相同，激活时拷贝到unit_charge_active中
- unit_charge_activation_time 调用`激活方法`的`时间`
- period 表示Charge`采集周期`，仅当charge_type = (0) consumption_based_collection 或 (1) time_based_collection
- charge_configuration 采集方式

  - bit 0: `比例方式`，用于charge_type = (2) payment_event_based_collection
  - bit 1: `不间断采集方式`，置位后total_amount_remaining为0时依旧采集，否则不采集
- last_collection_time `上次采集时间`
- last_collection_amount `上次收集金额`
- total_amount_remaining 总剩余金额 TODO:什么意思
- proportion 手续费`比例`，仅当charge_type = (2) payment_event_based_collection有效

方法：

- update_unit_charge (data) 更新 unit_charge_passive，TODO:为什么不直接SET该属性，而要通过方法。
- activate_passive_unit_charge (data) 启用备用方案 unit_charge_passive
- collect (data) charge_type 不为 (0) consumption_based_collection 时生效，采集在 unit_charge_active 定义的数据
- update_total_amount_remaining (data) 更新 total_amount_remaining
- set_total_amount_remaining (data) 设置 total_amount_remaining

### s4.6.5 Token gateway (class_id = 115, version = 0)

属性：

- token 包含最近接收或标记的未处理 octet string，以便在历史 profile 中捕获
- token_time 最近接收和处理token的时间
- token_description 最近接收和处理的token的描述
- token_delivery_method 最近接收的token的接收方式

  - 远程通信
  - 本地通信
  - 手动输入
- token_status token状态（接收，处理，校验，认证）

方法：

- enter (data) 以octet-string格式传入token

另外有两个 Data 类型的对象表示相关的参数，另见 6.2.17 Payment metering related objects：

- Max credit limit: 达到可用额度上限，不能充值token
- Max vend limit: 达到单次充值上限，不能充值token

### s4.6.6 IEC 62055-41 Attributes (class_id = 116, version =0)

`IEC 62055-41`数据元素的选择，这些元素是管理在DLMS服务器中实现的`STS`功能所必需的。

- meter_pan MeterPrimaryAccountNumber
- commodity 计量用途名称，“ELECTRICITY”, “WATER”, “GAS”, or “TIME”
- token_carrier_types
- encryption_algorithm
- supply_group_code
- tariff_index
- key_revision_number
- key_type
- key_expiry_number
- no_of_kct_supported
- sts_certificate_no

## s4.7 通过本地端口和调制解调器建立数据交换的接口类Interface classes for setting up data exchange via local ports and modems

### s4.7.1 IEC local port setup (class_id = 19, version = 1)

- default_mode 定义端口上仪表使用的协议

  - IEC 62056-21:2002 (modes A…E)
  - IEC 62056-46:2002/AMD1:2006
  - 协议未指定
- default_baud 起始波特率
- prop_baud 建议波特率
- response_time 接收到请求到发送回复的最小时间
- device_addr IEC 62056-21:2002定义
- pass_p1 IEC 62056-21:2002定义
- pass_p2 IEC 62056-21:2002定义
- pass_w5 IEC 62056-21:2002定义

### s4.7.2 IEC HDLC setup (class_id = 23, version = 1)

- comm_speed 对应端口支持的通信速度

  (0) 300 baud, (1) 600 baud, (2) 1 200 baud, (3) 2 400 baud, (4) 4 800 baud, (5) 9 600 baud, (6) 19 200 baud, (7) 38 400 baud, (8) 57 600 baud, (9) 115 200 baud
- window_size_transmit 发送窗口大小
- window_size_receive 接收窗口大小
- max_info_field_length_transmit 最大发送长度
- max_info_field_length_receive 最大接受长度
- inter_octet_time_out 接收超时，超时未接收到新字符时视为完整报文
- inactivity_time_out 超时断开
- device_address 物理设备地址

### s4.7.3 IEC twisted pair (1) setup (class_id = 24, version = 1)

允许通过IEC 62056-3-1:2021中规定的带有载波信号的中`绞线对`建立数据交换。可配置多个通信通道

### s4.7.4 Modem configuration (class_id = 27, version = 1)

和模块间的数据传输配置

- comm_speed 通信速度，波特率
- initialization_string 初始化命令
- modem_profile 海斯命令集（Hayes standard commands，AT命令）映射

### s4.7.5 Auto answer (class_id = 28, version = 2)

自动接听

- mode 自动接听工作模式

  - (0) 设备专用线路
  - (1) 共享线路管理，允许有限数量的呼叫。一旦达到了`调用的数量`，窗口状态就变成不活动，直到下一个开始日期，无论调用的结果是什么
  - (2) 共享线路管理，允许有限数量的成功呼叫。一旦达到了`成功通信的数量`，窗口状态就会变得不活动，直到下一个开始日期
  - (3) 目前没有连接调制解调器
  - (200…255) 制造商特定的模式
- listening_window 定义`通信窗口`的`活跃`(start_time)和`不活跃`(end_time)的时间点。start_time隐式地定义周期。
  
  允许not specified（0xFF）表示每月每日重复
- status 通信窗口状态

  - (0)未激活:设备将不会管理新的来电。当下一次监听窗口启动时，该状态将自动重置为Active
  - (1)主动:设备可以接听下一个来电
  - (2)锁定:该值可以由设备或特定的客户端自动设置，当该客户端完成其读取会话，并希望在窗口持续时间结束前将行返回给客户。当下一次监听窗口启动时，该状态将自动重置为Active
- number_of_calls mode为1或2时，最大呼叫数量
- number_of_rings TODO:ring是什么意思？环数？响声？
- list_of_allowed_callers 一个可选的主叫号码列表，包括呼叫和SMS短信

  - caller_id `号码`，允许通配符
  - call_type 定义了调用的`目的`，例如，它是一个标准的`CSD调用`还是一个`唤醒呼叫/唤醒消息`。

    - (0) = normal CSD call:modem只有在主叫号码与列表中的条目`匹配时`才`连接`。这是在测试所有其他属性的同时进行的，例如number_of_rings, listening_windows等

      `电路交换数据（CSD）`:属于2G技术,用于传输数据，类似GPRS，但更加老旧
    - (1) = wake-up request:来自`该主叫号码`的呼叫或消息将作为`唤醒请求`处理。唤醒请求将立即处理，而不考虑number_of_rings和listening_window等所有其他属性(除非主叫号码也出现在普通CSD调用列表中，请参见下面)。

      需要`为空`，否则不被是为`唤醒请求`

      如果`不为空`，且包含预连接AA客户端的可用xDLMS APDU消息,则视为`xDLMS服务消息`而非唤醒请求，否则不做任何反应

      TODO：需要补充

### s4.7.6 Auto connect (class_id = 29, version = 2)

自动连接，自动拨号、发送消息等

属性：

- mode 自动连接模式，根据时间、消息类型和要使用的基础设施来控制自动连接功能。
- repetitions 连接失败最大尝试次数
- repetition_delay 重试间隔，秒
- calling_window 活动窗口，在窗口时间内允许自动连接，看mode的配置
- destination_list 包含在特定条件下必须发送消息的目的地列表(例如电话号码、电子邮件地址或它们的组合)。这里没有定义数组元素的条件及其链接

方法：

- connect (data) 根据mode属性定义的规则向通信网络发起连接进程。

### s4.7.7 GPRS modem setup (class_id = 45, version = 0)

GPRS参数

- APN APN名称
- PIN_code 个人识别码（personal identification number）
- quality_of_service 指定服务质量参数（QoS）。它是一个由两个元素组成的结构:

  - 默认值
  - 请求值

### s4.7.8 GSM diagnostic (class_id: 47, version: 2)

“GSM diagnostic”类的一个实例存储了分析网络运行所必需的GSM/GPRS、UMTS、CDMA或LTE`网络参数`。

蜂窝网络在`注册状态`、`信号质量`等方面都在不断变化。监控和记录相关参数是必要的，以便获得诊断信息，以便识别网络中的通信问题。

可用“Profile generic”捕获

- operator 运营商名称
- status modem注册状态
- cs_attachment 当前电路切换（CS,Circuit Switch）状态，见[电路交换](https://baike.baidu.com/item/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2)
- ps_status 报文分组交换技术(PS,packet switch)状态，见[报文分组交换](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/1227042)
- cell_info 蜂窝网络状态
- adjacent_cells 临近节点状态
- capture_time 最近被捕获的时间

### s4.7.9 LTE monitoring (class_id: 151, version = 1)

允许通过处理所有必要的数据来`监控`LTE调制解调器

- LTE_network_parameters 网络参数
- LTE_quality_of_service 服务质量

## s4.8 通过M-Bus建立数据交换的接口类Interface classes for setting up data exchange via M-Bus

### s4.8.2 M-Bus slave port setup (class_id = 25, version = 0)

M-Bus`从设备`端口设置

- default_baud 起始波特率
- avail_baud 协商波特率
- addr_state 设备是否分配了地址
- bus_address 总线上当前为设备分配的地址

### s4.8.3 M-Bus client (class_id = 72, version = 2)

每个“M-Bus client”对象`控制`一个M-Bus`从设备`。

方法可以实现M-Bus从设备的`安装和卸载`

本对象可以向**从设备**采集数据，也可以发送数据（配置，动作，传密钥等）

属性：

- mbus_port_reference “`M-Bus master port setup`”对象`引用`，每个接口允许与一个或多个M-Bus从设备交换数据。
- capture_definition 捕获定义，TODO:需要看引用文档
- capture_period `捕获周期`

  - \>=1: 自动捕获，秒
  - 0：不自动捕获，需手动触发
- primary_address M-Bus从设备的主地址（primary address），范围是0-250

  有该值，表示可以立即通信，不允许还未准备就绪（安装）时写该值
- identification_number 标识号，第一次通信时写入
- manufacturer_id EN 137577:2018
- version EN 137577:2018
- device_type EN 137577:2018
- access_number EN 137577:2018
- status EN 137577:2018
- alarm EN 137577:2018
- configuration EN 137577:2018
- encryption_key_status `加密密钥状态`，设置、传输、使用
- configuration_extension EN 137577:2018
- invocation_status 携带未决（pending）M-Bus方法调用的`调用状态`。当invocation_status表示`(1)成功`时，结果携带在invocation_status的`return-data`中。如果没有返回数据可用，则return_data octet-string为空，即长度为0。当没有挂起的调用时，数组为空。

方法：

- slave_install (data) `安装`一个未配置的从设备（primary address 是 0）

  - 检查`M-Bus地址`0上是否有新设备
  - 没找到调用失败
  - 方法参数表示`primary address`，如果不带参数调用，则自动取未使用的`primary address`，分配并传输给从设备
- slave_deinstall (data) `卸载`从设备。此服务的主要目的是卸载M-Bus从设备，并让主设备为安装新设备做好准备。执行以下操作:

  - 从设备`M-Bus地址`设置为0
  - `销毁`之前传输的`密钥`，不影响默认密钥
  - encryption_key_status设为`(0): no encryption_key`
  - `primary address`设为0
  - 全部`属性`设置为`默认值`
- capture (data) 捕获，和capture_definition属性关联
- reset_alarm (data) 复位M-Bus从设备`告警状态`
- synchronize_clock (data) 同步从设备时钟
- data_send (data) 向从设备`发送数据`
- set_encryption_key (data) `设置`M-Bus`客户端`设备的加密`密钥`，**从设备**刚安装时客户端设备有个空密钥，且加密传输禁用，可以通过配置空密钥禁用加密传输
- transfer_key (data) `传输加密密钥`给从设备

  在加密传输启用前，`加密密钥`通过从设备`默认密钥`（密钥加密密钥，MK）`加密`，传输给从设备，本次传输通道`不加密`，之后才开始加密传输。之后可以重复调用该方法`更新`密钥，同样使用默认密钥加密密钥，但这次传输通道为`加密的`

  被卸载后，从设备内密钥销毁，但默认密钥不受影响，禁用加密传输
- transfer_security_information (data) 向M-Bus从设备传输`安全信息`(security_information)
- invocations_reset(data) 将M-Bus从设备的方法调用重置为初始状态

### s4.8.4 Wireless Mode Q channel (class_id = 73, version = 1)

使用模式Q接口进行通信的操作参数。参见*EN 13757-5:2015*。

### s4.8.5 M-Bus master port setup (class_id = 74, version = 0)

如果设备作为M-bus master，该IC的实例定义了使用*EN 13757-2*接口进行通信的操作参数。

### s4.8.6 DLMS server M-Bus port setup (class_id = 76, version = 0)

在M-Bus从设备托管的DLMS服务器中使用，使用DLMS/COSEM有线或无线M-Bus (wM-Bus)通信配置文件

- M-Bus_profile_selection 引用M-Bus通信端口设置对象,“M-Bus slave port setup” object (class_id = 25)或 “Wireless Mode Q channel” object (class_id = 73).
- M-Bus_port_communication_state M-Bus node通信状态

  - (0)无接入:仪表无接入窗口(单向仪表)，
  - (1)暂无接入:仪表一般支持双向接入，但本次传输后没有接入窗口(如为了保持占空比限制或`限制能耗`，暂无接入)，
  - (2)有限的访问:仪表仅在传输后提供一个短的访问窗口(如电池供电仪表)，
  - (3)无限接入:至少在下次传输(如市电供电设备)之前，仪表提供无限接入。
  - (4)此属性仅在wM-Bus中相关。

  TODO:node是什么意思？
- M-Bus_Data_Header_Type 报文头类型，派生自当前通信的CITL值。
- primary_address EN 137577:2018
- identification_number EN 137577:2018
- manufacturer_id EN 137577:2018
- version EN 137577:2018
- device_type EN 137577:2018
- max_pdu_size M-Bus低层pdu长度上限，对于长消息，可以使用`DLMS/COSEM应用层`提供的`块传输`或`传输层`提供的`分段传输`，也可以同时使用这两种机制。
- listening_window 此属性仅在wM-Bus中相关，定义点对点通信窗口活动(start_time)和不活动(end_time)的时间点。start_time隐式地定义周期

### s4.8.7 M-Bus diagnostic (class_id = 77, version = 0)

包含与M-Bus网络运行相关的信息，如当前`信号强度`、`通道标识符`、到M-Bus网络的`链路状态`以及与`帧交换`、`传输`和`帧接收``质量`相关的`计数器`。

- received-signal-strength 此属性仅与无线双向M-Bus（`wM-Bus,wireless M-Bus`）通信相关。

  当使用wM-Bus配置文件时，这个属性保存了接收到的最后一个wM-Bus帧的`信号强度值`，用`dBm`表示。
- channel_Id 此属性仅与wM-Bus通信相关。当使用wM-Bus配置文件时，此属性保存当前使用的`通道的标识`。缺省值为0。
- link_status 此属性仅与wM-Bus通信相关。当使用wM-Bus配置文件时，此属性保存到M-Bus网络的`链接`的`当前状态`

  - (0)缺省值(未接收到数据)
  - (1)链路正常运行
  - (2)链路暂时中断
- broadcast_frames_counter 持有`广播帧计数`器的值，时间戳为接收到的最后一帧，并由客户端标识符区分
- transmissions_counter 统计相关M-Bus端口`传输`的`帧数`。到达最大值归0。
- FCS_OK_frames_counter 以`正确的`校验和计算接收到的`帧数`。到达最大值归0。
- FCS_NOK_frames_counter 统计接收到的`校验和(checksum)错误`的`帧数`
- capture_time 保存属性received-signal-strength、link_status、transmissions_counter、FCS_OK_frames_counter或FCS_NOK_frames_counter的值`最近变化`的`时间戳`。

方法：

- reset (data) 清除所有计数器(counters)，received_signal_strength, link_status和capture_time

## s4.9 用于在Internet上建立数据交换的接口类Interface classes for setting up data exchange over the Internet

### s4.9.1 TCP-UDP setup (class_id = 41, version = 0)

允许对基于`TCP-UDP/IP`的通信配置文件的`TCP或UDP传输层`的设置建模

或基于`DLMS/COSEM CoAP`的`DLMS/COSEM CoAP传输层`的`UDP子层`的设置建模

在基于`TCP-UDP/IP`的通信配置文件中，承载`一个或多个`COSEM`客户端`应用程序进程的`物理设备`和承载`一个或多个`COSEM`服务器`ap的`物理设备`之间的`所有AAs`都依赖于`单个`TCP或UDP连接。TCP或UDP实体封装在基于COSEM TCP-UDP的传输层中。在物理设备中，每个`AP`(客户端AP或服务器逻辑设备)都绑定到一个`包装器端口(WPort)`

一个基于`COSEM TCP或UDP的传输层`可能能够支持一个`物理设备`和多个承载COSEM ap的`对等物理设备`之间的`多个`TCP或UDP连接。

一个`DLMS/COSEM CoAP传输层`可以支持`多个UDP连接`，用于一个`物理设备`和一个或多个承载COSEM ap的`对等物理设备`之间的通信。

当一个`COSEM物理设备`支持`各种数据链路层`时——例如以太网和PPP——`每一个`都需要`一个`TCP-UDP setup对象的`实例`。

- TCP-UDP_port 监听端口号，4059 TCP/UDP
- IP_reference 引用“IP setup”对象
- MSS 在最大段大小(MSS，Maximum Segment Size)选项的帮助下，TCP实体可以向它的对端指示最大的接收段大小。注意:

  - 这个选项只能在`初始连接请求`中发送(即发送`SYN控制位`的分段);
  - 如果这个选项不存在，通常MSS被认为是它的默认值，`576`;
  - MSS是`不可协商`的;它的值由这个属性指示。
- nb_of_sim_conn 基于COSEM TCP-UDP的传输层能够支持的`最大同时连接数`(maximum number of simultaneous connections)
- inactivity_time_out `接收超时释放`，定义时间，以秒表示，如果没有从COSEM客户端收到帧，`不活动`的TCP连接将被`中止`。

0表示永不中止

注意，所有与管理`非活动超时函数`相关的`操作`，如`测量`非活动时间、在超时结束时`终止`TCP连接等，都在`TCP-UDP层`实现中进行管理。

### s4.9.2 IPv4 setup (class_id = 42, version = 0)

IPv4信息，每个网口对应一个

属性：

- DL_reference 引用数据链路层(如以太网或PPP)设置对象
- IP_address 静态或动态的`ip地址`

  IPv4地址192.168.0.1(点分十进制)对应C0A80001 (hexa)，得到3232235521 (double-long-unsigned)。
- multicast_IP_address `组播地址`，该`数组`中的IP地址应属于`组播组地址范围`(“D类”地址，包括224.0.0.0 - 239.255.255.255范围内的IP地址)。当设备接收到IP数据报时，如果`目的IP地址`字段属于数组中IP地址之一，它应该认为该数据报是给它自己的。
- IP_options 包含支持所选IP选项的`必要参数`——例如`数据报时间戳`或`安全服务`(IPSec)。

  标准的[IP option RFC 791](https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml)中的部分

  - Security: IP_Option_Type = 0x82, IP_Option_Length = 11
  - Loose Source and Record Route: IP_Option_Type = 0x83 宽松的源站选路（为数据报指定一系列必须经过的IP地址）
  - Strict Source and Record Route: IP_Option_Type = 0x89 严格的源站选路选项。与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址。
  - Record Route: IP_Option_Type = 0x07 记录路径（让每个路由器都记下它的IP地址）
  - Internet Timestamp: IP_Option_Type = 0x44 时间戳选项
- subnet_mask 子网掩码
- gateway_IP_address 网关IP
- use_DHCP_flag 是否启用dhcp，启用后IP_address, subnet_mask and gateway_IP_address变为动态
- primary_DNS_address 主DNS
- secondary_DNS_address 备用DNS

方法：

- add_mc_IP_address (data) 向multicast_IP_address数组添加一个新的ip
- delete_mc_IP_address (data) 从multicast_IP_address数组删除一个ip
- get_nbof_mc_IP_addresses (data) 获取multicast_IP_address数组元素数量

### s4.9.3 IPv6 setup (class_id = 48, version = 0)

属性：

- DL_reference 同IPv4
- address_config_mode IPv6地址配置模式

  - (0) Auto-configuration (default)
  - (1) DHCPv6
  - (2) Manual
  - (3) ND (Neighbour Discovery)
- unicast_IPv6_addresses `单播地址`(唯一本地单播，链接本地单播 和/或 全球单播地址)，是`数组`
- multicast_IPv6_addresses `组播地址`, `数组`
- gateway_IPv6_addresses `网关IP`，`数组`
- primary_DNS_address 同IPv4
- secondary_DNS_address 同IPv4
- traffic_class 包含IPv6头的traffic class元素。RFC 2474:1998第3条规定，使用`DSCP` (Differentiated Services Codepoint)对报文进行分类，根据类型的不同QoS可以指定不同动作，如有些需要低延迟，有些需要大流量。
- neighbor_discovery_setup 包含用于支持IPv6`邻居发现协议NDP`(rfc4861)的路由器和主机的配置。

  - RS_max_retry 给出一个节点在`没有`收到`预期`的路由器`通告`时执行的最大路由器请求`重试次数`。
  - RS_retry_wait_time 给出两个连续路由器请求重试之间的`等待时间`(以`毫秒`为单位)。
  - RA_send_period 给出路由器通告传输的`周期`，单位为秒

方法：

- add_IPv6_address (data) 添加IPv6地址，参数包括类型：单播、组播、网关
- remove_IPv6_address (data) 移除IPv6地址，参数包括类型：单播、组播、网关

### s4.9.4 MAC address setup (class_id = 43, version = 0)

从原来的“Ethernet setup”更名而来，说明这个类原来仅用于以太网。现在可以用于更广泛的用途，如PLC网络的MAC

保存MAC地址

属性：

- MAC_address MAC地址

### s4.9.5 PPP setup (class_id = 44, version = 0)

通过处理与给定`物理设备`相关的`PPP设置`的`所有信息`，以及与使用这些设置的`低层连接`，该IC允许使用`PPP协议模拟接口`的设置。一个物理设备的`每个`网络接口都应该有一个该IC的实例。

- PHY_reference 通过它的logical_name引用`另一个对象`。引用的对象包含具体`物理层接口的信息`，支持PPP层。 TODO:引用什么对象？
- LCP_options `LCP`配置[参数](https://www.iana.org/assignments/ppp-numbers/ppp-numbers.xml)。

  - Maximum-Receive-Unit (MRU), LCP_Option_Type = 1. See RFC 1661. `最大接收单元`。用于通知peer可以接收更大的包（如对方发的包比较小，可以告诉他自己最大能接收多少），也能通知peer发更小的包，太大处理不了
  - Async-Control-Character-Map (ACCM), LCP_Option_Type = 2. See RFC 1662. 异步控制字符映像
  - Authentication-Protocol, LCP_Option_Type = 3. See RFC 1661. `认证协议`，PAP、CHAP、EAP。
  - Magic-Number, LCP_Option_Type = 5. See RFC 1661. 该配置选项提供了一种`检测回环链路`和其他数据链路层`异常`的方法;
  - Protocol-Field-Compression (PFC), LCP_Option_Type = 7. See RFC 1661. `协议域压缩`，这个配置选项提供了一种协商PPP协议字段压缩的方法
  - Address-and-Control-Field-Compression (ACFC), LCP_Option_Type = 8. See RFC 1661. `地址和控制字段压缩`，这个配置选项提供了一种方法来协商数据链路层地址和控制字段的压缩;
  - FCS-Alternatives, LCP_Option_Type = 9. See RFC 1570. FCS替换，可以指定对等端发送的`另一种`FCS格式，或者协商`完全放弃`FCS
  - Callback, LCP_Option_Type = 13. See RFC 1570.
 回拨，是指当通信一方拨号到另一方后，由另一方断开拨号连接并进行`反向的拨号`。更加安全，另一方可以在回叫前验证对方是否合法，如查数据库或查对方号码
- IPCP_options 包含`网际协议控制协议`（IPCP）(PPP的网络控制协议模块)的必要参数，允许协商理想的互联网协议参数。有关IPCP的详情，请参阅`RFC 1332`。
- PPP_authentication PPP认证参数，PAP、CHAP、EAP，[见本文](https://workos.com/blog/authentication-protocols-your-guide-to-the-basics)

  - PAP: 明文密码传输，客户端发送明文用户名密码
  - CHAP：服务端发个OTP(相当于盐)，客户端用OTP和密码计算哈希值，把明文的用户名和哈希值发送服务端，服务端用相同的OTP和密码计算哈希值，并比对。过程中密码没有明文传输
  - EAP: 服务器向客户端发送`身份验证请求`，包括它应使用的 `40 种`身份验证方法中的哪一种。客户端根据该方法加密用户名密码，发送给服务端

### s4.9.6 SMTP setup (class_id = 46, version = 0)

允许使用简单邮件传输协议(Simple Mail Transfer Protocol，SMTP)协议与远程服务器建立数据交换

- server_port 服务器端口，25/TCP,UDP
- user_name 用户名，登录用
- login_password 密码，登陆用
- server_address 服务器ip
- sender_address 发送者ip地址

### s4.9.7 NTP setup (class_id = 100, version = 0)

NTP协议时间同步

属性：

- activated NTP时间同步是否激活
- server_address NTP服务器地址
- server_port 端口
- authentication_method 认证方式
- authentication_keys 认证密钥数组
- client_key 客户端密钥，NTP服务端公钥，IFF方式

方法：

- synchronize (data) 同步时间
- add_authentication_key (data) 添加authentication_key
- delete_authentication_key (data) 删除authentication_key

### s4.9.8 CoAP setup (class_id = 152 version = 0)

属性：

- UDP_reference 指向`TCP-UDP setup`对象,和UDP层相关
- ack_timeout confirmable消息的最小`初始ACK超时时间`
- ack_random_factor 初始ACK超时时间生成`随机因子`，初始ACK超时时间在ack_timeout - ack_timeout x ack_random_factor x 0.01之间
- max_retransmit confirmable消息的`最大重传次数`
- nstart 同时未完成的下列形式的CoAP请求消息的数量:未收到CoAP确认的CON CoAP消息或未收到CoAP响应消息的NON CoAP消息。
- delay_ack_timeout CoAP消息传递层`等待应用层`返回响应的时间(单位为ms)，然后它将返回确认以防止来自对等体的虚假重传。
- exponential_back_off

  重发延迟因子
  
  > n表示第几次重发

  retransmission_delay = initial_ack_timeout x (exponential_back_off x 0.01) ^ (n -1)
- probing_rate 定义一个端点在发送到另一个没有响应的端点时`不应超过`的平均数据速率(字节/秒)。
- CoAP_uri_path uri-path
- transport_mode 传输方式

  - 仅可靠
  - 仅不可靠
  - 同时支持
- version DLMS/COSEM CoAP wrapper的版本
- token_length token长度（CoAP协议中的token）

### s4.9.9 CoAP diagnostic (class_id = 153, version = 0)

CoAP诊断

属性：

- messages_counter 报文计数
- request_response_counter CoAP请求响应的报文计数
- coap_bt_counter CoAP Block-Wise transfer layer(块传输)，发起总数，完成总数，超时总数
- capture_time 捕获时间（最近更新本对象相关属性的时间）

方法：

- reset (data) 全部清空

### s6.2.5 Clock objects (class_id = 8)

TODO:对图的疑问。表内时间实际上只有一份，通过D的不同区分不同的表现形式。而且可以用不同的类表示。说明obis和class间没有太大的联系

### s6.2.17 Payment metering related objects

C决定了大的功能模块，D区分这个功能模块需要用到的数据，可以是隶属于不同class的。

如图，C=19表示payment相关功能，需要用到来自111、112、113、115、01、116类的数据

### 6.2.28 Objects for data exchange using narrow-band OFDM PLC for G3-PLC networks 和 6.2.42 Device ID objects

给出了相同的obis对应不同的类的情况

## 特殊情况

复杂array:
