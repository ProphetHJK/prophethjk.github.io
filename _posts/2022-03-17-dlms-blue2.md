---
title: "DLMS Green Book学习笔记"
author: Jinkai
date: 2022-03-08 09:00:00 +0800
published: false
categories: [技术]
tags: [C++, DAO, database]
---

## 4.3.2 Register (class_id = 3, version = 0)

包含值（value）和量纲（scaler_unit,包括精度(scaler)、单位（unit)）

清除方法

## 4.3.3 Extended register (class_id = 4, version = 0)

包含值、量纲、状态（厂家自定义）、寄存器捕获时间

清除方法

## 4.3.4 Demand register (class_id = 5, version = 0)

需量寄存器

周期性测量某个值得到当前平均值与上次平均值

E3表示第三个周期内的电量增量,假设当前时间大于E3统计结束时间（第三周期结束时间），小于E4统计结束时间，电量记录值比E3统计结束时大Δe

- current_average_value 当前平均值，energy/3t,energy=E2+E3+Δe,t=period,3=周期个数
- last_average_value 上一平均值，energy/3t,energy=E1+E2+E3,t=period,3=周期个数
- scaler_unit 量纲
- status 状态
- capture_time 上一平均值计算时间
- start_time_current 当前平均值统计开始时间
- period 周期
- number_of_periods 周期个数，用于上一平均值计算，为1表示区间式(block)，大于1表示滑差式(sliding)

方法：

- reset (data) 清除
- next_period (data) 该方法用于触发一个时间段的正常终止(和重新启动)。关闭(终止)当前测量周期。更新capture_time和start_time，拷贝current_average_value到last_average_value，设置current_average_value为默认值。开始下一个测量周期。

## 4.3.5 Register activation (class_id = 6, version = 0)

- register_assignment 寄存器列表，包括Register”,“Extended register” or “Demand register”等的类id和OBIS
- mask_list 标记列表，有多个register_act_mask，每个register_act_mask包含唯一的mask_name，每个register_act_mask中的index_list中的值顺序与register_assignment中的对象顺序一一对应，TODO:示例
- active_mask 激活的标记，mask_list中的某个标记，使用mask_name决定，用于表示当前启用的mask，进一步表示启用的register

方法：

- add_register (data) 向register_assignment中添加一个项，添加在数组尾部
- add_mask (data) 添加或更新mask_list
- delete_mask (data) 从mask_list删除一个mask，使用mask_name

## 4.3.6 Profile generic (class_id = 7, version = 1)

曲线包含捕获对象，可通过值的范围或输入范围检索范围内所有记录

捕获对象列表定义了要保存在buffer中的值，列表是静态的，保证每个记录都拥有相同的长度和结构

修改捕获列表必须清空所有所有buffer中记录，buffer被其他profile使用也必须清空buffer。TODO:含义？

记录可以按某个字段进行排序，如时间，或是按先进后出的栈的方式排序。例，按照Demand register中的last_average_value值来从小到大排序获得最大需量register

### 曲线数据大小限制参数

- 记录数
- 最大保留条数。当记录数满时，新捕获数据会覆盖最不重要的一条数据，重要度根据排序方式获得，如根据时间排序，最不重要的数据就是最时间最早的数据
- 缓冲区物理限制

### 选择性访问

- 按照值的范围：

    值可以是时间，或是某个捕获对象的值

- 按照排序后记录存储的顺序范围：

    如从第一条记录（重要性最高）到第三条
    如从某个值最大的记录到第三大的记录，需要重新临时排序

### 属性

- buffer 包含记录序列，每个记录包含若干捕获对象
- capture_objects 捕获对象列表，数组形式
- capture_period 自动捕获周期，以秒为单位，大于1表示达到周期捕获，等于0表示不自动捕获，需要手动触发
- sort_method 排序方式，默认为先进先出排序。如果profile已经排序，插入新的记录时，将记录插入适当位置，移动该位置之后所有记录，最不重要记录可能在buffer满后丢失。如果新记录的重要度最低且buffer已满，则该记录不插入
- sort_object 排序依据（对象）
- entries_in_use 当前记录总数
- profile_entries 记录上限

### 方法

reset (data) 清空buffer，entries_in_use清零，其他配置不变
capture (data) 手动触发捕获，读取每个捕获对象的值，生成记录插入buffer,同样不会改变捕获对象列表

### 修改捕获对象列表后行为

调用使用了该捕获对象列表的profile的reset操作

### 限制

定义捕获对象列表时，避免相互或循环引用。TODO:实例？

## 4.3.7 Utility tables (class_id = 26, version = 0)

允许封装 ANSI C12.19:2012 table 数据 TODO:这是什么？

## 4.3.8 Register table (class_id = 61, version = 0)

对同构条目、多个对象的相同属性进行分组，这些对象都是相同IC的实例,并且在它们的logical_name (OBIS代码)中，值组A到D和F中的值是相同的。

属性：

logical_name 当逻辑名为A.B.C.D.255.F时，只捕获一个属性，如value。当逻辑名为A.B.98.10.X.255时，可以捕获有关对象的不同属性
table_cell_values 保存捕获属性的值，可压缩
table_cell_definition Class_id定义捕获属性的对象的公共Class_id;logical_name包含对象的通用逻辑名，E = 255(通配符);group_E_values包含单元标识符列表，类型为unsigned，在DLMS UA 1000-1 Ed 15 Part 1:2021的相应表中定义;Attribute_index是指向对象内属性的指针。Attribute_index 0表示所有公共属性。
scaler_unit 量纲，当“Register”或“Extended Register”对象的“value”属性被捕获时，scaler_unit应为所有对象的公共属性。如果是其他属性或是其他IC，则该属性无用且禁止访问

方法：

reset (data) 清空table_cell_values
capture (data) 捕获，将原IC对象中的值拷贝到table_cell_values中，如果table_cell_definition中的attribute_index为0，则捕获所有属性

table_cell_definition被写入时的动作：

自动调用reset方法，如果需要捕获的属性的占用空间过大，table_cell_definition的写入会被拒绝

## 4.3.9 Status mapping (class_id = 63, version = 0)

该IC允许将状态字中的位映射到引用表中的项。

- status_word 状态字，n*8比特，最大65536比特
- mapping_table 包含status_word到引用表中位置的映射。
  - ref_table_id 表示引用表的id
  - ref_table_mapping选择long-unsigned：该值对应引用表中的一条记录，该记录对应status_word中的第一位，该记录的下一条记录对应status_word中的第二位，直到status_word的最后一位

  假设status_word为10000001，long-unsigned值为3

  |status_word位值|引用表索引|
  |:---:|:---:|
  |1|3|
  |0|4|
  |0|5|
  |...|...|
  |1|10|
  - ref_table_mapping选择array：array中的每个值对应引用表中的一条记录，每条记录对应status_word中的对应位，如array第一个值对应status中的第一位，最后一个值代表最后一位

## 4.3.10 Compact data (class_id: 62, version = 1)

Compact数据IC的实例允许捕获由capture_objects属性确定的COSEM对象属性值。捕捉可以发生:
    - 在外部触发器上(显式捕捉);
    - 在读取compact_buffer属性时(隐式捕获)。

由capture_method属性确定

值保存在compact_buffer attribute中，以octet-string形式

这组数据类型由template_id属性标识。捕获的每个属性的数据类型由template_description属性保存。

客户端可以用未压缩的形式重新构造数据(解压)，即包括COSEM属性描述符、数据类型和使用capture_objects、template_id和template_description属性的数据值。

属性：

- compact_buffer 捕获的属性的值，octet-string形式，当类型为octet-string, bit-string, visible-string, utf8-string or array时，长度也包含在内
- capture_objects 指定分配给“Compact data”对象实例的`COSEM对象属性列表`，两种选择性访问方式：
  - `相对选择性访问`：相对当前的日期或当前的记录返回记录，由data_index元素控制
  - `绝对选择性访问`：根据明确的时间范围或记录范围返回记录，由restriction_element控制，列（columns）是由data_index的MS byte(Most Significant byte,意为最高有效字节)的低半字节（右边4位）决定的

  |MS-Byte|MS-Byte|LS-Byte|
  |:---:|:---:|:---:|
  |Upper nibble|`Lower nibble`||
  |0000|0000|00000000|
  - data_index:是一个指针，它`选择`具有复杂数据类型(结构或数组)的属性的一个或几个`特定元素`:
    - 如果属性的数据类型是简单类型，则该值无意义
    - 如果属性的数据类型是结构体或数组（非profile generic对象的buffer），则该值指向该结构体或数组中的一个或多个特定元素
    - 如果属性的数据类型是profile generic对象的buffer，该值包含相对选择性访问的参数，如当前日期或记录
    - 0x0000 =标识整个属性;
    - 0x0001到0x0FFF =标识复杂属性中的一个元素。复杂属性中的第一个元素由data_index 1标识;
    - 0x1000到0xFFFF =对保存Profile generic对象的buffer的数组进行相对选择性访问。数据索引选择最近(最近)时间段内的条目，或最近(最近)条目内的条目，以及数组中的列。
    - 参考Table 9 – Encoding of selective access parameters with data_index。例，0x830C，MS-Byte中的高4位为0x8，表示包括当前小时在内的最后一个完整小时数，低4位为0x3，表示前3列，LS-Byte为0x0C,表示12小时，综上，该值表示选择最后12个小时内的前3列数据
  - restriction_element：当属性的数据类型是profile generic对象时，该值用于表示`绝对选择性访问`的参数，时间范围，记录序号范围，
    - 此时的data_index条件：
      - MS Byte高4位为0（为1的话表示相对选择性访问）
      - MS Byte低4位为0x0到0xF
      - Lower byte为0
    - restriction_type表示选择性访问的方式
    - restriction_value表示选择性访问范围

- template_id 包含模板的`标识符`。它应唯一标识“Compact data”IC的实例和 template_description。
- template_description 每个被捕获的属性的`数据类型`，由服务端自动生成，根据capture_objects，包含以下结构体：
  - 第一个字节是0x02结构体tag
  - 后面是数量，变长，和capture_objects数量相同
  - 后面是每个属性的数据类型，与capture_objects一一对应:
    - 对于具有简单数据类型的属性，该值一个字节，包含类型tag，如bit-string\[4\]
    - 对于array\[1\]，该值为0x01，后面是元素的类型（数组内所有元素都相同，所以就一个）。不记录数目是因为compact_buffer已经记录了
    - 对于structure\[2\]，该值为0x02,后面是元素数目，后面是每个元素的类型
- capture_method 定义compact_buffer更新的方式：
  - 0：在调用Capture (data)方法时捕获。这可能发生在远程或本地(显式捕获)
  - 1：读取compact_buffer属性时捕获(隐式捕获)

方法：

- reset(data) 仅清空compact_buffer
- capture(data) 将捕获对象的值填充至compact_buffer中，**不会触发捕获对象内的任何其他操作**，如capture()或reset()

对capture_objects的任何修改，必须`重置`compact_buffer以及`自动更新`template_description

## 4.4 Interface classes for access control and management


