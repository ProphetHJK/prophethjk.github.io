---
title: "DLMS Green Book学习笔记"
author: Jinkai
date: 2022-04-19 09:00:00 +0800
published: true
categories: [技术]
tags: [C++, DAO, database]
---

## 1 Scope

1. `建模`: 包括设备的`接口模型`和数据识别规则;在blue book 中定义
2. `消息传递`: 这涵盖了将接口模型`映射`到协议数据单元(APDU)的服务，以及这个APDU的`编码`。在本green book中定义
3. `传输`: 通过通信通道`传输消息`。在本green book中定义

## 3 Terms, definitions and abbreviations and symbols

通信模型：

![comm-module](/assets/img/2022-03-17-dlms-green-1/DLMS1.png)

## 4 Information exchange in DLMS/COSEM

### 4.1 General

The key characteristics of data exchange using DLMS/COSEM are the following:

- devices can be accessed by various parties: clients and third parties;

    使用DLMS/COSEM进行数据交换的主要特点如下:设备可以被各种各方访问:客户端和第三方;

- mechanisms to control access to the resources of the device are provided;

    提供了控制对设备资源的访问的机制;

- these mechanisms are made available by the DLMS/COSEM AL and the COSEM objects ( Association SN / LN object, Security setup object);

    这些机制是由DLMS/COSEM AL和COSEM对象(关联SN / LN对象，安全设置对象)提供的;

- security and privacy is ensured by applying cryptographical protection to xDLMS messages and to COSEM data;

    通过对xDLMS消息和COSEM数据应用加密保护来确保安全性和私密性;

- low overhead and efficiency is ensured by various mechanisms including selective access, compact encoding and compression;

    通过各种机制，包括选择性访问、压缩编码和压缩，确保了低开销和效率;

- at a site, there may be single or multiple devices.

    在一个站点，可能有单个或多个设备。

- In the case of multiple devices at a site, a single access point can be made available;

    在一个站点有多个设备的情况下，可以提供一个单一的接入点;

- data exchange may take place either remotely or locally.

    数据交换可以在远程或本地进行。

- Depending on the capabilities of the device, local and remote data exchange may be performed simultaneously without interfering with each other;

    根据设备的能力，本地和远程数据交换可以在不相互干扰的情况下同时进行;

- various communication media can be used on local networks (LN), neighbourhood networks (NN) and wide area networks (WAN).

    各种通信媒体可用于局域网(LN)、邻网(NN)和广域网(WAN)。

### 4.2 Communication model

application processes(`APs`)之间的通信通过`应用程序实体`(application entities,`AEs`)之间的通信进行建模。AE代表AP的`通信功能`。

AP中可能有多组OSI通信功能，因此`一个AP`可以用`多个AEs`来表示

一个`server AP`对应一个`logical device`,`client AP`可以不对应logical device。`每个AP`绑定一个Service Access Point(`SAP`)，`SAP`位于application layer(`AL`)层。**也就是说SAP用于区分基于同一个AL的不同AP**(对服务端也可以说是logical device).

### 4.3 Naming and addressing

![comm-module](/assets/img/2022-03-17-dlms-green-1/address.jpg)

#### 4.3.3 Addressing

![comm-module](/assets/img/2022-03-17-dlms-green-1/sap.jpg)

SAP用于区分基于同一个AL的不同AP

#### 4.3.4 systemtitle

- 按单一DLMS/COSEM实体唯一，和逻辑设备名不同，一个实体可以有多个逻辑设备(名)，但只能有一个systemtitle,实体中的逻辑设备共享该systemtitle
- 固定8字节长，前3字节厂家ID，和逻辑设备名相同，后面的5字节，应为0-999,999,999,999(0x0-0xE8D4A50FFF)

#### 4.3.5 逻辑设备名

蓝皮书 part2 4.1.8

### 4.4 Connection oriented operation

- Phase 1: AA establishment
- Phase 2: Message exchange
- Phase 3: AA Release

`预连接AA`不需要1和3

### 4.5 Application associations

A COSEM logical device may support one or more AAs, each with a different client. Each AA determines the contexts in which information exchange takes place.

一个COSEM逻辑设备可以支持一个或多个AAs，每个AAs有一个`不同的客户端`。每个AA决定发生信息交换的上下文。

A confirmed AA is proposed by the client and accepted by the server provided that:

- confirmed AA:

  `确认AA`由客户端提出并被服务器`接受`，前提是

  - the user of the client is known by the server, see 4.3.6;

      客户端用户为服务器所知，见4.3.6;

  - the application context proposed by the client see 4.5.2 is acceptable for the server;

      客户端在4.5.2中提出的应用上下文对于服务器来说是可接受的;

  - the authentication mechanism proposed by the client see 4.5.3 is acceptable for the server and the authentication is successful;

      客户端(见4.5.3)提出的认证机制对服务器来说是可接受的，认证是成功的;

  - the elements of the xDLMS context see 4.5.4 can be successfully negotiated between the client and the server.

      xDLMS上下文的元素参见4.5.4可以在客户端和服务器之间成功协商。

  An unconfirmed AA is also proposed by a client with the assumption that the server will accept it. No negotiation takes place. Unconfirmed AAs are useful for sending broadcast messages from the client to servers

- unconfirmed AA:

  客户端也会提出`未经确认的AA`，并假设服务器会接受它。 没有谈判发生。 未确认的 AA 对于从客户端向服务器发送`广播消息`很有用。

#### 4.5.2 Application context

应用程序上下文确定：

- AL 中存在的一组应用服务元素（Application Service Elements,ASEs）
- COSEM 对象属性和方法的引用方式：短名称(SN) 引用或逻辑名称(LN) 引用。 另见 9.1.4.3.1
- 传输语法
- 是否使用加密

#### 4.5.3 Authentication

DLMS中的认证发生在AA建立阶段

- In confirmed AAs either the client (unilateral authentication) or both the client and the server (mutual authentication) can authenticate itself.

    在`已确认aa`中，客户端(单向认证)或客户端和服务器(相互认证)都可以对对端进行认证。
- In an unconfirmed AA, only the client can authenticate itself.

    对于`未确认AA`，只有客户端可以验证对端。
- In pre-established AAs, authentication of the communicating partners is not available.

    在`预连接AA`中，身份验证不可用。

#### 4.5.4 xDLMS context

xDLMS上下文确定可以在给定的AA中使用的xDLMS服务和功能集。见9.1.4。

#### 4.5.5 Security context

当应用程序上下文规定加密时，安全上下文是相关的。 它包括`安全套件`、`安全策略`、`安全密钥`和`其他安全材料`。 另见 9.2.2.3。 它由“`Security setup`”对象管理。

#### 4.5.6 Access rights

访问权限确定客户访问 AA 内的 COSEM 对象属性和方法的`权限`。 访问权限集取决于`客户端的角色`，并在服务器中`预先配置`。 另见 9.2.2.4。

### 4.6 Messaging patterns

![messages](/assets/img/2022-03-17-dlms-green-1/messagepatterns.jpg)

在`已确认AA` 中：

- 客户端可以发送确认的服务请求，服务器响应：`pull操作`
- 客户端可以发送未经确认的服务请求。 服务器没有响应
- 服务器可以向客户端发送未经请求的服务请求：`push操作`

> note:主动推送的服务可以是 InformationReport（使用 SN 引用）、EventNotification（使用 LN 引用）或 DataNotification（同时使用 SN 和 LN 引用）。

在`未确认AA` 中：

- 只有客户端可以发起服务请求，并且只有未确认的请求。 服务器无法响应，也无法发起服务请求。

### 4.8 Communication profiles

通信配置文件指定了 *`DLMS/COSEM AL`* 和*建模Application Process (AP) 的 `COSEM 数据模型`*如何由较低的通信媒体特定协议层支持。

通信配置文件包括许多`协议层`。 每一层都有不同的任务并为其上层`提供服务`并使用其支持协议层的服务。 客户端和服务器 `COSEM AP` 使用最高协议层的服务，即 `DLMS/COSEM AL` 的服务。 这是唯一包含 COSEM 特定元素(`xDLMS ASE`)的协议层； 见 9.1.4。 任何能够提供 DLMS/COSEM AL 所需服务的层都可以支持它。 较低层的数量和类型取决于所使用的通信媒体。

### 4.9 Model of a DLMS/COSEM system

设备被建模为`一组逻辑设备`，托管在`单个物理设备`中。 **每个逻辑设备代表一个服务器 AP**，并对`设备功能`的一个`子集`进行建模，这些功能子集可以通过其通信接口看到。使用COSEM对象对各种功能进行建模。

![messages](/assets/img/2022-03-17-dlms-green-1/model.jpg)

`数据采集系统`被建模为`一组客户端ap`，可以由一个或多个物理设备托管。每个客户端AP可能有不同的角色和访问权限，由设备授予。
`公共客户端`和`管理逻辑设备`APs有一个特殊的角色，它们应该一直存在。

### 4.10 Model of DLMS servers

- IP based profiles:

`DLMS/COSEM AL`由DLMS/COSEM Transport layer(`TL`)支持，该TL由internet TCP或UDP层和一个包装器(wrapper)组成(TODO:是不是47协议?)。`包装器`的主要作用是适应`OSI风格`的服务集，该服务集由DLMS/COSEM TL在TCP和UDP函数调用`之间`提供。它还为逻辑设备提供寻址，将它们`绑定`到一个称为包装器端口的`SAP`。`管理逻辑设备`总是绑定到包装器端口`0x01`。最后，`包装器`提供有关APDU传输`长度的信息`，以帮助对等端识别APDU的`末端`。由于TCP的流特性，这是必要的。

如果没有包装器这层，APDU直接通过TCP发出去，由于TCP是`流式`的，APDU不包含`头尾信息`，对端不知道是否是个`完整`的APDU`无法解析`

- 3-layer,CO,HDLC based profile:

`DLMS/COSEM AL` 由基于 `HDLC` 的数据链路层支持。 它的主要作用是在对等层之间提供可靠的数据传输。 它还以这样一种方式提供逻辑设备的`寻址`，即每个逻辑设备都`绑定`到`单个 HDLC 地址`。 管理逻辑设备始终绑定到地址 0x01。 为了允许创建一个`本地网络`，以便通过一个`单一的接入点`可以到达特定站点的`几个设备`，另一个地址，即`物理地址`也由数据链路层提供。(TODO:这个是和client区别的地方，是什么意思？)。 逻辑设备地址被称为高HDLC地址，而物理设备地址被称为低HDLC地址。 另见 8.4.2

TODO：HDLC层相关

### 4.11 Model of a DLMS client

![messages](/assets/img/2022-03-17-dlms-green-1/modelclient.jpg)

与服务器端不同，HDLC层提供的寻址只有一个级别，即每个应用程序流程(AP)的服务接入点(SAP)的级别。

客户端AP和服务器端AP由各自的`sap`识别，因此，客户端和服务器端AP之间的`AA`可以由`一对`客户端和服务器端`sap`识别。

### 4.12 Interoperability and interconnectivity in DLMS/COSEM

互操作性和互联性

- Interoperability：

双方的COSEM对象定义相同，都使用DLMS/COSEM AL层

- interconnectivity：

AEs互通，AE就是AL以下的层。如果两个AEs使用相同的`通信配置文件`，则它们是可互连的

### 4.13 Ensuring interconnectivity: the protocol identification service

`协议识别服务`

在DLMS/COSEM中，AA的建立总是由`客户端AE`发起。然而，在某些情况下，它可能`不了解`未知服务器设备所使用的`协议栈`（例如，当服务器启动物理连接建立时）。在这种情况下，客户端AE需要获得关于服务器中实现的`协议栈的信息`。
为此，提供了一种特定的应用级服务：`协议识别服务`。它是一种可选的应用级服务，允许客户机AE在建立物理连接后获得关于服务器中实现的协议栈的信息。5.3.3.3中规定的协议识别服务直接使用PhL的数据传输服务（`PH-DATA`.request /.indicat）；它绕过了其他协议层。建议在所有可以访问PhL的通信配置文件中支持它。

### 4.14 System integration and installation

`系统集成和安装`

DLMS/COSEM以多种方式支持系统集成。这里描述了一个可能的过程。

如图7所示，`Public Client`(在任何配置文件中绑定到地址`0x10`)在每个客户端系统中都是必需的。它的主要作用是揭示一个`未知的`--例如`新安装`的--设备的结构。这发生在公共客户端和管理逻辑设备之间的`强制AA`中，没有安全预防措施。一旦知道了结构，就可以使用`适当的身份验证机制`和xDLMS的`密码保护`来访问数据

当`系统`中安装了`新设备`时，可能会`向客户端`生成`事件报告`。一旦检测到这一点，客户机就可以检索设备的`内部结构`，然后向设备发送必要的`配置信息`(例如关税时间表和特定于安装的参数)。这样，设备就可以使用了

## 5 Physical layer services and procedures for connection-oriented asynchronous data exchange

物理层

### 5.1 Overview

- 通信是点对点或点对多点
- 至少可以有半双工连接
- 异步传输1位起始位，8位数据位，无奇偶校验和1位停止位(8N1)

### 5.2 Service specification

#### 5.2.1 List of services

- 建立/发布相关业务  PH-CONNECT, PH-ABORT;
- 数据传输业务  PH-DATA;
- 层管理服务

  层管理服务由`层管理进程`使用或为`层管理进程`提供，层管理进程是`AP`的一部分。下面给出一些示例:

  - PH-INITIALIZE.request / PH-INITIALIZE.confirm;
  - PH-GET_VALUE.request /  PH-GET_VALUE.confirm
  - PH-SET_VALUE.request / PH-SET_VALUE.confirm
  - PH-LM_EVENT.indication

#### 5.2.2 Use of the physical layer services

物理连接建立/释放服务是由`物理连接管理器AP`使用并为`物理连接管理器AP`提供的，而不是`数据链路层`

![messages](/assets/img/2022-03-17-dlms-green-1/physervices.jpg)

`注意这张图很关键，表明了AP用于管理物理层的关系，包括AP和物理层的原语，链路层和物理层的原语`

#### 5.2.3 Service definitions

- PH-CONNECT.request `连接建立服务`的服务请求原语

  在DLMS/COSEM环境中，PH-CONNECT.request原语的`用户`是物理连接管理器`AP`。它被用于建立一个物理连接。收到该基元后，PhL实体将执行所需的动作--例如拨号（如物理层PhL向modem发送`AT指令`）--以与对等PhL实体建立物理连接。5.4中给出了智能Hayes调制解调器情况下的这些动作的例子。

- PH-CONNECT.indication 连接建立服务的服务指示原语

  PH-CONNECT.indication由PhL实体基元生成，用于向服务用户实体指示一个远程设备要求建立物理连接。

- PH-CONNECT.confirm 连接建立服务的服务确认原语

  PhL实体用来传递相关联的PH-CONNECT.request的结果。如果由于本地错误(例如电话线不可用)而无法建立连接，则是本地生成的。

- PH-DATA.request `数据传输服务`的服务请求原语

  求使用PhL传输过程向一个或多个远程PhL实体发送数据字节

- PH-DATA.indication 数据传输服务的服务指示原语。

  向服务用户实体指示有效数据字节的到达

- PH-ABORT.request 连接中止服务的服务请求原语

  请求原语由服务用户实体Physical Connection Manager调用，以请求PhL实体终止现有的物理连接

- PH-ABORT.confirm 连接`中止服务`的服务确认原语

  PH-ABORT.confirm 原语由 PhL 实体生成，用于向服务用户实体 Physical Connection Manager 确认物理断开尝试的结果

- PH-ABORT.indication 连接中止服务的服务指示原语。

  原语由PhL实体生成，用于通知服务用户实体物理连接已意外终止。

### 5.3 Protocol specification

#### 5.3.1 Physical layer protocol data unit

Physical layer protocol data unit,`PHPDU`被指定为`一个字节`。然而，为了传输目的，这个数据字节可能被`调制解调器`设备`扩展`(错误检测/校正)或`修改`(位填充)，这取决于所使用的调制方案。

#### 5.3.2 Transmission order and characteristics

PHSDU字节——PH-DATA服务的Data参数——在传输前应以一个开始位和一个停止位完成。产生的帧应该从起始位开始传输，首先是最低有效位，最低有效位标识为位0，最高有效位标识为位7。

#### 5.3.3 Physical layer operation – description of the procedures

##### 5.3.3.1 General

连接的建立和释放由`物理连接管理器AP`管理。任何希望使用DLMS/COSEM协议的`AP`应在请求连接之前`检查PhL`的连接状态。如果PhL处于`非连接`状态，它将请求`物理连接管理器`建立连接

TODO:结合5.3.3.3和5.3.3.4就是说建立和释放还有识别服务由AP来做，这些做完后的数据传输阶段AP就不管了，通过数据链路层直接调用

##### 5.3.3.2 Setting up a physical connection

客户机和服务器设备都可以充当`主叫设备`，初始化到远程设备(即`被叫设备`)的物理连接。在这个`DLMS/COSEM配置文件`中，这些原语的服务用户只能是`物理连接管理器进程`

在`被叫设备端`，当检测到物理连接的启动时，需要对连接进行管理：`协商`、`接受`或`拒绝`。这些动作--与执行PH-CONNECT.request原语类似--取决于`物理连接类型`和使用的`调制解调器`，并可能以`自主方式`或由`PhL本身`完成(该过程不需要Physical
connection manager process参与)。

当主叫和被叫设备的`PhL完成建立`（或`不建立`）所需的物理连接时，它们使用`PH-CONNECT.confirm`（主叫方）和`PH-CONNECT.indicat`（被叫方）基元将结果通知服务用户实体。

![messages](/assets/img/2022-03-17-dlms-green-1/physicalconn.jpg)

##### 5.3.3.3 The Identification service

`可选识别服务`是一种`应用层面`（TODO:特别注意，应用层面）的服务。它的目的是让客户获得关于服务器中实现的`协议栈`的信息。因此，它不使用整个协议栈；识别信息在`客户端AP`和`服务器AP`之间使用`PhL数据服务`直接交换。如果在`多播`配置中使用了一个以上的服务器，客户端能够识别`每个`服务器中的协议栈。

该服务在`PH-CONNECT后`CONNECTED状态才能调用

- IDENTIFY.request 请求识别信息
- IDENTIFY.response IDENTIFY.response消息由`服务器AP`调用，携带识别请求的`结果`：`协议标准`、`版本`和`修订信息`或`错误信息`。在客户端，这是一个IDENTIFY.confirm原语。

![messages](/assets/img/2022-03-17-dlms-green-1/identify.jpg)

IDENTIFY.request `APDU`包含`一个或三个`字节。为了保持一致性，它的发送应受到数据链路层的`时间限制`（帧间和响应超时）。

当收到这`第一个字符`时，PhL进入 "`识别中`"状态，等待更多的字节或帧间超时(意味着消息的结束)。

- identify`识别阶段`过程：

  如果在收到三个以上的字节之前检测到`消息结束`条件(超时也算结束标志)，PhL将收到的APDU视为`IDENTIFY.request` APDU。它使用PH-DATA.indicaton原语将收到的字节发送到`（物理连接管理器）AP`，并返回到 "`等待接收`"状态，允许解决最终的错误。

- 跳过identify`识别阶段`，直接进入`数据传输阶段`：

  另一方面，如果在收到`第四个`传入字节之前没有检测到`消息结束`的条件（因为IDENTIFY.request最大就是3字节，收到第4个字节还没有结束标志，说明就不是IDENTIFY.request了），PhL认为识别过程已经结束，并进入 "`数据传输`"状态。传入的字节应使用`PH-DATA.indicaton`服务发送至服务用户的上层协议层。在3层的CO、HDLC的COSEM配置文件中，这是MAC子层。在这种连接中，PhL`不能返回`到`识别阶段`。

##### 5.3.3.4 Data transfer

一旦`PhL`退出`识别阶段`，它就进入了`数据传输阶段`，其中`PH-DATA.request`和`PH-DATA.indicative`原语完全由上层协议层即`数据链路层`使用。

在识别阶段AP是可以通过PH-DATA原语向物理层传数据的，进数据传输阶段就不行了

PhL`不负责`任何数据`流控`制功能：通过PHDATA.request primitive收到的数据应`立即传输`，或者--当实施物理数据`流控`制时--应`覆盖`之前尚未传输的字节。由于PH-DATA服务既不是本地确认，也不是远程确认，因此在后一种情况下，不应发出错误信号。

##### 5.3.3.5 Disconnection of an existing physical connection

客户端或服务器都可以启动现有物理连接的断开连接。这通过调用 `PH-ABORT.request` 原语的`物理连接管理器 AP` 来实现

PH-ABORT.request的调用者，会收到PH-ABORT.confirm作为通知(在本地处理，本地的物理层通知本地的调用AP，不外发，断开操作无需通知对方)

对方不会收到任何关于断开的请求，只能通过`检测物理连接`断开（收到物理层传来的`PH-ABORT.indication`事件）来发现物理通道断开了。

如果是信道异常导致的断开，双方应该都会收到物理层传来的PH-ABORT.indication，双方都断开。

![messages](/assets/img/2022-03-17-dlms-green-1/phydisconn.jpg)

### 5.4 example: PhL service primitives and Hayes commands

PH-CONNECT:

对于`主叫者`，physical
connection manager AP向物理层PhL发送`PH-CONNECT`.request，物理层PhL向modem(DCE)发送`AT拨号`命令，并返回拨号结果，物理层将结果转换为`PH-CONNECT.confirm`返回给AP

对于`被叫者`，AP会被物理层通知`PH-CONNECT.indication`表示物理层已连接

![messages](/assets/img/2022-03-17-dlms-green-1/phyconn.jpg)

PH-DATA:

假设之前`建立了`与远程DCE的`连接`，并且DCE现在处于`数据传输模式`，那么传递到本地DCE的所有数据都将被传输到远程DCE（不是透明传输，每一层都会对data数据做处理，比如添加开始停止位，校验位等）。

PH-ABORT：

在可以终止连接之前，必须首先将调制解调器切换到本地`命令模式`(从数据传输模式)

## 6 Direct Local Connection

IEC 62056-21的摘录，

TODO:需要了解HDLC协议

### 6.2 METERING HDLC protocol using protocol mode E for direct local data exchange

## 7 DLMS/COSEM transport layer for IP networks

- 基于UDP的无连接传输层;
- 面向连接的基于TCP的传输层;
- 一个基于无连接CoAP的传输层

`DLMS/COSEM TL`由`CoAP、UDP或TCP传输层`和一个称为`包装器wrapper`的额外子层组成

### 7.2 The TCP-UDP/IP based transport layers

DLMS/COSEM_on_IP

可以把DLMS/COSEM AL视为和HTTP一样的网络应用，使用TCP-UDP传输层服务

![messages](/assets/img/2022-03-17-dlms-green-1/cosemalprofile.jpg)

IANA中注册了4059/TCP-UDP端口

DLMS/COSEM `AL`只监听`一个UDP或TCP端口`。另一方面，如4.9和DLMS UA 1000-1所示，`一个物理设备`可能承载`多个`客户端或服务器`ap`。包装器子层提供的`附加寻址`功能允许寻址这些`ap`。

包装子层具有以下功能:

- 它在UDP/TCP端口上提供了一个`额外的寻址`能力(`wPort`);
- 它提供有关数据`传输长度`的信息。这个特性可以帮助发送方和接收方识别一个`完整的APDU`的接收，它可以在`多个TCP包`中发送和接收

![messages](/assets/img/2022-03-17-dlms-green-1/tlcosemonip.jpg)

TCP-CONNECT and TCP-DISCONNECT services的用户是TCP Connection Manager Process（TODO:是否是和COSEM AP同一级的其他AP，如之前有管理物理层的AP）

#### 7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer

无连接，可实现多播广播；开销小

缺点：不可靠，无重复发送保护

![messages](/assets/img/2022-03-17-dlms-green-1/udptl.jpg)

.request和.indication服务原语是必需的。本地的.confirm服务原语的实现是可选的。

```asn.1
UDP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length, Data
)
```

```asn.1
UDP-DATA.indication
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
```

```asn.1
UDP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
```

`Result`参数的值表示基于DLMS/COSEM UDP的TL是否能够发送请求的UDP数据报:`能(OK)`或`不能(NOK)`。result为OK只能表示数据已发送，不保证能送达

UDP-DATA.confirm是`可选的`

在这个通信配置文件中，包装子层是一个无状态的实体：它的唯一作用是确保使用wPort号码的源和目的地DLMS/COSEM AE识别，并提供`OSI风格`的`UDP-DATA.xxx服务调用`与`标准UDP`提供的SEND()和RECEIVE()接口函数之间的`转换`。

对于UDP这种`面向数据报`而非`面向流`的协议，包装器中的长度字段并非必要，因为每个udp报文就是完整单一的，不存在分好几包还要拼包拆包处理粘包等操作，但为了和TCP`兼容`还是需要该字段

#### 7.2.3.3.2 The wrapper protocol data unit (WPDU)

![messages](/assets/img/2022-03-17-dlms-green-1/wrapperwpdu.jpg)

- version:始终为0x0001
- source/destination wPort:DLMS/COSEM AE的端口
- Data length:APDU数据长度

![messages](/assets/img/2022-03-17-dlms-green-1/udppdu.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/wrapperport.jpg)

#### 7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer

面向流的，可靠，包括重传、全双工、流控

缺点：端到端，不支持广播和多播

`TCP`作为一种面向连接的传输协议，涉及到`建立连接`、`交换数据`和`释放连接`三个阶段。因此，基于TCP的`DLMS/COSEM TL`为服务用户提供三个阶段的`OSIstyle`服务:

- 在`连接建立`阶段，将`TCP-CONNECT`服务提供给服务用户`TCP连接管理器进程`;
- 在`数据传输`阶段，`TCP-DATA`服务提供给服务用户`DLMS/COSEM AL`;
- 在`连接关闭`阶段，`TCP-DISCONNECT`服务被提供给服务用户`TCP连接管理进程`;
- 此外，一个`TCP-ABORT`服务被提供给服务用户`DLMS/COSEM AL`。

`TCP连接管理服务`的服务用户`不是DLMS/COSEM AL`，而是`TCP连接管理进程`。该工艺的规范超出了本技术报告的范围

![messages](/assets/img/2022-03-17-dlms-green-1/tcptl.jpg)

TCP-DATA区别与UDP-DATA可本地或远程确认，UDP-DATA只能本地确认

##### TCP-CONNECT

```asn.1
TCP-CONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)

TCP-CONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
```

TCP-CONNECT由TCP连接管理进程和TCP层进行交互

TCP连接管理进程不能拒绝TCP连接请求，所以TCP-CONNECT.response总是成功的

TCP-CONNECT.confirm一般来说需要远程确认，如果是本地确认，可能回失败

##### TCP-DISCONNECT

```asn.1
TCP-DISCONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)
```

TCP-DISCONNECT.request 用于断开请求

```asn.1
TCP-DISCONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
```

TCP-DISCONNECT.indication中`Reason`参数:

- `对端设备`请求了TCP断开(Reason == `REMOTE_REQ`)
- `本地检测`到TCP连接断开(Reason == `ABORT`)

```asn.1
TCP-DISCONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
```

TCP连接管理进程`不能拒绝`TCP断开请求，表示远程断开Reason == REMOTE_REQ

```asn.1
TCP-DISCONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
```

同TCP-CONNECT.confirm

##### TCP-ABORT

见7.2 图27，TCP-ABORT是`AL`层和`TL`层交互的原语

```asn.1
TCP-ABORT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
```

由基于DLMS/COSEM TCP的`TL`生成，用于向服务用户`DLMS/COSEM AL`表示支持TCP连接的`非请求中断`。

当收到此指示时，`DLMS/COSEM AL`应释放所有使用此TCP连接建立的`AAs`，并应使用 `COSEM-ABORT.indivation`服务原语向 COSEM AP 表明这一点。

##### TCP-DATA

```asn.1
TCP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
```

Data是APDU

```asn.1
TCP-DATA.indication (
    Local_wPort, 
    Remote_wPort, 
    Local_TCP_Port, 
    Remote_TCP_Port, 
    Local_IP_Address, 
    Remote_IP_Address, 
    Data_Length, 
    Data 
)
```

TCP-DATA.indication基元由DLMS/COSEM `TL`生成，用于向服务用户DLMS/COSEM `AL`指示已从远程设备收到xDLMS `APDU`。如果携带APDU的TCP数据包中的Local_TCP_Port和Local_wPort参数都包含`有效的端口号`，即接收设备中存在一个与给定端口号绑定的DLMS/COSEM AE，则在基于DLMS/COSEM TCP的TL`接收完整的APDU`（在`一个或多个`TCP数据包中）后生成。否则，收到的消息将被直接丢弃。

TCP-DATA.indication需要在接收完完整包并解包后交给AL,Data是APDU

```asn.1
TCP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Confirmation_Type,
    Result
)
```

可选的，request的确认

##### 7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer

wrapper层和UDP的不同，因为TCP是流式的，需要发送/接收全APDU，还要处理粘包等

###### TCP connection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpconn.jpg)

为了能够响应，响应方必须在接收第一个SYN包之前执行一个`“被动”打开`。为此，它必须联系本地操作系统(OS)，以表明它已经`准备好`接受传入的连接请求。作为这个联系的结果，操作系统分配一个`TCP端口号`给连接的端点(开启TCP`端口监听`)，并为将来的连接保留所需的资源——但是没有发送消息。

###### TCP disconnection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpdisconn.jpg)

###### TCP connection abort

基于 DLMS/COSEM TCP 的 `TL` 在 `TCP-ABORT.indication` 原语的帮助下指示支持 `TCP 连接`到 DLMS/COSEM `AL` 的`中断或断开`。 请注意，这是提供给 DLMS/COSEM AL 的`唯一` TCP 连接管理服务(其他服务都是提供给TCP连接管理进程的)。

当 `TCP 连接`被 `TCP 连接管理器进程`断开时调用该服务（`优雅断开`的情况），或者当 TCP 断开以`非请求方式`发生时，例如 TCP 子层`检测`到不可解决的`错误`或 `物理连接`被`关闭`。

TODO:前文TCP-ABORT一节提到TCP-ABORT不是非请求中断才生成吗?为什么请求中断也会生成

该服务的目的是`通知` DLMS/COSEM `AL` TCP 连接`中断`，以便它可以`释放`所有现有的 `AA`。

###### Data transfer using the TCP-DATA service

![messages](/assets/img/2022-03-17-dlms-green-1/tcpdata.jpg)

可选`TCP-DATA.confirm`原语表示TCP-DATA`结果`。请求原语之前调用，这是OK或NOK。然而，这个结果的含义取决于实现。当.confirm原语被实现为`本地确认`时，结果t表示DLMS/COSEM TL是否能够`缓冲发送`APDU或`发送`APDU。当它作为`远程确认`实现时，结果表明APDU是否已`成功交付`到目的地。

#### 7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls

##### 7.2.5.1 Transport layer and TCP connection establishment

![messages](/assets/img/2022-03-17-dlms-green-1/tcphandshake.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/tcpmsc.jpg)

##### 7.2.5.2 Closing a transport layer and a TCP connection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpmscclose.jpg)

##### 7.2.5.3 TCP connection abort

![messages](/assets/img/2022-03-17-dlms-green-1/tcpabort.jpg)

通过TCP Wrapper层轮询TCP层状态

##### 7.2.5.4 Data transfer using the TCP-DATA service

![messages](/assets/img/2022-03-17-dlms-green-1/tcpsenddata.jpg)

`AL层`通过request原语发送一个`992`字节的`APDU`，`Wrapper层`加上`8字节`的头，第一次发送`1000`字节，实际一包发出去476字节，还剩524字节，以此类推`直到发完`，向AL层回复confirm原语。该过程由Wrapper层控制。

![messages](/assets/img/2022-03-17-dlms-green-1/tcpwrapperreceive.jpg)

Wrapper层接收到完整的wrapper头+APDU后，解开wrapper头，将APDU放在`TCP-DATA.ind`原语中发送给AL层。

### 7.3 The DLMS/COSEM CoAP based transport layer

#### 7.3.2 Overview

受限应用协议 (Constrained Application Protocol,`CoAP`) 是由 IETF 核心工作组定义的专用互联网应用协议。 CoAP 专为在`资源受限`的设备中使用而设计，用于通过非受限或受限的互联网通信网络（例如，`低功耗`、`有损网络`）进行通信。 CoAP 旨在提供高效的数据传输能力，同时满足`可靠性`、`多播支持`、`极低开销`、`效率`和`简单性`等特殊要求。

基于CoAP的`DLMS/COSEM CoAP TL`提供`不可靠`和`可靠`的传输服务(CoAP原来是属于`应用层`的，这里DLMS协议里把它做成了`传输层`，用来给AL提供服务)。`不可靠`的CoAP服务支持`组播`和`广播`。DLMS/COSEM CoAP TL为服务用户DLMS/COSEM AL提供`OSI风格`的服务。

![messages](/assets/img/2022-03-17-dlms-green-1/coaposi.jpg)

整个`DLMS/COSEM CoAP TL`层包括了Wrapper层、CoAP层、UDP层，和标准OSI模型中的不同

#### 7.3.3 Structure of the DLMS/COSEM CoAP transport layer

![messages](/assets/img/2022-03-17-dlms-green-1/coaplayer.jpg)

`DLMS/COSEM CoAP TL`提供`不可靠`和`可靠`的运输服务。不可靠的DLMS/COSEM CoAP传输服务使用`non-confirmable (NON)` CoAP消息，而可靠的DLMS/COSEM CoAP TL服务使用`confirmable (CON)` CoAP消息，并带有CoAP消息层提供的`重试机制`。

CoAP wrapper层提供的服务：

- 通过与`CoAP请求/响应层`操作的交互，将`OSI风格`的数据服务`原语`(CoAP-DATA)传递给`DLMS/COSEM AL`，以实现`CoAP POST方法`的使用
- DLMS/COSEM`服务接入点寻址`功能，从而允许`多个`DLMS/COSEM `AEs`驻留在物理设备的同一个CoAP客户机和服务器端点上

##### 7.3.3.2 Identification and addressing

识别与寻址

TODO: 结合Bluebook 4.9 关于CoAP配置的对象

###### 7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer

一个CoAP端口可以为`不同的应用`（如除了DLMS的应用）提供服务，用`URIPath`区分(CoAP类似于HTTP，可以通过URI区分接入点)，IANA规定的默认端口为5683

默认情况下，DLMS/COSEM AL，无论是DLMS客户端AL还是DLMS服务器AL，都使用`URIPath`: "`DLMS`"

###### DLMS/COSEM CoAP transport layer SAPs

![messages](/assets/img/2022-03-17-dlms-green-1/coapsap.jpg)

#### 7.3.4 Service specification for the DLMS/COSEM CoAP transport layer

![messages](/assets/img/2022-03-17-dlms-green-1/coaploop.jpg)

`远程环回确认`(正面（正面的意思就是传输成功的情况）的TL确认，用于`可靠`传输)，表示报文被`远端`确认，确认发送给本地CoAP client，再由`本地wrapper层`返回给AL层confirm原语

TODO:CoAP的可靠传输,7.3.3也有提到

`本地环回确认`(负面（负面的意思就是失败的情况，比如发生了什么错误）的TL确认，用于`可靠和不可靠`传输，可靠传输中可能是对方超时没回确认，视为失败，不可靠传输中可能是udp层有错误导致调用发送函数失败，视为失败)，用于失败的情况，由`本地CoAP client`返回给wrapper层错误信息，`本地wrapper层`返回给AL层confirm原语

##### 7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives

###### 7.3.4.2.1 CoAP-DATA.request

```asn.1
CoAP-DATA.request
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Remote_Path [Optional Use],
    Response_Mode,
    Request_ID [Optional Use],
    Data_Length,
    Data
)
```

- `Transport_Mode`: CoAP传输模式，“RELIABLE”可靠，“UNRELIABLE”不可靠
- `Remote_Path`： CoAP `Uri-Path`。Response_Mode为“RESPONSE”忽略该参数
- `Response_Mode`：表示是否期望返回DLMS/COSEM响应APDU。它取值:"`CONFIRMED`"， "`UNCONFIRMED`"， "`RESPONSE`"。
- `Request_ID`：标识了特定的数据请求操作。Request_ID将在可能产生的`CoAP-DATA.confirm`原语中返回，表明DLMS/COSEM CoAP TL`传送数据`参数中给出的APDU的`成功或失败`。Request_ID被指定为支持在`已发送多个`携带请求的APDU且DLMS/COSEM CoAP TL确认尚未完成的情况下，以`每个`APDU为基础返回DLMS/COSEM CoAP TL`确认`(类似于TCP的`滑动窗口`，可以`异步确认`)。以下情况适用:

  - 如果Request_ID未被指定，CoAP-DATA.confirm原语中Request_ID也不被指定。
  - 如果Transport_Mode被设置为`UNRELIABLE`，并且DLMS/COSEM CoAP TL实现`不支持`这种操作模式的CoAP-DATA.confirm原语，那么Request_ID可以不被指定。
  - 如果DLMS/COSEM CoAP TL服务`不支持`CoAP-DATA.`confirm`原语，CoAP wrapper将`忽略`指定的Request_ID标识。

**使用场景**：

- 发送`DLMS/COSEM请求`（单播或多播广播）：

  - `Remote_Path`指定为对方Uri-Path
  - `Local_Port and Local_IP_address`可选
  - `Response_Mode`：

    - `需确认`的请求，使用`CONFIRMED`
    - `无需确认`的请求，使用`UNCONFIRMED`
    - General Block Transfer(`GBT`)`分块传输`的请求,视情况，比如`单播或广播`，可用`CONFIRMED或UNCONFIRMED`

- 发送`DLMS/COSEM响应`（也为CoAP-DATA.request，只要是发送就是，和AL层的报文类型无关）：

  - `Remote_Path不指定`
  - `Local_Port and Local_IP_address`需要指定，和请求匹配
  - Transport_mode, Local_SAP, Remote_SAP, Remote_IP_address, Remote_Port需匹配请求
  - `Response_Mode`：

    - 一般为`RESPONSE`
    - APDU为GBT时，为`CONFIRMED`，Remote_Path需指定（TODO:这不是和上面说的不指定矛盾了吗）

###### 7.3.4.2.2 CoAP-DATA.indication

```asn.1
CoAP-DATA.indication
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address,
    Local_Port,
    Remote_IP_address,
    Remote_Port,
    Data_Length,
    Data
)
```

- Transport_Mode: CoAP传输模式，“RELIABLE”可靠，“UNRELIABLE”不可靠

###### 7.3.4.2.2 CoAP-DATA.confirm

```asn.1
CoAP-DATA.confirm
(
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Request_ID [Optional Use],
    Result
)
```

- Local_SAP：本地DLMS/COSEM AE的SAP
- Request_ID：对应的CoAP-DATA.request中携带的，如果request没有指定就是未定义
- Result：“REMOTE OK”表示远端已接收，“NOT OK”表示发送失败

**使用场景**：

CoAP-DATA.confirm由wrapper层生成

对于不可靠的传输模式，Result没有“REMOTE OK”远程确认，但可以生成“NOT OK”表示本地错误，该原语是可选的

#### 7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer

##### 7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU)

![messages](/assets/img/2022-03-17-dlms-green-1/coaplayer2.jpg)

`DLMS/COSEM CoAP TL PDU`是一个`UDP数据报`，携带`CoAP消息`作为其`有效载荷`。该CoAP消息携带`CoAP头`和DLMS/COSEM CoAP Wrapper PDU（`CWPDU`）。CWPDU携带DLMS/COSEM `APDU`作为其有效载荷加上DLMS/COSEM CoAP `TL控制信息`，。

##### 7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU)

DLMS/COSEM CoAP包装协议数据单元(`CWPDU`)由一个可选的`DLMS/COSEM CoAP包装头`和它的有效负载`APDU`组成。

只有在`CoAP请求`中携带APDU时，CoAP包装器才使用`DLMS/COSEM CoAP包装器报头`。当APDU在`CoAP响应`中携带时，CWPDU中`不包含`DLMS/COSEM CoAP包装头，因为相关的CoAP包装头内容(本地和远程SAP)可以在接收CoAP包装层从CoAP包装头请求/响应`上下文`的状态中`提取`出来(区别于TCP或UDP传输层的包装器，CoAP包装器的报头在响应时是可以省略的)。

![messages](/assets/img/2022-03-17-dlms-green-1/coapcwpdu.jpg)

- The DLMS/COSEM CoAP TL version：TL版本号，0-15，目前为0
- Reserved bits：保留
- The CoAP Wrapper Response Mode (WRM)：是否期望收到AL层响应，（比如上报就是不期望AL层响应）
- Remote SAP：接收站点的SAP
- Local SAP：发送站点的SAP

##### 7.3.5.4 The Constrained Application Protocol (CoAP)

###### 7.3.5.4.2 The CoAP Message

CoAP消息以简单的`二进制格式`编码。消息由一个固定大小的`4字节头`、一个`可变长`度的`Token值`(0-8字节)、`0个或多个tlv编码`的选项(可选地)和`负载`组成。

一个`非空的CWPDU`作为`有效负载`在CoAP消息中携带。

![messages](/assets/img/2022-03-17-dlms-green-1/coapprotocol.png)

本节其实就是介绍标准coap协议，可以看其他文章，见[CoAP学习笔记（1）CoAP报文结构](https://blog.csdn.net/weixin_41572450/article/details/103549125)

DLMS/COSEM CoAP TL层只用到了其中的一部分的code

- CoAP Request method codes

  在`DLMS/COSEM CoAP TL`的`CoAP消息`中使用的请求方法代码如下

  |Request|method|Meaning Use|
  |:---:|:---:|:---:|
  |0.02|POST method|发送`新的`包含CWPDU的`请求或响应`|
  |0.00|空报文ACK message without piggybacked response|在可靠传输中用于`ACKs`确认，不带响应|
  
  TODO:为什么响应也算post

- CoAP Success Response codes
  
  |Success Response code|Meaning|Use|
  |:---:|:---:|:---:|
  |2.04|Success (Changed)|对`已存在`的请求/响应回复包含CWPDU的`响应`|

  TODO:是否可以这么理解：和上面post的区别是，这个回应是要有请求对应的，而不是向上报那种没有请求的直接上报。

客户端错误和服务器`错误响应代码`由`CoAP协议层`或`CoAP包装器`根据错误条件`填充`

- Token(可选，TKL指定是否存在)

  令牌用于配置响应和请求

- Token Length(TKL指定)

  建议DLMS/COSEM CoAP TL实施的CoAP请求/响应层使用的令牌长度限制为`0-4字节`，以平衡令牌传输成本和上下文不匹配的风险，或者当令牌在相同的CoAP端点之间重复使用时可能出现的重复检测失败。进一步参考RFC 7252。

  DLMS服务器的DLMS/COSEM CoAP TL的CoAP协议层使用的Token长度可在`CoAP设置对象`中指定，见DLMS UA 1000-1 Part 2 Ed.15:2021, 4.9.8。

- Options

  Options也只用到了标准中的一部分,当然没有规定只能用这些，但要保证双方能处理这些选项
  
  ![messages](/assets/img/2022-03-17-dlms-green-1/coapoption.jpg)

  - `Uri-Path`: CoAP uri路径，默认是dlms
  - `Content-Format`：允许的传输格式，和HTTP类似，可以不指定，因为默认都是`application/octet-stream`
  - `Block1` and `Block2`：在RFC 7959中新增的两个option，用于表示分块传输，见7.3.5.4.5，另见[CoAP分块传输](https://zhuanlan.zhihu.com/p/461498161)TODO:查看该文档

###### 7.3.5.4.3 CoAP retransmission and response piggybacking

当CWPDU在`可靠`的CoAP消息层支持的新CoAP请求/响应上下文中传输时（即通过可确认的（CON）CoAP消息），那么，正如RFC 7252所规定的，CoAP消息层将继续`重传`CoAP请求消息，直到它被CoAP服务器终端`确认`。这可以是单独的`CoAP确认消息ACK`的返回形式，也可以是`附带`CWPDU或错误响应的`piggybacked ACK消息`

>关于[piggybacking技术](https://en.wikipedia.org/wiki/Piggybacking_(data_transmission))：
>
>在双向通信中，每当收到帧时，`接收方`都会`等待`，并且`不会立即`将控制帧（`确认`或`ACK`）发送回`发送方`。
>
>`接收方等待`，直到其网络层传入下一个`数据包`。然后，`延迟的确认`将`附加`到此传出数据帧。
>
>这种暂时`延迟确认`以便可以与下一个传出数据帧挂钩的技术称为`piggybacking`。
>
>`优点`：提高效率，更好地利用可用信道带宽。
>
>`缺点`：如果`接收方``没有要发送`的内容，则接收器可能会`阻塞`服务。这可以通过在接收到数据帧时启用计数器（`接收器超时`）来解决。如果`计数结束`并且没有要发送的数据帧，则`接收方将发送 ACK` 控制帧。`发送方`还会添加一个`计数器`（发送器超时），如果计数器在没有收到`确认`的情况下结束，则发送方将假定数据包丢失，然后`再次发送`帧。
>
>该技术主要是为了`减轻网络负担`,这个附带内容可以是接收器对于`上一帧的回复`（如果处理快的话也可以是本次请求的回复），也可以是`主动上报`等

CoAP层会考虑使用`piggybacking`的可能性，`ACK`会`延时发送`，直到本地wrapper层收到AL层的数据并打包成CWPDU或超时，再发送`附带或不附带数据`的`ACK`。要是超时的话这个CWPDU单独发送，不附带在这个ACK中

7.3.5.4.3.2 **CoAP Retransmission Parameters**

DLMS/COSEM CoAP TL中的可靠CoAP消息传递层使用许多参数来控制RFC 7252定义的CoAP重传算法。这些参数在CoAP setup interface class类中指定

- ack_timeout

  需确认消息的最小初始ACK超时
  
  `initial_ack_timeout`是在`ack_timeout`和`ack_timeout x ack_random_factor`之间`随机选择`的值。
  
  `initial_ack_timeout`是可靠的CoAP消息层的`初始重传延迟`。
- ack_random_factor

  用于申请初始ACK超时随机性的随机因子。
- max_retransmit

  需确认消息的最大重传次数。
- delay_ack_timeout

  CoAP 消息传递层在`返回确认`之前`等待`应用层返回响应的时间（以毫秒为单位）

  (TODO:是不是和piggybacking相关的)

7.3.5.4.3.3 **CoAP Congestion Control Parameters**

拥塞控制

- NSTART

  以下任一形式的同时`未完成`的 CoAP 请求消息的`数量`：

  - 没收到ACK的CON消息(需确认消息)
  - 没收到响应的NON消息(无需确认消息)
- PROBING_RATE

  探测速率

  定义一个端点发送到另一个没有响应的端点时不应超过的平均`数据速率`(字节/秒)。

  TODO：这个参数有什么用

###### 7.3.5.4.5 CoAP Block Transfer

见7.3.5.4.2

在APDU大于MTU，且小于receiver_max_pdu_size时生效（大于receiver_max_pdu_size本身就不合法，TODO:这个是应用层的限制，传输层是怎么知道的，需要做限制吗）

TODO:为什么是APDU大于MTU，MTU不是链路层的限制吗

DLMS/COSEM CoAP TL中的CoAP块传输层应按照`RFC 7959`的建议，在没有不当延迟的情况下完成CoAP块传输

##### 7.3.5.5 Error Handling

###### 7.3.5.5.2 CoAP protocol layers

CoAP`消息层`或`请求/响应层`的错误通过`重置消息`(名词)或CoAP协议层实体根据RFC 7252和RFC 7959`自动生成`的CoAP客户端和服务器`错误响应`传递给发送的CoAP实体

###### 7.3.5.5.3 CoAP wrapper layer

`wrapper层`的`错误处理`，就是从一个wrapper层发给另一个wrapper层

- Unreliable CoAP transport `不可靠传输`

  一般是多播，wrapper将接收到的不能处理的CWPDU`丢弃`

  TODO:wrapper层是不是通过CWPDU中的客户端SAP参数知道是否是多播的

- Reliable CoAP transport `可靠传输`

  接收端wrapper层无法处理接收到的CWPDU(由CoAP request携带)时返回错误

  这种错误响应可能有助于诊断，也可能有助于主动纠正措施。通常，当传入的请求由于`语法错误`而无法提供服务时，将返回`CoAP客户端错误`(类似HTTP状态码里的4xx表示客户端错误，5xx表示服务器错误，[HTTP状态码](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81))，而当CoAP包装器`无法处理`明显`有效`的请求时，将返回`CoAP服务器错误`

  ![messages](/assets/img/2022-03-17-dlms-green-1/coapwrappererror.jpg)

###### 7.3.5.5.4 Propagation of errors through CoAP wrapper layer

返回到发送端CoAP协议层的错误响应应该以所产生的`CoAP消息层交付失败`（见下）的形式传播到`发送端CoAP包装器`，或者以`返回的错误本身`的直接形式传播，`无论`它们是由`接收CoAP协议层`还是由`接收CoAP包装器层`产生的。

- CoAP消息层交付失败原因：

  - 接收到重置消息
  - 放弃CoAP block transfer操作
  - 可靠CoAP消息传递层放弃可靠传输的CoAP消息
  - CoAP层错误或UDP或IP层错误

如果是可靠传输，CWPDU的交付失败必须从协议层传播到wrapper层，以便其酌情通知AL层。

TODO:有点看不懂

##### 7.3.5.6 DLMS/COSEM CoAP TL confirmations

`CoAP包装器请求/响应上下文`（见7.3.5.7）对于在本地发起的CoAP请求/响应上下文中传送的任何`未完成`的CWPDU（还没有收到CoAP响应）`保持`给定`Request_ID`的`状态`，以便wrapper层在返回`负面`（比如有错误发生）或`正面`（比如传输成功）的DLMS/COSEM CoAP TL确认时可以用CoAP-DATA.confirm原语向AL层返回Request_ID。

对于`不可靠`的DLMS/COSEM CoAP TL，这个是`可选的`，也就是无需维护维护Request_ID的状态。也只能回复`负面`的确认（无需正面确认，因为不可靠就是无确认的）

- CoAP传输层错误指示

  如果**CoAP包装器从CoAP协议层**`收到`在本地发起的CoAP请求/响应上下文中传输的CWPDU的`交付失败指示`，则`CoAP包装器`通过CoAP-DATA.confirm 原语（结果为 "`NOT OK`"）和与CoAP-DATA.request 原语中的APDU提供的Request_ID相匹配的`Request_ID`来传达相关APDU的`交付失败`。参见7.3.5.7.5。

- CoAP传输层确认

  支持 DLMS/COSEM CoAP TL 确认，如果接收端的AL层不会对这条报文回确认，那这个确认可以由接收端传输层自己生成并回复(AL层面无需响应，也就不会回响应，但传输层可靠传输层面需要确认)。使用带有 push_operation_method (1) 的`无需确认` DataNotification 的`可靠数据推送`操作需要 DLMS/COSEM CoAP TL 确认。 参见 DLMS UA 1000-1 第 2 部分 Ed.15:2021, 4.4.8.2.2.11)。

  CoAP 包装层支持 DLMS/COSEM CoAP TL 确认，用于在 CoAPDATA.request 原语中以 Response_Mode = UNCONFIRMED 和 Transport_Mode = RELIABLE 提供的 APDU。

  TODO:可靠传输不是靠CoAP的ACK吗，为什么还要单独再搞个wrapper层的确认

  过程：

  1. 在 `Response_Mode = UNCONFIRMED` 的 CoAP-DATA.request 原语中提供给 CoAP 包装器的 APDU 应由 CoAP 包装器在 CoAP 包装器响应模式设置为 1 的 CWPDU 中的新本地发起 CoAP 请求/响应上下文中传输（`WRM = 1`)（WRM见7.3.5.2，关于CWPDU的定义）。 这指示接收 CoAP 包装器`不要等待`返回 DLMS AL 响应或 DLMS AP 响应；
  2. 接收 CoAP 包装器应在将接收到的嵌入的 APDU 成功交付给 DLMS AL 时，当通过`可靠` CoAP 消息传递层 在 `WRM = 1` 的 CWPDU 中接收到 APDU 时，`返回`一个`空的 CWPDU` 作为对发送 CoAP 包装器的`成功响应`实体
  3. 对于WRM = 1接收到的CWPDU的错误处理遵循上面描述的一般错误处理

##### 7.3.5.7 CoAP wrapper state machine

wrapper层状态机

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperstate.jpg)

- `空闲`：`关闭状态`，没有关联状态，CoAP 请求/响应层中`没有`相应的 CoAP 请求/响应上下文

- `客户端等待模式`：接收到AL层传来的CoAP-DATA.req，直到把该req处理完，进入Idle模式。

- `服务器等待模式`：接收CoAP层传来的非空且无需确认（WRM=0，wrapper报头中的一个参数，wrapper层面无需确认）消息，直到将CoAP-DATA.req发送给AL层

- `服务`：接收到CoAP层传来的非空且需确认消息（WRM=1，wrapper层面需确认）

###### 7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context

在`客户端等待模式`状态下维护的`参数`取自 `CoAP-DATA.request` 服务原语的服务参数(AL层发来的)

在`服务器等待模式`和`服务状态`下维护的`参数`取自较低的 `CoAP 协议层`和传入 CWPDU 的 `CWPDU 标头`(远端客户端发来的)

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperparam1.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperparam2.jpg)

- 服务器等待模式到空闲状态：

  在服务器等待模式下收到AL层传来的`CoAP-DATA.request`原语，且该原语中的Transport_Mode, the Local SAP, the Remote SAP, the Local_IP_address, the Local_port, the Remote_IP_address and the Remote_Port`参数与当前wrapper层上下文中的对应`

  >结合前文描述，wrapper层如果需确认，WRM=1，则通过回空消息CWPDU的方式传递wrapper层确认，否则是不需要确认，直接等待AL层响应把完整的传递回去

- 客户端等待模式到空闲状态

  收到失败信息或成功信息（比如需确认模式下空的CWPDU）

TODO:后面的内容稍后再补

## 8 Data Link Layer using the HDLC protocol

### 8.1 Overview

本章指定数据链路层为三层，`面向连接`，`基于HDLC`，`异步通信配置文件`。

本规范支持以下通信环境:

- 点对点和点对多点配置
- 专用和交换数据传输设施
- 半双工和全双工连接
- 异步 启动/停止 传输，1个启动位，8个数据位，无奇偶校验，1个停止位

#### 8.1.2 Structure of the data link layer

为了确保面向连接和无连接两种操作模式都有一致的数据链路层服务规范，数据链路层被划分为两个子层:`逻辑链路控制(LLC)`子层和`媒体访问控制(MAC)`子层

[LLC层](https://zh.wikipedia.org/zh-hans/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6)

- 类型1：`无连接`。该方式对信息的发送通常无法保证接收。
- 类型2：`面向连接`。该方式提供了四种服务：连接的`建立`、确认和承认`响应`、`差错恢复`（通过请求重发接收到的错误数据实现）以及`滑动窗口`（系数：128）。通过改变滑动窗口可以提高数据传输速率。
- 类型3：`无连接承认响应服务`。

类型1的 LLC 无连接服务中规定了一种静态帧格式，并支持运行网络协议。有关`传输层网络协议`通常是使用服务类型1方式。

类型2的 LLC 面向连接服务支持可靠数据传输，运用于`不需要`调用网络层和传输层协议的局域网环境。(相当于把TCP层的事情干了)

[MAC 子层](https://blog.csdn.net/dadoneo/article/details/8315833)（该数据链路层规范的主要部分）基于 ISO/IEC 13239。与原始 HDLC 标准相比，该标准的`第二版`包括许多增强功能，例如在`寻址`、`错误保护`和`分段`。 `第三版`采用了一种新的帧格式，可满足`电表`和类似行业`遥测应用`中的环境要求。

MAC子层的主要功能包括数据`帧的封装/卸装`，`帧的寻址和识别`，帧的`接收与发送`，`链路的管理`，帧的`差错控制`等。MAC子层的存在屏蔽了不同物理链路种类的差异性;非常重要的一项功能是仲裁`介质的使用权`，即规定站点何时可以使用通信介质。实际上，局域网技术中是采用具有冲突检测的`载波侦听多路访问`（Carrier Sense Multiple Access /
Collision Detection，`CSMA/CD`）这种介质访问方法的。

为本技术报告的目的，已从 HDLC 标准中做出以下选择：

TODO:后面都看不懂

#### 8.1.3 Specification method

数据链路层的子层根据服务和协议(services and protocols)进行划分

TODO:等第8章看完之后完善

### 8.2 Service specification

本节规定了服务用户层使用`面向连接`的程序对数据链路层`要求`的服务。

事实上，所有 DL 服务都由 MAC 子层提供：LLC 子层将 DL-CONNECT.xxx 服务原语作为适当的 MA-CONNECT.xxx 服务原语`透明地传输`到“真实”服务提供者 MAC 子层或从“真实”服务提供者 MAC 子层传输。

由于客户端和服务器端 LLC 和 MAC 子层不同，因此为双方指定了服务原语。

MAC 子层的寻址方案在 8.4.2 中规定。



## 参考

