---
title: "DLMS Green Book学习笔记"
author: Jinkai
date: 2022-04-19 09:00:00 +0800
published: true
math: true
categories: [技术]
tags: [C++, DAO, database]
image:
  src: /assets/img/2022-03-17-dlms-green-1/dlms.jpg
  alt: image alternative text
---

## 1 Scope

1. `建模`: 包括设备的`接口模型`和数据识别规则;在blue book 中定义
2. `消息传递`: 这涵盖了将接口模型`映射`到协议数据单元(APDU)的服务，以及这个APDU的`编码`。在本green book中定义
3. `传输`: 通过通信通道`传输消息`。在本green book中定义

## 3 Terms, definitions and abbreviations and symbols

通信模型：

![comm-module](/assets/img/2022-03-17-dlms-green-1/DLMS1.png)

## 4 Information exchange in DLMS/COSEM

### 4.1 General

The key characteristics of data exchange using DLMS/COSEM are the following:

- devices can be accessed by various parties: clients and third parties;

    使用DLMS/COSEM进行数据交换的主要特点如下:设备可以被各种各方访问:客户端和第三方;

- mechanisms to control access to the resources of the device are provided;

    提供了控制对设备资源的访问的机制;

- these mechanisms are made available by the DLMS/COSEM AL and the COSEM objects ( Association SN / LN object, Security setup object);

    这些机制是由DLMS/COSEM AL和COSEM对象(关联SN / LN对象，安全设置对象)提供的;

- security and privacy is ensured by applying cryptographical protection to xDLMS messages and to COSEM data;

    通过对xDLMS消息和COSEM数据应用加密保护来确保安全性和私密性;

- low overhead and efficiency is ensured by various mechanisms including selective access, compact encoding and compression;

    通过各种机制，包括选择性访问、压缩编码和压缩，确保了低开销和效率;

- at a site, there may be single or multiple devices.

    在一个站点，可能有单个或多个设备。

- In the case of multiple devices at a site, a single access point can be made available;

    在一个站点有多个设备的情况下，可以提供一个单一的接入点;

- data exchange may take place either remotely or locally.

    数据交换可以在远程或本地进行。

- Depending on the capabilities of the device, local and remote data exchange may be performed simultaneously without interfering with each other;

    根据设备的能力，本地和远程数据交换可以在不相互干扰的情况下同时进行;

- various communication media can be used on local networks (LN), neighbourhood networks (NN) and wide area networks (WAN).

    各种通信媒体可用于局域网(LN)、邻网(NN)和广域网(WAN)。

### 4.2 Communication model

application processes(`APs`)之间的通信通过`应用程序实体`(application entities,`AEs`)之间的通信进行建模。AE代表AP的`通信功能`。

AP中可能有多组OSI通信功能，因此`一个AP`可以用`多个AEs`来表示

一个`server AP`对应一个`logical device`,`client AP`可以不对应logical device。`每个AP`绑定一个Service Access Point(`SAP`)，`SAP`位于application layer(`AL`)层。**也就是说SAP用于区分基于同一个AL的不同AP**(对服务端也可以说是logical device).

### 4.3 Naming and addressing

![comm-module](/assets/img/2022-03-17-dlms-green-1/address.jpg)

#### 4.3.3 Addressing

![comm-module](/assets/img/2022-03-17-dlms-green-1/sap.jpg)

SAP用于区分基于同一个AL的不同AP

#### 4.3.4 systemtitle

- 按单一DLMS/COSEM实体唯一，和逻辑设备名不同，一个实体可以有多个逻辑设备(名)，但只能有一个systemtitle,实体中的逻辑设备共享该systemtitle
- 固定8字节长，前3字节厂家ID，和逻辑设备名相同，后面的5字节，应为0-999,999,999,999(0x0-0xE8D4A50FFF)

#### 4.3.5 逻辑设备名

蓝皮书 part2 4.1.8

### 4.4 Connection oriented operation

- Phase 1: AA establishment
- Phase 2: Message exchange
- Phase 3: AA Release

`预连接AA`不需要1和3

### 4.5 Application associations

A COSEM logical device may support one or more AAs, each with a different client. Each AA determines the contexts in which information exchange takes place.

一个COSEM逻辑设备可以支持一个或多个AAs，每个AAs有一个`不同的客户端`。每个AA决定发生信息交换的上下文。

A confirmed AA is proposed by the client and accepted by the server provided that:

- confirmed AA:

  `确认AA`由客户端提出并被服务器`接受`，前提是

  - the user of the client is known by the server, see 4.3.6;

      客户端用户为服务器所知，见4.3.6;

  - the application context proposed by the client see 4.5.2 is acceptable for the server;

      客户端在4.5.2中提出的应用上下文对于服务器来说是可接受的;

  - the authentication mechanism proposed by the client see 4.5.3 is acceptable for the server and the authentication is successful;

      客户端(见4.5.3)提出的认证机制对服务器来说是可接受的，认证是成功的;

  - the elements of the xDLMS context see 4.5.4 can be successfully negotiated between the client and the server.

      xDLMS上下文的元素参见4.5.4可以在客户端和服务器之间成功协商。

  An unconfirmed AA is also proposed by a client with the assumption that the server will accept it. No negotiation takes place. Unconfirmed AAs are useful for sending broadcast messages from the client to servers

- unconfirmed AA:

  客户端也会提出`未经确认的AA`，并假设服务器会接受它。 没有谈判发生。 未确认的 AA 对于从客户端向服务器发送`广播消息`很有用。

#### 4.5.2 Application context

应用程序上下文确定：

- AL 中存在的一组应用服务元素（Application Service Elements,ASEs）
- COSEM 对象属性和方法的引用方式：短名称(SN) 引用或逻辑名称(LN) 引用。 另见 9.1.4.3.1
- 传输语法
- 是否使用加密

#### 4.5.3 Authentication

DLMS中的认证发生在AA建立阶段

- In confirmed AAs either the client (unilateral authentication) or both the client and the server (mutual authentication) can authenticate itself.

    在`已确认aa`中，客户端(单向认证)或客户端和服务器(相互认证)都可以对对端进行认证。
- In an unconfirmed AA, only the client can authenticate itself.

    对于`未确认AA`，只有客户端可以验证对端。
- In pre-established AAs, authentication of the communicating partners is not available.

    在`预连接AA`中，身份验证不可用。

#### 4.5.4 xDLMS context

xDLMS上下文确定可以在给定的AA中使用的xDLMS服务和功能集。见9.1.4。

#### 4.5.5 Security context

当应用程序上下文规定加密时，安全上下文是相关的。 它包括`安全套件`、`安全策略`、`安全密钥`和`其他安全材料`。 另见 9.2.2.3。 它由“`Security setup`”对象管理。

#### 4.5.6 Access rights

访问权限确定客户访问 AA 内的 COSEM 对象属性和方法的`权限`。 访问权限集取决于`客户端的角色`，并在服务器中`预先配置`。 另见 9.2.2.4。

### 4.6 Messaging patterns

![messages](/assets/img/2022-03-17-dlms-green-1/messagepatterns.jpg)

在`已确认AA` 中：

- 客户端可以发送确认的服务请求，服务器响应：`pull操作`
- 客户端可以发送未经确认的服务请求。 服务器没有响应
- 服务器可以向客户端发送未经请求的服务请求：`push操作`

> note:主动推送的服务可以是 InformationReport（使用 SN 引用）、EventNotification（使用 LN 引用）或 DataNotification（同时使用 SN 和 LN 引用）。

在`未确认AA` 中：

- 只有客户端可以发起服务请求，并且只有未确认的请求。 服务器无法响应，也无法发起服务请求。

### 4.8 Communication profiles

通信配置文件指定了 *`DLMS/COSEM AL`* 和*建模Application Process (AP) 的 `COSEM 数据模型`*如何由较低的通信媒体特定协议层支持。

通信配置文件包括许多`协议层`。 每一层都有不同的任务并为其上层`提供服务`并使用其支持协议层的服务。 客户端和服务器 `COSEM AP` 使用最高协议层的服务，即 `DLMS/COSEM AL` 的服务。 这是唯一包含 COSEM 特定元素(`xDLMS ASE`)的协议层； 见 9.1.4。 任何能够提供 DLMS/COSEM AL 所需服务的层都可以支持它。 较低层的数量和类型取决于所使用的通信媒体。

### 4.9 Model of a DLMS/COSEM system

设备被建模为`一组逻辑设备`，托管在`单个物理设备`中。 **每个逻辑设备代表一个服务器 AP**，并对`设备功能`的一个`子集`进行建模，这些功能子集可以通过其通信接口看到。使用COSEM对象对各种功能进行建模。

![messages](/assets/img/2022-03-17-dlms-green-1/model.jpg)

`数据采集系统`被建模为`一组客户端ap`，可以由一个或多个物理设备托管。每个客户端AP可能有不同的角色和访问权限，由设备授予。
`公共客户端`和`管理逻辑设备`APs有一个特殊的角色，它们应该一直存在。

### 4.10 Model of DLMS servers

- IP based profiles:

`DLMS/COSEM AL`由DLMS/COSEM Transport layer(`TL`)支持，该TL由internet TCP或UDP层和一个包装器(wrapper)组成(TODO:是不是47协议?)。`包装器`的主要作用是适应`OSI风格`的服务集，该服务集由DLMS/COSEM TL在TCP和UDP函数调用`之间`提供。它还为逻辑设备提供寻址，将它们`绑定`到一个称为包装器端口的`SAP`。`管理逻辑设备`总是绑定到包装器端口`0x01`。最后，`包装器`提供有关APDU传输`长度的信息`，以帮助对等端识别APDU的`末端`。由于TCP的流特性，这是必要的。

如果没有包装器这层，APDU直接通过TCP发出去，由于TCP是`流式`的，APDU不包含`头尾信息`，对端不知道是否是个`完整`的APDU`无法解析`

- 3-layer,CO,HDLC based profile:

`DLMS/COSEM AL` 由基于 `HDLC` 的数据链路层支持。 它的主要作用是在对等层之间提供可靠的数据传输。 它还以这样一种方式提供逻辑设备的`寻址`，即每个逻辑设备都`绑定`到`单个 HDLC 地址`。 管理逻辑设备始终绑定到地址 0x01。 为了允许创建一个`本地网络`，以便通过一个`单一的接入点`可以到达特定站点的`几个设备`，另一个地址，即`物理地址`也由数据链路层提供。(TODO:这个是和client区别的地方，是什么意思？)。 逻辑设备地址被称为高HDLC地址，而物理设备地址被称为低HDLC地址。 另见 8.4.2

TODO：HDLC层相关

### 4.11 Model of a DLMS client

![messages](/assets/img/2022-03-17-dlms-green-1/modelclient.jpg)

与服务器端不同，HDLC层提供的寻址只有一个级别，即每个应用程序流程(AP)的服务接入点(SAP)的级别。

客户端AP和服务器端AP由各自的`sap`识别，因此，客户端和服务器端AP之间的`AA`可以由`一对`客户端和服务器端`sap`识别。

### 4.12 Interoperability and interconnectivity in DLMS/COSEM

互操作性和互联性

- Interoperability：

双方的COSEM对象定义相同，都使用DLMS/COSEM AL层

- interconnectivity：

AEs互通，AE就是AL以下的层。如果两个AEs使用相同的`通信配置文件`，则它们是可互连的

### 4.13 Ensuring interconnectivity: the protocol identification service

`协议识别服务`

在DLMS/COSEM中，AA的建立总是由`客户端AE`发起。然而，在某些情况下，它可能`不了解`未知服务器设备所使用的`协议栈`（例如，当服务器启动物理连接建立时）。在这种情况下，客户端AE需要获得关于服务器中实现的`协议栈的信息`。
为此，提供了一种特定的应用级服务：`协议识别服务`。它是一种可选的应用级服务，允许客户机AE在建立物理连接后获得关于服务器中实现的协议栈的信息。5.3.3.3中规定的协议识别服务直接使用PhL的数据传输服务（`PH-DATA`.request /.indicat）；它绕过了其他协议层。建议在所有可以访问PhL的通信配置文件中支持它。

### 4.14 System integration and installation

`系统集成和安装`

DLMS/COSEM以多种方式支持系统集成。这里描述了一个可能的过程。

如图7所示，`Public Client`(在任何配置文件中绑定到地址`0x10`)在每个客户端系统中都是必需的。它的主要作用是揭示一个`未知的`--例如`新安装`的--设备的结构。这发生在公共客户端和管理逻辑设备之间的`强制AA`中，没有安全预防措施。一旦知道了结构，就可以使用`适当的身份验证机制`和xDLMS的`密码保护`来访问数据

当`系统`中安装了`新设备`时，可能会`向客户端`生成`事件报告`。一旦检测到这一点，客户机就可以检索设备的`内部结构`，然后向设备发送必要的`配置信息`(例如关税时间表和特定于安装的参数)。这样，设备就可以使用了

## 5 Physical layer services and procedures for connection-oriented asynchronous data exchange

物理层

### 5.1 Overview

- 通信是点对点或点对多点
- 至少可以有半双工连接
- 异步传输1位起始位，8位数据位，无奇偶校验和1位停止位(8N1)

### 5.2 Service specification

#### 5.2.1 List of services

- 建立/发布相关业务  PH-CONNECT, PH-ABORT;
- 数据传输业务  PH-DATA;
- 层管理服务

  层管理服务由`层管理进程`使用或为`层管理进程`提供，层管理进程是`AP`的一部分。下面给出一些示例:

  - PH-INITIALIZE.request / PH-INITIALIZE.confirm;
  - PH-GET_VALUE.request /  PH-GET_VALUE.confirm
  - PH-SET_VALUE.request / PH-SET_VALUE.confirm
  - PH-LM_EVENT.indication

#### 5.2.2 Use of the physical layer services

物理连接建立/释放服务是由`物理连接管理器AP`使用并为`物理连接管理器AP`提供的，而不是`数据链路层`

![messages](/assets/img/2022-03-17-dlms-green-1/physervices.jpg)

`注意这张图很关键，表明了AP用于管理物理层的关系，包括AP和物理层的原语，链路层和物理层的原语`

#### 5.2.3 Service definitions

- PH-CONNECT.request `连接建立服务`的服务请求原语

  在DLMS/COSEM环境中，PH-CONNECT.request原语的`用户`是物理连接管理器`AP`。它被用于建立一个物理连接。收到该基元后，PhL实体将执行所需的动作--例如拨号（如物理层PhL向modem发送`AT指令`）--以与对等PhL实体建立物理连接。5.4中给出了智能Hayes调制解调器情况下的这些动作的例子。

- PH-CONNECT.indication 连接建立服务的服务指示原语

  PH-CONNECT.indication由PhL实体基元生成，用于向服务用户实体指示一个远程设备要求建立物理连接。

- PH-CONNECT.confirm 连接建立服务的服务确认原语

  PhL实体用来传递相关联的PH-CONNECT.request的结果。如果由于本地错误(例如电话线不可用)而无法建立连接，则是本地生成的。

- PH-DATA.request `数据传输服务`的服务请求原语

  求使用PhL传输过程向一个或多个远程PhL实体发送数据字节

- PH-DATA.indication 数据传输服务的服务指示原语。

  向服务用户实体指示有效数据字节的到达

- PH-ABORT.request 连接中止服务的服务请求原语

  请求原语由服务用户实体Physical Connection Manager调用，以请求PhL实体终止现有的物理连接

- PH-ABORT.confirm 连接`中止服务`的服务确认原语

  PH-ABORT.confirm 原语由 PhL 实体生成，用于向服务用户实体 Physical Connection Manager 确认物理断开尝试的结果

- PH-ABORT.indication 连接中止服务的服务指示原语。

  原语由PhL实体生成，用于通知服务用户实体物理连接已意外终止。

### 5.3 Protocol specification

#### 5.3.1 Physical layer protocol data unit

Physical layer protocol data unit,`PHPDU`被指定为`一个字节`。然而，为了传输目的，这个数据字节可能被`调制解调器`设备`扩展`(错误检测/校正)或`修改`(位填充)，这取决于所使用的调制方案。

#### 5.3.2 Transmission order and characteristics

PHSDU字节——PH-DATA服务的Data参数——在传输前应以一个开始位和一个停止位完成。产生的帧应该从起始位开始传输，首先是最低有效位，最低有效位标识为位0，最高有效位标识为位7。

#### 5.3.3 Physical layer operation – description of the procedures

##### 5.3.3.1 General

连接的建立和释放由`物理连接管理器AP`管理。任何希望使用DLMS/COSEM协议的`AP`应在请求连接之前`检查PhL`的连接状态。如果PhL处于`非连接`状态，它将请求`物理连接管理器`建立连接

TODO:结合5.3.3.3和5.3.3.4就是说建立和释放还有识别服务由AP来做，这些做完后的数据传输阶段AP就不管了，通过数据链路层直接调用

##### 5.3.3.2 Setting up a physical connection

客户机和服务器设备都可以充当`主叫设备`，初始化到远程设备(即`被叫设备`)的物理连接。在这个`DLMS/COSEM配置文件`中，这些原语的服务用户只能是`物理连接管理器进程`

在`被叫设备端`，当检测到物理连接的启动时，需要对连接进行管理：`协商`、`接受`或`拒绝`。这些动作--与执行PH-CONNECT.request原语类似--取决于`物理连接类型`和使用的`调制解调器`，并可能以`自主方式`或由`PhL本身`完成(该过程不需要Physical
connection manager process参与)。

当主叫和被叫设备的`PhL完成建立`（或`不建立`）所需的物理连接时，它们使用`PH-CONNECT.confirm`（主叫方）和`PH-CONNECT.indicat`（被叫方）基元将结果通知服务用户实体。

![messages](/assets/img/2022-03-17-dlms-green-1/physicalconn.jpg)

##### 5.3.3.3 The Identification service

`可选识别服务`是一种`应用层面`（TODO:特别注意，应用层面）的服务。它的目的是让客户获得关于服务器中实现的`协议栈`的信息。因此，它不使用整个协议栈；识别信息在`客户端AP`和`服务器AP`之间使用`PhL数据服务`直接交换。如果在`多播`配置中使用了一个以上的服务器，客户端能够识别`每个`服务器中的协议栈。

该服务在`PH-CONNECT后`CONNECTED状态才能调用

- IDENTIFY.request 请求识别信息
- IDENTIFY.response IDENTIFY.response消息由`服务器AP`调用，携带识别请求的`结果`：`协议标准`、`版本`和`修订信息`或`错误信息`。在客户端，这是一个IDENTIFY.confirm原语。

![messages](/assets/img/2022-03-17-dlms-green-1/identify.jpg)

IDENTIFY.request `APDU`包含`一个或三个`字节。为了保持一致性，它的发送应受到数据链路层的`时间限制`（帧间和响应超时）。

当收到这`第一个字符`时，PhL进入 "`识别中`"状态，等待更多的字节或帧间超时(意味着消息的结束)。

- identify`识别阶段`过程：

  如果在收到三个以上的字节之前检测到`消息结束`条件(超时也算结束标志)，PhL将收到的APDU视为`IDENTIFY.request` APDU。它使用PH-DATA.indicaton原语将收到的字节发送到`（物理连接管理器）AP`，并返回到 "`等待接收`"状态，允许解决最终的错误。

- 跳过identify`识别阶段`，直接进入`数据传输阶段`：

  另一方面，如果在收到`第四个`传入字节之前没有检测到`消息结束`的条件（因为IDENTIFY.request最大就是3字节，收到第4个字节还没有结束标志，说明就不是IDENTIFY.request了），PhL认为识别过程已经结束，并进入 "`数据传输`"状态。传入的字节应使用`PH-DATA.indicaton`服务发送至服务用户的上层协议层。在3层的CO、HDLC的COSEM配置文件中，这是MAC子层。在这种连接中，PhL`不能返回`到`识别阶段`。

##### 5.3.3.4 Data transfer

一旦`PhL`退出`识别阶段`，它就进入了`数据传输阶段`，其中`PH-DATA.request`和`PH-DATA.indicative`原语完全由上层协议层即`数据链路层`使用。

在识别阶段AP是可以通过PH-DATA原语向物理层传数据的，进数据传输阶段就不行了

PhL`不负责`任何数据`流控`制功能：通过PHDATA.request primitive收到的数据应`立即传输`，或者--当实施物理数据`流控`制时--应`覆盖`之前尚未传输的字节。由于PH-DATA服务既不是本地确认，也不是远程确认，因此在后一种情况下，不应发出错误信号。

##### 5.3.3.5 Disconnection of an existing physical connection

客户端或服务器都可以启动现有物理连接的断开连接。这通过调用 `PH-ABORT.request` 原语的`物理连接管理器 AP` 来实现

PH-ABORT.request的调用者，会收到PH-ABORT.confirm作为通知(在本地处理，本地的物理层通知本地的调用AP，不外发，断开操作无需通知对方)

对方不会收到任何关于断开的请求，只能通过`检测物理连接`断开（收到物理层传来的`PH-ABORT.indication`事件）来发现物理通道断开了。

如果是信道异常导致的断开，双方应该都会收到物理层传来的PH-ABORT.indication，双方都断开。

![messages](/assets/img/2022-03-17-dlms-green-1/phydisconn.jpg)

### 5.4 example: PhL service primitives and Hayes commands

PH-CONNECT:

对于`主叫者`，physical
connection manager AP向物理层PhL发送`PH-CONNECT`.request，物理层PhL向modem(DCE)发送`AT拨号`命令，并返回拨号结果，物理层将结果转换为`PH-CONNECT.confirm`返回给AP

对于`被叫者`，AP会被物理层通知`PH-CONNECT.indication`表示物理层已连接

![messages](/assets/img/2022-03-17-dlms-green-1/phyconn.jpg)

PH-DATA:

假设之前`建立了`与远程DCE的`连接`，并且DCE现在处于`数据传输模式`，那么传递到本地DCE的所有数据都将被传输到远程DCE（不是透明传输，每一层都会对data数据做处理，比如添加开始停止位，校验位等）。

PH-ABORT：

在可以终止连接之前，必须首先将调制解调器切换到本地`命令模式`(从数据传输模式)

## 6 Direct Local Connection

IEC 62056-21的摘录，

TODO:需要了解HDLC协议

### 6.2 METERING HDLC protocol using protocol mode E for direct local data exchange

## 7 DLMS/COSEM transport layer for IP networks

- 基于UDP的无连接传输层;
- 面向连接的基于TCP的传输层;
- 一个基于无连接CoAP的传输层

`DLMS/COSEM TL`由`CoAP、UDP或TCP传输层`和一个称为`包装器wrapper`的额外子层组成

### 7.2 The TCP-UDP/IP based transport layers

DLMS/COSEM_on_IP

可以把DLMS/COSEM AL视为和HTTP一样的网络应用，使用TCP-UDP传输层服务

![messages](/assets/img/2022-03-17-dlms-green-1/cosemalprofile.jpg)

IANA中注册了4059/TCP-UDP端口

DLMS/COSEM `AL`只监听`一个UDP或TCP端口`。另一方面，如4.9和DLMS UA 1000-1所示，`一个物理设备`可能承载`多个`客户端或服务器`ap`。包装器子层提供的`附加寻址`功能允许寻址这些`ap`。

包装子层具有以下功能:

- 它在UDP/TCP端口上提供了一个`额外的寻址`能力(`wPort`);
- 它提供有关数据`传输长度`的信息。这个特性可以帮助发送方和接收方识别一个`完整的APDU`的接收，它可以在`多个TCP包`中发送和接收

![messages](/assets/img/2022-03-17-dlms-green-1/tlcosemonip.jpg)

TCP-CONNECT and TCP-DISCONNECT services的用户是TCP Connection Manager Process（TODO:是否是和COSEM AP同一级的其他AP，如之前有管理物理层的AP）

#### 7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer

无连接，可实现多播广播；开销小

缺点：不可靠，无重复发送保护

![messages](/assets/img/2022-03-17-dlms-green-1/udptl.jpg)

.request和.indication服务原语是必需的。本地的.confirm服务原语的实现是可选的。

```asn.1
UDP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length, Data
)
```

```asn.1
UDP-DATA.indication
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
```

```asn.1
UDP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
```

`Result`参数的值表示基于DLMS/COSEM UDP的TL是否能够发送请求的UDP数据报:`能(OK)`或`不能(NOK)`。result为OK只能表示数据已发送，不保证能送达

UDP-DATA.confirm是`可选的`

在这个通信配置文件中，包装子层是一个无状态的实体：它的唯一作用是确保使用wPort号码的源和目的地DLMS/COSEM AE识别，并提供`OSI风格`的`UDP-DATA.xxx服务调用`与`标准UDP`提供的SEND()和RECEIVE()接口函数之间的`转换`。

对于UDP这种`面向数据报`而非`面向流`的协议，包装器中的长度字段并非必要，因为每个udp报文就是完整单一的，不存在分好几包还要拼包拆包处理粘包等操作，但为了和TCP`兼容`还是需要该字段

#### 7.2.3.3.2 The wrapper protocol data unit (WPDU)

![messages](/assets/img/2022-03-17-dlms-green-1/wrapperwpdu.jpg)

- version:始终为0x0001
- source/destination wPort:DLMS/COSEM AE的端口
- Data length:APDU数据长度

![messages](/assets/img/2022-03-17-dlms-green-1/udppdu.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/wrapperport.jpg)

#### 7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer

面向流的，可靠，包括重传、全双工、流控

缺点：端到端，不支持广播和多播

`TCP`作为一种面向连接的传输协议，涉及到`建立连接`、`交换数据`和`释放连接`三个阶段。因此，基于TCP的`DLMS/COSEM TL`为服务用户提供三个阶段的`OSIstyle`服务:

- 在`连接建立`阶段，将`TCP-CONNECT`服务提供给服务用户`TCP连接管理器进程`;
- 在`数据传输`阶段，`TCP-DATA`服务提供给服务用户`DLMS/COSEM AL`;
- 在`连接关闭`阶段，`TCP-DISCONNECT`服务被提供给服务用户`TCP连接管理进程`;
- 此外，一个`TCP-ABORT`服务被提供给服务用户`DLMS/COSEM AL`。

`TCP连接管理服务`的服务用户`不是DLMS/COSEM AL`，而是`TCP连接管理进程`。该工艺的规范超出了本技术报告的范围

![messages](/assets/img/2022-03-17-dlms-green-1/tcptl.jpg)

TCP-DATA区别与UDP-DATA可本地或远程确认，UDP-DATA只能本地确认

##### TCP-CONNECT

```asn.1
TCP-CONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)

TCP-CONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
```

TCP-CONNECT由TCP连接管理进程和TCP层进行交互

TCP连接管理进程不能拒绝TCP连接请求，所以TCP-CONNECT.response总是成功的

TCP-CONNECT.confirm一般来说需要远程确认，如果是本地确认，可能回失败

##### TCP-DISCONNECT

```asn.1
TCP-DISCONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)
```

TCP-DISCONNECT.request 用于断开请求

```asn.1
TCP-DISCONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
```

TCP-DISCONNECT.indication中`Reason`参数:

- `对端设备`请求了TCP断开(Reason == `REMOTE_REQ`)
- `本地检测`到TCP连接断开(Reason == `ABORT`)

```asn.1
TCP-DISCONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
```

TCP连接管理进程`不能拒绝`TCP断开请求，表示远程断开Reason == REMOTE_REQ

```asn.1
TCP-DISCONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
```

同TCP-CONNECT.confirm

##### TCP-ABORT

见7.2 图27，TCP-ABORT是`AL`层和`TL`层交互的原语

```asn.1
TCP-ABORT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
```

由基于DLMS/COSEM TCP的`TL`生成，用于向服务用户`DLMS/COSEM AL`表示支持TCP连接的`非请求中断`。

当收到此指示时，`DLMS/COSEM AL`应释放所有使用此TCP连接建立的`AAs`，并应使用 `COSEM-ABORT.indivation`服务原语向 COSEM AP 表明这一点。

##### TCP-DATA

```asn.1
TCP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
```

Data是APDU

```asn.1
TCP-DATA.indication (
    Local_wPort, 
    Remote_wPort, 
    Local_TCP_Port, 
    Remote_TCP_Port, 
    Local_IP_Address, 
    Remote_IP_Address, 
    Data_Length, 
    Data 
)
```

TCP-DATA.indication基元由DLMS/COSEM `TL`生成，用于向服务用户DLMS/COSEM `AL`指示已从远程设备收到xDLMS `APDU`。如果携带APDU的TCP数据包中的Local_TCP_Port和Local_wPort参数都包含`有效的端口号`，即接收设备中存在一个与给定端口号绑定的DLMS/COSEM AE，则在基于DLMS/COSEM TCP的TL`接收完整的APDU`（在`一个或多个`TCP数据包中）后生成。否则，收到的消息将被直接丢弃。

TCP-DATA.indication需要在接收完完整包并解包后交给AL,Data是APDU

```asn.1
TCP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Confirmation_Type,
    Result
)
```

可选的，request的确认

##### 7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer

wrapper层和UDP的不同，因为TCP是流式的，需要发送/接收全APDU，还要处理粘包等

###### TCP connection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpconn.jpg)

为了能够响应，响应方必须在接收第一个SYN包之前执行一个`“被动”打开`。为此，它必须联系本地操作系统(OS)，以表明它已经`准备好`接受传入的连接请求。作为这个联系的结果，操作系统分配一个`TCP端口号`给连接的端点(开启TCP`端口监听`)，并为将来的连接保留所需的资源——但是没有发送消息。

###### TCP disconnection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpdisconn.jpg)

###### TCP connection abort

基于 DLMS/COSEM TCP 的 `TL` 在 `TCP-ABORT.indication` 原语的帮助下指示支持 `TCP 连接`到 DLMS/COSEM `AL` 的`中断或断开`。 请注意，这是提供给 DLMS/COSEM AL 的`唯一` TCP 连接管理服务(其他服务都是提供给TCP连接管理进程的)。

当 `TCP 连接`被 `TCP 连接管理器进程`断开时调用该服务（`优雅断开`的情况），或者当 TCP 断开以`非请求方式`发生时，例如 TCP 子层`检测`到不可解决的`错误`或 `物理连接`被`关闭`。

TODO:前文TCP-ABORT一节提到TCP-ABORT不是非请求中断才生成吗?为什么请求中断也会生成

该服务的目的是`通知` DLMS/COSEM `AL` TCP 连接`中断`，以便它可以`释放`所有现有的 `AA`。

###### Data transfer using the TCP-DATA service

![messages](/assets/img/2022-03-17-dlms-green-1/tcpdata.jpg)

可选`TCP-DATA.confirm`原语表示TCP-DATA`结果`。请求原语之前调用，这是OK或NOK。然而，这个结果的含义取决于实现。当.confirm原语被实现为`本地确认`时，结果t表示DLMS/COSEM TL是否能够`缓冲发送`APDU或`发送`APDU。当它作为`远程确认`实现时，结果表明APDU是否已`成功交付`到目的地。

#### 7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls

##### 7.2.5.1 Transport layer and TCP connection establishment

![messages](/assets/img/2022-03-17-dlms-green-1/tcphandshake.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/tcpmsc.jpg)

##### 7.2.5.2 Closing a transport layer and a TCP connection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpmscclose.jpg)

##### 7.2.5.3 TCP connection abort

![messages](/assets/img/2022-03-17-dlms-green-1/tcpabort.jpg)

通过TCP Wrapper层轮询TCP层状态

##### 7.2.5.4 Data transfer using the TCP-DATA service

![messages](/assets/img/2022-03-17-dlms-green-1/tcpsenddata.jpg)

`AL层`通过request原语发送一个`992`字节的`APDU`，`Wrapper层`加上`8字节`的头，第一次发送`1000`字节，实际一包发出去476字节，还剩524字节，以此类推`直到发完`，向AL层回复confirm原语。该过程由Wrapper层控制。

![messages](/assets/img/2022-03-17-dlms-green-1/tcpwrapperreceive.jpg)

Wrapper层接收到完整的wrapper头+APDU后，解开wrapper头，将APDU放在`TCP-DATA.ind`原语中发送给AL层。

### 7.3 The DLMS/COSEM CoAP based transport layer

#### 7.3.2 Overview

受限应用协议 (Constrained Application Protocol,`CoAP`) 是由 IETF 核心工作组定义的专用互联网应用协议。 CoAP 专为在`资源受限`的设备中使用而设计，用于通过非受限或受限的互联网通信网络（例如，`低功耗`、`有损网络`）进行通信。 CoAP 旨在提供高效的数据传输能力，同时满足`可靠性`、`多播支持`、`极低开销`、`效率`和`简单性`等特殊要求。

基于CoAP的`DLMS/COSEM CoAP TL`提供`不可靠`和`可靠`的传输服务(CoAP原来是属于`应用层`的，这里DLMS协议里把它做成了`传输层`，用来给AL提供服务)。`不可靠`的CoAP服务支持`组播`和`广播`。DLMS/COSEM CoAP TL为服务用户DLMS/COSEM AL提供`OSI风格`的服务。

![messages](/assets/img/2022-03-17-dlms-green-1/coaposi.jpg)

整个`DLMS/COSEM CoAP TL`层包括了Wrapper层、CoAP层、UDP层，和标准OSI模型中的不同

#### 7.3.3 Structure of the DLMS/COSEM CoAP transport layer

![messages](/assets/img/2022-03-17-dlms-green-1/coaplayer.jpg)

`DLMS/COSEM CoAP TL`提供`不可靠`和`可靠`的运输服务。不可靠的DLMS/COSEM CoAP传输服务使用`non-confirmable (NON)` CoAP消息，而可靠的DLMS/COSEM CoAP TL服务使用`confirmable (CON)` CoAP消息，并带有CoAP消息层提供的`重试机制`。

CoAP wrapper层提供的服务：

- 通过与`CoAP请求/响应层`操作的交互，将`OSI风格`的数据服务`原语`(CoAP-DATA)传递给`DLMS/COSEM AL`，以实现`CoAP POST方法`的使用
- DLMS/COSEM`服务接入点寻址`功能，从而允许`多个`DLMS/COSEM `AEs`驻留在物理设备的同一个CoAP客户机和服务器端点上

##### 7.3.3.2 Identification and addressing

识别与寻址

TODO: 结合Bluebook 4.9 关于CoAP配置的对象

###### 7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer

一个CoAP端口可以为`不同的应用`（如除了DLMS的应用）提供服务，用`URIPath`区分(CoAP类似于HTTP，可以通过URI区分接入点)，IANA规定的默认端口为5683

默认情况下，DLMS/COSEM AL，无论是DLMS客户端AL还是DLMS服务器AL，都使用`URIPath`: "`DLMS`"

###### DLMS/COSEM CoAP transport layer SAPs

![messages](/assets/img/2022-03-17-dlms-green-1/coapsap.jpg)

#### 7.3.4 Service specification for the DLMS/COSEM CoAP transport layer

![messages](/assets/img/2022-03-17-dlms-green-1/coaploop.jpg)

`远程环回确认`(正面（正面的意思就是传输成功的情况）的TL确认，用于`可靠`传输)，表示报文被`远端`确认，确认发送给本地CoAP client，再由`本地wrapper层`返回给AL层confirm原语

TODO:CoAP的可靠传输,7.3.3也有提到

`本地环回确认`(负面（负面的意思就是失败的情况，比如发生了什么错误）的TL确认，用于`可靠和不可靠`传输，可靠传输中可能是对方超时没回确认，视为失败，不可靠传输中可能是udp层有错误导致调用发送函数失败，视为失败)，用于失败的情况，由`本地CoAP client`返回给wrapper层错误信息，`本地wrapper层`返回给AL层confirm原语

##### 7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives

###### 7.3.4.2.1 CoAP-DATA.request

```asn.1
CoAP-DATA.request
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Remote_Path [Optional Use],
    Response_Mode,
    Request_ID [Optional Use],
    Data_Length,
    Data
)
```

- `Transport_Mode`: CoAP传输模式，“RELIABLE”可靠，“UNRELIABLE”不可靠
- `Remote_Path`： CoAP `Uri-Path`。Response_Mode为“RESPONSE”忽略该参数
- `Response_Mode`：表示是否期望返回DLMS/COSEM响应APDU。它取值:"`CONFIRMED`"， "`UNCONFIRMED`"， "`RESPONSE`"。
- `Request_ID`：标识了特定的数据请求操作。Request_ID将在可能产生的`CoAP-DATA.confirm`原语中返回，表明DLMS/COSEM CoAP TL`传送数据`参数中给出的APDU的`成功或失败`。Request_ID被指定为支持在`已发送多个`携带请求的APDU且DLMS/COSEM CoAP TL确认尚未完成的情况下，以`每个`APDU为基础返回DLMS/COSEM CoAP TL`确认`(类似于TCP的`滑动窗口`，可以`异步确认`)。以下情况适用:

  - 如果Request_ID未被指定，CoAP-DATA.confirm原语中Request_ID也不被指定。
  - 如果Transport_Mode被设置为`UNRELIABLE`，并且DLMS/COSEM CoAP TL实现`不支持`这种操作模式的CoAP-DATA.confirm原语，那么Request_ID可以不被指定。
  - 如果DLMS/COSEM CoAP TL服务`不支持`CoAP-DATA.`confirm`原语，CoAP wrapper将`忽略`指定的Request_ID标识。

**使用场景**：

- 发送`DLMS/COSEM请求`（单播或多播广播）：

  - `Remote_Path`指定为对方Uri-Path
  - `Local_Port and Local_IP_address`可选
  - `Response_Mode`：

    - `需确认`的请求，使用`CONFIRMED`
    - `无需确认`的请求，使用`UNCONFIRMED`
    - General Block Transfer(`GBT`)`分块传输`的请求,视情况，比如`单播或广播`，可用`CONFIRMED或UNCONFIRMED`

- 发送`DLMS/COSEM响应`（也为CoAP-DATA.request，只要是发送就是，和AL层的报文类型无关）：

  - `Remote_Path不指定`
  - `Local_Port and Local_IP_address`需要指定，和请求匹配
  - Transport_mode, Local_SAP, Remote_SAP, Remote_IP_address, Remote_Port需匹配请求
  - `Response_Mode`：

    - 一般为`RESPONSE`
    - APDU为GBT时，为`CONFIRMED`，Remote_Path需指定（TODO:这不是和上面说的不指定矛盾了吗）

###### 7.3.4.2.2 CoAP-DATA.indication

```asn.1
CoAP-DATA.indication
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address,
    Local_Port,
    Remote_IP_address,
    Remote_Port,
    Data_Length,
    Data
)
```

- Transport_Mode: CoAP传输模式，“RELIABLE”可靠，“UNRELIABLE”不可靠

###### 7.3.4.2.2 CoAP-DATA.confirm

```asn.1
CoAP-DATA.confirm
(
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Request_ID [Optional Use],
    Result
)
```

- Local_SAP：本地DLMS/COSEM AE的SAP
- Request_ID：对应的CoAP-DATA.request中携带的，如果request没有指定就是未定义
- Result：“REMOTE OK”表示远端已接收，“NOT OK”表示发送失败

**使用场景**：

CoAP-DATA.confirm由wrapper层生成

对于不可靠的传输模式，Result没有“REMOTE OK”远程确认，但可以生成“NOT OK”表示本地错误，该原语是可选的

#### 7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer

##### 7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU)

![messages](/assets/img/2022-03-17-dlms-green-1/coaplayer2.jpg)

`DLMS/COSEM CoAP TL PDU`是一个`UDP数据报`，携带`CoAP消息`作为其`有效载荷`。该CoAP消息携带`CoAP头`和DLMS/COSEM CoAP Wrapper PDU（`CWPDU`）。CWPDU携带DLMS/COSEM `APDU`作为其有效载荷加上DLMS/COSEM CoAP `TL控制信息`，。

##### 7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU)

DLMS/COSEM CoAP包装协议数据单元(`CWPDU`)由一个可选的`DLMS/COSEM CoAP包装头`和它的有效负载`APDU`组成。

只有在`CoAP请求`中携带APDU时，CoAP包装器才使用`DLMS/COSEM CoAP包装器报头`。当APDU在`CoAP响应`中携带时，CWPDU中`不包含`DLMS/COSEM CoAP包装头，因为相关的CoAP包装头内容(本地和远程SAP)可以在接收CoAP包装层从CoAP包装头请求/响应`上下文`的状态中`提取`出来(区别于TCP或UDP传输层的包装器，CoAP包装器的报头在响应时是可以省略的)。

![messages](/assets/img/2022-03-17-dlms-green-1/coapcwpdu.jpg)

- The DLMS/COSEM CoAP TL version：TL版本号，0-15，目前为0
- Reserved bits：保留
- The CoAP Wrapper Response Mode (WRM)：是否期望收到AL层响应，（比如上报就是不期望AL层响应）
- Remote SAP：接收站点的SAP
- Local SAP：发送站点的SAP

##### 7.3.5.4 The Constrained Application Protocol (CoAP)

###### 7.3.5.4.2 The CoAP Message

CoAP消息以简单的`二进制格式`编码。消息由一个固定大小的`4字节头`、一个`可变长`度的`Token值`(0-8字节)、`0个或多个tlv编码`的选项(可选地)和`负载`组成。

一个`非空的CWPDU`作为`有效负载`在CoAP消息中携带。

![messages](/assets/img/2022-03-17-dlms-green-1/coapprotocol.png)

本节其实就是介绍标准coap协议，可以看其他文章，见[CoAP学习笔记（1）CoAP报文结构](https://blog.csdn.net/weixin_41572450/article/details/103549125)

DLMS/COSEM CoAP TL层只用到了其中的一部分的code

- CoAP Request method codes

  在`DLMS/COSEM CoAP TL`的`CoAP消息`中使用的请求方法代码如下

  |Request|method|Meaning Use|
  |:---:|:---:|:---:|
  |0.02|POST method|发送`新的`包含CWPDU的`请求或响应`|
  |0.00|空报文ACK message without piggybacked response|在可靠传输中用于`ACKs`确认，不带响应|
  
  TODO:为什么响应也算post

- CoAP Success Response codes
  
  |Success Response code|Meaning|Use|
  |:---:|:---:|:---:|
  |2.04|Success (Changed)|对`已存在`的请求/响应回复包含CWPDU的`响应`|

  TODO:是否可以这么理解：和上面post的区别是，这个回应是要有请求对应的，而不是向上报那种没有请求的直接上报。

客户端错误和服务器`错误响应代码`由`CoAP协议层`或`CoAP包装器`根据错误条件`填充`

- Token(可选，TKL指定是否存在)

  令牌用于配置响应和请求

- Token Length(TKL指定)

  建议DLMS/COSEM CoAP TL实施的CoAP请求/响应层使用的令牌长度限制为`0-4字节`，以平衡令牌传输成本和上下文不匹配的风险，或者当令牌在相同的CoAP端点之间重复使用时可能出现的重复检测失败。进一步参考RFC 7252。

  DLMS服务器的DLMS/COSEM CoAP TL的CoAP协议层使用的Token长度可在`CoAP设置对象`中指定，见DLMS UA 1000-1 Part 2 Ed.15:2021, 4.9.8。

- Options

  Options也只用到了标准中的一部分,当然没有规定只能用这些，但要保证双方能处理这些选项
  
  ![messages](/assets/img/2022-03-17-dlms-green-1/coapoption.jpg)

  - `Uri-Path`: CoAP uri路径，默认是dlms
  - `Content-Format`：允许的传输格式，和HTTP类似，可以不指定，因为默认都是`application/octet-stream`
  - `Block1` and `Block2`：在RFC 7959中新增的两个option，用于表示分块传输，见7.3.5.4.5，另见[CoAP分块传输](https://zhuanlan.zhihu.com/p/461498161)TODO:查看该文档

###### 7.3.5.4.3 CoAP retransmission and response piggybacking

当CWPDU在`可靠`的CoAP消息层支持的新CoAP请求/响应上下文中传输时（即通过可确认的（CON）CoAP消息），那么，正如RFC 7252所规定的，CoAP消息层将继续`重传`CoAP请求消息，直到它被CoAP服务器终端`确认`。这可以是单独的`CoAP确认消息ACK`的返回形式，也可以是`附带`CWPDU或错误响应的`piggybacked ACK消息`

>关于[piggybacking技术](https://en.wikipedia.org/wiki/Piggybacking_(data_transmission))：
>
>在双向通信中，每当收到帧时，`接收方`都会`等待`，并且`不会立即`将控制帧（`确认`或`ACK`）发送回`发送方`。
>
>`接收方等待`，直到其网络层传入下一个`数据包`。然后，`延迟的确认`将`附加`到此传出数据帧。
>
>这种暂时`延迟确认`以便可以与下一个传出数据帧挂钩的技术称为`piggybacking`。
>
>`优点`：提高效率，更好地利用可用信道带宽。
>
>`缺点`：如果`接收方``没有要发送`的内容，则接收器可能会`阻塞`服务。这可以通过在接收到数据帧时启用计数器（`接收器超时`）来解决。如果`计数结束`并且没有要发送的数据帧，则`接收方将发送 ACK` 控制帧。`发送方`还会添加一个`计数器`（发送器超时），如果计数器在没有收到`确认`的情况下结束，则发送方将假定数据包丢失，然后`再次发送`帧。
>
>该技术主要是为了`减轻网络负担`,这个附带内容可以是接收器对于`上一帧的回复`（如果处理快的话也可以是本次请求的回复），也可以是`主动上报`等

CoAP层会考虑使用`piggybacking`的可能性，`ACK`会`延时发送`，直到本地wrapper层收到AL层的数据并打包成CWPDU或超时，再发送`附带或不附带数据`的`ACK`。要是超时的话这个CWPDU单独发送，不附带在这个ACK中

7.3.5.4.3.2 **CoAP Retransmission Parameters**

DLMS/COSEM CoAP TL中的可靠CoAP消息传递层使用许多参数来控制RFC 7252定义的CoAP重传算法。这些参数在CoAP setup interface class类中指定

- ack_timeout

  需确认消息的最小初始ACK超时
  
  `initial_ack_timeout`是在`ack_timeout`和`ack_timeout x ack_random_factor`之间`随机选择`的值。
  
  `initial_ack_timeout`是可靠的CoAP消息层的`初始重传延迟`。
- ack_random_factor

  用于申请初始ACK超时随机性的随机因子。
- max_retransmit

  需确认消息的最大重传次数。
- delay_ack_timeout

  CoAP 消息传递层在`返回确认`之前`等待`应用层返回响应的时间（以毫秒为单位）

  (TODO:是不是和piggybacking相关的)

7.3.5.4.3.3 **CoAP Congestion Control Parameters**

拥塞控制

- NSTART

  以下任一形式的同时`未完成`的 CoAP 请求消息的`数量`：

  - 没收到ACK的CON消息(需确认消息)
  - 没收到响应的NON消息(无需确认消息)
- PROBING_RATE

  探测速率

  定义一个端点发送到另一个没有响应的端点时不应超过的平均`数据速率`(字节/秒)。

  TODO：这个参数有什么用

###### 7.3.5.4.5 CoAP Block Transfer

见7.3.5.4.2

在APDU大于MTU，且小于receiver_max_pdu_size时生效（大于receiver_max_pdu_size本身就不合法，TODO:这个是应用层的限制，传输层是怎么知道的，需要做限制吗）

TODO:为什么是APDU大于MTU，MTU不是链路层的限制吗

DLMS/COSEM CoAP TL中的CoAP块传输层应按照`RFC 7959`的建议，在没有不当延迟的情况下完成CoAP块传输

##### 7.3.5.5 Error Handling

###### 7.3.5.5.2 CoAP protocol layers

CoAP`消息层`或`请求/响应层`的错误通过`重置消息`(名词)或CoAP协议层实体根据RFC 7252和RFC 7959`自动生成`的CoAP客户端和服务器`错误响应`传递给发送的CoAP实体

###### 7.3.5.5.3 CoAP wrapper layer

`wrapper层`的`错误处理`，就是从一个wrapper层发给另一个wrapper层

- Unreliable CoAP transport `不可靠传输`

  一般是多播，wrapper将接收到的不能处理的CWPDU`丢弃`

  TODO:wrapper层是不是通过CWPDU中的客户端SAP参数知道是否是多播的

- Reliable CoAP transport `可靠传输`

  接收端wrapper层无法处理接收到的CWPDU(由CoAP request携带)时返回错误

  这种错误响应可能有助于诊断，也可能有助于主动纠正措施。通常，当传入的请求由于`语法错误`而无法提供服务时，将返回`CoAP客户端错误`(类似HTTP状态码里的4xx表示客户端错误，5xx表示服务器错误，[HTTP状态码](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81))，而当CoAP包装器`无法处理`明显`有效`的请求时，将返回`CoAP服务器错误`

  ![messages](/assets/img/2022-03-17-dlms-green-1/coapwrappererror.jpg)

###### 7.3.5.5.4 Propagation of errors through CoAP wrapper layer

返回到发送端CoAP协议层的错误响应应该以所产生的`CoAP消息层交付失败`（见下）的形式传播到`发送端CoAP包装器`，或者以`返回的错误本身`的直接形式传播，`无论`它们是由`接收CoAP协议层`还是由`接收CoAP包装器层`产生的。

- CoAP消息层交付失败原因：

  - 接收到重置消息
  - 放弃CoAP block transfer操作
  - 可靠CoAP消息传递层放弃可靠传输的CoAP消息
  - CoAP层错误或UDP或IP层错误

如果是可靠传输，CWPDU的交付失败必须从协议层传播到wrapper层，以便其酌情通知AL层。

TODO:有点看不懂

##### 7.3.5.6 DLMS/COSEM CoAP TL confirmations

`CoAP包装器请求/响应上下文`（见7.3.5.7）对于在本地发起的CoAP请求/响应上下文中传送的任何`未完成`的CWPDU（还没有收到CoAP响应）`保持`给定`Request_ID`的`状态`，以便wrapper层在返回`负面`（比如有错误发生）或`正面`（比如传输成功）的DLMS/COSEM CoAP TL确认时可以用CoAP-DATA.confirm原语向AL层返回Request_ID。

对于`不可靠`的DLMS/COSEM CoAP TL，这个是`可选的`，也就是无需维护维护Request_ID的状态。也只能回复`负面`的确认（无需正面确认，因为不可靠就是无确认的）

- CoAP传输层错误指示

  如果**CoAP包装器从CoAP协议层**`收到`在本地发起的CoAP请求/响应上下文中传输的CWPDU的`交付失败指示`，则`CoAP包装器`通过CoAP-DATA.confirm 原语（结果为 "`NOT OK`"）和与CoAP-DATA.request 原语中的APDU提供的Request_ID相匹配的`Request_ID`来传达相关APDU的`交付失败`。参见7.3.5.7.5。

- CoAP传输层确认

  支持 DLMS/COSEM CoAP TL 确认，如果接收端的AL层不会对这条报文回确认，那这个确认可以由接收端传输层自己生成并回复(AL层面无需响应，也就不会回响应，但传输层可靠传输层面需要确认)。使用带有 push_operation_method (1) 的`无需确认` DataNotification 的`可靠数据推送`操作需要 DLMS/COSEM CoAP TL 确认。 参见 DLMS UA 1000-1 第 2 部分 Ed.15:2021, 4.4.8.2.2.11)。

  CoAP 包装层支持 DLMS/COSEM CoAP TL 确认，用于在 CoAPDATA.request 原语中以 Response_Mode = UNCONFIRMED 和 Transport_Mode = RELIABLE 提供的 APDU。

  TODO:可靠传输不是靠CoAP的ACK吗，为什么还要单独再搞个wrapper层的确认

  过程：

  1. 在 `Response_Mode = UNCONFIRMED` 的 CoAP-DATA.request 原语中提供给 CoAP 包装器的 APDU 应由 CoAP 包装器在 CoAP 包装器响应模式设置为 1 的 CWPDU 中的新本地发起 CoAP 请求/响应上下文中传输（`WRM = 1`)（WRM见7.3.5.2，关于CWPDU的定义）。 这指示接收 CoAP 包装器`不要等待`返回 DLMS AL 响应或 DLMS AP 响应；
  2. 接收 CoAP 包装器应在将接收到的嵌入的 APDU 成功交付给 DLMS AL 时，当通过`可靠` CoAP 消息传递层 在 `WRM = 1` 的 CWPDU 中接收到 APDU 时，`返回`一个`空的 CWPDU` 作为对发送 CoAP 包装器的`成功响应`实体
  3. 对于WRM = 1接收到的CWPDU的错误处理遵循上面描述的一般错误处理

##### 7.3.5.7 CoAP wrapper state machine

wrapper层状态机

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperstate.jpg)

- `空闲`：`关闭状态`，没有关联状态，CoAP 请求/响应层中`没有`相应的 CoAP 请求/响应上下文

- `客户端等待模式`：接收到AL层传来的CoAP-DATA.req，直到把该req处理完，进入Idle模式。

- `服务器等待模式`：接收CoAP层传来的非空且无需确认（WRM=0，wrapper报头中的一个参数，wrapper层面无需确认）消息，直到将CoAP-DATA.req发送给AL层

- `服务`：接收到CoAP层传来的非空且需确认消息（WRM=1，wrapper层面需确认）

###### 7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context

在`客户端等待模式`状态下维护的`参数`取自 `CoAP-DATA.request` 服务原语的服务参数(AL层发来的)

在`服务器等待模式`和`服务状态`下维护的`参数`取自较低的 `CoAP 协议层`和传入 CWPDU 的 `CWPDU 标头`(远端客户端发来的)

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperparam1.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperparam2.jpg)

- 服务器等待模式到空闲状态：

  在服务器等待模式下收到AL层传来的`CoAP-DATA.request`原语，且该原语中的Transport_Mode, the Local SAP, the Remote SAP, the Local_IP_address, the Local_port, the Remote_IP_address and the Remote_Port`参数与当前wrapper层上下文中的对应`

  >结合前文描述，wrapper层如果需确认，WRM=1，则通过回空消息CWPDU的方式传递wrapper层确认，否则是不需要确认，直接等待AL层响应把完整的传递回去

- 客户端等待模式到空闲状态

  收到失败信息或成功信息（比如需确认模式下空的CWPDU）

TODO:后面的内容稍后再补

## 8 Data Link Layer using the HDLC protocol

### 8.1 Overview

本章指定数据链路层为三层，`面向连接`，`基于HDLC`，`异步通信配置文件`。

本规范支持以下通信环境:

- 点对点和点对多点配置
- 专用和交换数据传输设施
- 半双工和全双工连接
- 异步 启动/停止 传输，1个启动位，8个数据位，无奇偶校验，1个停止位

#### 8.1.2 Structure of the data link layer

为了确保面向连接和无连接两种操作模式都有一致的数据链路层服务规范，数据链路层被划分为两个子层:`逻辑链路控制(LLC)`子层和`媒体访问控制(MAC)`子层

[LLC层](https://zh.wikipedia.org/zh-hans/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6)

- 类型1：`无连接`。该方式对信息的发送通常无法保证接收。
- 类型2：`面向连接`。该方式提供了四种服务：连接的`建立`、确认和承认`响应`、`差错恢复`（通过请求重发接收到的错误数据实现）以及`滑动窗口`（系数：128）。通过改变滑动窗口可以提高数据传输速率。
- 类型3：`无连接承认响应服务`。

类型1的 LLC 无连接服务中规定了一种静态帧格式，并支持运行网络协议。有关`传输层网络协议`通常是使用服务类型1方式。

类型2的 LLC 面向连接服务支持可靠数据传输，运用于`不需要`调用网络层和传输层协议的局域网环境。(相当于把TCP层的事情干了)

[MAC 子层](https://blog.csdn.net/dadoneo/article/details/8315833)（该数据链路层规范的主要部分）基于 ISO/IEC 13239。与原始 HDLC 标准相比，该标准的`第二版`包括许多增强功能，例如在`寻址`、`错误保护`和`分段`。 `第三版`采用了一种新的帧格式，可满足`电表`和类似行业`遥测应用`中的环境要求。

MAC子层的主要功能包括数据`帧的封装/卸装`，`帧的寻址和识别`，帧的`接收与发送`，`链路的管理`，帧的`差错控制`等。MAC子层的存在屏蔽了不同物理链路种类的差异性;非常重要的一项功能是仲裁`介质的使用权`，即规定站点何时可以使用通信介质。实际上，局域网技术中是采用具有冲突检测的`载波侦听多路访问`（Carrier Sense Multiple Access /
Collision Detection，`CSMA/CD`）这种介质访问方法的。

为本技术报告的目的，已从 HDLC 标准中做出以下选择：

TODO:后面都看不懂

#### 8.1.3 Specification method

数据链路层的子层根据服务和协议(services and protocols)进行划分

TODO:等第8章看完之后完善

### 8.2 Service specification

本节规定了服务用户层使用`面向连接`的程序对数据链路层`要求`的服务。

`事实上`，所有 DL 服务都由 MAC 子层提供：LLC 子层将 DL-CONNECT.xxx 服务原语作为适当的 MA-CONNECT.xxx 服务原语`透明地传输`到“真实”服务提供者 MAC 子层或从“真实”服务提供者 MAC 子层接收。

由于客户端和服务器端 LLC 和 MAC 子层不同，因此为双方指定了服务原语。

MAC 子层的寻址方案在 8.4.2 中规定。

#### 8.2.2 Setting up the data link connection: the DL-CONNECT and MA-CONNECT services

![messages](/assets/img/2022-03-17-dlms-green-1/hdlcservicespec.jpg)

数据链路连接的建立`只能`由`客户端请求`。因此，DL-CONNECT / MA-CONNECT `.request`和`.confirm`原语仅在`客户端`(主站)提供。另一方面，MA-CONNECT / DL-CONNECT `.indication`和`.response`原语仅在`服务器`(辅助站点)端提供。

在`本地检测到错误`的情况下，DL-CONNECT / MA-CONNECT .request原语也可以在`本地进行确认`。(虚线部分)

##### 8.2.2.2 DL-CONNECT.request and MA-CONNECT.request

```asn.1
DL-CONNECT.request
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)

MA-CONNECT.request
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)
```

- Destination_MSAP和Source_MSAP: 标识要建立的`引用数据链路层连接`。
- User_Information：为`可选配置`。其内容的规范不属于本技术报告的范围。

服务用户层调用DL-CONNECT.request原语，LLC层接收后调用MA-CONNECT.request原语发给MAC层，MAC层发送格式化后的`SNRM帧`(Set Normal Response Mode (a HDLC frame type,HDLC协议的一部分))

##### 8.2.2.3 DL-CONNECT.indication and MA-CONNECT.indication

```asn.1
DL-CONNECT.indication
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)

MA-CONNECT.indication
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)
```

和上面的相反，接收SRNM转换报文

##### 8.2.2.4 DL-CONNECT.response and MA-CONNECT.response

```asn.1
DL-CONNECT.response 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)
MA-CONNECT.response 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)
```

Result指示提议的连接`是否可以被接受`，以及`是否应该发送响应帧`。它可以有以下值之一:

- Result == `OK`这意味着接收到的连接请求`可以`被服务用户层`接受`。MAC层收到后发送`UA帧`
- Result == `NOK`。这意味着接收到的连接请求`不能`被服务用户层`接受`;（如果链路层收到第二个连接请求，但同时只能有一个，即使服务用户层接受，连接也不能建立），MAC层收到后发送`DM帧`
- Result == `NO-RESPONSE`。这意味着不应发送对 DL-CONNECT.indication 的响应。MAC层收到MA-CONNECT.response后不发送任何帧

TODO:这里的MA-DISCONNECT.response是不是写错了

##### 8.2.2.5 DL-CONNECT.confirm and MA-CONNECT.confirm

```asn.1
DL-CONNECT.confirm 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)

MA-CONNECT.confirm 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)
```

`Result` 表示之前调用的 DL-CONNECT / MA-CONNECT.request 服务调用的结果。 它可以具有以下值之一：

- Result == OK。 这意味着远程站`接受`了连接请求；
- Result == NOK-REMOTE。 这意味着远程站`没有接受`连接请求；
- Result == NOK-LOCAL。 这意味着发生了`本地错误`，例如服务用户层试图建立一个已经存在的数据链路连接；
- Result == NO-RESPONSE。 这意味着远程站`没有响应`连接请求。

#### 8.2.3 Disconnecting the data link connection: the DL-DISCONNECT and MA-DISCONNECT services

![messages](/assets/img/2022-03-17-dlms-green-1/hdlcservicespec.jpg)

##### 8.2.3.2 DL-DISCONNECT.request and MA-DISCONNECT.request

同上8.2.2.2

##### 8.2.3.3 DL-DISCONNECT.indication and MA-DISCONNECT.indication

```asn.1
DL-DISCONNECT.indication ( 
    Destination_MSAP, 
    Source_MSAP, 
    Reason, 
    Unnumbered_Send_Status, 
    User_Information 
)

MA-DISCONNECT.indication ( 
    Destination_MSAP, 
    Source_MSAP, 
    Reason, 
    Unnumbered_Send_Status, 
    User_Information 
)
```

- Reason

  - Reason == REMOTE：数据链路层收到来自客户端的断开连接请求。 这种情况可能只发生在`服务器端`；
  - Reason == LOCAL-DL：出现致命的`数据链路连接失败`；
  - Reason == LOCAL-PHY：出现致命的`物理连接故障`。 后两种情况可能同时发生在`客户端和服务器端`。

- Unnumbered_Send_Status，USS，参数的值指示在DL-DISCONNECT / MA-DISCONNECT .indication 原语调用的时刻是否分别调用数据链路层。 MAC 子层有（USS == TRUE）或没有（USS == FALSE）待处理的 UI 消息。TODO:这句是什么意思

TODO:后面的之后再看

## 9 DLMS/COSEM application layer

### 9.1 DLMS/COSEM application layer main features

#### 9.1.2 DLMS/COSEM application layer structure

![messages](/assets/img/2022-03-17-dlms-green-1/applayer.jpg)

DLMS/COSEM AL的主要组成部分是`应用服务对象`Application Service Object(`ASO`)。它向其服务用户COSEM Application Process (`APs`)`提供`服务，并`使用`支持协议层提供的服务。它在客户端和服务器端都包含三个必需的组件:

- 关联控制服务元素，Association Control Service Element，`ACSE`
- 扩展DLMS应用服务元素the extended DLMS Application Service Elemen，`xDLMS ASE`;
- 控制功能the Control Function，`CF`。
- Client SN_Mapper ASE是客户端专有可选项

xDLMS `ASE`提供在COSEM `APs之间`传输数据的服务,见9.1.4

Control Function (`CF`)元素指定`ASO服务`如何调用`ACSE`、`xDLMS ASE`和`支持协议层`的服务的`适当服务原语`。见9.4.1。

客户端和服务器DLMS/COSEM `ASO`都可能包含其他可选的应用程序协议组件。

当`服务器`使用`SN引用`时，`可选的`Client SN_Mapper ASE出现在`客户端AL ASO`中。它使用LN和SN引用提供服务之间的`映射`。见9.1.5。

`DLMS/COSEM AL`也执行OSI表示层的一些功能:

- 对`ACSE`和`xDLMS APDUs`进行`编码和解码`，参见9.4.3;
- 另外，生成和使用代表`ACSE`和`xDLMS APDUs`的`XML文档`;
- 用于`压缩和解压`;
- 启用、验证和删除`密码保护`。

#### 9.1.3 The Association Control Service Element, ACSE

用于面向连接（connection oriented (CO)）通信

提供application association建立与释放服务：

- COSEM-OPEN;

  COSEM-OPEN服务用于`建立AAs`。它基于ACSE A-ASSOCIATE服务。基于ASE过程中的Application_Context_Name, Security_Mechanism_Name and xDLMS context 参数

  - `confirmed AAs`使用COSEM-OPEN服务，可以在单个客户端和单个服务器之间建立；

  - `unconfirmed AAs`使用COSEM-OPEN服务，可以在单个客户端和多个服务器见建立，只有客户端发送，服务端不回应。（多播，广播）

  - `pre-established AAs` 可能预先存在。 不使用 COSEM-OPEN 服务。 客户端必须知道服务器支持的上下文。 预先建立的 AA 可以是确认或未确认。 TODO:等后文详细了解

- COSEM-RELEASE

  `不丢失信息`，`优雅释放`AAs

  - TCP-UDP/IP based profile：基于`ACSE A-RELEASE` 服务
  - 3-layer, CO, HDLC based profile：confirmed AAs`直接断开`对应协议层连接，Pre-established AAs无需断开
- COSEM-ABORT

  `异常释放`，可能`丢失信息`，它不依赖于ACSE A-ABORT服务

#### 9.1.4 The xDLMS application service element

为了访问COSEM对象的属性和方法，使用了`xDLMS ASE`的服务

##### 9.1.4.2 The xDLMS initiate service

建立`xDLMS上下文`

##### 9.1.4.3 COSEM object related xDLMS services

与COSEM对象相关的xDLMS服务用于访问COSEM`对象属性和方法`。

- Logical Name (LN) referencing
- Short Name (SN) referencing

`客户端ASO`总是使用带有`LN引用`的xDLMS `ASE`。`服务器ASO`可以使用带有`LN引用`的xDLMS `ASE`，也可以使用带有`SN引用`的xDLMS ASE，或者`两者都使用`

服务可以是：

- requested / solicited：客户端请求

  客户端`请求`的服务也可以(见9.4.6.2):

  - confirmed:在这种情况下，服务器提供对请求的响应;
  - unconfirmed:在这种情况下，服务器不提供对请求的响应。
- unsolicited: 由服务器端发起，无需请求

  来自服务器的`未经请求`的`DataNotification`也可能是(见9.3.10):

  - confirmed:在这种情况下，客户端提供一个`响应`来确认收到了未经请求的DataNotification
  - unconfirmed:在这种情况下，客户端没有对未经请求的DataNotification提供响应

`附加服务`-不是基于IEC 61334-4-41:1996规定的DLMS服务-是:

- 使用LN引用访问COSEM对象属性和方法的`GET、SET、ACTION和ACCESS`;
- 服务器用于向客户端推送数据的`DataNotification`服务;
- 服务端使用`EventNotification`服务通知客户端服务器发生的事件。

>`IEC 61334-4-41:1996`规定的是早期的DLMS，后面有扩充的叫做xDLMS,多了很多重要的东西

###### 9.1.4.3.2 xDLMS services used by the client with LN referencing

GET9.3.6、SET9.3.7、ACTION9.3.8、ACCESS9.3.9

###### 9.1.4.3.3 xDLMS services used by the client with SN referencing

Read9.3.14、Write9.3.15、UnconfirmedWrite9.3.16

##### 9.1.4.3.4 Unsolicited services

主动上报

共有DataNotification，LN有EventNotification，SN有InformationReport

###### 9.1.4.3.5 Selective access

选择性访问属性内部分内容

###### 9.1.4.3.6 Multiple references

在COSEM对象相关的服务调用中，可以`引用`一个或`多个`命名变量、属性和/或方法，见9.4.6.1

TODO:这个特性还不知道

###### 9.1.4.3.7 Attribute_0 referencing

`属性0`表示`引用所有`公共属性（属性号为正），

##### 9.1.4.4 Additional mechanisms

与IEC 61334-4-41:1996中规定的DLMS相比，xDLMS指定了一些新的机制来提高功能、灵活性和效率。其他机制包括:

- 使用逻辑名logical names进行引用;
- 识别服务调用;
- 优先处理;
- 传输较长的应用信息;
- 可组合的xDLMS消息;
- 压缩解压;
- 通用密码保护;
- 通用块传输general block transfer(GBT)

下面逐个介绍

###### 9.1.4.4.2 Referencing methods and service mapping

在`confirmed AAs`的情况下，`引用方法`在AA建立阶段通过COSEM应用上下文进行`协商`。在AA成立期间`不得改变`。在给定的AA中使用LN或SN服务是独占的。

在`unconfirmed` and `pre-established` AAs的情况下，客户端AL需要`提前知道`服务器支持的`引用方法`。

###### 9.1.4.4.3 Identification of service invocations: the Invoke_Id parameter

在client/server模型中，请求由客户机发送，响应由服务器发送。允许客户端在接收到对前一个请求的响应之前发送`多个请求`，前提是`较低层允许`这样做。

需要用`Invoke_Id`来标识数据包，这样客户端才能判断响应是对哪个请求的

在`ACCESS`和`DataNotification`服务(参见9.3.9和9.3.10)中，使用`Long-Invoke-Id`参数来`代替`Invoke_Id参数。

`EventNotification`服务`不包含`Invoke_Id参数。

此功能仅在`LN引用`时可用

###### 9.1.4.4.4 Priority handling

对于使用`LN引用`的数据传输服务，有两个`优先级`可用:`normal (FALSE)`和`high (TRUE)`。

服务器不按先来先服务`FIFS`，而是根据`优先级`处理

此功能仅在`LN引用`时可用

###### 9.1.4.4.5 Transferring long messages

xDLMS服务原语由`xDLMS APDUs`以编码形式携带。这种编码形式可能比客户端/服务器`协商`的`最大接收PDU大小`长

两种方案：

- `通用块传输`(GBT)机制
- `特定于服务`的块传输机制

如果最大接收PDU大小很大，超过了下一层的限制，APDUs符合条件，不用分块，那就需要下一层进行分包操作

特定于服务的块传输机制用于：

- 使用LN参引用的confirmed services:GET、SET、ACTION;
- 使用SN参引用的confirmed services:Read、Write

特定于服务的块传输在以下情况下不可用:

- unconfirmed services
- unsolicited services (DataNotification, EventNotification and InformationReport)
- the ACCESS service

`特定于服务的块传输`只能一包一包顺序传，不支持流式传输，不支持恢复丢失块。加密是加一个block，而不是整个APDU，服务专用数字签名不可用。TODO：服务专用数字签名是什么

相反，`GBT机制`可以与任何xDLMS APDU一起使用，包括`通用密码和通用签名APDU`。它提供`双向块传输`、`流`和`丢失块恢复`。当需要加密保护时，对`完整的APDU`进行`加密保护`，然后被保护的APDU以`块的形式`传输，如图87所示。

###### 9.1.4.4.6 Composable xDLMS messages

可组合的xDLMS消息

处理xDLMS消息的三个重要方面是`编码/解码`、`应用、验证/删除密码保护`和`块传输`。

可组合xDLMS消息的概念将这`三个方面`分开

![messages](/assets/img/2022-03-17-dlms-green-1/xdlmscomp.jpg)

一旦AL构建了与AP调用的服务原语对应的APDU，就可以使用通用保护机制来应用密码保护。当不受保护或受保护的APDU长度超过协商的APDU长度时，可以采用`通用块传输机制`。

TODO:没看懂什么意思,就是各种处理方式可以组合使用的意思吗

###### 9.1.4.4.7 Compression and decompression

For details, see 9.2.3.6.

###### 9.1.4.4.8 General protection

此机制可用于对任何xDLMS APDU应用密码保护，这允许在客户机和服务器之间或第三方和服务器之间应用多层保护。见9.2.2.5。

- the general-ded-ciphering and the general-glo-ciphering APDUs;
- the general-ciphering APDUs;
- the general-signing APDU.

###### General block transfer (GBT)

GBT机制可用于块内传输任何长或短`xDLMS APDU`。在GBT中，块由`通用块传输APDU`携带，而不是由特定于服务的“with-datablock”APDUs携带。

GBT机制支持`双向块传输`、`流传输`和`丢失块恢复`:

- `双向块传输`意味着当一方发送块时，另一方不仅可以确认接收到的块，而且如果它有块可以发送，它也可以发送它们，就是`全双工`模式;
- `流式传输`意味着一方可以发送`多个区块`，而无需另一方对每个区块进行确认,有一个发送窗口;参考TCP传输
- `丢失块恢复`意味着如果发送的块的接收未被确认，它可以被`再次发送`。如果使用流，丢失的块恢复发生在每个`流窗口的结束`。

通用块传输机制的协议在9.4.6.13中指定

##### 9.1.4.5 Additional data types

##### 9.1.4.6 xDLMS version number

6

##### 9.1.4.7 xDLMS conformance block

`xDLMS一致性块`支持具有扩展功能的优化的DLMS服务实现。它可以通过标记“Application 31”与DLMS一致性块区分开来。请参见9.4.6.1、9.5和9.6。

TODO:这是什么意思，有什么用途

confirmed AAs可以在AA建立期间协商一致性块，unconfirmed and pre-established AAs需要客户端提前知道server的一致性块

##### 9.1.4.8 Maximum PDU size

- Client Max Receive PDU Size

  Unsigned16，必须能满足AARE APDU大小

  低于12的值被保留，0表示无限制

- Server Max Receive PDU Size

  Unsigned16

  低于12的值被保留，0表示无限制

#### 9.1.5 Layer management services

这些服务的规范不在本技术报告的范围内。

#### 9.1.6 Summary of DLMS/COSEM application layer services

- The DLMS/COSEM AL services are specified in 9.3.
- The DLMS/COSEM AL protocol is specified in 9.4.
- The abstract syntax of the ACSE and xDLMS APDUs is specified in 9.5.
- The XML schema is defined in 9.6.

![messages](/assets/img/2022-03-17-dlms-green-1/dlmsal.jpg)

#### 9.1.7 DLMS/COSEM application layer protocols

`DLMS/COSEM AL`协议是基于`ISO/IEC 15954:1999`中规定的`ACSE标准`和`IEC 61334-4-41:1996`中规定的`DLMS标准`，并扩展了DLMS/COSEM。

### 9.2 Information security in DLMS/COSEM

- DLMS/COSEM安全概念security concept，见9.2.2;
- 选择的加密算法，见9.2.3;
- 安全密钥，见9.2.4、9.2.5、9.2.6;
- 使用加密算法进行实体认证，xDLMS APDU保护和COSEM数据保护，见9.2.7。

#### 9.2.2 The DLMS/COSEM security concept

##### 9.2.2.2 Identification and authentication

###### 9.2.2.2.1 Identification

如4.3.3所述，DLMS/COSEM `AEs`被绑定到支持AL的`协议层`中的服务接入点(`SAPs`)。这些SAPs存在于AA中包含xDLMS APDUs的PDUs。

TODO:找到实例完善

客户端`用户识别机制`使`服务器`能够区分`客户端的不同用户`(可能是运营商或第三方)，以记录他们访问设备的活动。也看到4.3.6。

###### 9.2.2.2.2 Authentication mechanisms

身份验证机制确定通信实体在AA建立期间使用的协议来证明自己。

![messages](/assets/img/2022-03-17-dlms-green-1/dlmsauth.jpg)

- No security (Lowest Level Security) authentication

  `无安全性`(最低级别安全性)身份验证的目的是允许客户机从服务器检索一些`基本信息`。这种身份验证机制不需要任何身份验证;客户端可以访问安全上下文中的COSEM对象属性和方法，以及给定AA中普遍存在的访问权限。

- Low Level Security (LLS) authentication

  服务器要求`客户端`通过提供服务器知道的密码来`证明自己`。该密码是由当前持有的“`Association SN / LN`”对象建模的AA来建立的。“Association SN / LN”对象提供了更改密码的方法。

- High Level Security (HLS) authentication

客户端和服务器都必须成功地证明自己（`双向认证`），以建立一个AA。

- Pass 1:客户端发送一个“challenge”CtoS信息，以及根据身份验证机制附加的信息给服务器;
- Pass 2:服务器发送一个“challenge”StoC信息，以及根据身份验证机制附加的信息给客户端;

  >如果StoC与CtoS`相同`，客户应`拒绝并中止`AA建立过程。所以StoC与CtoS必须是独立生成的且不同的。
- Pass 3:`客户端`根据对给定AA有效的HLS身份验证机制的规则处理`StoC`和`其他信息`，并将结果`发送`给服务器。服务器检查`f(StoC)`是否是正确处理的结果，如果是，则`接受`客户端的身份验证
- Pass 4:`服务器`根据对给定AA有效的HLS身份验证机制的规则处理`CtoS`和`附加信息`，并将结果`发送`给客户端。客户端检查`f(CtoS)`是否是正确处理的结果，如果是，则`接受`服务器的身份验证。

总结，由服务端先校验客户端合法性，再由客户端校验服务端合法性

`pass2后`，如果application context and xDLMS context`合法`（这两个参数再pass1和2交换或生成，pass2后已存在，只不过要到pass4全走完才激活），则`授予`当前"Association SN / LN”对象的`reply_to_HLS_authentication`方法`权限`

pass3和4依赖于reply_to_HLS_authentication

##### 9.2.2.3 Security context

- `安全套件security suite`，确定可用的安全算法，参见9.2.3.7;
- `安全策略security policy`，确定在AA内交换的所有xDLMS APDUs的保护类型。可能的安全策略在9.2.7.2.2中指定;
- `安全材料security material`，与给定安全算法相关的，包括安全密钥、初始化向量、公钥证书等。由于每个安全算法的安全材料都是特定的，因此在相关条款中详细指定了元素。

##### 9.2.2.4 Access rights

属性的访问权限包括:no_access、read_only、write_only或read_and_write。

方法的访问权限可以是no_access或access。

可以对访问特定的属性或方法的APDUs单独配置加密，.request和.response也可以

##### 9.2.2.5 Application layer message security

就是对称加密传输的过程，AA已经建立的情况下

![messages](/assets/img/2022-03-17-dlms-green-1/applayersecurity.jpg)

为了确保端到端消息安全性，第三方必须能够与DLMS服务器交换受保护的xDLMS服务请求。在这种情况下，客户端充当代理

![messages](/assets/img/2022-03-17-dlms-green-1/endtoend.jpg)

- `第三方Third party`:

  - 感知DLMS/COSEM，即它可以`生成和处理`封装了携带COSEM对象相关的服务请求和响应的xDLMS `APDUs`的消息;
  - 它能够对携带请求的xDLMS APDU应用`自己的保护`（TODO：这个保护是不是不在DLMS规定的范围内，比如用HTTP传输，TLS保护.但是接受服务端消息时又写到能够处理server - client general protected APDU，AA不是client和server建立的吗，third party的密钥是哪里来的）;
  - 它能够`验证`由服务器和/或客户端应用的保护响应。

- `The DLMS client`

  - 作为第三方和服务器之间的中间人`broker`;
  - 根据`TP-client`消息中包含的信息，`为第三方提供适当的AA`;
  - 验证TP有权使用该AA;验证方法超出了本技术报告的范围。
  - 它可以验证第三方申请的保护;
  - `封装`第三方客户端消息到一个通用的受保护的xDLMS APDU;
  - 它可以验证服务器对封装COSEM对象相关服务响应或未经请求的服务请求的APDU应用的保护;(Push操作时);
  - 它可以对发送到TP的受保护的xDLMS APDU应用自己的保护。

- `The server`

- 与第三方使用的`客户端`(预先)`建立AA`;
- 它可以检查使用AA的第三方的身份;
- 一旦客户端和/或第三方应用的保护被服务端成功验证，服务端将提供访问COSEM对象属性和方法的权限，这些属性和方法由安全策略和访问权限确定;
- 它应该准备响应——或者，在推送操作的情况下，一个未经请求的服务请求——并应用由传入请求的保护、访问权限和安全策略决定的保护。

##### 9.2.2.6 COSEM data security

对`具体`COSEM对象内属性、方法参数等的`保护`，与AL层整体加密整个xDLMS APDU有区别。

#### 9.2.3 Cryptographic algorithms

- 散列函数hash functions
- 对称加密symmetric key algorithms
- 非对称加密asymmetric key algorithms

##### 9.2.3.2 Hash function

一个好的哈希函数是`单向函数`（逆过程很难），且要找到产生相同哈希值的两个特定输入也是极其困难的。

哈希函数接受任意长度的输入，输出固定长度的值。

一般用于校验完整性

在DLMS/COSEM中使用哈希算法的目的如下:

- 数字签名，见9.2.3.4.4;
- 密钥协议，见9.2.3.4.6;
- HLS认证。具体算法与认证机制有关，请参见9.2.7.4。

##### 9.2.3.3 Symmetric key algorithms

对称密钥算法在DLMS/COSEM中用于以下目的:

- 使用HLS认证机制对通信伙伴进行认证，参见9.2.7.4;
- xDLMS消息的认证和加密，参见9.2.7.2;
- COSEM数据认证和加密，参见9.2.7.5。

###### 9.2.3.3.2 Encryption and decryption

###### 9.2.3.3.3 Advanced Encryption Standard

AES算法，属于分组加密算法

AES结合了安全性、性能、效率、易于实现和灵活性。具体来说，该算法在各种计算环境的硬件和软件上都有良好的性能。此外，该算法对内存的要求非常低，这使得它非常适合于空间受限的环境。（TODO:内存占用少是不是因为是分组加密，每一块加解密时占用少导致的）

###### 9.2.3.3.4 Encryption Modes of Operation

AES-GCM可规避相同明文块加密成相同密文块带来的重复特征检测，密文块批量篡改的问题。

##### 9.2.3.3.5 Message Authentication Code

消息验证码MAC

MAC作用与HASH函数相似，都可以验证`完整性`，不同的是MAC`需要密钥`而HASH不需要密钥。MAC还能验证`真实性`，即使内容被篡改因为没有密钥也无法生成MAC

##### 9.2.3.3.6 Key wrapping

可以使用对称密钥算法使用密钥封装密钥(也称为`密钥加密密钥`)来封装(即加密)密钥材料。

master key

见9.2.3.3.8

###### 9.2.3.3.7 Galois/Counter Mode

GCM是AES算法的一种运行模式。

加密或认证可选，可以仅加密或仅认证

![messages](/assets/img/2022-03-17-dlms-green-1/aesgcm.jpg)

- **认证加密函数**
  - 输入:
    - `密钥`，`EK`
    - `明文`，表示为`P`;
    - `附加认证数据`Additional Authenticated Data(`AAD`)，记为`A`;
    - `初始化向量`initialization vector(IV)表示为`IV`。

    明文和AAD是GCM保护的两类数据。GCM保护了明文和AAD的真实性;GCM还保护明文的机密性，而AAD则是透明的（`明文加密认证，AAD仅认证`）

    长度要求（bit）：

    - len(P) < 2^39-256;
    - len(A) < 2^64-1;
    - 1 <= len(IV) <= 2^64-1.

    P、A、IV的位长都是`8的倍数`，所以这些值都是`字节串`。

  - 输出：
    - 一个与明文P位`长度相同`的`密文C`
    - 一个`身份验证标记`或`标记`，简称`T`

- **认证解密函数**
  - 输入：
    - `密钥`，`EK`
    - 密文C
    - `附加认证数据`Additional Authenticated Data(`AAD`)，记为`A`;
    - 一个`身份验证标记`，简称`T`

  - 输出：
    - 一个与密文C`长度相同`的`明文P`
    - 一个特殊的`错误代码`，在本技术报告中表示为FAIL

- The initialization vector, IV

  就是frame counter，每加密一次加1,DLMS协议里是systemtitle + IC

  每个加密密钥(EK)都有`两个`相关联的调用计数器(IC)，一个用于经过身份验证的加密函数，另一个用于经过身份验证的解密函数。

  - 当密钥建立时，对应的`IC`复位为0;
  - 使用`认证加密`功能后，对应的IC`加1`。如果IC已达到`最大值`，任何进一步调用认证加密函数将`返回错误`，且IC`不得增加`。
  - 使用`鉴权解密`功能时，验证`IC`的值。该值必须等于或大于`最低可接受值`。

    如果被验证的值满足此要求，则使用认证解密功能后，`最低可接受值`为`已验证的IC值``加1`。如果`被验证的值``小于`最低可接受值，则`验证失败`，经过验证的解密功能也会`失败`。如果被验证的值等于最大值，则经过验证的解密函数将返回一个错误。

    TODO:这里有个问题，如果客户端出现异常，被验证值设置得很大，那不是会很快到达最大值，导致设备不可用

  固定字段的位长将可以为给定密钥实现`验证加密功能`的不同物理设备的数量限制为 2^64。调用字段的位长将`验证加密功能`的调用次数限制为 2^32 输入集而不违反唯一性要求。(TODO:没看懂什么意思)

- The encryption key, EK

  `GCM`只使用`一个密钥`，即分组密码密钥。在DLMS/COSEM中，这被称为`加密密钥`，表示为`EK`。它的`大小`取决于安全套件(参见9.2.3.7)，应该是:

  - for security suite 0 and 1, 128 bits (16 octets): len(EK) = 128;
  - for security suite 2, 256 bits (32 octets): len(EK) = 256;

  密钥应该`随机均匀生成`，或者`近似随机`均匀生成，即每个可能的密钥生成的概率(几乎)相等。因此，该键将是`新的`，即，不等于任何以前的键，且概率很高。密钥应该是秘密的，应使用只适用于GCM和选定的分组密码AES。密钥建立和管理的附加要求在NIST SP 800-38D:2007, 8.1中进行了讨论。

- The authentication key, AK

  作为附加认证数据(`AAD`)的`一部分`

- Length of the authentication tag

  身份验证标记的`位长t`是一个安全参数。在安全套件0、1和2中，其值应为96位。

###### 9.2.3.3.8 AES key wrap

对于封装密钥数据，DLMS/COSEM选择了`RFC 3394`中指定的AES密钥封装算法。该算法旨在包装或加密关键数据。它对`64位块`进行操作。在wrap之前，关键数据被解析为`n个64位`的块,`n至少为2`。(AES密钥长度是128、192、256，所以肯定满足要求)

加密输入`密钥加密密钥KEK`和`明文密钥`，明文密钥为`n个64bit`块，输出`(n+1)*64bit`长度密文

解密相反。

TODO:输入输出不是等长的吗

在DLMS/COSEM中，KEK的大小取决于`安全套件`(参见9.2.3.7)，并应是:

- 对于安全套件`0和1`,128位(16位):len(KEK) = `128`;
- 对于安全套件`2`,256位(32位):len(KEK) = `256`。

##### 9.2.3.4 Public key algorithms

公钥密码系统一般采用难以解决的问题作为算法的基础。RSA算法是基于非常大的整数的质因数分解。椭圆曲线密码体制(ECC)是基于求解椭圆曲线离散对数问题(ECDLP)的难度。

- 通信双方`认证`
- xDLMS APDUs和COSEM数据的`数字签名`
- `密钥协商`key agreement

一些非对称密钥算法可以用于多种目的(例如，用于数字签名和密钥建立)。用于一种目的的密钥不得用于其他目的。（TODO:私钥是否需要有这个要求）

###### 9.2.3.4.2 Elliptic curve cryptography

椭圆曲线密码学ECC

素数域上的椭圆曲线由实数(x, y)组成，满足下列方程:

$$ y^2=x^3+ax+b $$

曲线的形状由a和b两个参数决定

- NIST推荐使用椭圆曲线

![messages](/assets/img/2022-03-17-dlms-green-1/recommandcurves.jpg)

###### 9.2.3.4.3 Data conversions

本节描述了数据转换原语，用于在用于指定公钥算法的不同数据类型之间进行转换：八位字节串 (OS)、位串 (BS)、整数 (I)、字段元素 (FE) 和椭圆曲线点 （ECP）。 DLMS/COSEM 使用八位组字符串来表示公钥算法的元素，并使用这些数据类型与八位组字符串之间的转换原语。 长度为 d 的`八位字节串` $M_{d–1}$ $M_{d–2}$ … $M_0$ 被编码为 `A-XDR` OCTET STRING，其中最左边的八位字节$M_{d–1}$对应于八位字节串的编码值的第一个八位位组

- Conversion between Bit Strings and Octet Strings (BS2OS)

  位串转换为八位串的数据转换原语称为位串到八位串转换原语，或称BS2OS。它以位字符串作为输入，输出八位字符串。长度为l的字节串$b_{l-1} b_{l-2}…b_{0}$应该转换为长度为$d=⌈l/8⌉$的八位字符串$M_{d-1} M_{d-2}…M_{0}$。

  >位串在内存中的编码非常密集。每个位只`占用一位`存储空间，整个位串的开销由一个小常数限定。但是，与访问向量或字符串的元素相比，访问位串中的位要慢。如果性能是最重要的问题，最好使用字符串来存储布尔值集，即使它们占用更多空间。
  >
  >位串和八位字节串的区别就是位串的位长`不需要是8的倍数`，而可以是任意值，转换的时候需要`补足8的倍数`

  转换器在左边`填充足够的零`，使位数为`8的倍数`，然后将其分解为八位。

  - for $0 \le i \lt d – 1$, let the octet $M_i = b_{8i+7} b_{8i+6} ... b_{8i},$;
  - the leftmost octet $M_{d–1}$ shall have its leftmost $8d – l$ bits set to zero;最左边的OS字节需要包含位串最左边填0部分
  - its rightmost $8 – (8d – l)$ bits shall be $b_{l–1} b_{l–2} … b_{8d–8}$.

- Conversion between Octet Strings and Bit Strings (OS2BS)

  和上面相反

  最左一字节的最左位必须是0

- Conversion between Integers and Octet Strings (I2OS)

  输入为`非负整数`$x$，预期长度$d$，需要满足$256^d \gt x$

  每个整数的位用一个字节表示：

  - $x = x_{d-1} \cdot 256^{d-1} + x_{d-2} \cdot 256^{d-2} + \cdots + x_1 \cdot 256 + x_0,$;
  - where $0 ≤ x_i < 256$ for $0 ≤ i ≤ d-1$;
  - $M_i = x_i$, for $0 ≤ i ≤ d-1$.

- Conversion between Octet Strings and Integers (OS2I)

  和上面相反

  0字节的OS输出整数0

- Conversion between Field Elements and Octet Strings (FE2OS)

  将`字段元素`转换为八位字符串的数据转换原语称为字段元素到八位字符串转换原语，或`FE2OS`。它接受一个`字段元素`作为`输入`，并`输出`相应的`八位字符串`。应用I2OS转换原语，参数$l$将域元素$x \in F_p$转换为长度为$d =⌈\log_{256}p⌉$的八位字符串$M_{d-1} M_{d-2} … M_0$，其中

  - $FE2OS(x) = I2OS(x,l)$

- Conversion between Octet Strings and Field Elements (OS2FE)

  与上面相反

  $OS2FE(x) = OS2I(x) \mod p$

TODO:Field Elements是什么，FE2OS不懂

###### 9.2.3.4.4 Digital signature

数字签名是书面签名的电子模拟，可用于向收件人或第三方证明消息是由发信人签名的(这种特性称为`不可否认性`)。还可以为所存储的数据和程序生成数字签名，以便可以在稍后时间验证数据和程序的`完整性`

![messages](/assets/img/2022-03-17-dlms-green-1/digitalsign.jpg)

###### 9.2.3.4.5 Elliptic curve digital signature (ECDSA)

对于DLMS/COSEM，选择了FIPS PUB 186-4:2013中指定的`椭圆曲线数字签名(ECDSA)算法`。NSA1提供了一个实现指南。

- 在DLMS/COSEM中使用的椭圆曲线和算法为:

  - in the case of Security Suite `1`, the elliptic curve `P-256` with the `SHA-256` hash algorithm;
  - in the case of Security Suite `2`, the elliptic curve `P-384` with the `SHA-384` hash algorithm.

- 签名
  - 输入：
    - 要签名的消息M;
    - 签名者的私钥d
  - 输出：
    - ECDSA signature (r, s) over M.

- 验签
  - 输入：
    - 已签名的消息M'
    - ECDSA signature (r',s')
    - 签名者的公钥Q

TODO:这里的(r',s')和(r, s)应该是相同的吧

在 DLMS/COSEM 中，应使用纯文本格式：签名 (r, s) 被编码为八位字节串 R || S(表示`串联`，不是逻辑运算符的或)，即作为八位字节串 `R = I2OS(r,l)` 和 `S = I2OS(s,l)` 的`串联`, $l = [\log_{256} n]$。 因此，签名具有 `2l` 个八位字节的`固定长度`。

###### 9.2.3.4.6 Key agreement

密钥协商允许两个实体联合计算共享密钥并从中派生密钥材料。

对于DLMS/COSEM，已从NIST SP 80056A Rev. 2: 2013中选择了三种椭圆曲线密钥协商方案

- 椭圆曲线密钥协商方案：

  - the Ephemeral Unified Model C(2e, 0s, ECC CDH) scheme;

    此方案用于DLMS客户机和服务器之间就主密钥、全局加密密钥和/或身份验证密钥达成一致。`客户端`扮演`U`方角色，`服务器`扮演`V`方角色。流程由“`Security setup`”接口类的方法支持;见DLMS UA 1000-1 Part 2 Ed.15:2021, 4.4.7.

    双方从域参数d(TODO:域参数是什么)中生成一个`临时密钥对`。双方`交换临时公钥`，然后使用`域参数`、`各自的临时私钥`和`对方的临时公钥`计算`共享密钥Z`。`密钥材料`是使用9.2.3.4.6.5中指定的`密钥派生函数`从`共享密钥Z`和`其他输入`中派生出来的。(TODO:密钥材料，密钥派生是什么。)

  - the One-Pass Diffie-Hellman C(1e,1s, ECC CDH) scheme;

    和上面的类似，主要是静态动态公钥的区别，就是不需要服务端把动态公钥给客户端，客户端可以通过预先导入的证书（可信CA签名）获得对方的静态公钥

    全程只需要发送一次公钥
  - the Static Unified Model C(0e, 2s, ECC CDH) scheme.

    和上面的类似，将动态公钥变成了静态公钥，不需要发送公钥，只需要Nonce，Nonce用于计算密钥材料，保证每次生成的密钥材料不同。

- Key Derivation Function – The NIST Concatenation KDF

  密钥派生函数

  Function call: `kdf(Z, OtherInput)`
  - `Z`
    共享密钥，byte string
  - `OtherInput`
    - keydatalen
      一个整数，表示要生成的`密钥材料`的`长度`(以`位`为单位):安全套件`1`为`128`位，安全套件`2`为`256`位;
    - OtherInfo
      等于下列串联的位字符串

      AlgorithmID || PartyUInfo || PartyVInfo {||SuppPubInfo}{||SuppPrivInfo}

      - AlgorithmID
        bit string，指示如何`解析`派生的密钥材料,以及派生的密钥材料将用于哪种`算法`

        GUEK and GAK：AES-GCM-128 / AES-GCM-256.

        KEK：AES-WRAP-128 / AES-WRAP-256

        ![messages](/assets/img/2022-03-17-dlms-green-1/algorithmid.jpg)
      - PartyUInfo
        U方提供的公开信息，用于派生过程，bit string
      - PartyVInfo
        V方提供的公开信息，用于派生过程，bit string
      - SuppPubInfo
        (Optional),额外的公开信息，DLMS/COSEM不使用
      - SuppPrivInfo
        (Optional),额外的非公开信息，DLMS/COSEM不使用

##### 9.2.3.5 Random number generation

应提供强随机数生成器(RNG)，以生成DLMS/COSEM中使用的各种算法所需的随机数。

##### 9.2.3.6 Compression

和加密无关，只是放在一起

##### 9.2.3.7 Security suite

安全套件确定可用于各种密码原语的`密码算法集`和`密钥长度`。

`DLMS/COSEM安全套件`(见表27)基于[NSA suite B](https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography)，包括用于`身份验证、加密、密钥协议、数字签名和哈希的加密算法

![messages](/assets/img/2022-03-17-dlms-green-1/securitysuite.jpg)

#### 9.2.4 Cryptographic keys – overview

密钥作用：

- 明文到密文的转换;
- 密文到明文的转换;
- 验证码(MAC)的计算和验证;
- 密钥包装wrapping;
- 应用和验证数字签名;
- 密钥协商。

#### 9.2.5 Key used with symmetric key algorithms

##### 9.2.5.1 Symmetric keys types

对称密钥的分类：

- 按目的分类
  - key encrypting key (KEK)用于加密其他对称加密密钥，master key
  - encryption key用于AES-GCM算法的块加密
  - authentication key用于AES-GCM算法的AAD
- 按生命周期分类
  - 打算使用`较长时间`的`静态密钥`。 在 DLMS/COSEM 中，它们可能是：
    - 一个`全局密钥`，可用于在相同合作伙伴之间重复建立的多个 AA。 全局密钥可以是单播加密密钥（`GUEK`）、广播加密密钥（`GBEK`）或认证密钥（`GAK`）；
    - 在两个合作伙伴之间建立的单个 AA 期间可以重复使用的`专用密钥`。 因此，其生命周期与 `AA 的生命周期`相同。 专用密钥只能是`单播加密密钥`。
  - `临时密钥`通常用于 一个 AA 内的单个交换。

TODO:InitiateRequest APDU和AARQ是什么关系？答：见12.3 Table 133 最后，InitiateRequest APDU是AARQ中user-information字段的一部分，是可以加密的

`专用密钥`由AARQ APDU中的`InitiateRequest APDU`携带，这个InitiateRequest APDU`本身`要被全局单播加密密钥（`GUEK`）加密，AARE中的`InitiateResponse APDU`也要用相同的方式加密。

> AARQ和AARE APDUs本身`不受保护`。

![messages](/assets/img/2022-03-17-dlms-green-1/symmetrickeytypes.jpg)

##### 9.2.5.2 Key information with general-ciphering APDU and data protection

当general-ciphering APDU 用于保护 xDLMS APDU 或 COSEM 数据时，发送方发送关于已经/将用于加密/解密 xDLMS APDU/COSEM 数据的`密钥的必要信息`，以及`加密的` xDLMS APDU / COSEM `数据`。

TODO:没看懂

##### 9.2.5.3 Key identification

TODO:没看懂

##### 9.2.5.4 Key wrapping

可以用key wrapping加密的：

- the master key, KEK; and/or
- the global unicast encryption key GUEK; and/or
- the global broadcast encryption key GBEK; and/or
- the (global) authentication key, GAK.

“Security setup” 对象的key_transfer方法。

##### 9.2.5.5 Key agreement

可以用The `Ephemeral` Unified Model C(2e,0s, ECC CDH) scheme协商的密钥：

- the master key, KEK; and/or
- the global unicast encryption key GUEK; and/or
- the global broadcast encryption key GBEK; and/or
- the (global) authentication key, GAK.

##### 9.2.5.6 Symmetric key cryptoperiods

对称密钥的加密周期应在项目特定的配套规范中确定。

#### 9.2.6 Keys used with public key algorithms

非对称加密算法密钥分类：

- 按目的：数字签名、密钥协商

- 按生命周期：静态密钥、临时密钥

![messages](/assets/img/2022-03-17-dlms-green-1/asymmetrickeytypes.jpg)

##### 9.2.6.2 Key pair generation

由(q, FR, a, b {, domain_parameter_seed}, G, n, h)生成私钥d和公钥Q

##### 9.2.6.3 Public key certificates and infrastructure

Public Key Infrastructure (PKI)

###### 9.2.6.3.2 Trust model

DLMS servers 设备制造过程应该预先导入`trust anchors`信任锚、自己的证书、CA证书、DLMS clients and third parties证书。

>设备制造导入证书或信任锚属于`Out of Band (OOB)`带外过程，也就是`正规操作以外`的过程，正常导入证书应该是通过“Security setup”对象

>[信任锚](https://ldapwiki.com/wiki/Trust%20Anchor)或是[这篇文章](https://stackoverflow.com/questions/56061101/trust-anchor-certificates-in-pki)，信任锚就是最终信任的那个实体，可以有多个，可以是root CA，一般操作系统预装了可以信赖的root CA列表

“Security setup”类提供：

- 提供关于存储在服务器上的`证书`的信息的`属性`;
- 用于`生成`服务器`密钥对`的方法和用于`生成`服务器上的证书签名请求(`CSR`)信息的方法,CSR由客户端`代为发送给CA`;
- `导入、导出、移除证书`的方法

证书一般都有一个`有效期限`。但是，颁发给`DLMS服务器`的证书可能`无限期有效`。证书到期后，可能需要进行`替换`。

在服务器使用证书之前，必须对其进行验证。验证包括:

- 检查证书的`语法`有效性;
- 检查证书包含的`属性`;
- 检查证书有效期是否`未过期`;
- 检查`信任锚点`的认证路径;
- 检查证书`颁发者`的`签名`

###### 9.2.6.3.3 PKI architecture – informative

PKI是一种安全基础设施，它`创建`和`管理公钥证书`，以方便使用公钥(即，非对称密钥)加密。

- 在验证绑定的准确性后，`生成并分发公钥证书`，以将公钥绑定到其他信息上（证书包含了公钥和部分设备自定义信息，最后加上数字签名）
- 维护和分发未过期证书的证书`状态信息`。

![messages](/assets/img/2022-03-17-dlms-green-1/pkiarch.jpg)

- Root-CA
  提供PKI的`信任锚点`。它为Sub-CAs颁发证书，并维护一个证书撤销列表(`CRL`)。Root-CA证书策略定义了处理证书颁发的规则

  Root-CA拥有根证书“`C(Root)`”。Root-CA的证书是用Root-CA的私钥`自签名`的。`Sub-CAs`证书也使用Root-CA`私钥签名`。

- Sub-CA
  Sub-CA是为终端实体颁发证书的组织，被Root-CA授权

  每个Sub-CA Certificate Policy证书策略必须遵守Root-CA Certificate Policy
  
  备存发给终端实体End entity的`证书清单`及`证书撤销清单`

  Sub-CA拥有证书`C(sub-CA)`。此证书由Root-CA颁发。Sub-CA的私钥用于签名终端实体End entity证书。

- End entities
  - 数字签名密钥证书`C(digitalSignature)`，用于数字签名;
  - 静态密钥协商密钥证书`C(keyAgreement)`，用于密钥密钥协商;
  - （可选）TLS- certificate `C(TLS)`，用于在建立TLS安全通道之前在DLMS客户端和DLMS服务器之间进行认证。

##### 9.2.6.4 Certificate and certificate extension profile

所有证书都应具有为`X.509 V3`证书指定的结构。

###### 9.2.6.4.2 The X.509 v3 Certificate

- m (mandatory): 强制使用;
- o (optional): 可选;
- x (do not use): 不要使用.

Certificate：

- tbsCertificate
  包含主题和颁发者的名称、与主题关联的公钥、有效期和其他相关信息
  - Version
    V3为2
  - Serial number
    序列号必须为CA分配给每个证书的`正整数`。对于给定CA颁发的每个证书，它必须是`唯一`的。上限`20个字节`
  - Issuer and Subject
    颁发者字段标识签名和颁发证书的实体。

    ![messages](/assets/img/2022-03-17-dlms-green-1/rootcasubject.jpg)

    ![messages](/assets/img/2022-03-17-dlms-green-1/subcasubject.jpg)

    ![messages](/assets/img/2022-03-17-dlms-green-1/entitysubject.jpg)
  
    Common Name需要是DLMS/COSEM System title
  - Validity period
    证书有效期

    - 开始生效(notBefore)
    - 无效时间(notAfter)

    DLMS服务器可以获得无法指定有效过期日期的证书;这样的证书将在设备的`整个生命周期`内使用

    为了表明证书没有明确定义的到期日期，`notAfter` 应该被分配 `99991231235959Z` 的 `GeneralizedTime` 值。
  - SubjectPublicKeyInfo
    标识公钥和密钥算法

    ```asn.1
    SubjectPublicKeyInfo ::= SEQUENCE 
    {
      Algorithm               AlgorithmIdentifier, 
      subjectPublicKey        BIT STRING 
    }
    AlgorithmIdentifier ::= SEQUENCE 
    {
      algorithm               OBJECT IDENTIFIER, 
      parameters              ANY DEFINED BY algorithm OPTIONAL
    }
    ```

    AlgorithmIdentifier用于识别密钥算法

    OBJECT IDENTIFIER：
    - OID value: 1.2.840.10045.2.1;
    - OID description: ECDSA and ECDH Public Key.

    parameter：
    - 1.2.840.10045.3.1.7：NIST P-256
    - 1.3.132.0.34：NIST P-384

  - Subject Unique ID
    主题唯一id可以选择性地用于终端设备证书，而不是服务器证书。
  
- Certificate extensions

  ![messages](/assets/img/2022-03-17-dlms-green-1/x509v3ext.jpg)

  - Authority Key Identifier
    标识公钥，公钥是和用于签名证书的私钥对应的
  - SubjectKeyIdentifier
    标识包含特定公钥的证书
  - KeyUsage
    密钥用途，keyAgreement、digitalSignature等
  - CertificatePolicies
    证书策略
  - SubjectAltNames
    主题备用名称,可以当作subject的扩展
  - IssuerAltName
    签发者备用名称
  - Basic constraints
    标识本证书所有者是否为CA
  - Extended Key Usage
    该证书可作为TLS服务器证书使用
  - cRLDistributionPoints
    标识如何获取CRL
  - Other extensions
- signatureAlgorithm
  包含CA用于签名此证书的`签名算法`的标识符。和`signatureValue`相关

  ```asn.1
  AlgorithmIdentifier ::= SEQUENCE
  {
    algorithm         OBJECT IDENTIFIER
    parameters        ANY DEFINED BY algorithm OPTIONAL 
  }
  ```

  - `ecdsa-with-SHA256`, OID 1.2.840.10045.4.3.2 in the case of security suite 1;
  - `ecdsa-with-SHA384`, OID 1.2.840.10045.4.3.3 in the case of security suite 2;
  
- signatureValue
  由`ASN.1 DER编码的tbsCertificate`生成的`数字签名`

  用于验证tbsCertificate的有效性

##### 9.2.6.5 Suite B end entity certificate types to be supported by DLMS servers

终端设备包含的证书类型

证书必须用ECDSA签名，证书中的`P-256`类型密钥必须用`P-256或P-384`类型密钥签名，证书中的`P-384`类型密钥必须用`P-384`类型密钥签名

- Root-CA自签名证书（信任锚）
- Sub-CA证书
- 用于ECDSA签名生成和验签的证书（TODO：这个证书是干什么用的）
- Key Establishment(Key agreement)用证书（One-Pass Diffie-Hellman C(1e, 1s) scheme or with the Static Unified Model C(0e, 2s, ECC CDH) scheme）
- TLS证书

##### 9.2.6.6 Management of certificates

证书管理

###### 9.2.6.6.2 Provisioning servers with trust anchors

为服务器提供`信任锚`，需要再设备`正常运行前`导入`Root-CA,Sub-CA证书`或`直接信任的CA公钥`。可以有多个信任锚

信任锚的部署或替换是`带外操作`，out of band (`OOB`)

信任锚证书和其他证书`存储在一起`（TODO:这个是否有安全问题，比如windows有专门的受信任根证书区域，每个分类都有专属区域。）

可以`导出`，不能`导入或删除`（TODO:解释了上面的安全问题，是有防篡改保护的）

直接信任的CA公钥不能导出

###### 9.2.6.6.3 Provisioning the server with further CA certificates

为服务器提供`进一步的CA证书`（应该是Sub-CA，非信任锚）

“`Security setup`”对象中的`import_certificate`方法

导入的CA证书需要使用信任锚校验

###### 9.2.6.6.4 Security personalisation of the server

安全个性化导入非对称密钥：

- 通过设备商专有方式导入私钥和公钥证书
- “Security setup”相关函数产生
  
  ![messages](/assets/img/2022-03-17-dlms-green-1/mscpersonal.jpg)

  1. 客户端调用`generate_key_pair`方法。方法调用参数指定要生成的特定用途的`密钥对`:数字签名、密钥协商或TLS;
  2. 客户端调用`generate_certificate_request`方法。方法调用参数标识将为其生成证书签名请求(`CSR`)的密钥对。返回参数包括CSR，由新生成的密钥对的私钥签名;（TODO:CSR还要私钥签名吗）
  3. 客户端`向CA发送CSR`，该消息封装了调用generate_certificate_request方法得到的返回参数。CA(如果满足必要条件)`颁发`证书并将其发送给客户端;
  4. 客户端调用`import_certificate`方法。方法调用参数包含证书。服务器`验证`证书，如果成功，则将证书上的信息添加到certificates属性。如果验证失败，证书将被丢弃。

  导入新证书成功后，旧证书将被移除。

  使用服务器证书的`各方`可以通过以下方式`获得证书`:

  - 带外`out of band`;
  - 使用“`Security setup`”对象的`export_certificate`方法
  - 作为`AARE`的一部分(在`HLS认证`期间)

###### 9.2.6.6.5 Provisioning servers with certificates of clients and third parties

向服务器提供客户端和第三方证书

服务器要`验证数字签名`，要使用使用静态密钥协商密钥的方案执行`密钥协商`，或要`建立TLS连接`，`服务器`需要`对方`的适当`公钥证书`。

如果在制造时`已经知道`客户端和/或第三方，则制造商可以将其`公钥证书注入服务器`。

否则，可以使用“`Security setup`”对象的`import_certificate`方法为服务器提供客户端和第三方的证书。

###### 9.2.6.6.6 Provisioning clients and third parties with certificates of servers

向客户端和第三方提供服务器的证书

要`验证数字签名`，要使用使用静态密钥协商密钥的方案执行`密钥协商`，或要`建立TLS连接`，`客户端或第三方`需要`对方`的适当`公钥证书`。

证书可以随服务器一起交付，并插入到客户端/第三方OOB中。

或者，客户端或第三方可以使用“`Security setup`”对象的`export_certificate`方法从服务器请求证书。方法调用参数标识所请求的证书。

###### 9.2.6.6.7 Certificate removal from the server

从服务器上删除证书

当属于服务器的证书被删除时，与公钥相`关联的私钥`也应被`销毁`。

"`Security setup`"对象的`remove_certificate`方法用于删除证书

#### 9.2.7 Applying cryptographic protection

- 保护`xDLMS APDUs`参见9.2.7.2;
- 处理HLS认证期间的挑战信息`challenges`，见9.2.7.4;
- 保护`COSEM data`，参见9.2.7.5。

##### 9.2.7.2 Protecting xDLMS APDUs

本小节9.2.7.2指定了9.2.3.3和9.2.3.4中指定的加密算法如何用于保护xDLMS APDUs:

###### 9.2.7.2.2 Security policy and access rights values

![messages](/assets/img/2022-03-17-dlms-green-1/securitypolicy.jpg)

`access rights访问权限`由“`Association LN`”的 `object_list` 属性或“`Association SN`”对象的 `access_rights_list` 持有。access_rights的`access_mode`元素决定了访问类型并规定了密码保护。它是一个enum数据类型。

![messages](/assets/img/2022-03-17-dlms-green-1/accessright1.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/accessright2.jpg)

对 `COSEM对象` 属性 和/或 方法 的`访问权Access rights`可能要求对xDLMS APDUs进行 认证、加密 和/或 签名 。为此，只允许保护程度`超过或等于安全策略security policy`要求的APDUs。保护程度`低于安全策略和访问权限要求`的APDU应被`拒绝`。

在这种情况下，`更多的保护`是指在xDLMS APDU上应用比安全策略所要求的`更多种类`的保护：例如，安全策略security policy要求所有的APDU都经过`认证`，但访问权限Access rights要求APDU经过`加密和认证`，即更高的保护。

>(access rights是针对某个对象的特定属性或方法的，security policy是全局的，所以access rights可以比security policy更严格，而不能更宽松)

###### 9.2.7.2.3 Ciphered xDLMS APDUs

`加密的xDLMS APDUs`只能在加密的`应用程序上下文`中使用。另一方面，在加密的应用程序上下文中，可以同时使用`加密`和`未加密`的APDUs。

general-ded-ciphering  `dedicated` 专用的

general-glo-ciphering `global` 全局的

![messages](/assets/img/2022-03-17-dlms-green-1/cipheredxdlmsapdus.jpg)

###### 9.2.7.2.4 Encryption, authentication and compression

在`消息保护`的情况下，要保护的信息是`xDLMS APDU`。在COSEM`数据保护`的情况下，需要保护的信息是`COSEM data数据`，即`COSEM属性值`或`方法调用/返回参数`。

![messages](/assets/img/2022-03-17-dlms-green-1/aesgcmapdus.jpg)

- The security header

  SH = SC || IC

  ![messages](/assets/img/2022-03-17-dlms-green-1/securitycontrolbyte.jpg)

  - Bit 3…0: Security_Suite_Id, see 9.2.3.7;
  - Bit 4: “A” subfield: 是否认证
  - Bit 5: “E” subfield: 是否加密
  - Bit 6: Key_Set subfield:
  0 = Unicast, 1 = Broadcast;
  - Bit 7: 是否压缩

- Plaintext and Additional Authenticated Data

  plaintext, P

  Additional Authenticated Data, A

  security control byte, SC

  authentication key, AK

  information, I

  `P`是一个关于加密的`形参`，可以为I，如果不加密的话就是空的。

  根据SC的不同，AAD也会不同

- Encryption key and authentication key

- Initialization vector

- Service-specific ciphering xDLMS APDUs

  `Service-specific`区别于`general`，可以使用部分`变体`

  ![messages](/assets/img/2022-03-17-dlms-green-1/servicespecificapdus.jpg)

- The general-glo-ciphering and geneal-ded-ciphering xDLMS APDUs

  ![messages](/assets/img/2022-03-17-dlms-green-1/generalglocipher.jpg)

  The general-ciphering APDU可以用于客户端和服务器之间，也可以用于第三方和服务器之间。这些`APDU`还携带了所使用`密钥`的`必要信息`。

  ![messages](/assets/img/2022-03-17-dlms-green-1/generalcipher.jpg)

- Use of the fields of the ciphering xDLMS APDUs

- Encoding example: global-get-request xDLMS APDU

###### 9.2.7.2.5 Digital signature

![messages](/assets/img/2022-03-17-dlms-green-1/generalsign.jpg)

##### 9.2.7.3 Multi-layer protection by multiple parties

多重保护一般用于third party->client->server模型，即third party应用一层，client应用一层。

server需要根据请求的保护状态以及security policy and access rights要求的保护来保护数据

TODO:很难理解，需要实例。

##### 9.2.7.4 HLS authentication mechanisms

![messages](/assets/img/2022-03-17-dlms-green-1/dlmshlsauth.jpg)

需要提前知道对方的证书和systemtitle,不知道的话需要传递

见原文示例

##### 9.2.7.5 Protecting COSEM data

需要保护的数据列表、需要保护的对象和保护参数由“`Data protection`”对象决定。

### 9.3 DLMS/COSEM application layer service specification

#### 9.3.1 Service primitives and parameters

- `REQUEST`：请求原语从 N-用户传递到 N-层以请求启动服务；
- `INDICATION`：指示原语从 N-层传递给 N-用户，以指示对 N-用户重要的内部 N-层事件。 该事件可能逻辑上与远程服务请求有关，也可能是N-层内部的事件引起的；
- `RESPONSE`：响应原语从 N-用户传递到 N-层，以完成先前由指示原语调用的过程。
- `CONFIRM`：确认原语从 N-层传递给 N-用户，以传达一个或多个相关的先前服务请求的结果。

`（重要）命名规则`

#### 9.3.2 The COSEM-OPEN service

COSEM-OPEN服务的作用是在对端COSEM应用实体(AEs)之间建立AA。

使用ACSE的A-ASSOCIATE服务

- Protocol_Connection_Parameters

  强制。 它包含使用通信配置文件层所必需的所有信息，包括通信配置文件（协议）标识符和所需的地址。 它确定了 AA 的参与者。 该参数的元素被传递给管理低层连接的实体，并酌情传递给低层。

- ACSE_Protocol_Version

  可选参数。如果存在，则应使用缺省值。

- Application_Context_Name

  强制。在请求原语中，它持有客户端`提议`的值。在响应原语中，它保存相同的值或服务器`支持`的值。(类似于TLS握手中的加密策略，是一个需要`协商`的值)

- Called_AP_Title, Called_AE_Qualifier, Called_AP_Invocation
_Identifier, Called_AE_Invocation_Identifier

  可选

- Calling_AP_Title

  有条件的。当建议的`应用程序上下文`和/或建议的`HLS认证机制`要求使用`客户端system title`，并且在注册过程中尚未传输时，Calling_AP_Title应携带客户端system title。见4.3.4。

  TODO：注册过程是什么

- Calling_AE_Qualifier

  有条件的。当Application_Context_Name为加密的`应用上下文Application_Context_Name`时，可能携带客户端的公共数字签名密钥`证书`。

- Calling_AP_Invocation_Identifier

  可选。

- Calling_AE_Invocation_Identifier

  可选。携带AA的客户端用户的标识符。

- Local_or_Remote

  强制。接收到AARE APDU生成的确认就是Remote,本地确认就是Local

- Result

  强制。remote confirmation下为AA是否被接受，local confirmation下为本地低层协议栈是否接受请求

- Failure_Type

  强制。在远程确认的情况下，它携带服务器提供的信息。在局部和消极negative确认的情况下，表示失败的原因。

- Responding_AP_Title

  有条件的。当协商的应用程序上下文和/或协商的HLS认证机制要求使用服务器系统标题，并且在注册过程中尚未转移时，则Responding_AP_Title应携带服务器`系统标题system title`。

- Responding_AE_Qualifier

  有条件的。当Application_Context_Name为加密的应用上下文时，可能携带服务器的公共数字签名密钥`证书`。

- Responding_AP_Invocation_Identifier and Responding_AE_Invocation_Identifier

  可选

TODO:后面参数太多了，先省略了。

##### 9.3.2.3 Use

![messages](/assets/img/2022-03-17-dlms-green-1/timeseq.jpg)

- confirmed AA -- `a`
- unconfirmed AA -- `b`
- pre-established AA -- `c`

原语发生在AP和AL之间，

#### 9.3.3 The COSEM-RELEASE service

`优雅释放`已经存在的AA

调用它的方式（`Use_RLRQ_RLRE`参数）决定了它是`否使用`ACSE的`A-RELEASE`服务。

#### 9.3.4 The COSEM-ABORT service

指示支持协议层的主动断开,只有COSEM-ABORT.indication原语，，对应上图中的`e`情况

COSEM-ABORT.indication原语在客户端和服务器端`本地生成`，以指示COSEM AP下层连接以`非请求`的方式`关闭`。

此类事件的起因可以是一个`外部事件`(例如物理线路断线)，或者在一些配置文件中出现的一个`支持协议层连接管理器AP`(`层管理AP`，非COSEM AP)的动作，当支持的协议层连接不是由DLMS/COSEM AL管理时。这将导致COSEM AP`中止`任何现有的AA，除了在服务器端预连接AA。

#### 9.3.5 Protection and general block transfer parameters

![messages](/assets/img/2022-03-17-dlms-green-1/protectiongbtparams.jpg)

`Additional_Service_Parameters`仅在使用`加密`或`GBT`时存在。

- Invocation_Type:`COMPLETE`, `FIRST-PART`, `ONE-PART` and `LAST-PART`

Block_Transfer_Streaming指示是否允许AL使用流（GBT），见9.4.6.13

Block_Transfer_Window指示最大接受窗口大小

#### 9.3.6 The GET service

其功能是`读取`一个或多个COSEM对象属性的值。结果可以在`单个响应`中交付，或者(如果它太长，不能在单个响应中交付)在`多个响应`中交付，使用`块传输`。

![messages](/assets/img/2022-03-17-dlms-green-1/getparams.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/getreqtype.jpg)

两个优先级normal (FALSE) or high (TRUE).

如果是Request_Type=NEXT就不用带COSEM_Attribute_Descriptor

REQUEST-WITH-LIST会带多个COSEM_Attribute_Descriptor，但不能超过server-max-receive-pdu-size。`原则：GET.request服务原语必须包含在单个APDU中`

整个`响应`单个APDU`放得下`就用Response_Type == NORMAL or WITH-LIST，`放不下`就用Response_Type == `ONE-BLOCK`，最后一包用LAST-BLOCK

COSEM_Object_Attribute_Id == 0 (`Attribute_0`)的情况，表示读取`所有的属性`，返回一个包含所有数据的`结构体`，没权限的或访问出错的回null-data（TODO:这里是用NORMAL还是 WITH-LIST，我觉得是NORMAL，返回的是一个结构体，包含所有数据，而不是LIST）

- successful confirmed GET -- `a`
- unconfirmed GET -- `d`
- unsuccessful attempt due to a local error -- `c`

#### 9.3.7 The SET service

写入一个或多个COSEM对象属性的值。要写入的数据可以在单个请求中发送，或者(如果数据太长，不能在单个请求中发送)在`多个请求`中使用`块传输`。(不同于GET，SET请求可以分包)

![messages](/assets/img/2022-03-17-dlms-green-1/setparams.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/setreqtype.jpg)

仅Request_Type == NORMAL, FIRST-BLOCK, WITH-LIST and FIRST-BLOCK-WITH-LIST携带COSEM_Attribute_Descriptor

响应不能分包

COSEM_Object_Attribute_Id == 0 (`Attribute_0`)的情况，同GET，需要SET请求包含有`全部公开属性`的Data值的`结构体`。Result将携带一个结果，如果写入了`所有属性`则为`成功`，或者只有一个`失败原因`。(TODO:部分成功的情况呢)

- successful confirmed SET -- `a`
- unconfirmed SET -- `d`
- unsuccessful attempt due to a local error -- `c`

#### 9.3.8 The ACTION service

调用一个或多个COSEM对象方法

请求响应都能分包,需要请求`完整发完`，响应才开始分包发送结果

![messages](/assets/img/2022-03-17-dlms-green-1/actionparams.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/actionreqtypes.jpg)

`第一阶段`：client AP向AL发送ACTION.request，server的AL收到后向AP发送ACTION.indication，server AP回ACTION.response，ACTION.confirm由AL发送给client AP,都是可以是分包的。直到收到完整的请求（LAST-BLOCK发送后）。

`第二阶段`：开始执行方法，执行完后返回结果，可以分包

#### 9.3.9 The ACCESS service

使用一个.request / .response访问（access）`多个`COSEM对象属性和/或方法，包括GET / SET / ACTION的组合

ACCESS好像就是DSMR里的COSEM-ACCESS

`Long_Invoke_Id`，区别于上面的Invoke_Id

`自描述响应`，不仅包含结果data，也包含请求参数，可以不依赖于对应的请求直接解析响应。可选。

对于GET，Access_Request_List_Of_Data中也包括data,对于GET就是null-data，需要由响应填充

可以带`时间戳`，表示.request和.response调用时间，降低消耗（TODO:为什么可以降低消耗）

支持list访问，Access_Request_Specification作为数组可以有多个元素

##### 9.3.9.2 Service specification

![messages](/assets/img/2022-03-17-dlms-green-1/accessparams.jpg)

Access_Request_Specification:

- Access_Request_Get 不带选择性访问参数
- Access_Request_Set 不带选择性访问参数
- Access_Request_Action
- Access_Request_Get_With_Selection 带选择性访问参数，不能用于Attribute_0情况
- Access_Request_Set_With_Selection 带选择性访问参数，不能用于Attribute_0情况

优先判断result，如果result失败直接丢弃data。

#### 9.3.10 The DataNotification service

数据推送

unsolicited未经请求, unconfirmed无需确认 或 confirmed需确认

request支持分块传输

![m esages](/assets/img/2022-03-17-dlms-green-1/datanotiparams.jpg)

Confirmed：收到Data-Notification-Confirm APDU

Unconfirmed：收到支持层确认

服务原语通信模型：Figure 112 a), b) and d).

TODO:这里的d是什么情况，按照描述，Unconfirmed也需要支持层响应

#### 9.3.11 The EventNotification service

unconfirmed无需确认

request支持分块传输

![messages](/assets/img/2022-03-17-dlms-green-1/eventnotiparams.jpg)

Application_Addresses:可选，如果`没有`相应的`AA`，则包含全部识别信息(也就是允许没有AA的情况上报)

服务原语通信模型：Figure 112 f), g)

#### 9.3.12 The TriggerEventNotificationSending service

EventNotification的触发服务，由客户端发起，用于EventNotification不能自动触发的情况。

不需要AA

#### 9.3.13 Variable access specification

#### 9.3.14 The Read service

#### 9.3.15 The Write service

#### 9.3.16 The UnconfirmedWrite service

#### 9.3.17 The InformationReport service

#### 9.3.18 Client side layer management services: the SetMapperTable.request

有关SN的跳过

### 9.4 DLMS/COSEM application layer protocol specification

#### 9.4.1 The control function (CF)

##### 9.4.1.1 State definitions of the client side control function

![messages](/assets/img/2022-03-17-dlms-green-1/clientcfstatemachine.jpg)

带`/`的表示`过程`，也就是在转换过程中发生的，不带`/`的表示状态转换触发的`起点`。(可以这么理解，左右两个pending就是`中间态`，而IDLE和ASSOCIATED是`起始态`，从起始触发的就是不带`/`的)

##### 9.4.1.2 State definitions of the server side control function

![messages](/assets/img/2022-03-17-dlms-green-1/servercfstatemachine.jpg)

TODO:图上的EventNotification.reg单词拼错了，应该是req

#### 9.4.2 The ACSE services and APDUs

##### 9.4.2.1 ACSE functional units, services and service parameters

见文中Table 81

AARQ APDU由COSEM-OPEN.request原语决定，AARE APDU由COSEM-OPEN.response原语决定

`user-information`:AARQ APDU中携带xDLMS InitiateRequest APDU包含Proposed_xDLMS_Context参数。AARE APDU中携带an xDLMS InitiateResponse APDU包含Negotiated_xDLMS_Context参数

##### 9.4.2.2 Registered COSEM names

TODO:看不太懂

- COSEM_Application_Context_Name
- COSEM_Authentication_Mechanism_Name
- COSEM_Cryptographic_Algorithm_Id

#### 9.4.3 APDU encoding rules

##### 9.4.3.1 Encoding of the ACSE APDUs

`ACSE` APDUs编码：`BER`

`user-information`内的内容因为是`xDLMS`格式的，所以需要用`A-XDR`编码

##### 9.4.3.2 Encoding of the xDLMS APDUs

`xDLMS` APDUs编码：`A-XDR`

##### 9.4.3.3 XML

DataNotification APDU可以编码为XML格式。

#### 9.4.4 Protocol for application association establishment

##### 9.4.4.1 Protocol for the establishment of confirmed application associations

client AP发送`COSEM-OPEN.request`原语（Service_Class == Confirmed），client `CF`（control function）进入`ASSOCIATION PENDING`状态（见9.4.1），

然后，`CF` 在 `xDLMS ASE` 和 `ACSE` 的帮助下`组装`包含从 AP 接收的 COSEM-OPEN.request 原语参数的 `AARQ APDU`，并将其`发送`到服务器。

(`xDLMS ASE`是InitiateRequest APDU打包器（只和xDLMS相关，就是AARQ中的`user-information`），`ACSE`是AARQ APDU打包器（ACSE中的`Kernel`和`authentication` functional相关的参数,见9.4.2.1）)

`服务器` AL 的 `CF` 将收到的 AARQ APDU 提供给 `ACSE`, ACSE提取 `ACSE` 相关参数，然后将`控制权`交还给 CF。

然后，`CF` 将 AARQ APDU 的用户信息参数的内容（携带 xDLMS InitiateRequest APDU）传递给 `xDLMS ASE`,xDLMS ASE检索此 APDU 的参数，然后将`控制权`交还给 CF。

CF 使用收到的 APDU 参数生成 COSEM-OPEN.indication 给服务器 AP ，并进入“`ASSOCIATION PENDING`”状态。

![messages](/assets/img/2022-03-17-dlms-green-1/mscaa.jpg)

总结：先xDLMS ASE层打包，再ACSE层打包，得到AARQ APDU。AARQ APDU先ACSE层解包，再xDLMS ASE层解包

##### 9.4.4.2 Repeated COSEM-OPEN service invocations

AA已经存在时，client AP发的COSEM-OPEN.request直接由client AL回应确认

##### 9.4.4.3 Establishment of unconfirmed application associations

Service_Class == Unconfirmed

本地AL不等待回应直接回.confirm

一般用于单向通信或广播

无需确认AA中只能使用无需确认xDLMS数据传输服务

##### 9.4.4.4 Pre-established application associations

无需AA建立和释放

#### 9.4.5 Protocol for application association release

- 优雅graceful方式
  - 断开AL的支持协议层

    前提是`面向连接`的协议层（HDLC,TCP）

    the COSEM-RELEASE，`Use_RLRQ_RLRE`参数`不存在`或为`FALSE`(就是不使用ACSE的`A-RELEASE`服务，见9.3.3)

    ![messages](/assets/img/2022-03-17-dlms-green-1/releaseaaspl.jpg)

  - 使用ACSE A-Release服务

    `Use_RLRQ_RLRE`参数为`TRUE`（就是使用ACSE的`A-RELEASE`服务），COSEM-RELEASE服务可以包含`加密的`xDLMS InitiateRequest / InitiateResponse在RLRQ / RLRE APDUs的`user-information`参数中，从而防止潜在的`拒绝服务攻击`(没有保护的话谁都可以断开连接)。

    ![messages](/assets/img/2022-03-17-dlms-green-1/releaseaa.jpg)

- 非优雅Non-graceful方式

  当AP发生意外事件(如检测到物理连接中断)时，检测本地错误，等等

  ![messages](/assets/img/2022-03-17-dlms-green-1/phabort.jpg)

#### 9.4.6 Protocol for the data transfer services

##### 9.4.6.1 Negotiation of services and options – the conformance block

一致性块，用于协商双方支持的功能

![messages](/assets/img/2022-03-17-dlms-green-1/conformanceblock.jpg)

COSEM-OPEN服务中：xDLMS InitiateRequest APDU中的proposed-conformance参数和xDLMS InitiateResponse APDU中的negotiated-conformance

##### 9.4.6.2 Confirmed and unconfirmed xDLMS service invocations

- client发起：

  - 在`confirmed`的AAs中

    可以以confirmed or unconfirmed的方式调用xDLMS服务。

  - 在`unconfirmed`的AAs中

    只能以unconfirmed的方式调用xDLMS服务。这样，在多播 和/或 广播的情况下，由于潜在的`多重响应`而产生的`冲突`可以避免。

  unconfirmed xDLMS services三种目的地址：

  - 单个地址
  - 组地址
  - 广播地址

  如果AA没建立，服务端会丢弃unconfirmed请求。

- 服务端发起：

  unsolicited services：

  - InformationReport;
  - EventNotification;
  - DataNotification.

##### 9.4.6.3 Protocol for the GET service

有多个属性的情况下，每个属性都要回对应的Data或Data_Access_Result

第一个.response的DataBlock_G(见9.3.7)：

- Last_Block == FALSE;
- Block_Number  == 1;
- Result (Raw_Data) == the first K bytes of the encoded data: B1, B2, B3,…., BK.

客户端AP继续发送GET-REQUEST-NEXT,Block_Number和上一次接受到的回复相同，也就是1。

各种错误处理

##### 9.4.6.4 Protocol for the SET service

类似GET

即使分包，每一包的Invoke_Id和Priority必须是一样的，因为是同一个请求

各种错误处理

##### 9.4.6.5 Protocol for the ACTION service

请求响应都能分包，请求发完，再由响应分包。

##### 9.4.6.6 Protocol for the ACCESS service

TODO：不太理解，要等到GBT看完

##### 9.4.6.7 Protocol of the DataNotification service

- unconfirmed，支持协议层回错误（及时）

![messages](/assets/img/2022-03-17-dlms-green-1/datanotimsc.jpg)

- unconfirmed，支持协议层超时未回应

  AP超时未收到回应直接进重发模式，开始重发等待，此时支持协议层返回的信息都忽略，不管成功还是失败，

- confirmed

  总是忽视本地确认，未收到远程确认前总是重发

##### 9.4.6.8 Protocol for the EventNotification service

详见10

##### 9.4.6.9 Protocol for the Read service

##### 9.4.6.10 Protocol for the Write service

##### 9.4.6.11 Protocol for the UnconfirmedWrite service

##### 9.4.6.12 Protocol for the InformationReport service

SN相关的跳过

##### 9.4.6.13 Protocol of general block transfer mechanism

由AL层实现，使用`General-Block-Transfer (GBT) xDLMS APDUs`传输`任意长度APDUs`

AL收到AP层.request / .response服务原语：

- 打包APDU
- 根据Security_Options打包加密APDU
- 如果大于协商的最大APDU大小，使用GBT分包

这个区别于AP层的`块传输`，这个GBT是针对APDU的





## 参考

