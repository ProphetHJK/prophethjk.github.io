---
title: "DLMS Green Book学习笔记"
author: Jinkai
date: 2022-04-19 09:00:00 +0800
published: true
math: true
categories: [技术]
tags: [C++, DAO, database]
image:
  src: /assets/img/2022-03-17-dlms-green-1/dlms.jpg
  alt: image alternative text
---

## 1 Scope

1. `建模`: 包括设备的`接口模型`和数据识别规则;在blue book 中定义
2. `消息`: 这涵盖了将接口模型`映射`到协议数据单元(APDU)的服务，以及这个APDU的`编码`。在本green book中定义
3. `传输`: 通过通信通道`传输消息`。在本green book中定义

通信模型：

![comm-module](/assets/img/2022-03-17-dlms-green-1/DLMS1.png)

## 3 Terms, definitions and abbreviations and symbols

### 3.1 General DLMS/COSEM definitions

- ACSE APDU：Association Control Service Element (ACSE)标准A-ASSOCIATE/A-RELEASE实现的APDU，AARQ/AARE/RLRQ/RLRE
- application association：两个应用实体AEs之间的合作关系
- application entity,AE: 独立于系统的应用活动，这些活动作为应用服务提供给应用代理，例如，一组应用服务元素，它们共同执行应用程序的所有或部分通信方面。
- xDLMS APDU：xDLMS Application Service Element (xDLMS ASE)使用的APDU

## 4 Information exchange in DLMS/COSEM

### 4.1 General

The key characteristics of data exchange using DLMS/COSEM are the following:

- devices can be accessed by various parties: clients and third parties;

    使用DLMS/COSEM进行数据交换的主要特点如下:设备可以被各种各方访问:客户端和第三方;

- mechanisms to control access to the resources of the device are provided;

    提供了控制对设备资源的访问的机制;

- these mechanisms are made available by the DLMS/COSEM AL and the COSEM objects ( Association SN / LN object, Security setup object);

    这些机制是由DLMS/COSEM AL和COSEM对象(关联SN / LN对象，安全设置对象)提供的;

- security and privacy is ensured by applying cryptographical protection to xDLMS messages and to COSEM data;

    通过对xDLMS消息和COSEM数据应用加密保护来确保安全性和私密性;

- low overhead and efficiency is ensured by various mechanisms including selective access, compact encoding and compression;

    通过各种机制，包括选择性访问、压缩编码和压缩，确保了低开销和效率;

- at a site, there may be single or multiple devices.

    在一个站点，可能有单个或多个设备。

- In the case of multiple devices at a site, a single access point can be made available;

    在一个站点有多个设备的情况下，可以提供一个单一的接入点;

- data exchange may take place either remotely or locally.

    数据交换可以在远程或本地进行。

- Depending on the capabilities of the device, local and remote data exchange may be performed simultaneously without interfering with each other;

    根据设备的能力，本地和远程数据交换可以在不相互干扰的情况下同时进行;

- various communication media can be used on local networks (LN), neighbourhood networks (NN) and wide area networks (WAN).

    各种通信媒体可用于局域网(LN)、邻网(NN)和广域网(WAN)。

### 4.2 Communication model

application processes(`APs`)之间的通信通过`应用程序实体`(application entities,`AEs`)之间的通信进行建模。AE代表AP的`通信功能`。

AP中可能有`多组`OSI通信功能，因此`一个AP`可以用`多种AEs`来表示（比如一个AP可以使用HDLC-based profile，也可以使用TCP-IP based profile）。一个AE只对应一个AP（可能两个AP都使用HDLC-based profile，这两个AE也是不同的，可以理解为类和对象的关系，基于同一个类的两个对象实例化后是不同的）。一个AE包含一组称为application service elements(`ASEs`)的通信功能

TODO:AE的意思还不明确

### 4.3 Naming and addressing

一个`server AP`对应一个`logical device`,`client AP`可以不对应logical device。`每个AP`绑定一个Service Access Point(`SAP`)，`SAP`位于application layer(`AL`)层。**也就是说SAP用于区分基于同一个AL的不同AP**(对服务端也可以说是logical device).

![comm-module](/assets/img/2022-03-17-dlms-green-1/address.jpg)

#### 4.3.3 Addressing

![comm-module](/assets/img/2022-03-17-dlms-green-1/sap.jpg)

SAP用于区分基于同一个AL的不同AP

#### 4.3.4 System title

- 按单一DLMS/COSEM实体`唯一`，和逻辑设备名不同，一个实体可以有多个逻辑设备(名)，但只能有一个`systemtitle`,实体中的逻辑设备`共享`该systemtitle
- 固定`8字节`长，前3字节厂家ID，和逻辑设备名相同，后面的5字节，应为0-999,999,999,999(0x0-0xE8D4A50FFF)

交换方式（见10.4.3.3）：

- 通信配置注册过程
- 在明确建立AA的情况下，在AA建立期间使用`COSEM-OPEN`服务;
- 通过在“`Security setup`”对象写入client_system_title属性和读取的server_system_title属性。适用于预连接AA
- 加密APDU交换，general-ciphering (originator and recipient system title)或general-glo-ciphering (originator system title).

#### 4.3.5 Logical Device Name

蓝皮书 part2 4.1.8

### 4.4 Connection oriented operation

- Phase 1: AA establishment
- Phase 2: Message exchange
- Phase 3: AA Release

`预连接AA`不需要1和3

### 4.5 Application associations

Application Associations (`AAs`)是一个客户端`AE`和一个服务端`AE`间的`逻辑连接`。可以使用ACSE服务建立，也可以是预连接的

一个COSEM逻辑设备可以支持一个或多个AAs，每个AAs有一个`不同的客户端`。每个AA决定发生信息交换的上下文。

- confirmed AA:

  `confirmed AA`由客户端提出并被服务器`接受`，前提是：

  - 客户端用户为服务器所知，见4.3.6;
  - 客户端在4.5.2中提出的应用上下文对于服务器来说是可接受的;
  - 客户端(见4.5.3)提出的认证机制对服务器来说是可接受的，认证是成功的;
  - xDLMS上下文的元素参见4.5.4可以在客户端和服务器之间成功协商。

- unconfirmed AA:

  客户端也会提出`未经确认的AA`，并`假设`服务器会接受它。 `没有协商`发生。 未确认的 AA 对于从客户端向服务器发送`广播消息`很有用。

#### 4.5.2 Application context

应用程序上下文确定：

- AL 中存在的一组应用服务元素（Application Service Elements,ASEs）
- COSEM 对象属性和方法的引用方式：短名称(SN) 引用或逻辑名称(LN) 引用。 另见 9.1.4.3.1
- 传输语法
- 是否使用加密

#### 4.5.3 Authentication

DLMS中的认证发生在AA建立阶段

- 在`confirmed AAs`中，客户端(`单向认证`)或客户端和服务器(`双向认证`)都可以对对端进行认证。
- 对于`unconfirmed AA`，只有客户端可以验证对端。
- 在`预连接AA`中，身份验证不可用。

#### 4.5.4 xDLMS context

xDLMS上下文确定可以在给定的AA中使用的xDLMS服务和功能集。见9.1.4。

- additional services, see 9.1.4.3;
- additional mechanisms, see 9.1.4.4;
- additional data types, see 9.1.4.5;
- new DLMS version number, see 9.1.4.6;
- new conformance block, see 9.1.4.7;
- clarification of the meaning of the PDU size, see 9.1.4.8.

#### 4.5.5 Security context

当应用程序上下文规定加密时，安全上下文是相关的。 它包括`安全套件`、`安全策略`、`安全密钥`和`其他安全材料`。 另见 9.2.2.3。 它由“`Security setup`”对象管理。

#### 4.5.6 Access rights

访问权限确定客户访问 AA 内的 COSEM 对象属性和方法的`权限`。 访问权限集取决于`客户端的角色`，并在服务器中`预先配置`。 另见 9.2.2.4。

### 4.6 Messaging patterns

![messages](/assets/img/2022-03-17-dlms-green-1/messagepatterns.jpg)

在`confirmed AA` 中：

- 客户端可以发送确认的服务请求，服务器响应：`pull操作`
- 客户端可以发送未经确认的服务请求。 服务器没有响应
- 服务器可以向客户端发送未经请求的服务请求：`push操作`

> note:主动推送的服务可以是 InformationReport（使用 SN 引用）、EventNotification（使用 LN 引用）或 DataNotification（同时使用 SN 和 LN 引用）。

在`unconfirmed AA` 中：

- 只有客户端可以发起服务请求，并且只有未确认的请求。 服务器无法响应，也无法发起服务请求。

### 4.8 Communication profiles

通信配置文件指定了 *`DLMS/COSEM AL`* 和*建模Application Process (AP) 的 `COSEM 数据模型`*如何由较低的通信媒体特定协议层支持。

通信配置文件包括许多`协议层`。 每一层都有不同的任务并为其上层`提供服务`并使用其支持协议层的服务。 客户端和服务器 `COSEM AP` 使用最高协议层的服务，即 `DLMS/COSEM AL` 的服务。 这是唯一包含 COSEM 特定元素(`xDLMS ASE`)的协议层； 见 9.1.4。 任何能够提供 DLMS/COSEM AL 所需服务的层都可以支持它。 较低层的数量和类型取决于所使用的通信媒体。

![messages](/assets/img/2022-03-17-dlms-green-1/commprofile.jpg)

### 4.9 Model of a DLMS/COSEM system

设备被建模为`一组逻辑设备`，托管在`单个物理设备`中。 **每个逻辑设备代表一个服务器 AP**，并对`设备功能`的一个`子集`进行建模，这些功能子集可以通过其通信接口看到。使用COSEM对象对各种功能进行建模。

![messages](/assets/img/2022-03-17-dlms-green-1/model.jpg)

`数据采集系统`被建模为`一组客户端ap`，可以由`一个或多个物理设备`托管。每个客户端AP可能有`不同`的角色和访问权限，由设备授予。

`公共客户端0x10`和`管理逻辑设备0x01`APs有一个特殊的角色，它们应该一直存在。

### 4.10 Model of DLMS servers

![messages](/assets/img/2022-03-17-dlms-green-1/dlmsservermodel.jpg)

- IP based profiles:

`DLMS/COSEM AL`由DLMS/COSEM Transport layer(`TL`)支持，该TL由internet TCP或UDP层和一个包装器(wrapper)组成。`包装器`的主要作用是适应`OSI风格`的服务集，该服务集由DLMS/COSEM TL在TCP和UDP函数调用`之间`提供。它还为逻辑设备提供寻址，将它们`绑定`到一个称为包装器端口的`SAP`。`管理逻辑设备`总是绑定到包装器端口`0x01`。最后，`包装器`提供有关APDU传输`长度的信息`，以帮助对等端识别APDU的`末端`。由于TCP的流特性，这是必要的。

如果没有包装器这层，APDU直接通过TCP发出去，由于TCP是`流式`的，APDU不包含`头尾信息`，对端不知道是否是个`完整`的APDU，`无法解析`

- 3-layer,CO,HDLC based profile:

`DLMS/COSEM AL` 由基于 `HDLC` 的数据链路层支持。 它的主要作用是在对等层之间提供可靠的数据传输。 它还以这样一种方式提供逻辑设备的`寻址`，即每个逻辑设备都`绑定`到`单个 HDLC 地址`。 管理逻辑设备始终绑定到地址 0x01。 为了允许创建一个`本地网络`，以便通过一个`单一的接入点`可以到达特定站点的`几个物理设备`，另一个地址，即`物理设备地址`也由数据链路层提供。 逻辑设备地址被称为高HDLC地址，而物理设备地址被称为低HDLC地址。 另见 8.4.2

### 4.11 Model of a DLMS client

客户端模型

![messages](/assets/img/2022-03-17-dlms-green-1/modelclient.jpg)

- DLMS/COSEM AL使用HDLC或IP-based TLs提供的服务，`由AP决定`使用哪种。
- 与服务器端不同，客户端的HDLC层提供的寻址只有`一个级别`，即每个应用程序流程(AP)的服务接入点(SAP)的级别。(*也就是没有物理地址级别，见`8.4.2`，原语参数中客户端地址只有一个字节，就是SAP地址*)

客户端AP和服务器端AP由各自的`SAP`识别，因此，客户端和服务器端AP之间的`AA`可以由`一对`客户端和服务器端`SAP`识别。

### 4.12 Interoperability and interconnectivity in DLMS/COSEM

互操作性和互联性

- Interoperability：

  双方的COSEM对象定义相同，都使用DLMS/COSEM AL层

- interconnectivity：

  AEs互联。如果两个AEs使用`相同`的`通信配置文件`，则它们是可`互联`的

### 4.13 Ensuring interconnectivity: the protocol identification service

`协议识别服务`

在DLMS/COSEM中，AA的建立总是由`客户端AE`发起。然而，在某些情况下，它可能`不了解`未知服务器设备所使用的`协议栈`（例如，当服务器启动物理连接建立时）。在这种情况下，客户端AE需要获得关于服务器中实现的`协议栈的信息`。
为此，提供了一种特定的应用级服务：`协议识别服务`。它是一种可选的应用级服务，允许客户机AE在建立物理连接后获得关于服务器中实现的协议栈的信息。5.3.3.3中规定的协议识别服务直接使用PhL的数据传输服务（`PH-DATA`.request /.indicat）；它绕过了其他协议层。建议在所有可以访问PhL的通信配置文件中支持它。

### 4.14 System integration and installation

`系统集成和安装`

DLMS/COSEM以多种方式支持系统集成。这里描述了一个可能的过程。

如图7所示，`Public Client`(在任何配置文件中绑定到地址`0x10`)在每个客户端系统中都是必需的。它的主要作用是揭示一个`未知的`--例如`新安装`的--设备的结构。这发生在公共客户端和管理逻辑设备之间的`强制AA`中，没有安全预防措施。一旦知道了结构，就可以使用`适当的身份验证机制`和xDLMS的`密码保护`来访问数据

当`系统`中安装了`新设备`时，可能会`向客户端`生成`事件报告`。一旦检测到这一点，客户机就可以检索设备的`内部结构`，然后向设备发送必要的`配置信息`(例如关税时间表和特定于安装的参数)。这样，设备就可以使用了

## 5 Physical layer services and procedures for connection-oriented asynchronous data exchange

物理层

### 5.1 Overview

- 通信是`点对点`或`点对多点`
- `至少`可以有`半双工`连接
- 异步传输1位起始位，8位数据位，无奇偶校验和1位停止位(`8N1`)

> **串口通信原理**
>
> 9600 8N1代表着波特为9600，8个数据位，无奇偶校验和1个停止位，这一种是较为常用的串行协议配置方法。那么，9600 8N1的数据包是什么样的呢？举个例子吧！传输ASCII字符'`O`'和'`K`'的设备必须创建两个数据包。O的ASCII值（大写）为79，则二进制值`01001111`，而K的二进制值为`01001011`。剩下的就是追加同步位。假设传输数据时首先传输`最低位`：
>
> ![messages](/assets/img/2022-03-17-dlms-green-1/8n1.jpg)

### 5.2 Service specification

#### 5.2.1 List of services

- 建立/发布相关业务  PH-CONNECT, PH-ABORT;
- 数据传输业务  PH-DATA;
- 层管理服务

  层管理服务由`层管理进程`使用或为`层管理进程`提供，层管理进程是`AP`的一部分。下面给出一些示例:

  - PH-INITIALIZE.request / PH-INITIALIZE.confirm;
  - PH-GET_VALUE.request /  PH-GET_VALUE.confirm
  - PH-SET_VALUE.request / PH-SET_VALUE.confirm
  - PH-LM_EVENT.indication

#### 5.2.2 Use of the physical layer services

物理连接建立/释放服务是由`物理连接管理器AP`使用并为`物理连接管理器AP`提供的，而不是`数据链路层`

![messages](/assets/img/2022-03-17-dlms-green-1/physervices.jpg)

`注意这张图很关键，表明了管理器AP用于管理物理层的关系，包括管理器AP和物理层的原语，链路层和物理层的原语`

#### 5.2.3 Service definitions

- PH-CONNECT.request `连接建立服务`的服务请求原语

  在DLMS/COSEM环境中，PH-CONNECT.request原语的`用户`是物理连接管理器`AP`。它被用于建立一个物理连接。收到该基元后，PhL实体将执行所需的动作--例如拨号（如物理层PhL向modem发送`AT指令`）--以与对等PhL实体建立物理连接。5.4中给出了智能Hayes调制解调器情况下的这些动作的例子。

- PH-CONNECT.indication 连接建立服务的服务指示原语

  PH-CONNECT.indication由PhL实体基元生成，用于向服务用户实体指示一个远程设备要求建立物理连接。

- PH-CONNECT.confirm 连接建立服务的服务确认原语

  PhL实体用来传递相关联的PH-CONNECT.request的结果。如果由于本地错误(例如电话线不可用)而无法建立连接，则是本地生成的。

- PH-DATA.request `数据传输服务`的服务请求原语

  求使用PhL传输过程向一个或多个远程PhL实体发送数据字节

- PH-DATA.indication 数据传输服务的服务指示原语。

  向服务用户实体指示有效数据字节的到达

- PH-ABORT.request 连接中止服务的服务请求原语

  请求原语由服务用户实体Physical Connection Manager调用，以请求PhL实体终止现有的物理连接

- PH-ABORT.confirm 连接`中止服务`的服务确认原语

  PH-ABORT.confirm 原语由 PhL 实体生成，用于向服务用户实体 Physical Connection Manager 确认物理断开尝试的结果

- PH-ABORT.indication 连接中止服务的服务指示原语。

  原语由PhL实体生成，用于通知服务用户实体物理连接已意外终止。

### 5.3 Protocol specification

#### 5.3.1 Physical layer protocol data unit

Physical layer protocol data unit,`PHPDU`被指定为`一个字节`。然而，为了传输目的，这个数据字节可能被`调制解调器`设备`扩展`(错误检测/校正)或`修改`(位填充)，这取决于所使用的调制方案。

#### 5.3.2 Transmission order and characteristics

`PHSDU`字节——PH-DATA服务的Data参数——在传输前应以一个开始位和一个停止位完成。产生的帧应该从起始位开始传输，首先是最低有效位，最低有效位标识为位0，最高有效位标识为位7。

#### 5.3.3 Physical layer operation – description of the procedures

##### 5.3.3.1 General

连接的建立和释放由`物理连接管理器AP`管理。任何希望使用DLMS/COSEM协议的`AP`应在请求连接之前`检查PhL`的连接状态。如果PhL处于`非连接`状态，它将请求`物理连接管理器`建立连接

(结合5.3.3.3和5.3.3.4就是说`建立和释放`还有`识别`服务由AP来做，这些做完后的数据`传输阶段`AP就不管了，通过`数据链路层`直接调用)

##### 5.3.3.2 Setting up a physical connection

客户机和服务器设备都可以充当`主叫设备`，初始化到远程设备(即`被叫设备`)的物理连接。在这个`DLMS/COSEM配置文件`中，这些原语的服务用户只能是`物理连接管理器进程`

在`被叫设备端`，当检测到物理连接的启动时，需要对连接进行管理：`协商`、`接受`或`拒绝`。这些动作--与执行PH-CONNECT.request原语类似--取决于`物理连接类型`和使用的`调制解调器`，并可能以`自主方式`或由`PhL本身`完成(该过程不需要Physical
connection manager process参与)。

当主叫和被叫设备的`PhL完成建立`（或`不建立`）所需的物理连接时，它们使用`PH-CONNECT.confirm`（主叫方）和`PH-CONNECT.indicat`（被叫方）基元将结果通知服务用户实体。

![messages](/assets/img/2022-03-17-dlms-green-1/physicalconn.jpg)

##### 5.3.3.3 The Identification service

用于客户端读取协议栈识别信息

可选的`识别服务`是一种`应用层面`（*特别注意，应用层面*）的服务。它的目的是让客户获得关于服务器中实现的`协议栈`的信息。因此，它不使用整个协议栈；识别信息在`客户端AP`和`服务器AP`之间使用`PhL数据data服务`直接交换。如果在`多播`配置中使用了一个以上的服务器，客户端能够识别`每个`服务器中的协议栈。

该服务在`PH-CONNECT后`CONNECTED状态才能调用

只能由`客户端`发起请求

- IDENTIFY.request 请求识别信息
- IDENTIFY.response IDENTIFY.response消息由`服务器AP`调用，携带识别请求的`结果`：

  - `协议标准`
  - `版本`
  - `修订信息`
  - `错误信息`

  在客户端，这是一个IDENTIFY.confirm原语。

![messages](/assets/img/2022-03-17-dlms-green-1/identify.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/identifystate.jpg)

IDENTIFY.request `APDU`包含`一个或三个`字节。为了保持一致性，它的发送应受到数据链路层的`时间限制`（帧间和响应超时）。

当收到这`第一个字符`时，PhL进入 "`识别中`"状态，等待更多的字节或帧间超时(意味着消息的结束)。

- identify`识别阶段`过程：

  如果在收到三个以上的字节之前检测到`消息结束`条件(`超时也算`结束标志)，PhL将收到的APDU视为`IDENTIFY.request` APDU。它使用PH-DATA.indicaton原语将收到的字节发送到`（物理连接管理器）AP`，并返回到 "`等待接收`"状态，允许解决最终的错误。

- 跳过identify`识别阶段`，直接进入`数据传输阶段`：

  另一方面，如果在收到`第四个`传入字节之前没有检测到`消息结束`的条件（因为IDENTIFY.request最大就是3字节，收到第4个字节还没有结束标志，说明就不是IDENTIFY.request了，同时要保证正确的数据PDU长度是大于3字节的），PhL认为识别过程已经结束，并进入 "`数据传输`"状态。传入的字节应使用`PH-DATA.indicaton`服务发送至服务用户的上层协议层。在3层的CO、HDLC的COSEM配置文件中，这是MAC子层。在这种连接中，PhL`不能返回`到`识别阶段`。

![messages](/assets/img/2022-03-17-dlms-green-1/phlstatemachine.jpg)

PhL有参数Destination_process表示数据发到哪一层去，默认为NULL表示发给物理层管理AP，进入数据传输模式后为其他值表示发给MAC层。

##### 5.3.3.4 Data transfer

一旦`PhL`退出`识别阶段`，它就进入了`数据传输阶段`，其中`PH-DATA.request`和`PH-DATA.indicative`原语完全由上层协议层即`数据链路层`使用。

在`识别阶段`AP是可以通过PH-DATA原语向物理层传数据的，进`数据传输阶`段就不行了

PhL`不负责`任何数据`流控`制功能：通过PH-DATA.request primitive收到的数据应`立即传输`，或者--当实施物理数据`流控`制时--应`覆盖`之前尚未传输的字节。由于PH-DATA服务既不是本地确认，也不是远程确认，因此在后一种情况下，不应发出错误信号。

##### 5.3.3.5 Disconnection of an existing physical connection

客户端或服务器都可以启动现有物理连接的断开连接。这通过调用 `PH-ABORT.request` 原语的`物理连接管理器 AP` 来实现

PH-ABORT.request的调用者，会收到PH-ABORT.confirm作为通知(在本地处理，本地的物理层通知本地的调用AP，不外发，断开操作无需通知对方)

对方`不会收到`任何关于`断开`的消息，只能通过`检测物理连接`断开来发现物Qq理通道断开了。然后物理层生成PH-ABORT.indication

如果是信道异常导致的断开，双方应该都会收到物理层传来的PH-ABORT.indication，双方都断开。

![messages](/assets/img/2022-03-17-dlms-green-1/phydisconn.jpg)

### 5.4 example: PhL service primitives and Hayes commands

PH-CONNECT:

对于`主叫者`，physical
connection manager AP向物理层PhL发送`PH-CONNECT`.request，物理层PhL向modem(DCE)发送`AT拨号`命令，并返回拨号结果，物理层将结果转换为`PH-CONNECT.confirm`返回给AP

对于`被叫者`，AP会被物理层通知`PH-CONNECT.indication`表示物理层已连接

![messages](/assets/img/2022-03-17-dlms-green-1/phyconn.jpg)

PH-DATA:

假设之前`建立了`与远程DCE的`连接`，并且DCE现在处于`数据传输模式`，那么传递到本地DCE的所有数据都将被传输到远程DCE（不是透明传输，每一层都会对data数据做处理，比如添加开始停止位，校验位等）。

PH-ABORT：

在可以终止连接之前，必须首先将调制解调器切换到本地`命令模式`(从数据传输模式)

## 6 Direct Local Connection

光口物理层连接

![messages](/assets/img/2022-03-17-dlms-green-1/modechange.jpg)

## 7 DLMS/COSEM transport layer for IP networks

- 基于UDP的无连接传输层;
- 面向连接的基于TCP的传输层;
- 一个基于无连接CoAP的传输层

`DLMS/COSEM TL`由`CoAP、UDP或TCP传输层`和一个称为`包装器wrapper`的额外子层组成

### 7.2 The TCP-UDP/IP based transport layers

DLMS/COSEM_on_IP

可以把DLMS/COSEM AL视为和HTTP一样的网络应用，使用TCP-UDP传输层服务

![messages](/assets/img/2022-03-17-dlms-green-1/cosemalprofile.jpg)

IANA中注册了4059/TCP-UDP端口

DLMS/COSEM `AL`只监听`一个UDP或TCP端口`。另一方面，如4.9和DLMS UA 1000-1所示，`一个物理设备`可能承载`多个`客户端或服务器`ap`。包装器子层提供的`附加寻址`功能允许寻址这些`ap`。

包装`wrapper`子层具有以下功能:

- 它在UDP/TCP端口上提供了一个`额外的寻址`能力(`wPort`);
- 它提供有关数据`传输长度`的信息。这个特性可以帮助发送方和接收方识别一个`完整的APDU`的接收，它可以在`多个TCP包`中发送和接收

![messages](/assets/img/2022-03-17-dlms-green-1/tlcosemonip.jpg)

TCP-CONNECT and TCP-DISCONNECT services的用户是TCP Connection Manager Process，就是说TCP连接和释放不是AL管理的，由专门的管理进程管的，当然AL也要了解TCP当前的连接状态。

#### 7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer

`无连接`，可实现`多播广播`；`开销小`

缺点：`不可靠`（可以由上层实现可靠，当然DLMS AL层不会这么做，但是CoAP协议是个例子，基于UDP实现了可靠传输），无重复发送保护

![messages](/assets/img/2022-03-17-dlms-green-1/udptl.jpg)

.request和.indication服务原语是必需的。本地的.confirm服务原语的实现是可选的。

```asn.1
UDP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length, Data
)
```

```asn.1
UDP-DATA.indication
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
```

```asn.1
UDP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
```

`Result`参数的值表示基于DLMS/COSEM UDP的TL是否能够发送请求的UDP数据报:`能(OK)`或`不能(NOK)`。result为OK只能表示数据已发送，不保证能送达

UDP-DATA.confirm是`可选的`

在这个通信配置文件中，包装子层是一个无状态的实体：它的唯一作用是确保使用wPort号码的源和目的地DLMS/COSEM AE识别，并提供`OSI风格`的`UDP-DATA.xxx服务调用`与`标准UDP`提供的SEND()和RECEIVE()接口函数之间的`转换`。

对于UDP这种`面向数据报`而非`面向流`的协议，包装器中的长度字段并非必要，因为每个udp报文就是完整单一的，不存在分好几包还要拼包拆包处理粘包等操作，但为了和TCP`兼容`还是需要该字段

#### 7.2.3.3.2 The wrapper protocol data unit (WPDU)

![messages](/assets/img/2022-03-17-dlms-green-1/wrapperwpdu.jpg)

- version:始终为0x0001
- source/destination wPort:DLMS/COSEM AE的端口
- Data length:APDU数据长度

![messages](/assets/img/2022-03-17-dlms-green-1/udppdu.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/wrapperport.jpg)

#### 7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer

面向流的，可靠，包括重传、全双工、流控

缺点：端到端，不支持广播和多播

`TCP`作为一种面向连接的传输协议，涉及到`建立连接`、`交换数据`和`释放连接`三个阶段。因此，基于TCP的`DLMS/COSEM TL`为服务用户提供三个阶段的`OSIstyle`服务:

- 在`连接建立`阶段，将`TCP-CONNECT`服务提供给服务用户`TCP连接管理器进程`;
- 在`数据传输`阶段，`TCP-DATA`服务提供给服务用户`DLMS/COSEM AL`;
- 在`连接关闭`阶段，`TCP-DISCONNECT`服务被提供给服务用户`TCP连接管理进程`;
- 此外，一个`TCP-ABORT`服务被提供给服务用户`DLMS/COSEM AL`。

`TCP连接管理服务`的服务用户`不是DLMS/COSEM AL`，而是`TCP连接管理进程`。该工艺的规范超出了本技术报告的范围

![messages](/assets/img/2022-03-17-dlms-green-1/tcptl.jpg)

`TCP-DATA`可`本地或远程`确认，`UDP-DATA`只能`本地`确认

##### TCP-CONNECT

```asn.1
TCP-CONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)

TCP-CONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
```

TCP-CONNECT由TCP连接管理进程和TCP层进行交互

TCP连接管理进程不能拒绝TCP连接请求，所以TCP-CONNECT.response总是成功的

TCP-CONNECT.confirm一般来说需要远程确认，如果是本地确认，可能回失败

##### TCP-DISCONNECT

```asn.1
TCP-DISCONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)
```

TCP-DISCONNECT.request 用于断开请求

```asn.1
TCP-DISCONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
```

TCP-DISCONNECT.indication中`Reason`参数:

- `对端设备`请求了TCP断开(Reason == `REMOTE_REQ`)
- `本地检测`到TCP连接断开(Reason == `ABORT`)

```asn.1
TCP-DISCONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
```

TCP连接管理进程`不能拒绝`TCP断开请求，表示远程断开Reason == REMOTE_REQ

```asn.1
TCP-DISCONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
```

同TCP-CONNECT.confirm

##### TCP-ABORT

见7.2 图27，TCP-ABORT是`AL`层和`TL`层交互的原语

```asn.1
TCP-ABORT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
```

由基于DLMS/COSEM TCP的`TL`生成，用于向服务用户`DLMS/COSEM AL`表示支持TCP连接的`非请求中断`。

当收到此指示时，`DLMS/COSEM AL`应释放所有使用此TCP连接建立的`AAs`，并应使用 `COSEM-ABORT.indivation`服务原语向 COSEM AP 表明这一点。

##### TCP-DATA

```asn.1
TCP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
```

Data是APDU

```asn.1
TCP-DATA.indication (
    Local_wPort, 
    Remote_wPort, 
    Local_TCP_Port, 
    Remote_TCP_Port, 
    Local_IP_Address, 
    Remote_IP_Address, 
    Data_Length, 
    Data 
)
```

TCP-DATA.indication基元由DLMS/COSEM `TL`生成，用于向服务用户DLMS/COSEM `AL`指示已从远程设备收到xDLMS `APDU`。如果携带APDU的TCP数据包中的Local_TCP_Port和Local_wPort参数都包含`有效的端口号`，即接收设备中存在一个与给定端口号绑定的DLMS/COSEM AE，则在基于DLMS/COSEM TCP的TL`接收完整的APDU`（在`一个或多个`TCP数据包中）后生成。否则，收到的消息将被直接丢弃。

TCP-DATA.indication需要在接收完完整包并解包后交给AL,Data是APDU

```asn.1
TCP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Confirmation_Type,
    Result
)
```

可选的，request的确认

##### 7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer

wrapper层和UDP的不同，因为TCP是流式的，需要发送/接收全APDU，还要处理`粘包`等

###### 7.2.4.3.5 Definition of the procedures

wrapper层`透传`**TCP连接管理器AP**和**TCP层**之间的调用。TODO:该设计是否合理，wrapper层又多做了判断操作，直接管理TCP层是否更合理

- TCP connection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpconn.jpg)

为了能够响应，响应方必须在接收第一个SYN包之前执行一个`“被动”打开`。为此，它必须联系本地操作系统(OS)，以表明它已经`准备好`接受传入的连接请求。作为这个联系的结果，操作系统分配一个`TCP端口号`给连接的端点(开启TCP`端口监听`)，并为将来的连接保留所需的资源——但是没有发送消息。

- TCP disconnection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpdisconn.jpg)

客户端和服务端`TCP连接管理器进程`可以通过调用`TCP-DISCONNECT.request`来启动该过程。

- TCP connection abort

基于 DLMS/COSEM TCP 的 `TL` 在 `TCP-ABORT.indication` 原语的帮助下指示支持 `TCP 连接`到 DLMS/COSEM `AL` 的`中断或断开`。 请注意，这是提供给 DLMS/COSEM AL 的`唯一` TCP 连接管理服务(其他服务都是提供给TCP连接管理进程的)。

当 `TCP 连接`被 `TCP 连接管理器进程`断开时调用该服务（`优雅断开`的情况），或者当 TCP 断开以`非请求方式`发生时，例如 TCP 子层`检测`到不可解决的`错误`或 `物理连接`被`关闭`。

TODO:前文TCP-ABORT一节提到TCP-ABORT不是非请求中断才生成吗?为什么请求中断也会生成

该服务的目的是`通知` DLMS/COSEM `AL` TCP 连接`中断`，以便它可以`释放`所有现有的 `AA`。

- Data transfer using the TCP-DATA service

![messages](/assets/img/2022-03-17-dlms-green-1/tcpdata.jpg)

可选`TCP-DATA.confirm`原语表示TCP-DATA`结果`。请求原语之前调用，这是OK或NOK。然而，这个结果的含义取决于实现。当.confirm原语被实现为`本地确认`时，结果t表示DLMS/COSEM TL是否能够`缓冲发送`APDU或`发送`APDU。当它作为`远程确认`实现时，结果表明APDU是否已`成功交付`到目的地。

WPDU由wrapper层打包组包解包，TCP是流式的，不关心字节范围，WPDU可能被分为好几个TCP包发送

#### 7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls

##### 7.2.5.1 Transport layer and TCP connection establishment

![messages](/assets/img/2022-03-17-dlms-green-1/tcphandshake.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/tcpmsc.jpg)

##### 7.2.5.2 Closing a transport layer and a TCP connection

![messages](/assets/img/2022-03-17-dlms-green-1/tcpmscclose.jpg)

##### 7.2.5.3 TCP connection abort

![messages](/assets/img/2022-03-17-dlms-green-1/tcpabort.jpg)

通过TCP Wrapper层轮询TCP层状态

##### 7.2.5.4 Data transfer using the TCP-DATA service

![messages](/assets/img/2022-03-17-dlms-green-1/tcpsenddata.jpg)

`AL层`通过request原语发送一个`992`字节的`APDU`，`Wrapper层`加上`8字节`的头，第一次发送`1000`字节，实际一包发出去476字节，还剩524字节，以此类推`直到发完`，向AL层回复confirm原语。该过程由Wrapper层控制。

![messages](/assets/img/2022-03-17-dlms-green-1/tcpwrapperreceive.jpg)

Wrapper层接收到完整的wrapper头+APDU后，解开wrapper头，将APDU放在`TCP-DATA.ind`原语中发送给AL层。

### 7.3 The DLMS/COSEM CoAP based transport layer

#### 7.3.2 Overview

受限应用协议 (Constrained Application Protocol,`CoAP`) 是由 IETF 核心工作组定义的专用互联网应用协议。 CoAP 专为在`资源受限`的设备中使用而设计，用于通过非受限或受限的互联网通信网络（例如，`低功耗`、`有损网络`）进行通信。 CoAP 旨在提供高效的数据传输能力，同时满足`可靠性`、`多播支持`、`极低开销`、`效率`和`简单性`等特殊要求。

基于CoAP的`DLMS/COSEM CoAP TL`提供`不可靠`和`可靠`的传输服务(CoAP原来是属于`应用层`的，这里DLMS协议里把它做成了`传输层`，用来给AL提供服务)。`不可靠`的CoAP服务支持`组播`和`广播`。DLMS/COSEM CoAP TL为服务用户DLMS/COSEM AL提供`OSI风格`的服务。

![messages](/assets/img/2022-03-17-dlms-green-1/coaposi.jpg)

整个`DLMS/COSEM CoAP TL`层包括了Wrapper层、CoAP层、UDP层，和标准OSI模型中的不同

#### 7.3.3 Structure of the DLMS/COSEM CoAP transport layer

![messages](/assets/img/2022-03-17-dlms-green-1/coaplayer.jpg)

`DLMS/COSEM CoAP TL`提供`不可靠`和`可靠`的运输服务。

- 不可靠的DLMS/COSEM CoAP传输服务使用`non-confirmable (NON)` CoAP消息
- 可靠的DLMS/COSEM CoAP TL服务使用`confirmable (CON)` CoAP消息，并带有CoAP消息层提供的`重试机制`。

`CoAP wrapper`层提供的服务：

- 通过与`CoAP请求/响应层`操作的交互，将`OSI风格`的数据服务`原语`(CoAP-DATA)传递给`DLMS/COSEM AL`，以实现`CoAP POST方法`的使用
- DLMS/COSEM`服务接入点SAP寻址`功能，从而允许`多个`DLMS/COSEM `AEs`驻留在物理设备的同一个CoAP客户机和服务器端点上

##### 7.3.3.2 Identification and addressing

识别与寻址

默认5683端口，同一个物理机里的客户端和服务端可以共用该端口

TODO: 结合Bluebook 4.9 关于CoAP配置的对象

###### 7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer

一个CoAP端口可以为`不同的应用`（如除了DLMS的应用）提供服务，用`URIPath`区分(CoAP类似于HTTP，可以通过URI区分接入点)，IANA规定的默认端口为5683

默认情况下，DLMS/COSEM AL，无论是DLMS客户端AL还是DLMS服务器AL，都使用该`URI-Path`: "`dlms`"

coap://127.0.0.1:5683/dlms

###### DLMS/COSEM CoAP transport layer SAPs

![messages](/assets/img/2022-03-17-dlms-green-1/coapsap.jpg)

#### 7.3.4 Service specification for the DLMS/COSEM CoAP transport layer

![messages](/assets/img/2022-03-17-dlms-green-1/coaploop.jpg)

`远程环回确认`(积极（传输成功的情况）的TL确认，用于`可靠`传输)，表示报文被`远端`确认，确认发送给本地CoAP client，再由`本地wrapper层`返回给AL层confirm原语

`本地环回确认`(消极（失败的情况，比如发生了什么错误）的TL确认，用于`可靠和不可靠`传输，可靠传输中可能是对方超时没回确认，视为失败，不可靠传输中可能是udp层有错误导致调用发送函数失败，视为失败)，用于失败的情况，由`本地CoAP client`返回给wrapper层错误信息，`本地wrapper层`返回给AL层confirm原语

##### 7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives

###### 7.3.4.2.1 CoAP-DATA.request

```asn.1
CoAP-DATA.request
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Remote_Path [Optional Use],
    Response_Mode,
    Request_ID [Optional Use],
    Data_Length,
    Data
)
```

- `Transport_Mode`: CoAP传输模式，“RELIABLE”可靠，“UNRELIABLE”不可靠（这里的可靠其实是对于wrapper层来说的，当然底层还是需要CoAP可靠或不可靠模式的支持）
- `Remote_Path`： CoAP `Uri-Path`。Response_Mode为“RESPONSE”忽略该参数
- `Response_Mode`：表示是否期望返回DLMS/COSEM响应APDU。它取值:"`CONFIRMED`"， "`UNCONFIRMED`"， "`RESPONSE`"。
- `Request_ID`：标识了特定的数据请求操作。Request_ID将在可能产生的`CoAP-DATA.confirm`原语中返回，表明DLMS/COSEM CoAP TL`传送数据`参数中给出的APDU的`成功或失败`。Request_ID被指定为支持在`已发送多个`携带请求的APDU且DLMS/COSEM CoAP TL确认尚未完成的情况下，以`每个`APDU为基础返回DLMS/COSEM CoAP TL`确认`(类似于TCP的`滑动窗口`，可以`异步确认`)。以下情况适用:

  - 如果Request_ID未被指定，CoAP-DATA.confirm原语中Request_ID也不被指定。
  - 如果Transport_Mode被设置为`UNRELIABLE`，并且DLMS/COSEM CoAP TL实现`不支持`这种操作模式的CoAP-DATA.confirm原语，那么Request_ID可以不被指定。
  - 如果DLMS/COSEM CoAP TL服务`不支持`CoAP-DATA.`confirm`原语，CoAP wrapper将`忽略`指定的Request_ID标识。

**使用场景**：

- 发送`DLMS/COSEM请求`（单播或多播广播）：

  - `Remote_Path`指定为对方Uri-Path
  - `Local_Port and Local_IP_address`可选
  - `Response_Mode`：

    - `需确认`的请求，使用`CONFIRMED`
    - `无需确认`的请求，使用`UNCONFIRMED`
    - General Block Transfer(`GBT`)`分块传输`的请求,视情况，比如`单播或广播`，可用`CONFIRMED或UNCONFIRMED`

- 发送`DLMS/COSEM响应`（也为CoAP-DATA.request，只要是发送就是，和AL层的报文类型无关）：

  - `Remote_Path不指定`
  - `Local_Port and Local_IP_address`需要指定，和请求匹配
  - Transport_mode, Local_SAP, Remote_SAP, Remote_IP_address, Remote_Port需匹配请求
  - `Response_Mode`：

    - 一般为`RESPONSE`
    - APDU为GBT时，为`CONFIRMED`，Remote_Path需指定（TODO:这不是和上面说的不指定矛盾了吗）

###### 7.3.4.2.2 CoAP-DATA.indication

```asn.1
CoAP-DATA.indication
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address,
    Local_Port,
    Remote_IP_address,
    Remote_Port,
    Data_Length,
    Data
)
```

- Transport_Mode: CoAP传输模式，“RELIABLE”可靠，“UNRELIABLE”不可靠

###### 7.3.4.2.2 CoAP-DATA.confirm

```asn.1
CoAP-DATA.confirm
(
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Request_ID [Optional Use],
    Result
)
```

- Local_SAP：本地DLMS/COSEM AE的SAP
- Request_ID：对应的CoAP-DATA.request中携带的，如果request没有指定就是未定义
- Result：“REMOTE OK”表示远端已接收，“NOT OK”表示发送失败

**使用场景**：

CoAP-DATA.confirm由wrapper层生成

对于`不可靠`的传输模式，Result没有“REMOTE OK”`远程确认`，但可以生成“NOT OK”表示`本地错误`，对不可靠传输模式该原语是可选的

#### 7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer

##### 7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU)

CoAP-PDU = UDP header + CoAP header + CWPDU(wrapper header + APDU)

![messages](/assets/img/2022-03-17-dlms-green-1/coaplayer2.jpg)

`DLMS/COSEM CoAP TL PDU`是一个`UDP数据报`，携带`CoAP消息`作为其`有效载荷`。该CoAP消息携带`CoAP头`和DLMS/COSEM CoAP Wrapper PDU（`CWPDU`）。CWPDU携带DLMS/COSEM `APDU`作为其有效载荷加上DLMS/COSEM CoAP `TL控制信息`，。

##### 7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU)

CWPDU = wrapper header + APDU

DLMS/COSEM CoAP包装协议数据单元(`CWPDU`)由一个可选的`DLMS/COSEM CoAP wrapper头`和它的有效负载`APDU`组成。

`CoAP请求`中CWPDU`才包含`DLMS/COSEM CoAP `wrapper`报头。

`CoAP响应`中CWPDU`不包含`DLMS/COSEM CoAP `wrapper`头，

> 不同于TCP或UDP，CoAP是`请求响应模型`的，所以请求和回应在DLMS的TL层也是一一对应的（通过Token匹配），客户端完全可以知道回应的wrapper头中的`SAP`应该是什么。所以响应中的wrapper头可以省略

![messages](/assets/img/2022-03-17-dlms-green-1/coapcwpdu.jpg)

CoAP不是流式传输，报文也是完整的，不需要`长度`信息

- The DLMS/COSEM CoAP TL version：TL版本号，0-15，目前为0
- Reserved bits：保留
- The CoAP Wrapper Response Mode (WRM)：通知对方的wrapper层是否应该期望收到对方的AL层响应，(为1时，服务端wrapper层就知道不需要等待服务端AL层响应，客户端AL也不会收到传输层给它的确认，但当启用了传输层可靠传输时，传输层自己要保证发送成功，包括超时重发和失败重发)，见7.3.5.6
- Remote SAP：接收站点的SAP
- Local SAP：发送站点的SAP

##### 7.3.5.4 The Constrained Application Protocol (CoAP)

###### 7.3.5.4.2 The CoAP Message

CoAP消息以简单的`二进制格式`编码。消息由一个固定大小的`4字节头`、一个`可变长`度的`Token值`(0-8字节)、`0个或多个tlv编码`的选项(可选地)和`负载`组成。

一个`非空的CWPDU`作为`有效负载`在CoAP消息中携带。

![messages](/assets/img/2022-03-17-dlms-green-1/coapprotocol.png)

本节其实就是介绍标准coap协议，可以看其他文章，见[CoAP学习笔记（1）CoAP报文结构](https://blog.csdn.net/weixin_41572450/article/details/103549125)

DLMS/COSEM CoAP TL层只用到了其中的一部分的code

- CoAP Request method codes

  在`DLMS/COSEM CoAP TL`的`CoAP消息`中使用的请求方法代码如下

  |Request|method|Meaning Use|
  |:---:|:---:|:---:|
  |0.02|POST method|发送`新的`包含CWPDU的`请求或响应`|
  |0.00|空报文ACK message without piggybacked response|在可靠传输中用于`ACKs`确认，不带响应|

- CoAP Success Response codes
  
  |Success Response code|Meaning|Use|
  |:---:|:---:|:---:|
  |2.04|Success (Changed)|对`已存在`的请求/响应回复包含CWPDU的`响应`|

三种响应模式见上述文章

客户端错误和服务器`错误响应代码`由`CoAP协议层`或`CoAP包装器`根据错误条件`填充`

- Token(可选，TKL指定是否存在)

  令牌用于配置响应和请求

- Token Length(TKL指定)

  建议DLMS/COSEM CoAP TL实施的CoAP请求/响应层使用的令牌长度限制为`0-4字节`，以平衡令牌传输成本和上下文不匹配的风险，或者当令牌在相同的CoAP端点之间重复使用时可能出现的重复检测失败。进一步参考RFC 7252。

  DLMS服务器的DLMS/COSEM CoAP TL的CoAP协议层使用的Token长度可在`CoAP设置对象`中指定，见DLMS UA 1000-1 Part 2 Ed.15:2021, 4.9.8。

- Options

  Options也只用到了标准中的一部分,当然没有规定只能用这些，但要保证双方能处理这些选项
  
  ![messages](/assets/img/2022-03-17-dlms-green-1/coapoption.jpg)

  - `Uri-Path`: CoAP uri路径，默认是dlms
  - `Content-Format`：允许的传输格式，和HTTP类似，可以不指定，因为默认都是`application/octet-stream`
  - `Block1` and `Block2`：在RFC 7959中新增的两个option，用于表示分块传输，见7.3.5.4.5，另见[CoAP分块传输](https://zhuanlan.zhihu.com/p/461498161)TODO:查看该文档

###### 7.3.5.4.3 CoAP retransmission and response piggybacking

当CWPDU在`可靠`的CoAP消息层支持的新CoAP请求/响应上下文中传输时（即通过可确认的（CON）CoAP消息），那么，正如RFC 7252所规定的，CoAP消息层将继续`重传`CoAP请求消息，直到它被CoAP服务器终端`确认`。这可以是单独的`CoAP确认消息ACK`的返回形式，也可以是`附带`CWPDU或错误响应的`piggybacked ACK消息`

>关于[piggybacking技术](https://en.wikipedia.org/wiki/Piggybacking_(data_transmission))：
>
>在双向通信中，每当收到帧时，`接收方`都会`等待`，并且`不会立即`将控制帧（`确认`或`ACK`）发送回`发送方`。
>
>`接收方等待`，直到其网络层传入下一个`数据包`。然后，`延迟的确认`将`附加`到此传出数据帧。
>
>这种暂时`延迟确认`以便可以与下一个传出数据帧挂钩的技术称为`piggybacking`。
>
>`优点`：提高效率，更好地利用可用信道带宽。
>
>`缺点`：如果`接收方``没有要发送`的内容，则接收器可能会`阻塞`服务。这可以通过在接收到数据帧时启用计数器（`接收器超时`）来解决。如果`计数结束`并且没有要发送的数据帧，则`接收方将发送 ACK` 控制帧。`发送方`还会添加一个`计数器`（发送器超时），如果计数器在没有收到`确认`的情况下结束，则发送方将假定数据包丢失，然后`再次发送`帧。
>
>该技术主要是为了`减轻网络负担`,这个附带内容可以是接收器对于`上一帧的回复`（如果处理快的话也可以是本次请求的回复），也可以是`主动上报`等

CoAP层会考虑使用`piggybacking`的可能性，`ACK`会`延时发送`，直到本地wrapper层收到AL层的数据并打包成CWPDU或超时，再发送`附带或不附带数据`的`ACK`。要是超时的话这个CWPDU单独发送，不附带在这个ACK中

7.3.5.4.3.2 **CoAP Retransmission Parameters**

DLMS/COSEM CoAP TL中的可靠CoAP消息传递层使用许多参数来控制RFC 7252定义的CoAP重传算法。这些参数在CoAP setup interface class类中指定

- ack_timeout

  需确认消息的最小初始ACK超时
  
  `initial_ack_timeout`是在`ack_timeout`和`ack_timeout x ack_random_factor`之间`随机选择`的值。
  
  `initial_ack_timeout`是可靠的CoAP消息层的`初始重传延迟`。
- ack_random_factor

  用于申请初始ACK超时随机性的随机因子。
- max_retransmit

  需确认消息的最大重传次数。
- delay_ack_timeout

  CoAP 消息传递层在`返回确认`之前`等待`应用层返回响应的时间（以毫秒为单位），piggybacking相关的，防止太久不回ACK触发对方重传

7.3.5.4.3.3 **CoAP Congestion Control Parameters**

拥塞控制

- NSTART

  以下任一形式的同时`未完成`的 CoAP 请求消息的`数量`：

  - 没收到ACK的CON消息(需确认消息)
  - 没收到响应的NON消息(无需确认消息)
- PROBING_RATE

  探测速率

  定义一个端点发送到另一个没有响应的端点时不应超过的平均`数据速率`(字节/秒)。

###### 7.3.5.4.5 CoAP Block Transfer

见7.3.5.4.2

[第31篇：CoAP分块传输](https://zhuanlan.zhihu.com/p/461498161)

在APDU大于MTU，且小于receiver_max_pdu_size时生效（大于receiver_max_pdu_size本身就不合法，AL或TL应该屏蔽该报文，TODO:这个是应用层的限制，传输层是怎么知道的，需要做限制吗）

TODO:为什么是APDU大于MTU，MTU不是链路层的限制吗，就算要分也是加上IP头，UDP头和CoAP头，wrapper头后的APDU的长度作为基准吧

DLMS/COSEM CoAP TL中的CoAP块传输层应按照`RFC 7959`的建议，在没有不当延迟的情况下完成CoAP块传输

##### 7.3.5.5 Error Handling

###### 7.3.5.5.2 CoAP protocol layers

CoAP`消息层`或`请求/响应层`的错误通过`重置消息`(名词)或CoAP协议层实体根据RFC 7252和RFC 7959`自动生成`的CoAP客户端和服务器`错误响应`传递给发送的CoAP实体

###### 7.3.5.5.3 CoAP wrapper layer

`wrapper层`的`错误处理`，就是从一个wrapper层发给另一个wrapper层

- Unreliable CoAP transport `不可靠传输`

  一般是多播，wrapper将接收到的不能处理的CWPDU`丢弃`

  TODO:wrapper层是不是通过CWPDU中的客户端SAP参数知道是否是多播的 更新：不是，是通过CoAP协议的多播。然后其实这个丢弃和多播无关，不是多播也会丢弃。因为是不可靠传输，所以不需要wrapper层回确认或否认
- Reliable CoAP transport `可靠传输`

  接收端wrapper层无法处理接收到的CWPDU(由CoAP request携带)时返回错误

  这种错误响应可能有助于诊断，也可能有助于主动纠正措施。通常，当传入的请求由于`语法错误`而无法提供服务时，将返回`CoAP客户端错误`(类似HTTP状态码里的4xx表示客户端错误，5xx表示服务器错误，[HTTP状态码](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81))，而当CoAP包装器`无法处理`明显`有效`的请求时，将返回`CoAP服务器错误`

  ![messages](/assets/img/2022-03-17-dlms-green-1/coapwrappererror.jpg)

###### 7.3.5.5.4 Propagation of errors through CoAP wrapper layer

返回到发送端CoAP协议层的错误响应应该以所产生的`CoAP消息层交付失败`（见下）的形式传播到`发送端CoAP wrapper层`，或者以`返回的错误本身`的直接形式传播，`无论`它们是由`接收CoAP协议层`还是由`接收CoAP包装器层`产生的。

- CoAP消息层交付失败原因：

  - 接收到重置消息
  - 放弃CoAP block transfer操作
  - 可靠CoAP消息传递层放弃可靠传输的CoAP消息
  - CoAP层错误或UDP或IP层错误

如果是可靠传输，CWPDU的交付失败必须从CoAP协议层传播到wrapper层，以便其酌情通知AL层。

##### 7.3.5.6 DLMS/COSEM CoAP TL confirmations

`CoAP包装器请求/响应上下文`（见7.3.5.7）对于在本地发起的CoAP请求/响应上下文中传送的任何`未完成`的CWPDU（还没有收到CoAP响应）`保持`给定`Request_ID`的`状态`，以便wrapper层在返回`负面`（比如有错误发生）或`正面`（比如传输成功）的DLMS/COSEM CoAP TL确认时可以用CoAP-DATA.confirm原语向AL层返回Request_ID。

对于`不可靠`的DLMS/COSEM CoAP TL，这个是`可选的`，也就是无需维护维护`Request_ID`的状态。也只能回复`负面`的确认（无需正面确认，因为不可靠就是无确认的）

- CoAP传输层错误指示

  如果**CoAP包装器从CoAP协议层**`收到`在本地发起的CoAP请求/响应上下文中传输的CWPDU的`交付失败指示`，则`CoAP包装器`通过CoAP-DATA.confirm 原语（结果为 "`NOT OK`"）和与CoAP-DATA.request 原语中的APDU提供的Request_ID相匹配的`Request_ID`来传达相关APDU的`交付失败`。参见7.3.5.7.5。

  TODO:看7.3.5.7.5

- CoAP传输层确认

  支持 DLMS/COSEM CoAP TL 确认，如果接收端的AL层不会对这条报文回确认，那这个确认可以由接收端传输层自己生成并回复(AL层面无需响应，也就不会回响应，但传输层可靠传输层面需要确认)。使用带有 push_operation_method (1) 的`无需确认` DataNotification 的`可靠数据推送`操作需要 DLMS/COSEM CoAP TL 确认。 参见 DLMS UA 1000-1 第 2 部分 Ed.15:2021, 4.4.8.2.2.11)，就是蓝皮书中的push_operation_method为1这种情况，需要传输层确认，而无需AL层确认，当然确认结果也不用给AL层，重发也是传输层自己负责

  CoAP 包装层支持 DLMS/COSEM CoAP TL 确认，用于在 CoAPDATA.request 原语中以 `Response_Mode = UNCONFIRMED` 和 `Transport_Mode = RELIABLE` 提供的 APDU。(服务端AL层无需响应，客户端AL也不会收到传输层给它的确认，但传输层自己要保证发送成功，包括超时重发和失败重发。**注意，CoAP层只会在未收到ACK时重发，对于wrapper层CWPDU未收到的情况需要wrapper层自己重发**)

  TODO:可靠传输不是靠CoAP的ACK吗，为什么还要单独再搞个wrapper层的确认 更新：DLMS/COSEM TL层的可靠传输，属于整一层的，CoAP的ACK也是wrapper层用于判断传输成功的一种依据。比如还有明明收到了ACK但没收到对方wrapper层的响应，就要由wrapper层自己重发，来保证可靠传输

  过程：

  1. 在 `Response_Mode = UNCONFIRMED` 的 CoAP-DATA.request 原语中提供给 CoAP 包装器的 APDU 应由 CoAP 包装器在 `CoAP 包装器响应模式`(WRM)设置为 1 的 CWPDU 中的新本地发起 CoAP 请求/响应上下文中传输（`WRM = 1`)（WRM见7.3.5.2，关于CWPDU的定义）。 这指示接收 CoAP 包装器`不要等待`返回 DLMS AL 响应或 DLMS AP 响应；
  2. 接收 CoAP 包装器应在将接收到的嵌入的 APDU 成功交付给 DLMS AL 时，当通过`可靠` CoAP 消息传递层 在 `WRM = 1` 的 CWPDU 中接收到 APDU 时，`返回`一个`空的 CWPDU` 作为对发送 CoAP 包装器的`成功响应`实体
  3. 对于WRM = 1接收到的CWPDU的错误处理遵循上面描述的一般错误处理

##### 7.3.5.7 CoAP wrapper state machine

wrapper层状态机

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperstate.jpg)

- `空闲Idle`：`关闭状态`，没有关联状态，CoAP 请求/响应层中`没有`相应的 CoAP 请求/响应上下文

- `客户端等待模式Client Waiting Mode`：接收到AL层传来的CoAP-DATA.req，直到把该req处理完,包括等待结果，进入Idle模式。

- `服务器等待模式Server Waiting Mode`：接收CoAP层传来的非空且需AL层回复（WRM=0）消息，发给AL层后，`等待`AL层回复CoAP-DATA.req消息

- `服务Serving`：接收到CoAP层传来的非空且无需AL层回复(WRM=1)消息，发给AL层后直接结束，进入Idle

###### 7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context

在`客户端等待模式`状态下维护的`参数`取自 `CoAP-DATA.request` 服务原语的服务参数(AL层发来的)

在`服务器等待模式`和`服务状态`下维护的`参数`取自较低的 `CoAP 协议层`和传入 CWPDU 的 `CWPDU 标头`(远端客户端发来的)

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperparam1.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coapwrapperparam2.jpg)

- 空闲到客户端等待模式

  - 收到AL层CoAP-DATA.request调用，且Response_Mode = UNCONFIRMED
  - 收到AL层CoAP-DATA.request调用，且Response_Mode = CONFIRMED，且是个请求（没找到对应请求，说明不是回应）
  - 收到AL层CoAP-DATA.request调用，且Response_Mode = RESPONSE，且是个请求（没找到对应请求，说明不是回应）TODO:和GBT相关，等会再看

- 空闲到服务器等待模式

  收到CoAP层传来的非空且`需AL层回复`（WRM=0）消息，发给AL层后，`等待`AL层回复CoAP-DATA.req消息

- 服务器等待模式到空闲状态：

  在服务器等待模式下收到AL层传来的`CoAP-DATA.request`原语，且该原语中的Transport_Mode, the Local SAP, the Remote SAP, the Local_IP_address, the Local_port, the Remote_IP_address and the Remote_Port`参数与当前wrapper层上下文中的对应`

  - 收到AL层CoAP-DATA.request调用，且Response_Mode = RESPONSE，且是个回应（找的到对应的请求）
  - 收到AL层CoAP-DATA.request调用，且Response_Mode = CONFIRMED，且是个回应（找的到对应的请求）（GBT相关）

- 客户端等待模式到空闲状态

  - 收到CoAP层失败信息
  - 收空(确认)或非空(响应)CWPDU

  然后根据情况处理后回给AL层

- 空闲状态到服务状态

  接收到CoAP层传来的非空且无需AL层回复(WRM=1)消息，发给AL层后直接结束，进入Idle（可能还要回个空CWPDU给对方wrapper层表示确认）

###### 7.3.5.7.4 CoAP-DATA.request invocation handling

![messages](/assets/img/2022-03-17-dlms-green-1/coapdatareqinv.jpg)

###### 7.3.5.7.5 Handling of incoming CWPDU or CoAP layer transmission failures

![messages](/assets/img/2022-03-17-dlms-green-1/cwpdufailure.jpg)

###### 7.3.5.7.6 Garbage collection

CoAP相关的`缓存清理`，和实现相关。

#### 7.3.6 DLMS/COSEM CoAP TL Data Transfers

##### 7.3.6.2 General transfer of confirmed DLMS/COSEM AL service requests

![messages](/assets/img/2022-03-17-dlms-green-1/coaptlconfirmed.jpg)

##### 7.3.6.3 Reliable DLMS/COSEM CoAP TL operation

Piggybacked模式下，ACK和response同时回复，由客户端掌握重发权，没收到ACK就重发

separate模式下，ACK先发，response后发，服务端掌握重发权，如果response没收到对方ACK则重发（TODO:如果是服务端发给客户端的ACK丢了呢）

![messages](/assets/img/2022-03-17-dlms-green-1/reliablecoaptl.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coaptlloss.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/relicoaptluncondatanoti.jpg)

##### 7.3.6.4 Unreliable DLMS/COSEM CoAP TL operation

![messages](/assets/img/2022-03-17-dlms-green-1/coaptluncondatanoti.jpg)

##### 7.3.6.5 DLMS/COSEM CoAP Block Transfer operation

CoAP块传输，用于APDU大于MTU但小于receiver_max_pdu_size的情况，主要是用于让IP层无需再分片，属于CoAP标准中的一部分。

![messages](/assets/img/2022-03-17-dlms-green-1/coapbt.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coapbtrequest.jpg)

对于UNRELIABLE服务，图58中的Transport_Mode替换为`UNRELIABLE`，CoAP type替换为`NON`

![messages](/assets/img/2022-03-17-dlms-green-1/coapbtreqresp.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coapbtdatanoti.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coapbtuncondatanoti.jpg)

##### 7.3.6.6 DLMS GBT operation over DLMS/COSEM CoAP TL

DLMS GBT分块，区别于CoAP块传输，属于DLMS/COSEM AL层实现的分块传输，在某些方面优于CoAP块传输。

![messages](/assets/img/2022-03-17-dlms-green-1/coapbtgbt.jpg)

TODO:FIRST-PART是不是就只是用来交换GBT参数的，此时直接发出去应该data是个空的也行

TODO:后面省略

## 8 Data Link Layer using the HDLC protocol

### 8.1 Overview

本章指定数据链路层为三层，`面向连接`，`基于HDLC`，`异步通信配置文件`。

本规范支持以下通信环境:

- 点对点和点对多点配置
- 专用和交换数据传输设施
- 半双工和全双工连接
- 异步 启动/停止 传输，1个启动位，8个数据位，无奇偶校验，1个停止位

#### 8.1.2 Structure of the data link layer

为了确保面向连接和无连接两种操作模式都有一致的数据链路层服务规范，数据链路层被划分为两个子层:`逻辑链路控制(LLC)`子层和`媒体访问控制(MAC)`子层

[LLC层](https://zh.wikipedia.org/zh-hans/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6)

- 类型1：`无连接`。该方式对信息的发送通常无法保证接收。
- 类型2：`面向连接`。该方式提供了四种服务：连接的`建立`、确认和承认`响应`、`差错恢复`（通过请求重发接收到的错误数据实现）以及`滑动窗口`（系数：128）。通过改变滑动窗口可以提高数据传输速率。
- 类型3：`无连接承认响应服务`。

`类型1`的 LLC `无连接`服务中规定了一种静态帧格式，并支持运行网络协议。有关`传输层网络协议`通常是使用服务类型1方式。

`类型2`的 LLC `面向连接`服务支持`可靠数据传输`，运用于`不需要`调用网络层和传输层协议的局域网环境。(相当于把TCP层的事情干了)

[MAC 子层](https://blog.csdn.net/dadoneo/article/details/8315833)（该数据链路层规范的主要部分）基于 ISO/IEC 13239。与原始 HDLC 标准相比，该标准的`第二版`包括许多增强功能，例如在`寻址`、`错误保护`和`分段`。 `第三版`采用了一种新的帧格式，可满足`电表`和类似行业`遥测应用`中的环境要求。

MAC子层的主要功能包括数据`帧的封装/卸装`，`帧的寻址和识别`，帧的`接收与发送`，`链路的管理`，帧的`差错控制`等。MAC子层的存在屏蔽了不同物理链路种类的差异性;非常重要的一项功能是仲裁`介质的使用权`，即规定站点何时可以使用通信介质。实际上，局域网技术中是采用具有冲突检测的`载波侦听多路访问`（Carrier Sense Multiple Access /
Collision Detection，`CSMA/CD`）这种介质访问方法的。

为本技术报告的目的，已从 HDLC 标准中做出以下选择：

TODO:后面都看不懂

#### 8.1.3 Specification method

数据链路层的子层根据服务和协议(services and protocols)进行划分

TODO:等第8章看完之后完善

### 8.2 Service specification

本节规定了服务用户层使用`面向连接`的程序对数据链路层`要求`的服务。

`事实上`，所有 DL 服务都由 MAC 子层提供：LLC 子层将 DL-CONNECT.xxx 服务原语作为适当的 MA-CONNECT.xxx 服务原语`透明地传输`到“真实”服务提供者 MAC 子层或从“真实”服务提供者 MAC 子层接收。

由于客户端和服务器端 LLC 和 MAC 子层不同，因此为双方指定了服务原语。

MAC 子层的寻址方案在 8.4.2 中规定。

#### 8.2.2 Setting up the data link connection: the DL-CONNECT and MA-CONNECT services

![messages](/assets/img/2022-03-17-dlms-green-1/hdlcservicespec.jpg)

数据链路连接的建立`只能`由`客户端请求`。因此，DL-CONNECT / MA-CONNECT `.request`和`.confirm`原语仅在`客户端`(主站)提供。另一方面，MA-CONNECT / DL-CONNECT `.indication`和`.response`原语仅在`服务器`(辅助站点)端提供。

在`本地检测到错误`的情况下，DL-CONNECT / MA-CONNECT .request原语也可以在`本地进行确认`。(虚线部分)

##### 8.2.2.2 DL-CONNECT.request and MA-CONNECT.request

```asn.1
DL-CONNECT.request
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)

MA-CONNECT.request
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)
```

- Destination_MSAP和Source_MSAP: 标识要建立的`引用数据链路层连接`。
- User_Information：为`可选配置`。其内容的规范不属于本技术报告的范围。

服务用户层调用DL-CONNECT.request原语，LLC层接收后调用MA-CONNECT.request原语发给MAC层，MAC层发送格式化后的`SNRM帧`(Set Normal Response Mode (a HDLC frame type,HDLC协议的一部分))

##### 8.2.2.3 DL-CONNECT.indication and MA-CONNECT.indication

```asn.1
DL-CONNECT.indication
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)

MA-CONNECT.indication
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)
```

和上面的相反，接收SRNM转换报文

##### 8.2.2.4 DL-CONNECT.response and MA-CONNECT.response

```asn.1
DL-CONNECT.response 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)
MA-CONNECT.response 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)
```

Result指示提议的连接`是否可以被接受`，以及`是否应该发送响应帧`。它可以有以下值之一:

- Result == `OK`这意味着接收到的连接请求`可以`被服务用户层`接受`。MAC层收到后发送`UA帧`
- Result == `NOK`。这意味着接收到的连接请求`不能`被服务用户层`接受`;（如果链路层收到第二个连接请求，但同时只能有一个，即使服务用户层接受，连接也不能建立），MAC层收到后发送`DM帧`
- Result == `NO-RESPONSE`。这意味着不应发送对 DL-CONNECT.indication 的响应。MAC层收到MA-CONNECT.response后不发送任何帧

TODO:这里的MA-DISCONNECT.response是不是写错了

##### 8.2.2.5 DL-CONNECT.confirm and MA-CONNECT.confirm

```asn.1
DL-CONNECT.confirm 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)

MA-CONNECT.confirm 
(
    Destination_MSAP, 
    Source_MSAP, 
    Result, 
    User_Information 
)
```

`Result` 表示之前调用的 DL-CONNECT / MA-CONNECT.request 服务调用的结果。 它可以具有以下值之一：

- Result == OK。 这意味着远程站`接受`了连接请求；
- Result == NOK-REMOTE。 这意味着远程站`没有接受`连接请求；
- Result == NOK-LOCAL。 这意味着发生了`本地错误`，例如服务用户层试图建立一个已经存在的数据链路连接；
- Result == NO-RESPONSE。 这意味着远程站`没有响应`连接请求。

#### 8.2.3 Disconnecting the data link connection: the DL-DISCONNECT and MA-DISCONNECT services

![messages](/assets/img/2022-03-17-dlms-green-1/hdlcservicespec.jpg)

##### 8.2.3.2 DL-DISCONNECT.request and MA-DISCONNECT.request

同上8.2.2.2

##### 8.2.3.3 DL-DISCONNECT.indication and MA-DISCONNECT.indication

```asn.1
DL-DISCONNECT.indication ( 
    Destination_MSAP, 
    Source_MSAP, 
    Reason, 
    Unnumbered_Send_Status, 
    User_Information 
)

MA-DISCONNECT.indication ( 
    Destination_MSAP, 
    Source_MSAP, 
    Reason, 
    Unnumbered_Send_Status, 
    User_Information 
)
```

- Reason

  - Reason == REMOTE：数据链路层收到来自客户端的断开连接请求。 这种情况可能只发生在`服务器端`；
  - Reason == LOCAL-DL：出现致命的`数据链路连接失败`；
  - Reason == LOCAL-PHY：出现致命的`物理连接故障`。 后两种情况可能同时发生在`客户端和服务器端`。

- Unnumbered_Send_Status，USS，参数的值指示在DL-DISCONNECT / MA-DISCONNECT .indication 原语调用的时刻是否分别调用数据链路层。 MAC 子层有（USS == TRUE）或没有（USS == FALSE）待处理的 UI 消息（UI帧）。TODO:这句是什么意思

TODO:之后的需要完善，现在时间有限，先简单写下

##### 8.2.3.4 DL-DISCONNECT.response and MA-DISCONNECT.response

service user layer不能拒绝该服务，结果仅表明指定的DL connection是否存在

RESULT == NO-RESPONSE表明MAC不应该发送任何响应

##### 8.2.3.5 DL-DISCONNECT.confirm and MA-DISCONNECT.confirm

和response类似

#### 8.2.4 Data transfer: the DL-DATA and MA-DATA services

使用I帧或UI帧

>和DL-DISCONNECT及DL-CONNECT的区别是这个DL-DATA不再是`透传`了，LLC层需要组LSDU作为data，前面两个LLC就是什么也不干，直接把参数和data给MAC层。

##### 8.2.4.2 DL-DATA.request and MA-DATA.request

Frame_type：

- client: I-COMPLETE and UI;(这里假设了client的资源足够大（比如缓冲区），所以调用原语时不需要分包，直接用完整的)
- server: I-COMPLETE, I-FIRST-FRAGMENT, I-FRAGMENT, ILAST-FRAGMENT, and UI

收到调用后，LLC层组装`LSDU`，其中包括`LLC specific fields` (the two LLC addresses and the LLC_Quality parameter)，不在Frame_type == I-FRAGMENT or I-LAST-FRAGMENT中添加，因为这个是`头信息`，只要在I-FIRST-FRAGMENT和I-COMPLETE中添加就行

##### 8.2.4.3 DL-DATA.indication and MA-DATA.indication

LLC层要解LSDU，校验`LLC specific fields` (the two LLC addresses and the LLC_Quality parameter)

##### 8.2.4.4 DL-DATA.confirm and MA-DATA.confirm

MAC层生成，MAC层判断是否发送成功

Frame_type = I-FIRST-FRAGMENT, I-FRAGMENT or I-LAST-FRAGMENT

#### 8.2.5 Physical layer services used by the MAC sublayer

物理层`配置`还有`断开`不是MAC层管的（TODO:是不是层管理AP管的）

物理层`断开`会通过`PH-ABORT.indication原语`通知MAC层

##### 8.2.5.4 Data transfer

PH-DATA.request and .indication原语

### 8.3 Protocol specification for the LLC sublayer

#### 8.3.2 LLC PDU format

![messages](/assets/img/2022-03-17-dlms-green-1/llcpdu.jpg)

- `Source_LSAP`: 最低位表示command(0)/response(1)
- `Control byte`: LLC_Quality，保留，固定0x00

destination LSAP `0xFF`用于`广播`

#### 8.3.3 State transition tables for the LLC sublayer

![messages](/assets/img/2022-03-17-dlms-green-1/statetransitionclientllc.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/statetransitionserverllc.jpg)

区别是client端没有I-FRAGMENT or ILAST-FRAGMENT，就不用判断类型，LSDU里全部加上LLC头就行

### 8.4 Protocol specification for the MAC sublayer

#### 8.4.1 The MAC PDU and the HDLC frame

##### 8.4.1.1 HDLC frame format type 3

![messages](/assets/img/2022-03-17-dlms-green-1/macframe.jpg)

- Flag field:固定`0x7E`，在帧`头尾`,连续发送时头尾可以互连
- Frame format field:
  - Format type sub-field (4 bit):3，表示`type3`(HDLC frame format type 3)
  - the Segmentation bit (S, 1 bit):`类型细分`，对上面的format type的继续细分
  - the frame length sub-field (11 bit):除了flag外的`长度`
- Destination and source address fields:见8.4.2
- Control field：`控制字段`，见8.4.3
- Header check sequence (HCS) field：对头部序列的`校验`，计算`opening flag和HCS之间`的部分，如Frame format+Dest. address+Src. address+Control，不包括后面的信息域和FCS。当信息域不存在或者为空时，则HCS不存在，仅有FCS
- Information field：携带`信息域`（比如MSDU）,I and UI帧可用(其他类型帧可能也有，后面提到了Disconnect (DISC) command)
- Frame check sequence (FCS) field：计算`校验`，除flag和FCS

#### 8.4.2 MAC addressing

##### 8.4.2.2 Address field structure

HDLC地址：HDLC帧格式`type 3`(参见8.4.1.1)包含两个地址字段:`目的地址`和`源地址`。根据数据`传输的方向`，客户端地址和服务器地址`都可以`是目的地址或源地址。

- client address：总是1字节，不能扩展

- server address：只允许1，2，4字节

  - `upper` HDLC address：`Logical Device`(在物理设备内的一个单独的可寻址的实体)
  - `lower` HDLC address：`Physical Device`,可选

##### 8.4.2.3 Reserved special HDLC addresses

![messages](/assets/img/2022-03-17-dlms-green-1/hdlcaddress.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/reservedaddress.jpg)

> 每个字节的LSB用于标识是否有后续字节，所以`不计入`实际字节的表示，也就是一个字节就`7个有效位`。1111 1111表示一个字节，后续无字节，然后把LSB去掉就是1111 111，前面补0就是0111 1111，一个字节最大就能表示`0x7F`。如果要表示`0xFF`,就是，0000 0010 1111 1111，去掉无效位（每个字节的LSB），0000 001 1111 111，合并填0，就是0000 0000 1111 1111。对于4个字节的情况，分高upper地址2字节和低lower地址2字节考虑。

![messages](/assets/img/2022-03-17-dlms-green-1/addressexample.jpg)

##### 8.4.2.4 Handling special addresses

源地址不能用All-station or the Nostation address

##### 8.4.2.5 Handling inopportune address lengths in the server

对于`服务端接收`，源地址(就是客户端地址)固定1字节，超过1字节的帧丢弃（client address仅允许1字节）

对于目的地址长度，有如下要求：

![messages](/assets/img/2022-03-17-dlms-green-1/dalength.jpg)

#### 8.4.3 Command and response frames

![messages](/assets/img/2022-03-17-dlms-green-1/controlfieldbit.jpg)

RRR is the receive sequence number N(R)

SSS is the send sequence number N(S)

P/F is the poll/final bit.

P表示`poll bit`，表示是否交出`发送权`，一般需要响应的请求的最后一帧会置为`TRUE`

- `I帧`，Information transfer command and response

  信息传递

  - `N(S)`：发送帧的`序号`
  - `N(R)`：`期望接收`到的下一帧的`序号`，表明`N(R)-1`序号的帧已被`正确接收`。

  发送接收最大`information field`长度`默认为128字节`

- Receive ready (`RR`) command and response

  - 通知`准备好`接收I帧
  - 确认之前收到的N(R)-1序号的I帧

- Receive not ready (`RNR`) command and response

  - 通知`未准备好`接收I帧
  - 确认之前收到的N(R)-1序号的I帧

  RNR接收方应该要知道，N(R)-1之后的I帧发送都是无效的，也不应该再发I帧了

- Set normal response mode (`SNRM`) command

  SNRM 命令应用于将已分配地址的从站置于`正常响应模式`（`NRM`），其中所有控制字段的长度应为一个八位字节。 次站应通过在第一个响应机会时发送 `UA` 响应来确认 SNRM 命令的接受。 在接受该命令后，从站发送和接收状态变量应设置为零。

  此命令执行后，原来由DL层管理的未被确认的I帧需要交还给更高层管理，是否重新交给DL层发送取决于该高层。（TODO:作用是什么）

  TODO:什么是正常响应模式。更新：见8.4.4

- Disconnect (`DISC`) command

  终止之前配置的可操作或初始化模式，从站应进入逻辑断开模式。

  TODO:逻辑断开模式和正常断开模式区别？更新：应该是同一个概念，就是NDM

  从站应发UA响应表示确认收到

  （同SNRM）此命令执行后，原来由DL层管理的未被确认的I帧需要交还给更高层管理，是否重新交给DL层发送取决于该高层。（TODO:作用是什么）

  > 可以理解为SNRM的逆操作

  可能携带information field

- Unnumbered acknowledge (`UA`) response

  对SNRM 和 DISC的响应
  
  可能携带information field,用于传递DL层参数

- Disconnected mode (`DM`) response

  报告自身处于Normal Disconnected Mode(NDM)状态

  - 请求主站或其他关联站向自己发送模式设置命令，如切成NRM
  - 响应模式设置请求，报告自己仍处于NDM

  例如，可以通过SNRM命令退出NDM，进入NRM

- Frame reject (`FRMR`) response

  从站`报告接收到的帧的错误`，该错误`不能通过重传相同的`解决，且该错误不是由于FCS错误引起的：

- Unnumbered information (`UI`) command and response

  发送信息，不影响V(S)和V(R)，可以在任何模式（NRM,NDM）下使用

  从站无需响应，可能丢失

  V(S)：Send state Variable

  V(R)：Receive state Variable

  TODO:意思是不是不影响I帧或其他帧的序号

#### 8.4.4 Elements of the procedures

当主备用站点之间建立了物理链路，但没有建立活动的数据链路通道时，客户端和服务器端的MAC子层都处于`正常断开模式`Normal Disconnected Mode(`NDM`);不传送或不接受任何信息或编号的监控帧。从站功能限制为：

- 接收与响应SNRM
- 接收UI
- 发送UI响应
- 收到DISC后发送DM响应

当MAC连接建立后，MAC层工作在正常响应模式(NRM)。从站(服务器)只有在从主站(客户端)获得明确的许可后才可以开始数据传输。在收到许可(POLL BIT == TRUE)后，从站发起响应传输。响应传输可以由一个或多个帧组成，同时保持活跃的数据链路通道状态(见8.4.4.3.1)。响应传输的最后一帧应由从站明确表示(FINAL BIT == TRUE)。在最后一帧指示之后，从站应停止发送，直到再次收到主站的明确许可。

##### 8.4.4.2 Transmission considerations

  TODO:透明传输没看懂

  按照一个字节内`低位优先`传输，多个字节按照`最有意义`字节优先

##### 8.4.4.3 HDLC channel states

- Active HDLC channel state

  当主站或从站处于传输帧中的一个字节状态时，就是active 状态，保留有继续传输权
- Abort sequence
  
  不适用
- Start/stop transmission inter-octet time-out

  字节间超时等待状态，接收完一个字节开始等待，直到收到下个字节或超时，超时要结束接收。

- Idle HDLC channel state

  当连续标记保持条件持续一段系统特定的时间($T_{idle}$)时，数据链路通道进入空闲状态。

#### 8.4.5 HDLC channel operation – Description of the procedures

选择了`非平衡连接模式`(unbalanced connection-mode)的数据链路操作。不平衡数据链路包括`一个主站`和`一个或多个`从站。数据链路的整体错误恢复最终由主站负责

选择了`NRM`和`NDM`模式。

##### 8.4.5.2 Data station characteristics

主站负责:

- 设置数据链路，断开数据链路;
- 发送信息传递、监督和无序号命令;
- 检查收到的响应。

从站应负责:

- 检查收到的命令;
- 根据接收到的指令，发送信息，监督和无序号命令的回复。

##### 8.4.5.3 Procedures for setting up and disconnecting the data link

- Setting up the data link

  主站发SNRM，从站回UA表示确认并进入NRM，回DM表示无法进入NRM

  主站未收到回应等待超时重发，直到MAX_NB_OF_RETRIES次数停止

- HDLC parameter negotiation during the connection phase

  SNRM/UA消息交换不仅可以建立连接，还可以协商一些数据链路参数

  - 最大information field长度参数，默认128字节

    - 发送
    - 接收
  - Window size窗口大小，默认1，最大7.

    - 发送
    - 接收

  SNRM中的Window size – receive是强制的，UA中的‘Max_info_field_length– receive’ (0x40), and the ‘Window size – transmit’ (0x07)是强制的

- Disconnecting the data link

  主站发`DISC`，从站回`UA`响应，并进入NDM。如果已经处于断开模式NDM，将发送`DM`响应。

  超时重发和Setting up the data link相同

##### 8.4.5.4 Procedures for data exchange

收到MA-DATA.request调用后，发送`I帧`，只能在`NRM`下发送。若Frame_type == UI，则发送`UI帧`，一般用于`广播多播`，且可以在`NRM或NDM`状态发送。

- Exchange of information frames

  主站请求的最后一帧`poll bit`置1，表示`等待响应`，从站响应的最后一帧`final bit`置位表示发送结束。

- 8.4.5.4.5 Transferring long MSDUs from the server to the client

  服务端`资源有限`，客户端资源较多，对dl-data进行`分段`，Frame_type == IFIRST-FRAGMENT、I-FRAGMENT、I-LAST-FRAGMENT

- 8.4.5.4.6 Multi- and broadcasting

  对使用`UI帧`实现`多播广播`的情况，仅允许`客户端`发送，服务端不允许

  只有UI(和DISC)消息可以作为广播或组播消息，此时UI帧的`Poll bit`必须为`FALSE`,表示`无需响应`（就是不会把发送权交给从站）

  `DISC`一般用于在`通过断开低层连接方式断开AA`时发送的命令。

  多播广播支持对一个物理设备的多个逻辑设备，或多个物理设备，根据HDLC目的地址的upper和lower字节

  ![messages](/assets/img/2022-03-17-dlms-green-1/broadcastui.jpg)

- 8.4.5.4.7 Sending an UI frame from the server to the client

  服务端发送UI帧的情况

  在HDLC中因为是`主从模型`，服务器作为从站`没有权利`主动上报，需要等客户端作为主站发送任意请求后，因为需要回复，从站获得`发送权`，再趁机发送该上报UI帧，且应在响应的最后一帧前发送

  ![messages](/assets/img/2022-03-17-dlms-green-1/serveruievent.jpg)

  其他情况：

  - 客户端发送RR帧，P=1
  - 客户端发送空的UI帧，P=1

- 8.4.5.4.8 Handling the CALLING device physical address

  CALLING Physical Device address，见8.4.2.3

  允许服务端发起物理连接请求，以便自己能上报数据

  TODO:服务端需要发送什么信息。是否是PH层管理AP建立了PH层连接后，客户端直接发送SNRM，不需要服务端DL层发送信息

  客户端需要发送`SNRM`为服务端配置模式，其中Lower MAC Address的值应该为`CALLING Physical Device Address (0x7E)`，表示该报文是给`正在寻求发起连接`的服务端。

  多点multi-drop网络中，所有服务端收到后首先判断自身的`CALLING DEVICE`标志，如为`TRUE`，表示自己正在寻求发起连接，则接收，如果为FALSE，则丢弃。（收到PH-ABORT.indication 物理层断开后应该置为FALSE）

  服务端接收后需要回复`UA`（确认）或`DM`（否认），此时源地址的`Lower MAC Address`字段应为正确的本机MAC物理地址，而不是CALLING Physical Device Address

##### 8.4.5.5 Exception recovery

- Response time-out

  响应超时

  发送完poll bit为1的帧后开始计时，收到final bit为0的帧时刷新计时，收到final bit为1的帧时结束计时

  超时应该重发，当该帧时I帧时不应该重发，应该发RR帧同步I帧序号，确认丢失的是哪帧（TODO:是否同步完再重发I帧）

- FCS and HCS error

  TODO：引用了一些其他标准
  
  有错误帧时，所有的连续帧都应被丢弃。

- N(S) sequence error

- Command/response frame rejection

  FRMR回应

- Busy

##### 8.4.5.6 Time-outs and other MAC sublayer parameters

- Time-out 1: Response time-out (TO_WAIT_RESP)

  等待响应超时时间，所有命令和信息帧，客户端参数

  TO_WAIT_RESP > RespTime + 2*MaxTxTime

- Layer Parameter 1: Maximum number of retries (MAX_NB_OF_RETRIES)

  最大超时重发次数

- Time-out 2: Inactivity time-out

  未向PhL发送或接收超时。超时应断开DL层连接

  TODO:断开PhL连接不是user layer的管理AP做的吗，而接收发送数据是DL层管理的，是不是这两个也要有关联

- Time-out 3: Inter-frame time-out

  帧间超时，接收端参数，超时未收到下一帧表示已经结束

- Maximum information field length

  最大information field长度，默认128

- Window size

  窗口大小，默认1

##### 8.4.5.7 State transition diagram for the server MAC sublayer

![messages](/assets/img/2022-03-17-dlms-green-1/statemacsublayer.jpg)

### 8.5 FCS calculation

#### 8.5.1 Test sequence for the FCS calculation

TODO：计算规则不明确

#### 8.5.2 Fast frame check sequence (FCS) implementation

16位的FCS计算参考RFC 1662

#### 8.5.3 16-bit FCS computation method

### 8.6 Data link layer management services

![messages](/assets/img/2022-03-17-dlms-green-1/layermanage.jpg)

- DL-INITIALIZE

  初始化DL层参数

- DL-GET_VALUE

  从DL层获取一个或多个参数

- DL-SET_VALUE

  设置DL层的一个或多个参数

- DL-LM_EVENT

  通知DL层的事件

## 9 DLMS/COSEM application layer

### 9.1 DLMS/COSEM application layer main features

#### 9.1.2 DLMS/COSEM application layer structure

![messages](/assets/img/2022-03-17-dlms-green-1/applayer.jpg)

DLMS/COSEM AL的主要组成部分是`应用服务对象`Application Service Object(`ASO`)。它向其服务用户COSEM Application Process (`APs`)`提供`服务，并`使用`支持协议层提供的服务。它在客户端和服务器端都包含三个必需的组件:

- 关联控制服务元素，Association Control Service Element，`ACSE`
- 扩展DLMS应用服务元素the extended DLMS Application Service Elemen，`xDLMS ASE`;
- 控制功能the Control Function，`CF`。
- Client SN_Mapper ASE是客户端专有可选项

xDLMS `ASE`提供在COSEM `APs之间`传输数据的服务,见9.1.4

Control Function (`CF`)元素指定`ASO服务`如何调用`ACSE`、`xDLMS ASE`和`支持协议层`的服务的`适当服务原语`。见9.4.1。

客户端和服务器DLMS/COSEM `ASO`都可能包含其他可选的应用程序协议组件。

当`服务器`使用`SN引用`时，`可选的`Client SN_Mapper ASE出现在`客户端AL ASO`中。它使用LN和SN引用提供服务之间的`映射`。见9.1.5。

`DLMS/COSEM AL`也执行OSI表示层的一些功能:

- 对`ACSE`和`xDLMS APDUs`进行`编码和解码`，参见9.4.3;
- 另外，生成和使用代表`ACSE`和`xDLMS APDUs`的`XML文档`;
- 用于`压缩和解压`;
- 启用、验证和删除`密码保护`。

#### 9.1.3 The Association Control Service Element, ACSE

用于面向连接（connection oriented (CO)）通信

提供application association建立与释放服务：

- COSEM-OPEN;

  COSEM-OPEN服务用于`建立AAs`。它基于ACSE A-ASSOCIATE服务。基于ASE过程中的Application_Context_Name, Security_Mechanism_Name and xDLMS context 参数

  - `confirmed AAs`使用COSEM-OPEN服务，可以在单个客户端和单个服务器之间建立；

  - `unconfirmed AAs`使用COSEM-OPEN服务，可以在单个客户端和多个服务器见建立，只有客户端发送，服务端不回应。（多播，广播）

  - `pre-established AAs` 可能预先存在。 不使用 COSEM-OPEN 服务。 客户端必须知道服务器支持的上下文。 预先建立的 AA 可以是确认或未确认。 TODO:等后文详细了解

- COSEM-RELEASE

  `不丢失信息`，`优雅释放`AAs

  - TCP-UDP/IP based profile：基于`ACSE A-RELEASE` 服务
  - 3-layer, CO, HDLC based profile：confirmed AAs`直接断开`对应协议层连接，Pre-established AAs无需断开
- COSEM-ABORT

  `异常释放`，可能`丢失信息`，它不依赖于ACSE A-ABORT服务

#### 9.1.4 The xDLMS application service element

为了访问COSEM对象的属性和方法，使用了`xDLMS ASE`的服务

##### 9.1.4.2 The xDLMS initiate service

建立`xDLMS上下文`

##### 9.1.4.3 COSEM object related xDLMS services

与COSEM对象相关的xDLMS服务用于访问COSEM`对象属性和方法`。

- Logical Name (LN) referencing
- Short Name (SN) referencing

`客户端ASO`总是使用带有`LN引用`的xDLMS `ASE`。`服务器ASO`可以使用带有`LN引用`的xDLMS `ASE`，也可以使用带有`SN引用`的xDLMS ASE，或者`两者都使用`

服务可以是：

- requested / solicited：客户端请求

  客户端`请求`的服务也可以(见9.4.6.2):

  - confirmed:在这种情况下，服务器提供对请求的响应;
  - unconfirmed:在这种情况下，服务器不提供对请求的响应。
- unsolicited: 由服务器端发起，无需请求

  来自服务器的`未经请求`的`DataNotification`也可能是(见9.3.10):

  - confirmed:在这种情况下，客户端提供一个`响应`来确认收到了未经请求的DataNotification
  - unconfirmed:在这种情况下，客户端没有对未经请求的DataNotification提供响应

`附加服务`-不是基于IEC 61334-4-41:1996规定的DLMS服务-是:

- 使用LN引用访问COSEM对象属性和方法的`GET、SET、ACTION和ACCESS`;
- 服务器用于向客户端推送数据的`DataNotification`服务;
- 服务端使用`EventNotification`服务通知客户端服务器发生的事件。

>`IEC 61334-4-41:1996`规定的是早期的DLMS，后面有扩充的叫做xDLMS,多了很多重要的东西

###### 9.1.4.3.2 xDLMS services used by the client with LN referencing

GET9.3.6、SET9.3.7、ACTION9.3.8、ACCESS9.3.9

###### 9.1.4.3.3 xDLMS services used by the client with SN referencing

Read9.3.14、Write9.3.15、UnconfirmedWrite9.3.16

##### 9.1.4.3.4 Unsolicited services

主动上报

共有DataNotification，LN有EventNotification，SN有InformationReport

###### 9.1.4.3.5 Selective access

选择性访问属性内部分内容

###### 9.1.4.3.6 Multiple references

在COSEM对象相关的服务调用中，可以`引用`一个或`多个`命名变量、属性和/或方法，见9.4.6.1

TODO:这个特性还不知道

###### 9.1.4.3.7 Attribute_0 referencing

`属性0`表示`引用所有`公共属性（属性号为正），

##### 9.1.4.4 Additional mechanisms

与IEC 61334-4-41:1996中规定的DLMS相比，xDLMS指定了一些新的机制来提高功能、灵活性和效率。其他机制包括:

- 使用逻辑名logical names进行引用;
- 识别服务调用;
- 优先处理;
- 传输较长的应用信息;
- 可组合的xDLMS消息;
- 压缩解压;
- 通用密码保护;
- 通用块传输general block transfer(GBT)

下面逐个介绍

###### 9.1.4.4.2 Referencing methods and service mapping

在`confirmed AAs`的情况下，`引用方法`在AA建立阶段通过COSEM应用上下文进行`协商`。在AA成立期间`不得改变`。在给定的AA中使用LN或SN服务是独占的。

在`unconfirmed` and `pre-established` AAs的情况下，客户端AL需要`提前知道`服务器支持的`引用方法`。

###### 9.1.4.4.3 Identification of service invocations: the Invoke_Id parameter

在client/server模型中，请求由客户机发送，响应由服务器发送。允许客户端在接收到对前一个请求的响应之前发送`多个请求`，前提是`较低层允许`这样做。

需要用`Invoke_Id`来`标识`数据包，这样客户端才能判断响应是`对应`哪个请求的

在`ACCESS`和`DataNotification`服务(参见9.3.9和9.3.10)中，使用`Long-Invoke-Id`参数来`代替`Invoke_Id参数。

`EventNotification`服务`不包含`Invoke_Id参数。

此功能仅在`LN引用`时可用

###### 9.1.4.4.4 Priority handling

对于使用`LN引用`的数据传输服务，有两个`优先级`可用:`normal (FALSE)`和`high (TRUE)`。

服务器不按先来先服务`FIFS`，而是根据`优先级`处理

此功能仅在`LN引用`时可用

###### 9.1.4.4.5 Transferring long messages

xDLMS服务原语由`xDLMS APDUs`以编码形式携带。这种编码形式可能比客户端/服务器`协商`的`最大接收PDU大小`长

两种方案：

- `通用块传输`(GBT)机制
- `特定于服务`的块传输机制

如果最大接收PDU大小很大，超过了下一层的限制，APDUs符合条件，不用分块，那就需要下一层进行分包操作

特定于服务的块传输机制用于：

- 使用LN参引用的confirmed services:GET、SET、ACTION;
- 使用SN参引用的confirmed services:Read、Write

特定于服务的块传输在以下情况下不可用:

- unconfirmed services
- unsolicited services (DataNotification, EventNotification and InformationReport)
- the ACCESS service

`特定于服务的块传输`只能一包一包顺序传，不支持流式传输，不支持恢复丢失块。加密是加一个block，而不是整个APDU，服务专用数字签名不可用。TODO：服务专用数字签名是什么

相反，`GBT机制`可以与任何xDLMS APDU一起使用，包括`通用密码和通用签名APDU`。它提供`双向块传输`、`流`和`丢失块恢复`。当需要加密保护时，对`完整的APDU`进行`加密保护`，然后被保护的APDU以`块的形式`传输，如图87所示。

###### 9.1.4.4.6 Composable xDLMS messages

可组合的xDLMS消息

处理xDLMS消息的三个重要方面是`编码/解码`、`应用、验证/删除密码保护`和`块传输`。

可组合xDLMS消息的概念将这`三个方面`分开

![messages](/assets/img/2022-03-17-dlms-green-1/xdlmscomp.jpg)

一旦AL构建了与AP调用的服务原语对应的APDU，就可以使用通用保护机制来应用密码保护。当不受保护或受保护的APDU长度超过协商的APDU长度时，可以采用`通用块传输机制`。

TODO:没看懂什么意思,就是各种处理方式可以组合使用的意思吗

###### 9.1.4.4.7 Compression and decompression

For details, see 9.2.3.6.

###### 9.1.4.4.8 General protection

此机制可用于对任何xDLMS APDU应用密码保护，这允许在客户机和服务器之间或第三方和服务器之间应用多层保护。见9.2.2.5。

- the general-ded-ciphering and the general-glo-ciphering APDUs;
- the general-ciphering APDUs;
- the general-signing APDU.

###### General block transfer (GBT)

GBT机制可用于块内传输任何长或短`xDLMS APDU`。在GBT中，块由`通用块传输APDU`携带，而不是由特定于服务的“with-datablock”APDUs携带。

GBT机制支持`双向块传输`、`流传输`和`丢失块恢复`:

- `双向块传输`意味着当一方发送块时，另一方不仅可以确认接收到的块，而且如果它有块可以发送，它也可以发送它们，就是`全双工`模式;
- `流式传输`意味着一方可以发送`多个区块`，而无需另一方对每个区块进行确认,有一个发送窗口;参考TCP传输
- `丢失块恢复`意味着如果发送的块的接收未被确认，它可以被`再次发送`。如果使用流，丢失的块恢复发生在每个`流窗口的结束`。

通用块传输机制的协议在9.4.6.13中指定

##### 9.1.4.5 Additional data types

##### 9.1.4.6 xDLMS version number

6

##### 9.1.4.7 xDLMS conformance block

`xDLMS一致性块`支持具有扩展功能的优化的DLMS服务实现。它可以通过标记“Application 31”与DLMS一致性块区分开来。请参见9.4.6.1、9.5和9.6。

`confirmed AAs`可以在`AA建立期间`协商一致性块，`unconfirmed and pre-established AAs`需要客户端`提前知道`server的一致性块

##### 9.1.4.8 Maximum PDU size

- Client Max Receive PDU Size

  Unsigned16，必须能满足AARE APDU大小

  低于12的值被保留，0表示无限制

- Server Max Receive PDU Size

  Unsigned16

  低于12的值被保留，0表示无限制

#### 9.1.5 Layer management services

这些服务的规范不在本技术报告的范围内。

#### 9.1.6 Summary of DLMS/COSEM application layer services

- The DLMS/COSEM AL services are specified in 9.3.
- The DLMS/COSEM AL protocol is specified in 9.4.
- The abstract syntax of the ACSE and xDLMS APDUs is specified in 9.5.
- The XML schema is defined in 9.6.

![messages](/assets/img/2022-03-17-dlms-green-1/dlmsal.jpg)

#### 9.1.7 DLMS/COSEM application layer protocols

`DLMS/COSEM AL`协议是基于`ISO/IEC 15954:1999`中规定的`ACSE标准`和`IEC 61334-4-41:1996`中规定的`DLMS标准`，并扩展了DLMS/COSEM。

### 9.2 Information security in DLMS/COSEM

- DLMS/COSEM安全概念security concept，见9.2.2;
- 选择的加密算法，见9.2.3;
- 安全密钥，见9.2.4、9.2.5、9.2.6;
- 使用加密算法进行实体认证，xDLMS APDU保护和COSEM数据保护，见9.2.7。

#### 9.2.2 The DLMS/COSEM security concept

##### 9.2.2.2 Identification and authentication

###### 9.2.2.2.1 Identification

如4.3.3所述，DLMS/COSEM `AEs`被绑定到支持AL的`协议层`中的服务接入点(`SAPs`)。这些SAPs存在于AA中包含xDLMS APDUs的PDUs。

TODO:找到实例完善

客户端`用户识别机制`使`服务器`能够区分`客户端的不同用户`(可能是运营商或第三方)，以记录他们访问设备的活动。也看到4.3.6。

###### 9.2.2.2.2 Authentication mechanisms

身份验证机制确定通信实体在AA建立期间使用的协议来证明自己。

![messages](/assets/img/2022-03-17-dlms-green-1/dlmsauth.jpg)

- No security (Lowest Level Security) authentication

  `无安全性`(最低级别安全性)身份验证的目的是允许客户机从服务器检索一些`基本信息`。这种身份验证机制不需要任何身份验证;客户端可以访问安全上下文中的COSEM对象属性和方法，以及给定AA中普遍存在的访问权限。

- Low Level Security (LLS) authentication

  服务器要求`客户端`通过提供服务器知道的密码来`证明自己`。该密码是由当前持有的“`Association SN / LN`”对象建模的AA来建立的。“Association SN / LN”对象提供了更改密码的方法。

- High Level Security (HLS) authentication

客户端和服务器都必须成功地证明自己（`双向认证`），以建立一个AA。

- Pass 1:客户端发送一个“challenge”CtoS信息，以及根据身份验证机制附加的信息给服务器;
- Pass 2:服务器发送一个“challenge”StoC信息，以及根据身份验证机制附加的信息给客户端;

  >如果StoC与CtoS`相同`，客户应`拒绝并中止`AA建立过程。所以StoC与CtoS必须是独立生成的且不同的。
- Pass 3:`客户端`根据对给定AA有效的HLS身份验证机制的规则处理`StoC`和`其他信息`，并将结果`发送`给服务器。服务器检查`f(StoC)`是否是正确处理的结果，如果是，则`接受`客户端的身份验证
- Pass 4:`服务器`根据对给定AA有效的HLS身份验证机制的规则处理`CtoS`和`附加信息`，并将结果`发送`给客户端。客户端检查`f(CtoS)`是否是正确处理的结果，如果是，则`接受`服务器的身份验证。

总结，由服务端先校验客户端合法性，再由客户端校验服务端合法性

`pass2后`，如果application context and xDLMS context`合法`（这两个参数再pass1和2交换或生成，pass2后已存在，只不过要到pass4全走完才激活），则`授予`当前"Association SN / LN”对象的`reply_to_HLS_authentication`方法`权限`

pass3和4依赖于reply_to_HLS_authentication

##### 9.2.2.3 Security context

- `安全套件security suite`，确定可用的安全算法，参见9.2.3.7;
- `安全策略security policy`，确定在AA内交换的所有xDLMS APDUs的保护类型。可能的安全策略在9.2.7.2.2中指定;
- `安全材料security material`，与给定安全算法相关的，包括安全密钥、初始化向量、公钥证书等。由于每个安全算法的安全材料都是特定的，因此在相关条款中详细指定了元素。

##### 9.2.2.4 Access rights

属性的访问权限包括:no_access、read_only、write_only或read_and_write。

方法的访问权限可以是no_access或access。

可以对访问特定的属性或方法的APDUs单独配置加密，.request和.response也可以

##### 9.2.2.5 Application layer message security

就是对称加密传输的过程，AA已经建立的情况下

![messages](/assets/img/2022-03-17-dlms-green-1/applayersecurity.jpg)

为了确保端到端消息安全性，第三方必须能够与DLMS服务器交换受保护的xDLMS服务请求。在这种情况下，客户端充当代理

![messages](/assets/img/2022-03-17-dlms-green-1/endtoend.jpg)

- `第三方Third party`:

  - 感知DLMS/COSEM，即它可以`生成和处理`封装了携带COSEM对象相关的服务请求和响应的xDLMS `APDUs`的消息;
  - 它能够对携带请求的xDLMS APDU应用`自己的保护`（TODO：这个保护是不是不在DLMS规定的范围内，比如用HTTP传输，TLS保护.但是接受服务端消息时又写到能够处理server - client general protected APDU，AA不是client和server建立的吗，third party的密钥是哪里来的）;
  - 它能够`验证`由服务器和/或客户端应用的保护响应。

- `The DLMS client`

  - 作为第三方和服务器之间的中间人`broker`;
  - 根据`TP-client`消息中包含的信息，`为第三方提供适当的AA`;
  - 验证TP有权使用该AA;验证方法超出了本技术报告的范围。
  - 它可以验证第三方申请的保护;
  - `封装`第三方客户端消息到一个通用的受保护的xDLMS APDU;
  - 它可以验证服务器对封装COSEM对象相关服务响应或未经请求的服务请求的APDU应用的保护;(Push操作时);
  - 它可以对发送到TP的受保护的xDLMS APDU应用自己的保护。

- `The server`

- 与第三方使用的`客户端`(预先)`建立AA`;
- 它可以检查使用AA的第三方的身份;
- 一旦客户端和/或第三方应用的保护被服务端成功验证，服务端将提供访问COSEM对象属性和方法的权限，这些属性和方法由安全策略和访问权限确定;
- 它应该准备响应——或者，在推送操作的情况下，一个未经请求的服务请求——并应用由传入请求的保护、访问权限和安全策略决定的保护。

##### 9.2.2.6 COSEM data security

对`具体`COSEM对象内属性、方法参数等的`保护`，与AL层整体加密整个xDLMS APDU有区别。

#### 9.2.3 Cryptographic algorithms

- 散列函数hash functions
- 对称加密symmetric key algorithms
- 非对称加密asymmetric key algorithms

##### 9.2.3.2 Hash function

一个好的哈希函数是`单向函数`（逆过程很难），且要找到产生相同哈希值的两个特定输入也是极其困难的。

哈希函数接受任意长度的输入，输出固定长度的值。

一般用于校验完整性

在DLMS/COSEM中使用哈希算法的目的如下:

- 数字签名，见9.2.3.4.4;
- 密钥协议，见9.2.3.4.6;
- HLS认证。具体算法与认证机制有关，请参见9.2.7.4。

##### 9.2.3.3 Symmetric key algorithms

对称密钥算法在DLMS/COSEM中用于以下目的:

- 使用HLS认证机制对通信伙伴进行认证，参见9.2.7.4;
- xDLMS消息的认证和加密，参见9.2.7.2;
- COSEM数据认证和加密，参见9.2.7.5。

###### 9.2.3.3.2 Encryption and decryption

###### 9.2.3.3.3 Advanced Encryption Standard

AES算法，属于分组加密算法

AES结合了安全性、性能、效率、易于实现和灵活性。具体来说，该算法在各种计算环境的硬件和软件上都有良好的性能。此外，该算法对内存的要求非常低，这使得它非常适合于空间受限的环境。（TODO:内存占用少是不是因为是分组加密，每一块加解密时占用少导致的）

###### 9.2.3.3.4 Encryption Modes of Operation

AES-GCM可规避相同明文块加密成相同密文块带来的重复特征检测，密文块批量篡改的问题。

##### 9.2.3.3.5 Message Authentication Code

消息验证码MAC

MAC作用与HASH函数相似，都可以验证`完整性`，不同的是MAC`需要密钥`而HASH不需要密钥。MAC还能验证`真实性`，即使内容被篡改因为没有密钥也无法生成MAC

##### 9.2.3.3.6 Key wrapping

可以使用对称密钥算法使用密钥封装密钥(也称为`密钥加密密钥`)来封装(即加密)密钥材料。

master key

见9.2.3.3.8

###### 9.2.3.3.7 Galois/Counter Mode

GCM是AES算法的一种运行模式。

加密或认证可选，可以仅加密或仅认证

![messages](/assets/img/2022-03-17-dlms-green-1/aesgcm.jpg)

- **认证加密函数**
  - 输入:
    - `密钥`，`EK`
    - `明文`，表示为`P`;
    - `附加认证数据`Additional Authenticated Data(`AAD`)，记为`A`;
    - `初始化向量`initialization vector(IV)表示为`IV`。

    明文和AAD是GCM保护的两类数据。GCM保护了明文和AAD的真实性;GCM还保护明文的机密性，而AAD则是透明的（`明文加密认证，AAD仅认证`）

    长度要求（bit）：

    - len(P) < 2^39-256;
    - len(A) < 2^64-1;
    - 1 <= len(IV) <= 2^64-1.

    P、A、IV的位长都是`8的倍数`，所以这些值都是`字节串`。

  - 输出：
    - 一个与明文P位`长度相同`的`密文C`
    - 一个`身份验证标记`或`标记`，简称`T`

- **认证解密函数**
  - 输入：
    - `密钥`，`EK`
    - 密文C
    - `附加认证数据`Additional Authenticated Data(`AAD`)，记为`A`;
    - 一个`身份验证标记`，简称`T`

  - 输出：
    - 一个与密文C`长度相同`的`明文P`
    - 一个特殊的`错误代码`，在本技术报告中表示为FAIL

- The initialization vector, IV

  就是frame counter，每加密一次加1,DLMS协议里是systemtitle + IC

  每个加密密钥(EK)都有`两个`相关联的调用计数器(IC)，一个用于经过身份验证的加密函数，另一个用于经过身份验证的解密函数。

  - 当密钥建立时，对应的`IC`复位为0;
  - 使用`认证加密`功能后，对应的IC`加1`。如果IC已达到`最大值`，任何进一步调用认证加密函数将`返回错误`，且IC`不得增加`。
  - 使用`鉴权解密`功能时，验证`IC`的值。该值必须等于或大于`最低可接受值`。

    如果被验证的值满足此要求，则使用认证解密功能后，`最低可接受值`为`已验证的IC值``加1`。如果`被验证的值``小于`最低可接受值，则`验证失败`，经过验证的解密功能也会`失败`。如果被验证的值等于最大值，则经过验证的解密函数将返回一个错误。

    TODO:这里有个问题，如果客户端出现异常，被验证值设置得很大，那不是会很快到达最大值，导致设备不可用

  固定字段的位长将可以为给定密钥实现`验证加密功能`的不同物理设备的数量限制为 2^64。调用字段的位长将`验证加密功能`的调用次数限制为 2^32 输入集而不违反唯一性要求。(TODO:没看懂什么意思)

- The encryption key, EK

  `GCM`只使用`一个密钥`，即分组密码密钥。在DLMS/COSEM中，这被称为`加密密钥`，表示为`EK`。它的`大小`取决于安全套件(参见9.2.3.7)，应该是:

  - for security suite 0 and 1, 128 bits (16 octets): len(EK) = 128;
  - for security suite 2, 256 bits (32 octets): len(EK) = 256;

  密钥应该`随机均匀生成`，或者`近似随机`均匀生成，即每个可能的密钥生成的概率(几乎)相等。因此，该键将是`新的`，即，不等于任何以前的键，且概率很高。密钥应该是秘密的，应使用只适用于GCM和选定的分组密码AES。密钥建立和管理的附加要求在NIST SP 800-38D:2007, 8.1中进行了讨论。

- The authentication key, AK

  作为附加认证数据(`AAD`)的`一部分`

- Length of the authentication tag

  身份验证标记的`位长t`是一个安全参数。在安全套件0、1和2中，其值应为96位。

###### 9.2.3.3.8 AES key wrap

对于封装密钥数据，DLMS/COSEM选择了`RFC 3394`中指定的AES密钥封装算法。该算法旨在包装或加密关键数据。它对`64位块`进行操作。在wrap之前，关键数据被解析为`n个64位`的块,`n至少为2`。(AES密钥长度是128、192、256，所以肯定满足要求)

加密输入`密钥加密密钥KEK`和`明文密钥`，明文密钥为`n个64bit`块，输出`(n+1)*64bit`长度密文

解密相反。

TODO:输入输出不是等长的吗

在DLMS/COSEM中，KEK的大小取决于`安全套件`(参见9.2.3.7)，并应是:

- 对于安全套件`0和1`,128位(16位):len(KEK) = `128`;
- 对于安全套件`2`,256位(32位):len(KEK) = `256`。

##### 9.2.3.4 Public key algorithms

公钥密码系统一般采用难以解决的问题作为算法的基础。RSA算法是基于非常大的整数的质因数分解。椭圆曲线密码体制(ECC)是基于求解椭圆曲线离散对数问题(ECDLP)的难度。

- 通信双方`认证`
- xDLMS APDUs和COSEM数据的`数字签名`
- `密钥协商`key agreement

一些非对称密钥算法可以用于多种目的(例如，用于数字签名和密钥建立)。用于一种目的的密钥不得用于其他目的。（TODO:私钥是否需要有这个要求）

###### 9.2.3.4.2 Elliptic curve cryptography

椭圆曲线密码学ECC

素数域上的椭圆曲线由实数(x, y)组成，满足下列方程:

$$ y^2=x^3+ax+b $$

曲线的形状由a和b两个参数决定

- NIST推荐使用椭圆曲线

![messages](/assets/img/2022-03-17-dlms-green-1/recommandcurves.jpg)

###### 9.2.3.4.3 Data conversions

本节描述了数据转换原语，用于在用于指定公钥算法的不同数据类型之间进行转换：八位字节串 (OS)、位串 (BS)、整数 (I)、字段元素 (FE) 和椭圆曲线点 （ECP）。 DLMS/COSEM 使用八位组字符串来表示公钥算法的元素，并使用这些数据类型与八位组字符串之间的转换原语。 长度为 d 的`八位字节串` $M_{d–1}$ $M_{d–2}$ … $M_0$ 被编码为 `A-XDR` OCTET STRING，其中最左边的八位字节$M_{d–1}$对应于八位字节串的编码值的第一个八位位组

- Conversion between Bit Strings and Octet Strings (BS2OS)

  位串转换为八位串的数据转换原语称为位串到八位串转换原语，或称BS2OS。它以位字符串作为输入，输出八位字符串。长度为l的字节串$b_{l-1} b_{l-2}…b_{0}$应该转换为长度为$d=⌈l/8⌉$的八位字符串$M_{d-1} M_{d-2}…M_{0}$。

  >位串在内存中的编码非常密集。每个位只`占用一位`存储空间，整个位串的开销由一个小常数限定。但是，与访问向量或字符串的元素相比，访问位串中的位要慢。如果性能是最重要的问题，最好使用字符串来存储布尔值集，即使它们占用更多空间。
  >
  >位串和八位字节串的区别就是位串的位长`不需要是8的倍数`，而可以是任意值，转换的时候需要`补足8的倍数`

  转换器在左边`填充足够的零`，使位数为`8的倍数`，然后将其分解为八位。

  - for $0 \le i \lt d – 1$, let the octet $M_i = b_{8i+7} b_{8i+6} ... b_{8i},$;
  - the leftmost octet $M_{d–1}$ shall have its leftmost $8d – l$ bits set to zero;最左边的OS字节需要包含位串最左边填0部分
  - its rightmost $8 – (8d – l)$ bits shall be $b_{l–1} b_{l–2} … b_{8d–8}$.

- Conversion between Octet Strings and Bit Strings (OS2BS)

  和上面相反

  最左一字节的最左位必须是0

- Conversion between Integers and Octet Strings (I2OS)

  输入为`非负整数`$x$，预期长度$d$，需要满足$256^d \gt x$

  每个整数的位用一个字节表示：

  - $x = x_{d-1} \cdot 256^{d-1} + x_{d-2} \cdot 256^{d-2} + \cdots + x_1 \cdot 256 + x_0,$;
  - where $0 ≤ x_i < 256$ for $0 ≤ i ≤ d-1$;
  - $M_i = x_i$, for $0 ≤ i ≤ d-1$.

- Conversion between Octet Strings and Integers (OS2I)

  和上面相反

  0字节的OS输出整数0

- Conversion between Field Elements and Octet Strings (FE2OS)

  将`字段元素`转换为八位字符串的数据转换原语称为字段元素到八位字符串转换原语，或`FE2OS`。它接受一个`字段元素`作为`输入`，并`输出`相应的`八位字符串`。应用I2OS转换原语，参数$l$将域元素$x \in F_p$转换为长度为$d =⌈\log_{256}p⌉$的八位字符串$M_{d-1} M_{d-2} … M_0$，其中

  - $FE2OS(x) = I2OS(x,l)$

- Conversion between Octet Strings and Field Elements (OS2FE)

  与上面相反

  $OS2FE(x) = OS2I(x) \mod p$

TODO:Field Elements是什么，FE2OS不懂

###### 9.2.3.4.4 Digital signature

数字签名是书面签名的电子模拟，可用于向收件人或第三方证明消息是由发信人签名的(这种特性称为`不可否认性`)。还可以为所存储的数据和程序生成数字签名，以便可以在稍后时间验证数据和程序的`完整性`

![messages](/assets/img/2022-03-17-dlms-green-1/digitalsign.jpg)

###### 9.2.3.4.5 Elliptic curve digital signature (ECDSA)

对于DLMS/COSEM，选择了FIPS PUB 186-4:2013中指定的`椭圆曲线数字签名(ECDSA)算法`。NSA1提供了一个实现指南。

- 在DLMS/COSEM中使用的椭圆曲线和算法为:

  - in the case of Security Suite `1`, the elliptic curve `P-256` with the `SHA-256` hash algorithm;
  - in the case of Security Suite `2`, the elliptic curve `P-384` with the `SHA-384` hash algorithm.

- 签名
  - 输入：
    - 要签名的消息M;
    - 签名者的私钥d
  - 输出：
    - ECDSA signature (r, s) over M.

- 验签
  - 输入：
    - 已签名的消息M'
    - ECDSA signature (r',s')
    - 签名者的公钥Q

TODO:这里的(r',s')和(r, s)应该是相同的吧

在 DLMS/COSEM 中，应使用纯文本格式：签名 (r, s) 被编码为八位字节串 R || S(表示`串联`，不是逻辑运算符的或)，即作为八位字节串 `R = I2OS(r,l)` 和 `S = I2OS(s,l)` 的`串联`, $l = [\log_{256} n]$。 因此，签名具有 `2l` 个八位字节的`固定长度`。

###### 9.2.3.4.6 Key agreement

密钥协商允许两个实体联合计算共享密钥并从中派生密钥材料。

对于DLMS/COSEM，已从NIST SP 80056A Rev. 2: 2013中选择了三种椭圆曲线密钥协商方案

- 椭圆曲线密钥协商方案：

  - the Ephemeral Unified Model C(2e, 0s, ECC CDH) scheme;

    此方案用于DLMS客户机和服务器之间就主密钥、全局加密密钥和/或身份验证密钥达成一致。`客户端`扮演`U`方角色，`服务器`扮演`V`方角色。流程由“`Security setup`”接口类的方法支持;见DLMS UA 1000-1 Part 2 Ed.15:2021, 4.4.7.

    双方从域参数d(TODO:域参数是什么)中生成一个`临时密钥对`。双方`交换临时公钥`，然后使用`域参数`、`各自的临时私钥`和`对方的临时公钥`计算`共享密钥Z`。`密钥材料`是使用9.2.3.4.6.5中指定的`密钥派生函数`从`共享密钥Z`和`其他输入`中派生出来的。(TODO:密钥材料，密钥派生是什么。)

  - the One-Pass Diffie-Hellman C(1e,1s, ECC CDH) scheme;

    和上面的类似，主要是静态动态公钥的区别，就是不需要服务端把动态公钥给客户端，客户端可以通过预先导入的证书（可信CA签名）获得对方的静态公钥

    全程只需要发送一次公钥
  - the Static Unified Model C(0e, 2s, ECC CDH) scheme.

    和上面的类似，将动态公钥变成了静态公钥，不需要发送公钥，只需要Nonce，Nonce用于计算密钥材料，保证每次生成的密钥材料不同。

- Key Derivation Function – The NIST Concatenation KDF

  密钥派生函数

  Function call: `kdf(Z, OtherInput)`
  - `Z`
    共享密钥，byte string
  - `OtherInput`
    - keydatalen
      一个整数，表示要生成的`密钥材料`的`长度`(以`位`为单位):安全套件`1`为`128`位，安全套件`2`为`256`位;
    - OtherInfo
      等于下列串联的位字符串

      AlgorithmID || PartyUInfo || PartyVInfo {||SuppPubInfo}{||SuppPrivInfo}

      - AlgorithmID
        bit string，指示如何`解析`派生的密钥材料,以及派生的密钥材料将用于哪种`算法`

        GUEK and GAK：AES-GCM-128 / AES-GCM-256.

        KEK：AES-WRAP-128 / AES-WRAP-256

        ![messages](/assets/img/2022-03-17-dlms-green-1/algorithmid.jpg)
      - PartyUInfo
        U方提供的公开信息，用于派生过程，bit string
      - PartyVInfo
        V方提供的公开信息，用于派生过程，bit string
      - SuppPubInfo
        (Optional),额外的公开信息，DLMS/COSEM不使用
      - SuppPrivInfo
        (Optional),额外的非公开信息，DLMS/COSEM不使用

##### 9.2.3.5 Random number generation

应提供强随机数生成器(RNG)，以生成DLMS/COSEM中使用的各种算法所需的随机数。

##### 9.2.3.6 Compression

和加密无关，只是放在一起

##### 9.2.3.7 Security suite

安全套件确定可用于各种密码原语的`密码算法集`和`密钥长度`。

`DLMS/COSEM安全套件`(见表27)基于[NSA suite B](https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography)，包括用于`身份验证、加密、密钥协议、数字签名和哈希的加密算法

![messages](/assets/img/2022-03-17-dlms-green-1/securitysuite.jpg)

#### 9.2.4 Cryptographic keys – overview

密钥作用：

- 明文到密文的转换;
- 密文到明文的转换;
- 验证码(MAC)的计算和验证;
- 密钥包装wrapping;
- 应用和验证数字签名;
- 密钥协商。

#### 9.2.5 Key used with symmetric key algorithms

##### 9.2.5.1 Symmetric keys types

对称密钥的分类：

- 按目的分类
  - key encrypting key (KEK)用于加密其他对称加密密钥，master key
  - encryption key用于AES-GCM算法的块加密
  - authentication key用于AES-GCM算法的AAD
- 按生命周期分类
  - 打算使用`较长时间`的`静态密钥`。 在 DLMS/COSEM 中，它们可能是：
    - 一个`全局密钥`，可用于在相同合作伙伴之间重复建立的多个 AA。 全局密钥可以是单播加密密钥（`GUEK`）、广播加密密钥（`GBEK`）或认证密钥（`GAK`）；
    - 在两个合作伙伴之间建立的单个 AA 期间可以重复使用的`专用密钥`。 因此，其生命周期与 `AA 的生命周期`相同。 专用密钥只能是`单播加密密钥`。
  - `临时密钥`通常用于 一个 AA 内的单个交换。

TODO:InitiateRequest APDU和AARQ是什么关系？答：见12.3 Table 133 最后，InitiateRequest APDU是AARQ中user-information字段的一部分，是可以加密的

`专用密钥`由AARQ APDU中的`InitiateRequest APDU`携带，这个InitiateRequest APDU`本身`要被全局单播加密密钥（`GUEK`）加密，AARE中的`InitiateResponse APDU`也要用相同的方式加密。

> AARQ和AARE APDUs本身`不受保护`。

![messages](/assets/img/2022-03-17-dlms-green-1/symmetrickeytypes.jpg)

##### 9.2.5.2 Key information with general-ciphering APDU and data protection

当general-ciphering APDU 用于保护 xDLMS APDU 或 COSEM 数据时，发送方发送关于已经/将用于加密/解密 xDLMS APDU/COSEM 数据的`密钥的必要信息`，以及`加密的` xDLMS APDU / COSEM `数据`。

TODO:没看懂

##### 9.2.5.3 Key identification

TODO:没看懂

##### 9.2.5.4 Key wrapping

可以用key wrapping加密的：

- the master key, KEK; and/or
- the global unicast encryption key GUEK; and/or
- the global broadcast encryption key GBEK; and/or
- the (global) authentication key, GAK.

“Security setup” 对象的key_transfer方法。

##### 9.2.5.5 Key agreement

可以用The `Ephemeral` Unified Model C(2e,0s, ECC CDH) scheme协商的密钥：

- the master key, KEK; and/or
- the global unicast encryption key GUEK; and/or
- the global broadcast encryption key GBEK; and/or
- the (global) authentication key, GAK.

##### 9.2.5.6 Symmetric key cryptoperiods

对称密钥的加密周期应在项目特定的配套规范中确定。

#### 9.2.6 Keys used with public key algorithms

非对称加密算法密钥分类：

- 按目的：数字签名、密钥协商

- 按生命周期：静态密钥、临时密钥

![messages](/assets/img/2022-03-17-dlms-green-1/asymmetrickeytypes.jpg)

##### 9.2.6.2 Key pair generation

由(q, FR, a, b {, domain_parameter_seed}, G, n, h)生成私钥d和公钥Q

##### 9.2.6.3 Public key certificates and infrastructure

Public Key Infrastructure (PKI)

###### 9.2.6.3.2 Trust model

DLMS servers 设备制造过程应该预先导入`trust anchors`信任锚、自己的证书、CA证书、DLMS clients and third parties证书。

>设备制造导入证书或信任锚属于`Out of Band (OOB)`带外过程，也就是`正规操作以外`的过程，正常导入证书应该是通过“Security setup”对象

>[信任锚](https://ldapwiki.com/wiki/Trust%20Anchor)或是[这篇文章](https://stackoverflow.com/questions/56061101/trust-anchor-certificates-in-pki)，信任锚就是最终信任的那个实体，可以有多个，可以是root CA，一般操作系统预装了可以信赖的root CA列表

“Security setup”类提供：

- 提供关于存储在服务器上的`证书`的信息的`属性`;
- 用于`生成`服务器`密钥对`的方法和用于`生成`服务器上的证书签名请求(`CSR`)信息的方法,CSR由客户端`代为发送给CA`;
- `导入、导出、移除证书`的方法

证书一般都有一个`有效期限`。但是，颁发给`DLMS服务器`的证书可能`无限期有效`。证书到期后，可能需要进行`替换`。

在服务器使用证书之前，必须对其进行验证。验证包括:

- 检查证书的`语法`有效性;
- 检查证书包含的`属性`;
- 检查证书有效期是否`未过期`;
- 检查`信任锚点`的认证路径;
- 检查证书`颁发者`的`签名`

###### 9.2.6.3.3 PKI architecture – informative

PKI是一种安全基础设施，它`创建`和`管理公钥证书`，以方便使用公钥(即，非对称密钥)加密。

- 在验证绑定的准确性后，`生成并分发公钥证书`，以将公钥绑定到其他信息上（证书包含了公钥和部分设备自定义信息，最后加上数字签名）
- 维护和分发未过期证书的证书`状态信息`。

![messages](/assets/img/2022-03-17-dlms-green-1/pkiarch.jpg)

- Root-CA
  提供PKI的`信任锚点`。它为Sub-CAs颁发证书，并维护一个证书撤销列表(`CRL`)。Root-CA证书策略定义了处理证书颁发的规则

  Root-CA拥有根证书“`C(Root)`”。Root-CA的证书是用Root-CA的私钥`自签名`的。`Sub-CAs`证书也使用Root-CA`私钥签名`。

- Sub-CA
  Sub-CA是为终端实体颁发证书的组织，被Root-CA授权

  每个Sub-CA Certificate Policy证书策略必须遵守Root-CA Certificate Policy
  
  备存发给终端实体End entity的`证书清单`及`证书撤销清单`

  Sub-CA拥有证书`C(sub-CA)`。此证书由Root-CA颁发。Sub-CA的私钥用于签名终端实体End entity证书。

- End entities
  - 数字签名密钥证书`C(digitalSignature)`，用于数字签名;
  - 静态密钥协商密钥证书`C(keyAgreement)`，用于密钥密钥协商;
  - （可选）TLS- certificate `C(TLS)`，用于在建立TLS安全通道之前在DLMS客户端和DLMS服务器之间进行认证。

##### 9.2.6.4 Certificate and certificate extension profile

所有证书都应具有为`X.509 V3`证书指定的结构。

###### 9.2.6.4.2 The X.509 v3 Certificate

- m (mandatory): 强制使用;
- o (optional): 可选;
- x (do not use): 不要使用.

Certificate：

- tbsCertificate
  包含主题和颁发者的名称、与主题关联的公钥、有效期和其他相关信息
  - Version
    V3为2
  - Serial number
    序列号必须为CA分配给每个证书的`正整数`。对于给定CA颁发的每个证书，它必须是`唯一`的。上限`20个字节`
  - Issuer and Subject
    颁发者字段标识签名和颁发证书的实体。

    ![messages](/assets/img/2022-03-17-dlms-green-1/rootcasubject.jpg)

    ![messages](/assets/img/2022-03-17-dlms-green-1/subcasubject.jpg)

    ![messages](/assets/img/2022-03-17-dlms-green-1/entitysubject.jpg)
  
    Common Name需要是DLMS/COSEM System title
  - Validity period
    证书有效期

    - 开始生效(notBefore)
    - 无效时间(notAfter)

    DLMS服务器可以获得无法指定有效过期日期的证书;这样的证书将在设备的`整个生命周期`内使用

    为了表明证书没有明确定义的到期日期，`notAfter` 应该被分配 `99991231235959Z` 的 `GeneralizedTime` 值。
  - SubjectPublicKeyInfo
    标识公钥和密钥算法

    ```asn.1
    SubjectPublicKeyInfo ::= SEQUENCE 
    {
      Algorithm               AlgorithmIdentifier, 
      subjectPublicKey        BIT STRING 
    }
    AlgorithmIdentifier ::= SEQUENCE 
    {
      algorithm               OBJECT IDENTIFIER, 
      parameters              ANY DEFINED BY algorithm OPTIONAL
    }
    ```

    AlgorithmIdentifier用于识别密钥算法

    OBJECT IDENTIFIER：
    - OID value: 1.2.840.10045.2.1;
    - OID description: ECDSA and ECDH Public Key.

    parameter：
    - 1.2.840.10045.3.1.7：NIST P-256
    - 1.3.132.0.34：NIST P-384

  - Subject Unique ID
    主题唯一id可以选择性地用于终端设备证书，而不是服务器证书。
  
- Certificate extensions

  ![messages](/assets/img/2022-03-17-dlms-green-1/x509v3ext.jpg)

  - Authority Key Identifier
    标识公钥，公钥是和用于签名证书的私钥对应的
  - SubjectKeyIdentifier
    标识包含特定公钥的证书
  - KeyUsage
    密钥用途，keyAgreement、digitalSignature等
  - CertificatePolicies
    证书策略
  - SubjectAltNames
    主题备用名称,可以当作subject的扩展
  - IssuerAltName
    签发者备用名称
  - Basic constraints
    标识本证书所有者是否为CA
  - Extended Key Usage
    该证书可作为TLS服务器证书使用
  - cRLDistributionPoints
    标识如何获取CRL
  - Other extensions
- signatureAlgorithm
  包含CA用于签名此证书的`签名算法`的标识符。和`signatureValue`相关

  ```asn.1
  AlgorithmIdentifier ::= SEQUENCE
  {
    algorithm         OBJECT IDENTIFIER
    parameters        ANY DEFINED BY algorithm OPTIONAL 
  }
  ```

  - `ecdsa-with-SHA256`, OID 1.2.840.10045.4.3.2 in the case of security suite 1;
  - `ecdsa-with-SHA384`, OID 1.2.840.10045.4.3.3 in the case of security suite 2;
  
- signatureValue
  由`ASN.1 DER编码的tbsCertificate`生成的`数字签名`

  用于验证tbsCertificate的有效性

##### 9.2.6.5 Suite B end entity certificate types to be supported by DLMS servers

终端设备包含的证书类型

证书必须用ECDSA签名，证书中的`P-256`类型密钥必须用`P-256或P-384`类型密钥签名，证书中的`P-384`类型密钥必须用`P-384`类型密钥签名

- Root-CA自签名证书（信任锚）
- Sub-CA证书
- 用于ECDSA签名生成和验签的证书（TODO：这个证书是干什么用的）
- Key Establishment(Key agreement)用证书（One-Pass Diffie-Hellman C(1e, 1s) scheme or with the Static Unified Model C(0e, 2s, ECC CDH) scheme）
- TLS证书

##### 9.2.6.6 Management of certificates

证书管理

###### 9.2.6.6.2 Provisioning servers with trust anchors

为服务器提供`信任锚`，需要再设备`正常运行前`导入`Root-CA,Sub-CA证书`或`直接信任的CA公钥`。可以有多个信任锚

信任锚的部署或替换是`带外操作`，out of band (`OOB`)

信任锚证书和其他证书`存储在一起`（TODO:这个是否有安全问题，比如windows有专门的受信任根证书区域，每个分类都有专属区域。）

可以`导出`，不能`导入或删除`（TODO:解释了上面的安全问题，是有防篡改保护的）

直接信任的CA公钥不能导出

###### 9.2.6.6.3 Provisioning the server with further CA certificates

为服务器提供`进一步的CA证书`（应该是Sub-CA，非信任锚）

“`Security setup`”对象中的`import_certificate`方法

导入的CA证书需要使用信任锚校验

###### 9.2.6.6.4 Security personalisation of the server

安全个性化导入非对称密钥：

- 通过设备商专有方式导入私钥和公钥证书
- “Security setup”相关函数产生
  
  ![messages](/assets/img/2022-03-17-dlms-green-1/mscpersonal.jpg)

  1. 客户端调用`generate_key_pair`方法。方法调用参数指定要生成的特定用途的`密钥对`:数字签名、密钥协商或TLS;
  2. 客户端调用`generate_certificate_request`方法。方法调用参数标识将为其生成证书签名请求(`CSR`)的密钥对。返回参数包括CSR，由新生成的密钥对的私钥签名;（TODO:CSR还要私钥签名吗）
  3. 客户端`向CA发送CSR`，该消息封装了调用generate_certificate_request方法得到的返回参数。CA(如果满足必要条件)`颁发`证书并将其发送给客户端;
  4. 客户端调用`import_certificate`方法。方法调用参数包含证书。服务器`验证`证书，如果成功，则将证书上的信息添加到certificates属性。如果验证失败，证书将被丢弃。

  导入新证书成功后，旧证书将被移除。

  使用服务器证书的`各方`可以通过以下方式`获得证书`:

  - 带外`out of band`;
  - 使用“`Security setup`”对象的`export_certificate`方法
  - 作为`AARE`的一部分(在`HLS认证`期间)

###### 9.2.6.6.5 Provisioning servers with certificates of clients and third parties

向服务器提供客户端和第三方证书

服务器要`验证数字签名`，要使用使用静态密钥协商密钥的方案执行`密钥协商`，或要`建立TLS连接`，`服务器`需要`对方`的适当`公钥证书`。

如果在制造时`已经知道`客户端和/或第三方，则制造商可以将其`公钥证书注入服务器`。

否则，可以使用“`Security setup`”对象的`import_certificate`方法为服务器提供客户端和第三方的证书。

###### 9.2.6.6.6 Provisioning clients and third parties with certificates of servers

向客户端和第三方提供服务器的证书

要`验证数字签名`，要使用使用静态密钥协商密钥的方案执行`密钥协商`，或要`建立TLS连接`，`客户端或第三方`需要`对方`的适当`公钥证书`。

证书可以随服务器一起交付，并插入到客户端/第三方OOB中。

或者，客户端或第三方可以使用“`Security setup`”对象的`export_certificate`方法从服务器请求证书。方法调用参数标识所请求的证书。

###### 9.2.6.6.7 Certificate removal from the server

从服务器上删除证书

当属于服务器的证书被删除时，与公钥相`关联的私钥`也应被`销毁`。

"`Security setup`"对象的`remove_certificate`方法用于删除证书

#### 9.2.7 Applying cryptographic protection

- 保护`xDLMS APDUs`参见9.2.7.2;
- 处理HLS认证期间的挑战信息`challenges`，见9.2.7.4;
- 保护`COSEM data`，参见9.2.7.5。

##### 9.2.7.2 Protecting xDLMS APDUs

本小节9.2.7.2指定了9.2.3.3和9.2.3.4中指定的加密算法如何用于保护xDLMS APDUs:

###### 9.2.7.2.2 Security policy and access rights values

![messages](/assets/img/2022-03-17-dlms-green-1/securitypolicy.jpg)

`access rights访问权限`由“`Association LN`”的 `object_list` 属性或“`Association SN`”对象的 `access_rights_list` 持有。access_rights的`access_mode`元素决定了访问类型并规定了密码保护。它是一个enum数据类型。

![messages](/assets/img/2022-03-17-dlms-green-1/accessright1.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/accessright2.jpg)

对 `COSEM对象` 属性 和/或 方法 的`访问权Access rights`可能要求对xDLMS APDUs进行 认证、加密 和/或 签名 。为此，只允许保护程度`超过或等于安全策略security policy`要求的APDUs。保护程度`低于安全策略和访问权限要求`的APDU应被`拒绝`。

在这种情况下，`更多的保护`是指在xDLMS APDU上应用比安全策略所要求的`更多种类`的保护：例如，安全策略security policy要求所有的APDU都经过`认证`，但访问权限Access rights要求APDU经过`加密和认证`，即更高的保护。

>(access rights是针对某个对象的特定属性或方法的，security policy是全局的，所以access rights可以比security policy更严格，而不能更宽松)

###### 9.2.7.2.3 Ciphered xDLMS APDUs

`加密的xDLMS APDUs`只能在加密的`应用程序上下文`中使用。另一方面，在加密的应用程序上下文中，可以同时使用`加密`和`未加密`的APDUs。

general-ded-ciphering  `dedicated` 专用的

general-glo-ciphering `global` 全局的

![messages](/assets/img/2022-03-17-dlms-green-1/cipheredxdlmsapdus.jpg)

###### 9.2.7.2.4 Encryption, authentication and compression

在`消息保护`的情况下，要保护的信息是`xDLMS APDU`。在COSEM`数据保护`的情况下，需要保护的信息是`COSEM data数据`，即`COSEM属性值`或`方法调用/返回参数`。

![messages](/assets/img/2022-03-17-dlms-green-1/aesgcmapdus.jpg)

- The security header

  SH = SC || IC

  ![messages](/assets/img/2022-03-17-dlms-green-1/securitycontrolbyte.jpg)

  - Bit 3…0: Security_Suite_Id, see 9.2.3.7;
  - Bit 4: “A” subfield: 是否认证
  - Bit 5: “E” subfield: 是否加密
  - Bit 6: Key_Set subfield:
  0 = Unicast, 1 = Broadcast;
  - Bit 7: 是否压缩

- Plaintext and Additional Authenticated Data

  plaintext, P

  Additional Authenticated Data, A

  security control byte, SC

  authentication key, AK

  information, I

  `P`是一个关于加密的`形参`，可以为I，如果不加密的话就是空的。

  根据SC的不同，AAD也会不同

- Encryption key and authentication key

- Initialization vector

- Service-specific ciphering xDLMS APDUs

  `Service-specific`区别于`general`，可以使用部分`变体`

  ![messages](/assets/img/2022-03-17-dlms-green-1/servicespecificapdus.jpg)

- The general-glo-ciphering and geneal-ded-ciphering xDLMS APDUs

  ![messages](/assets/img/2022-03-17-dlms-green-1/generalglocipher.jpg)

  The general-ciphering APDU可以用于客户端和服务器之间，也可以用于第三方和服务器之间。这些`APDU`还携带了所使用`密钥`的`必要信息`。

  ![messages](/assets/img/2022-03-17-dlms-green-1/generalcipher.jpg)

- Use of the fields of the ciphering xDLMS APDUs

- Encoding example: global-get-request xDLMS APDU

###### 9.2.7.2.5 Digital signature

![messages](/assets/img/2022-03-17-dlms-green-1/generalsign.jpg)

##### 9.2.7.3 Multi-layer protection by multiple parties

多重保护一般用于third party->client->server模型，即third party应用一层，client应用一层。

server需要根据请求的保护状态以及security policy and access rights要求的保护来保护数据

TODO:很难理解，需要实例。

##### 9.2.7.4 HLS authentication mechanisms

![messages](/assets/img/2022-03-17-dlms-green-1/dlmshlsauth.jpg)

需要提前知道对方的证书和systemtitle,不知道的话需要传递

见原文示例

##### 9.2.7.5 Protecting COSEM data

需要保护的数据列表、需要保护的对象和保护参数由“`Data protection`”对象决定。

### 9.3 DLMS/COSEM application layer service specification

#### 9.3.1 Service primitives and parameters

- `REQUEST`：请求原语从 N-用户传递到 N-层以请求启动服务；
- `INDICATION`：指示原语从 N-层传递给 N-用户，以指示对 N-用户重要的内部 N-层事件。 该事件可能逻辑上与远程服务请求有关，也可能是N-层内部的事件引起的；
- `RESPONSE`：响应原语从 N-用户传递到 N-层，以完成先前由指示原语调用的过程。
- `CONFIRM`：确认原语从 N-层传递给 N-用户，以传达一个或多个相关的先前服务请求的结果。

`（重要）命名规则`

#### 9.3.2 The COSEM-OPEN service

COSEM-OPEN服务的作用是在对端COSEM应用实体(AEs)之间建立AA。

![messages](/assets/img/2022-03-17-dlms-green-1/serviceparamopen.jpg)

> AA相关协商后参数，AL会保存，比如密钥、加密策略、是否使用GBT、最大接收PDU大小等，

使用ACSE的A-ASSOCIATE服务

- Protocol_Connection_Parameters

  强制。 它包含使用通信配置文件层所必需的所有信息，包括通信配置文件（协议）标识符和所需的地址。 它确定了 AA 的参与者。 该参数的元素被传递给管理低层连接的实体，并酌情传递给低层。

- ACSE_Protocol_Version

  可选参数。如果存在，则应使用缺省值。

- Application_Context_Name

  强制。在请求原语中，它持有客户端`提议`的值。在响应原语中，它保存相同的值或服务器`支持`的值。(类似于TLS握手中的加密策略，是一个需要`协商`的值)

- Called_AP_Title, Called_AE_Qualifier, Called_AP_Invocation
_Identifier, Called_AE_Invocation_Identifier

  可选

- Calling_AP_Title

  有条件的。当建议的`应用程序上下文`和/或建议的`HLS认证机制`要求使用`客户端system title`，并且在注册过程中尚未传输时，Calling_AP_Title应携带客户端system title。见4.3.4。

  TODO：注册过程是什么

- Calling_AE_Qualifier

  有条件的。当Application_Context_Name为加密的`应用上下文Application_Context_Name`时，可能携带客户端的公共数字签名密钥`证书`。

- Calling_AP_Invocation_Identifier

  可选。

- Calling_AE_Invocation_Identifier

  可选。携带AA的客户端用户的标识符。

- Local_or_Remote

  强制。接收到AARE APDU生成的确认就是Remote,本地确认就是Local

- Result

  强制。remote confirmation下为AA是否被接受，local confirmation下为本地低层协议栈是否接受请求

- Failure_Type

  强制。在远程确认的情况下，它携带服务器提供的信息。在局部和消极negative确认的情况下，表示失败的原因。

- Responding_AP_Title

  有条件的。当协商的应用程序上下文和/或协商的HLS认证机制要求使用服务器系统标题，并且在注册过程中尚未转移时，则Responding_AP_Title应携带服务器`系统标题system title`。

- Responding_AE_Qualifier

  有条件的。当Application_Context_Name为加密的应用上下文时，可能携带服务器的公共数字签名密钥`证书`。

- Responding_AP_Invocation_Identifier and Responding_AE_Invocation_Identifier

  可选

- ACSE_Requirements

  可选。用于选择认证功能单元。见9.4.2.1表格81。DLMS中的ACSE支持的Authentication功能模块（还有一个是kernel模块）为AARQ添加了一些参数

  - Lowest Level Security:无此参数
  - LLS：.request有，.response可能有
  - HLS: .request和.response都有

- Security_Mechanism_Name

  有条件的。

- The Calling_Authentication_Value、the Responding_Authentication_Value

  有条件的。

- Implementation_Information

  可选的

- Proposed_xDLMS_Context

  xDLMS_Context建议值。包含在`AARQ` APDU中的`user-information`中的xDLMS InitiateRequest APDU中

- Negotiated_xDLMS_Context

  服务端接受Proposed_xDLMS_Context建议后回复。包含在`AARE` APDU中的`user-information`中的xDLMS InitiateRequest APDU中

- xDLMS_Initiate_Error

  服务端不接受Proposed_xDLMS_Context建议，回复。包含在`AARE` APDU中的`user-information`中的xDLMS InitiateRequest APDU中

- `User_Information`

  > 请不要将COSEM-OPEN服务的`User_Information`参数与AARQ / AARE apdu的`user-information`字段`混淆`。

- Service_Class

  强制的。指示服务是`confirmed`还是`unconfirmed`

##### 9.3.2.3 Use

![messages](/assets/img/2022-03-17-dlms-green-1/timeseq.jpg)

- confirmed AA -- `a`
- unconfirmed AA -- `b`
- pre-established AA -- `c`

原语发生在AP和AL之间，

#### 9.3.3 The COSEM-RELEASE service

`优雅释放`已经存在的AA

调用它的方式（`Use_RLRQ_RLRE`参数）决定了它是否使用ACSE的`A-RELEASE`服务。

如果Use_RLRQ_RLRE为FALSE，则AL层不能使用A-RELEASE服务中的`RLRQ和RLRE`（和AARQ/AARE相对，见9.4.2.1），也就不能使用RLRQ/RLRE断链。可以通过断开支持层的方式断链

#### 9.3.4 The COSEM-ABORT service

指示支持协议层的主动断开,只有COSEM-ABORT.indication原语，，对应上图中的`e`情况

COSEM-ABORT.indication原语在客户端和服务器端`本地生成`，以指示COSEM AP下层连接以`非请求`的方式`关闭`。

此类事件的起因可以是一个`外部事件`(例如物理线路断线)，或者在一些配置文件中出现的一个`支持协议层连接管理器AP`(`层管理AP`，非COSEM AP)的动作，当支持的协议层连接不是由DLMS/COSEM AL管理时。这将导致COSEM AP`中止`任何现有的AA，除了在服务器端预连接AA。

#### 9.3.5 Protection and general block transfer parameters

![messages](/assets/img/2022-03-17-dlms-green-1/protectiongbtparams.jpg)

`Additional_Service_Parameters`仅在使用`加密`或`GBT`时存在。

- Invocation_Type:`COMPLETE`, `FIRST-PART`, `ONE-PART` and `LAST-PART`

[x]TODO:`重要！`这里又提到了Partial service invocations，就是用FIRST-PART之类的分包，属于可选的Additional_Service_Parameters参数，与GET之类的原语的service-specific block transfer不一样，和general block transfer（GBT）又不一样，那这三种分包方式可以同时存在吗 更新：1.Invocation_Type的分包是针对本地AL和本地AP之间的，可能是用于AL接受缓存或AP发送缓存不够的情况。2.service-specific block transfer是针对本地AP和对端AP之间的，用于解决超过AP接受或发送缓存的情况，这时候还没有APDU,数据仅仅是原语的参数 3.GBT是本地AL和对端AL之间的，这时候分割的APDU，用于APDU过大的情况

`Partial service invocations`在接收端时，AL需要判断是否可以划分PART，比如，因为GBT是流的形式传输，接收到的包都是按照字节分割的，所以接收端APDU需要判断是否可以完整解密、是否可以组成原语（如ACTION-LIST，见9.3.8和Figure 149，属性列表在前，参数列表在后，需要收全后才能组成原语），然后才能划分PART。

Block_Transfer_Streaming指示是否允许AL使用流（GBT），见9.4.6.13

Block_Transfer_Window指示最大接受窗口大小

#### 9.3.6 The GET service

其功能是`读取`一个或多个COSEM对象属性的值。结果可以在`单个响应`中交付，或者(如果它太长，不能在单个响应中交付)在`多个响应`中交付，使用`块传输`（没有指定是那种类型的块传输）。

![messages](/assets/img/2022-03-17-dlms-green-1/getparams.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/getreqtype.jpg)

两个优先级normal (FALSE) or high (TRUE).

如果是Request_Type=NEXT就不用带COSEM_Attribute_Descriptor

REQUEST-WITH-LIST会带多个COSEM_Attribute_Descriptor，但不能超过server-max-receive-pdu-size。`原则：GET.request服务原语必须包含在单个APDU中,所以不能用分BLOCK方式发请求`

整个`响应`单个APDU`放得下`就用Response_Type == NORMAL or WITH-LIST，`放不下`就用Response_Type == `ONE-BLOCK`，最后一包用LAST-BLOCK

COSEM_Object_Attribute_Id == 0 (`Attribute_0`)的情况，表示读取`所有的属性`，返回一个包含所有数据的`结构体`，没权限的或访问出错的回null-data（TODO:这里是用NORMAL还是 WITH-LIST，我觉得是NORMAL，返回的是一个结构体，包含所有数据，而不是LIST）

- successful confirmed GET -- `a`
- unconfirmed GET -- `d`
- unsuccessful attempt due to a local error -- `c`

> 重要：关于`编解码`，AP层并不负责对APDU的编解码（比如A-XDR编码），对于AL层原语的调用（如COSEM-OPEN、GET等），传递的只是参数（或者叫变量），关于参数的格式和定义就是设计的问题了（可以使用编程语言的基本变量类型或自定义变量类型）。
>
> `Table 60`中包含了原语的很多参数，但只有`部分`是需要被包含进`最终的APDU`中的，所以AP编解码本身就解释不通，否则AL需要再进行解码再封装，多此一举。其中Result中的`Data`是一个`octet-string格式`的参数，其内部的值已经是编完码的了，因为Data编解码是业务层蓝皮书的部分，需要AP来进行，但这里仅仅作为一个octet-string类型的变量，和AP不对整个APDU进行编码的观点不冲突。AL属于绿皮书范畴，是通信的协议层，APDU是作为通信载体，应该属于绿皮书范畴，所以需要AL层编解码

#### 9.3.7 The SET service

写入一个或多个COSEM对象属性的值。要写入的数据可以在单个请求中发送，或者(如果数据太长，不能在单个请求中发送)在`多个请求`中使用`块传输`。(不同于GET，SET请求可以分包)

![messages](/assets/img/2022-03-17-dlms-green-1/setparams.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/setreqtype.jpg)

仅Request_Type == NORMAL, FIRST-BLOCK, WITH-LIST and FIRST-BLOCK-WITH-LIST携带COSEM_Attribute_Descriptor

响应不能分包

COSEM_Object_Attribute_Id == 0 (`Attribute_0`)的情况，同GET，需要SET请求包含有`全部公开属性`的Data值的`结构体`。Result将携带一个结果，如果写入了`所有属性`则为`成功`，或者只有一个`失败原因`。(TODO:部分成功的情况呢)

- successful confirmed SET -- `a`
- unconfirmed SET -- `d`
- unsuccessful attempt due to a local error -- `c`

#### 9.3.8 The ACTION service

调用一个或多个COSEM对象方法

请求响应都能分包,需要请求`完整发完`，响应才开始分包发送结果

![messages](/assets/img/2022-03-17-dlms-green-1/actionparams.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/actionreqtypes.jpg)

`第一阶段`：client AP向AL发送ACTION.request，server的AL收到后向AP发送ACTION.indication，server AP回ACTION.response，ACTION.confirm由AL发送给client AP,都是可以是分包的。直到收到完整的请求（LAST-BLOCK发送后）。

`第二阶段`：开始执行方法，执行完后返回结果，可以分包

#### 9.3.9 The ACCESS service

使用一个.request / .response访问（access）`多个`COSEM对象属性和/或方法，包括GET / SET / ACTION的组合

ACCESS好像就是DSMR里的COSEM-ACCESS

`Long_Invoke_Id`，区别于上面的Invoke_Id

`自描述响应`，不仅包含结果data，也包含请求参数，可以不依赖于对应的请求直接解析响应。可选。

对于GET，Access_Request_List_Of_Data中也包括data,对于GET就是null-data，需要由响应填充

可以带`时间戳`，表示.request和.response调用时间，降低消耗（TODO:为什么可以降低消耗）

支持list访问，Access_Request_Specification作为数组可以有多个元素

##### 9.3.9.2 Service specification

![messages](/assets/img/2022-03-17-dlms-green-1/accessparams.jpg)

Access_Request_Specification:

- Access_Request_Get 不带选择性访问参数
- Access_Request_Set 不带选择性访问参数
- Access_Request_Action
- Access_Request_Get_With_Selection 带选择性访问参数，不能用于Attribute_0情况
- Access_Request_Set_With_Selection 带选择性访问参数，不能用于Attribute_0情况

优先判断result，如果result失败直接丢弃data。

#### 9.3.10 The DataNotification service

数据推送

unsolicited未经请求, unconfirmed无需确认 或 confirmed需确认

request支持分块传输

![m esages](/assets/img/2022-03-17-dlms-green-1/datanotiparams.jpg)

Confirmed：收到Data-Notification-Confirm APDU

Unconfirmed：收到支持层确认

服务原语通信模型：Figure 112 a), b) and d).

TODO:这里的d是什么情况，按照描述，Unconfirmed也需要支持层响应

#### 9.3.11 The EventNotification service

unconfirmed无需确认

request支持分块传输

![messages](/assets/img/2022-03-17-dlms-green-1/eventnotiparams.jpg)

Application_Addresses:可选，如果`没有`相应的`AA`，则包含全部识别信息(也就是允许没有AA的情况上报)

服务原语通信模型：Figure 112 f), g)

#### 9.3.12 The TriggerEventNotificationSending service

EventNotification的触发服务，由客户端发起，用于EventNotification不能自动触发的情况。

不需要AA

#### 9.3.13 Variable access specification

#### 9.3.14 The Read service

#### 9.3.15 The Write service

#### 9.3.16 The UnconfirmedWrite service

#### 9.3.17 The InformationReport service

#### 9.3.18 Client side layer management services: the SetMapperTable.request

有关SN的跳过

### 9.4 DLMS/COSEM application layer protocol specification

#### 9.4.1 The control function (CF)

##### 9.4.1.1 State definitions of the client side control function

![messages](/assets/img/2022-03-17-dlms-green-1/clientcfstatemachine.jpg)

带`/`的表示`过程`，也就是在转换过程中发生的，不带`/`的表示状态转换触发的`起点`。(可以这么理解，左右两个pending就是`中间态`，而IDLE和ASSOCIATED是`起始态`，从起始触发的就是不带`/`的)

##### 9.4.1.2 State definitions of the server side control function

![messages](/assets/img/2022-03-17-dlms-green-1/servercfstatemachine.jpg)

TODO:图上的EventNotification.reg单词拼错了，应该是req

#### 9.4.2 The ACSE services and APDUs

##### 9.4.2.1 ACSE functional units, services and service parameters

DLMS/COSEM AL ACSE基于IEC标准中的connection-oriented ACSE

支持`Kernel`、`Authentication`两个功能模块

AARQ和AARE中的`acse-requirements`(见9.3.2)参数用于选择功能模块启用

见文中Table 81

AARQ APDU由COSEM-OPEN.request原语决定，AARE APDU由COSEM-OPEN.response原语决定

各个参数：

TODO:用到的时候补充下

- `user-information`:AARQ APDU中携带`xDLMS InitiateRequest APDU`包含Proposed_xDLMS_Context参数。AARE APDU中携带an xDLMS InitiateResponse APDU包含Negotiated_xDLMS_Context参数

##### 9.4.2.2 Registered COSEM names

TODO:看不太懂

- COSEM_Application_Context_Name
- COSEM_Authentication_Mechanism_Name
- COSEM_Cryptographic_Algorithm_Id

#### 9.4.3 APDU encoding rules

##### 9.4.3.1 Encoding of the ACSE APDUs

`ACSE` APDUs编码：`BER`

`user-information`内的内容因为是`xDLMS`格式的，所以需要用`A-XDR`编码

##### 9.4.3.2 Encoding of the xDLMS APDUs

`xDLMS` APDUs编码：`A-XDR`

##### 9.4.3.3 XML

DataNotification APDU可以编码为XML格式。

#### 9.4.4 Protocol for application association establishment

##### 9.4.4.1 Protocol for the establishment of confirmed application associations

client AP发送`COSEM-OPEN.request`原语（Service_Class == Confirmed），client `CF`（control function）进入`ASSOCIATION PENDING`状态（见9.4.1），

然后，`CF` 在 `xDLMS ASE` 和 `ACSE` 的帮助下`组装`包含从 AP 接收的 COSEM-OPEN.request 原语参数的 `AARQ APDU`，并将其`发送`到服务器。

> `xDLMS ASE`是InitiateRequest APDU打包器（只和xDLMS相关，就是AARQ中的`user-information`），`ACSE`是AARQ APDU打包器（ACSE中的`Kernel`和`authentication` functional相关的参数,见9.4.2.1）

`服务器` AL 的 `CF` 将收到的 AARQ APDU 提供给 `ACSE`, ACSE提取 `ACSE` 相关参数，然后将`控制权`交还给 CF。

然后，`CF` 将 AARQ APDU 的用户信息参数的内容（携带 xDLMS InitiateRequest APDU）传递给 `xDLMS ASE`,xDLMS ASE检索此 APDU 的参数，然后将`控制权`交还给 CF。

CF 使用收到的 APDU 参数生成 COSEM-OPEN.indication 给服务器 AP ，并进入“`ASSOCIATION PENDING`”状态。

![messages](/assets/img/2022-03-17-dlms-green-1/mscaa.jpg)

> 总结：先xDLMS ASE层打包，再ACSE层打包，得到AARQ APDU。AARQ APDU先ACSE层解包，再xDLMS ASE层解包

##### 9.4.4.2 Repeated COSEM-OPEN service invocations

AA已经存在时，client AP发的COSEM-OPEN.request直接由client AL回应确认

##### 9.4.4.3 Establishment of unconfirmed application associations

Service_Class == Unconfirmed

本地AL不等待回应直接回.confirm

一般用于单向通信或广播

无需确认AA中只能使用无需确认xDLMS数据传输服务

##### 9.4.4.4 Pre-established application associations

无需AA建立和释放

#### 9.4.5 Protocol for application association release

- 优雅graceful方式
  - 断开AL的支持协议层

    前提是`面向连接`的协议层（HDLC,TCP）

    the COSEM-RELEASE，`Use_RLRQ_RLRE`参数`不存在`或为`FALSE`(就是不使用ACSE的`A-RELEASE`服务，见9.3.3)

    ![messages](/assets/img/2022-03-17-dlms-green-1/releaseaaspl.jpg)

  - 使用ACSE A-Release服务

    `Use_RLRQ_RLRE`参数为`TRUE`（就是使用ACSE的`A-RELEASE`服务），COSEM-RELEASE服务可以包含`加密的`xDLMS InitiateRequest / InitiateResponse在RLRQ / RLRE APDUs的`user-information`参数中，从而防止潜在的`拒绝服务攻击`(没有保护的话谁都可以断开连接)。

    ![messages](/assets/img/2022-03-17-dlms-green-1/releaseaa.jpg)

- 非优雅Non-graceful方式

  当AP发生意外事件(如检测到物理连接中断)时，检测本地错误，等等

  ![messages](/assets/img/2022-03-17-dlms-green-1/phabort.jpg)

#### 9.4.6 Protocol for the data transfer services

##### 9.4.6.1 Negotiation of services and options – the conformance block

一致性块，用于协商双方支持的功能

`COSEM-OPEN`服务中：xDLMS InitiateRequest APDU中的`proposed-conformance`参数和xDLMS InitiateResponse APDU中的`negotiated-conformance`

![messages](/assets/img/2022-03-17-dlms-green-1/conformanceblock.jpg)

> 图中提到了只有get、set、action可以配置为使用block-transfer,应该就是service-specific block transfer，和9.4.6.6 ACCESS服务不支持service-specific block transfer相符

##### 9.4.6.2 Confirmed and unconfirmed xDLMS service invocations

- client发起：

  - 在`confirmed`的AAs中

    可以以confirmed or unconfirmed的方式调用xDLMS服务。

  - 在`unconfirmed`的AAs中

    只能以unconfirmed的方式调用xDLMS服务。这样，在多播 和/或 广播的情况下，由于潜在的`多重响应`而产生的`冲突`可以避免。

    `unconfirmed` xDLMS services三种`目的地址`：

    - 单个地址
    - 组地址
    - 广播地址

  如果AA没建立，服务端会丢弃unconfirmed请求。

- 服务端发起：

  unsolicited services：

  - InformationReport;

    只能以unconfirmed方式调用
  - EventNotification;

    只能以unconfirmed方式调用
  - DataNotification.

    1)unconfirmed，支持协议层失败重试;
    2)unconfirmed，丢失支持协议层确认重试;
    3)confirmed，丢失确认重试

    详见9.4.6.7

##### 9.4.6.3 Protocol for the GET service

有多个属性的情况下，每个属性都要回对应的Data或Data_Access_Result

通过`conformance block`协商在`APDU过长`时是否使用`GBT`或`service-specific block transfer`

![messages](/assets/img/2022-03-17-dlms-green-1/getprotocol.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/getprotoblock.jpg)

结合9.3.6对GET的说明，AP负责Data的`编解码`，同时可以对`Data进行分块`，也就是service-specific block transfer的基础。其中分块可以是`按字节`不按逻辑分，也可以`按逻辑`分(每块都能自解析)。这样的话服务端就可以`分段生成回复`，对于已经发送的块可以释放内存，`减少内存占用`

- 发送接收流程：

  第一个.response的DataBlock_G(见9.3.7)：

  - Last_Block == FALSE;
  - Block_Number  == 1;
  - Result (Raw_Data) == the first K bytes of the encoded data: B1, B2, B3,…., BK.

  客户端AP继续发送GET-REQUEST-NEXT,`Block_Number`和`上一次`接受到的回复`相同`，也就是1（可以理解为客户端确认序号，表示1已确认）。服务端AP收到请求后继续发Block_Number为2的块

- 各种错误处理

![messages](/assets/img/2022-03-17-dlms-green-1/getprotolongerror.jpg)

NEXT请求序号与上一条回应序号不匹配

##### 9.4.6.4 Protocol for the SET service

类似GET

即使分包，每一包的Invoke_Id和Priority必须是一样的，因为是同一个请求

多了ACK-BLOCK，用于中间块的接收响应

各种错误处理

##### 9.4.6.5 Protocol for the ACTION service

请求响应都能分包，请求发完，再由响应分包。

##### 9.4.6.6 Protocol for the ACCESS service

[x]TODO:ACCESS是不支持service-specific block transfer吗，文中只给了GBT的例子，没有 更新：见9.4.6.1，一致性块不包含，不支持

![messages](/assets/img/2022-03-17-dlms-green-1/accessprotogbt.jpg)

图中的FIRST和LAST应该是`partial service invocations`部分服务调用（FIRST-PART,LAST-PART），不是service-specific block transfer

[x]TODO:在这个例子中为什么客户端AL可以在不知道对方接收窗口的情况下发送W=3的GBT，如果按照AL层的GBT参数必须由AP提供来看应该是错误的 更新：图片前有条件说明，Both parties know a priori that the other party supports streaming with window size = 3,已经知道是三个包

> 有个要注意的是对于`GET\SET\ACTION\ACCESS`,`客户端`总是作为`主动方`，也就是管理重发的角色。服务端发出去的都不需要客户端回确认，超时也不重发

##### 9.4.6.7 Protocol of the DataNotification service

可以使用`partial service invocations`

可以使用GBT

DataNotification.request原语的`Service_Class`参数：

- unconfirmed，支持协议层回错误（及时）时重发

  ![messages](/assets/img/2022-03-17-dlms-green-1/datanotimsc.jpg)

- unconfirmed，支持协议层超时未回应时重发

  AP超时未收到回应直接进重发模式，开始重发等待，此时支持协议层返回的信息都忽略，不管成功还是失败，

- confirmed，未收到确认超时时重发

  总是忽视本地确认，未收到远程AP确认前总是重发

##### 9.4.6.8 Protocol for the EventNotification service

详见10

##### 9.4.6.9 Protocol for the Read service

##### 9.4.6.10 Protocol for the Write service

##### 9.4.6.11 Protocol for the UnconfirmedWrite service

##### 9.4.6.12 Protocol for the InformationReport service

SN相关的跳过

##### 9.4.6.13 Protocol of general block transfer mechanism

`block transfer块传输总结`：

1. Partial service invocations，9.3.5
2. service-specific block transfer，9.3.5，一般用于每包都独立，可以自解析的情况
3. general block transfer，由AP提供窗口和流参数，但如果没有参数会不会也触发GBT有待讨论.AA握手时AL会保存相关参数，见9.3.2.2 table 54

由AL层实现，使用`General-Block-Transfer (GBT) xDLMS APDUs`传输`任意长度APDUs`

AL收到AP层.request / .response服务原语：

- 打包APDU
- 根据Security_Options打包加密APDU
- 如果大于协商的最大APDU大小，使用GBT分包

> 区别于AP层的`partial service invocations部分服务调用`(9.3.5)，这个`GBT`是针对APDU的，两者没有直接关系

![messages](/assets/img/2022-03-17-dlms-green-1/partialandgbt.jpg)

原语参数：

- Block_Transfer_Streaming (`BTS`):用于AP指示AL是否可以用`流方式`(窗口)发送，（窗口的意思就是每发若干个包确认一次，结合BTW若为0，表示无需确认，若为1，表示1个包确认一次）

- Block_Transfer_Window (`BTW`)：用于AP指示AL`最大流窗口大小`，但最终由AL决定，AL可以设置的很小用于传输丢失包。

`unconfirmed services`固定Block_Transfer_Streaming为`FALSE`，以及Block_Transfer_Window为`0`.类似UDP，可以尽可能的发，无需对方AL层确认

GBT APDU字段：

- the last-block (`LB`) ：是(LB = TRUE(1))否最后一包
- streaming(`STR`) :对于一个窗口，在过程中(STR = TRUE(1))还是已结束(STR = FALSE(0)，一个窗口内的`最后一包`)。如果是已结束，需要`对方`回个`确认`，这个确认是对这个窗口的，如果是完整APDU的最后一包则`不回`(`最后一个窗口不确认`)（[x]TODO:怎么判断收全了 更新：通过发送权思路，就是谁是主动方，谁负责报文的送达确认，这里接受方是主动方，如果没收全，会在超时时重发请求，发送端无需保证自己的报文送达）
- `window`：发送该APDU的一方的`接收窗口大小`，发送`unconfirmed services`时为0
- block-number (`BN`)：`block序号`，第一个为1(TODO:具体什么时候开始重新计数)
- block-number-acknowledged (`BNA`)：`被确认`块号，最后一个`连续的`被确认的块的`块号`（这个块之前的所有块也要已经被确认。这个是用于指示对方发送的块的确认，表明自己已确认）
- block-data (`BD`):数据域，xDLMS APDU的一部分

###### 9.4.6.13.2 The GBT procedure

子过程：

- **9.4.6.13.4 Send GBT APDU stream**
  
  ![messages](/assets/img/2022-03-17-dlms-green-1/sendgbtapdustream.jpg)

  - Confirmed GBT stream send

    AP调用原语参数`BTW`要大于0，SQ为空时填充一个空的block,NextBN递增

    TODO:9.4.6.13.4.3.1 If the SQ is empty, an empty block is added to the SQ and Nex tBN is incremented.为什么要加入空的block,这个空的好像是确认包

    Gs.LB = B.LB, Gs.STR = STRself, Gs.W = Wself, Gs.BN = B.BN, Gs.BNA = BNAself and Gs.BD = B.BD

    被确认后才能从SQ删除，最后一包不需要对方确认，所以不能直接从SQ中删除。TODO:应该什么时候删除，文中也没说，是否是超时
  - Unconfirmed GBT send

    AP调用原语参数`BTW`要等于0

    发完就清SQ，不用确认
- **9.4.6.13.5 Process GBT APDU sub-procedure**
  
  ![messages](/assets/img/2022-03-17-dlms-green-1/processgbt.jpg)

  - confirmed GBT procedure

    TODO:为什么RQ数量=BTW就结束了？
  - unconfirmed GBT procedure

    TODO:If the number of the blocks in the RQ reaches the maximum number of blocks that can be accommodated, then the stream is considered to be finished.接收上限是多少
  
- **9.4.6.13.6 Check RQ and fill gaps**

  ![messages](/assets/img/2022-03-17-dlms-green-1/checkrqandfile.jpg)

  用于检查是否丢包，以及是否要求重传

349页-`Send Queue SQ`：发送队列，对于block

  每收到`AP调用原语`，(和partial service invocations无关，不管Invocation_Type参数为COMPLETE, FIRST-PART, ONE-PART or LAST-PART等)，就分成一个或多个blocks放进SQ中

  对于SQ内blocks的发送是个流过程（TODO:意思是不是已经和调用原语无关了 更新：与调用原语无关，也就是和partial service invocations无关）

349页-`Receive Queue RQ`：接收队列，对于block

![messages](/assets/img/2022-03-17-dlms-green-1/gbtprocedure.jpg)

gaps的意思是空闲空间，就是RQ中待填充空间。填充完成后还有gaps，那就是有丢包，有丢包要补包

###### 9.4.6.13.3 GBT procedure state variables

![messages](/assets/img/2022-03-17-dlms-green-1/gbtprocedurestate.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/gbtprocedurestate2.jpg)

- `Gr`: 接收到的`对方参数`
- `Gs`: 发送的`自己的参数`
- `BNApeer`：自己的发送被对方确认的数量，（被Gr.BNA修改）
- `BNAself`：对方的发送被自己确认的数量，（发给对方）
- `NextBN`：自己SQ发送队列的下个插入序号，（插入SQ时递增）
- `STRpeer`：对方是否支持GBT流，（被Gr.STR修改）
- `STRself`：自己是否支持GBT流，（被本地AP修改）
- `Wpeer`：对方接收窗口大小，（被Gr.W修改）
- `Wself`：自己接收窗口的大小，（被本地AP修改）

[x]TODO:其中Wself有默认值，是不是不需要AP提供，也可以有默认值 更新：有默认值的参数不需要AP提供也能使用，初始值就是默认值

###### 9.4.6.13.7 GBT protocol examples

![messages](/assets/img/2022-03-17-dlms-green-1/getwithgbt.jpg)

[x]TODO:图里的GET.cnf NORMAL(FIRST-PART)是否是一种AL向AP请求GBT参数的机制，前提是AL不知道相关的参数，所以GET.req NORMAL(COMPLETE)其实是个空的报文？结合9.3.5 Additional service parameters，这个参数是否应该在这个原语里携带。更新：the client AP invokes a GET.request NORMAL service primitive, without additional service parameters. The client AL sends the request in a Get-Request-Normal APDU明确提到了GET相关原语可以携带Additional service parameters

![messages](/assets/img/2022-03-17-dlms-green-1/getservicewithpartial.jpg)

可以只补单个包，此时请求的W置1，BNA置3，表示窗口大小变为1，就是单个确认。然后BNA为3表示让对方补第4个包。

[x]TODO:如果4、5两包都丢了，是不是就是先补4，再补5，不会两包一起补。更新：如果4、5丢了，就W置2，BNA置3，可以表示丢了连续的两个包

如果是最后一包LB=1的丢了，由客户端请求这一包

![messages](/assets/img/2022-03-17-dlms-green-1/setgbt.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/actionlistgbt.jpg)

[x]TODO:为什么Action-Request-With-List收到一半，服务端就可以回Action-Response-With-List 更新：应该是一个错误，没有收全时是无法回复完整的，这里回个确认（空BD）比较合理

![messages](/assets/img/2022-03-17-dlms-green-1/unconfirmeddatanoti.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/confirmeddatanoti.jpg)

###### 9.4.6.13.8 Aborting the GBT procedure

终止条件：

1. an ABORT GBT APDU with LB = 1, STR = FALSE, `BN = 0` and BNA = 0;
2. 开始新的GBT过程。收到BN = 1 and BNA = 0;
3. 收到APDU而不是GBT
4. confirmed服务超时未收到确认

##### 9.4.6.14 Protocol of exception mechanism

exception-response APDU回应GET, SET, ACTION and ACCESS services表示无法处理的错误

[x]TODO:错误是AL层直接打包还是AP层来通知的 更新：结合上下文，是AL层生成的

### 9.5 Abstract syntax of COSEM PDUs

### 9.6 COSEM PDU XML schema

## 10 Using the DLMS/COSEM application layer in various communications profiles

### 10.1 Communication profile specific elements

在DLMS/COSEM中，只有`COSEM-OPEN`服务具有特定的通信配置文件`参数`。它们的值和用途被定义为通信概要文件规范的一部分。

### 10.2 The 3-layer, connection-oriented, HDLC based ommunication profile

#### 10.2.2 The structure of the profile

- 应用层：DLMS/COSEM AL，章节9
- 链路层：基于HDLC标准的，章节8
- 物理层： 章节5，光口和本地回环物理接口见章节6

#### 10.2.3 Identification and addressing scheme

Data Link SAP-s提供服务给AL

客户端：只要定义客户端AP，物理地址由PhL层填充

服务端：因为多点网络寻址的原因，所以目的地址需要物理设备地址加上逻辑设备地址。

![messages](/assets/img/2022-03-17-dlms-green-1/hdlcprofile.jpg)

例子：Client_01 (HDLC address = 16) and Server 2 in Host Device 02 (HDLC address = 2392)，客户端地址为16，服务端地址为2392，23为upper地址，92为lower地址

#### 10.2.4 Supporting protocol layer services and service mapping

- DL层连接管理
- 面向连接数据传输
- 无连接数据传输

![messages](/assets/img/2022-03-17-dlms-green-1/datalinksummary.jpg)

DL-CONNECT和DL-DISCONNECT也是由AL管理的，用于AL在收到COSEM-OPEN.request调用时开启DL连接，PhL层的连接是AP管理的，不是DL层管理的

#### 10.2.5 Communication profile specific service parameters of the DLMS/COSEM AL services

COSEM-OPEN携带Communication profile的参数

• Protocol (Profile) Identifier   3-Layer, connection-oriented, HDLC based;
• Server_Lower_MAC_Address    (COSEM Physical Device Address);
• Server_Upper_MAC_Address    (COSEM Logical Device Address);
• Client_MAC_Address;
• Server_LLC_Address;
• Client_LLC_Address.

> 也就是HDLC及PhL的地址也是AP管理的

#### 10.2.6 Specific considerations / constraints

##### 10.2.6.1 Confirmed and unconfirmed AAs and data transfer service invocations, frame types used

![messages](/assets/img/2022-03-17-dlms-green-1/aahdlcprofile.jpg)

Confirmed AARQ用I帧携带

Unconfirmed AARQ用UI帧携带

当通过网关访问服务端时，COSEM APDUs总是使用`I帧`携带，包括Unconfirmed的APDU也是，此时服务端必须通过xDLMS InitiateRequest APDU的`response-allowed`（见9.4.2.1）或Invoke-Id-And-Priority / Long-Invoke-Id-And-Priority的`service-class` bit（用于指示是否为confirmed见381页）判断请求是否是Unconfirmed,

##### 10.2.6.2 Correspondence between AAs and data link layer connections, releasing AAs

`释放AA连接`的方式是`A-RELEASE服务`或`断开支持层连接`，因为本配置文件不需要任何下层连接，所以断开支持层连接方式不可用，如果A-RELEASE服务也不支持，就没有别的方式释放连接

##### 10.2.6.3 Service parameters of the COSEM-OPEN / -RELEASE / -ABORT services

由于`SNRM`和`DISC`可以透明传输高层参数，COSEM-OPEN和COSEM-RELEASE中的`User_Information`将会可用

##### 10.2.6.4 EventNotification service and protocol

事件上报时，服务端角色为Management Logical Device（upper HDLC地址0x01）,客户端角色为Management AP（upper HDLC地址0x01）

使用UI帧发送，发送机会在8.4.5.4.7说明了

![messages](/assets/img/2022-03-17-dlms-green-1/eventnotificationtrigger.jpg)

当`客户端`检测到一个成功的`物理连接建立`——并且没有其他原因接收一个传入的调用——它就`假定`这个调用是由打算发送`事件通知`请求APDU的服务器发起的。

客户端必须首先使用第5章中描述的`可选协议识别服务`读取通信协议栈

客户端发起TriggerEventNotificationSending .request原语，发送UI帧交出发送权，此时服务端才能上报

##### 10.2.6.5 Transporting long messages

使用I_FRAGMENT，传输长消息，见8.4.5.4.5

##### 10.2.6.6 Supporting multi-drop configurations

![messages](/assets/img/2022-03-17-dlms-green-1/multidropconfi.jpg)

可以视为逻辑总线

冲突避免一般使用主从模型，由主站控制发送权限

上报时可能多个设备同时上报，需要解决两个问题：

- 总线上的冲突，冲突在物理层体现，由厂家解决（可以用CSMA之类的）
- 客户端不知道需要上报服务端的物理地址时，目的地址可以使用CALLING Physical Device Address（只有要上报的客户端才会接受这个地址）

### 10.3 The TCP-UDP/IP based communication profiles (COSEM_on_IP)

COSEM物理设备通过IP地址唯一标识，区别于HDLC地址。逻辑设备AP识别需要额外的地址，由wrap层提供，wPort。AL只监听一个TCP/UDP端口。

![messages](/assets/img/2022-03-17-dlms-green-1/tcpprofile.jpg)

TCP TL层提供的服务：

- TCP connection manager AP:

  - TCP-CONNECT.request, .indication, .response, .confirm;
  - TCP-DISCONNECT.request, .indication, .response, .confirm;

- DLMS/COSEM AL:

  - TCP-DATA .request, .indication, (. confirm).

UDP TL层提供的服务：

- DLMS/COSEM AL:

  - UDP-DATA .request, .indication, (.confirm)

TCP连接的建立是独立于DLMS/COSEM AP的。

AP能够在COSEM-OPEN前向TCP管理AP获取参数

![messages](/assets/img/2022-03-17-dlms-green-1/tcpudplayerservice.jpg)

Protocol_Connection_Parameters：

- Protocol (Profile) Identifier -- TCP/IP or UDP/IP;
- Server_IP_Address -- COSEM Physical Device Address;
- Server_TCP_or_UDP_Port -- The TCP or UDP port used for DLMS/COSEM, see 7.2;
- Server_Wrapper_Port -- COSEM Logical Device Address;
- Client_IP_Address -- COSEM Client’s Physical Device Address;
- Client_TCP_or_UDP_Port -- The TCP or UDP port used for DLMS/COSEM, see 7.2;
- Client_Wrapper_Port -- COSEM application process (type) identifier.

#### 10.3.6 Specific considerations / constraints

![messages](/assets/img/2022-03-17-dlms-green-1/tcpudpprofile.jpg)

TCP不支持使用Unconfirmed AA,因为TCP不支持无连接访问，而Unconfirmed AA需要支持在不建立`支持层连接`情况下发送数据。两者矛盾

**释放AA只能使用RLRQ/RLRE，不能使用通过断开支持层方式**，因为一个TCP/UDP端口`承载所有AA`，一旦断开，`所有AA`都会断开，必须通过RLRQ/RLRE有选择的断开。还有UDP是`无连接`的，不能通过断开支持层连接`断开`AA

User_Information不可用

##### 10.3.6.6 Transporting long messages

`wrapper层`需要包含`完整APDU`。如需分块在AL层分块。

（就是AL调用wrapper服务时不支持分块）

##### 10.3.6.7 Allowing COSEM servers to establish the TCP connection

服务端发起TCP连接，长连接模式，适用于服务端没有公开地址可以连接时。

### 10.4 The CoAP based communication profile (DLMS/COSEM_on_CoAP)

![messages](/assets/img/2022-03-17-dlms-green-1/coapprofile.jpg)

CoAP可以提供可靠和不可靠服务

CoAP支持`分段`，合理分段后就不用`IP层`再根据MTU`分片`了，详见文章[动图图解！既然IP层会分片，为什么TCP层也还要分段？](https://zhuanlan.zhihu.com/p/378153230)。AL也支持引用层的分块传输，根据对方AL层支持的接收大小receiver_max_pdu_size

TODO:TCP/UDP IP通信配置里好像没用到UDP支持广播的特性，可能是UDP广播只能在本地局域网中进行，不能跨路由器进行的原因

#### 10.4.3 Identification and addressing

CoAP URI：Uri-Host + Uri-Port + Uri-Path

发送端AL需要知道对方的`CoAP URI`和SAP，由于CoAP封装了UDP，所以`不需要`知道`ip地址和端口`，可能会动态变化

DLMS AE通过唯一systemtitle标识，通过以下方式交换：(TODO:AE是什么意思)

- 在明确建立AA的情况下，在AA建立期间使用COSEM-OPEN服务;
- 通过在“Security setup”对象写入client_system_title属性和读取的server_system_title属性。适用于预连接AA
- 加密APDU交换，general-ciphering (originator and recipient system title)或general-glo-ciphering (originator system title).

CoAP-DATA原语需要包含对端的`ip地址`和端口，如果IP是`静态`的，那可以`静态绑定`到`system title`。如果是`动态`的，需要动态更新绑定，可以通过服务端ip变更自动推送实现

当客户端AL收到服务端上报data时，如果是动态ip，客户端可以根据system title确认身份。

#### 10.4.4 Supporting layer services and service mapping

#### 10.4.6 Specific considerations / constraints

![messages](/assets/img/2022-03-17-dlms-green-1/coapaadata1.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/coapaadata2.jpg)

unconfirmed AA不能传confirmed消息,Reliable可靠CoAP传输层配置不能传输广播消息

CoAP传输层无连接，不能通过断开传输层连接断开AA,只能通过RLRQ/RLRE断开

### 10.8 LPWAN profile

[什么是LPWAN？ LPWAN技术有哪些？](https://zhuanlan.zhihu.com/p/151780634)

`LPWAN`(低功耗广域网)，也称为LPWA)或LPN，是一种用于物联网(例如，以电池为电源的传感器)的类型，这是一种能够以低比特率进行远距离通信的无线网络。LPWAN可以同时满足覆盖和续航的要求。以最小的功耗提供最长的距离覆盖是LPWAN最大的技术优势。

- `NB-IoT`是物联网领域的一项新兴技术，支持广域网中低功耗设备的蜂窝数据连接。它也称为低功耗广域网(LPWAN)。NB-IoT支持设备有效连接，待机时间长，对网络连接要求高。据称，NB-IoT设备的电池续航时间可以提高到至少10年。
- `eMTC`作为物联网的一种应用场景。它具有超可靠和低延迟的特点。eMTC主要应用在设备之间的通信需求上。
- `Lora`是一项专有技术， Semtech为其提供芯片。Lora技术改变了以往在传输距离和功耗之间的折衷，为用户提供了一个简单的系统，可以实现远距离、长续航、大容量，进而扩展传感器网络。

![messages](/assets/img/2022-03-17-dlms-green-1/lpwanarch.jpg)

支持层固定使用了UDP和IPV6

LPWAN提供了`低层加密`和SCHC`压缩/解压`和`分段/重组`功能

可以通过DLMS/COSEM对象配置LPWAN参数

![messages](/assets/img/2022-03-17-dlms-green-1/lpwancommprofile.jpg)

传输层还有AA和UDP通信配置差不多

绿皮书没有介绍多少东西，基本都源于RFC 8376，RFC 8724

### 10.9 Wi-SUN profile

`Wi-SUN Field Area Network` (FAN)是一种基于`IEEE 802.15.4`的IPv6无线网状网络，专为关键基础设施项目设计。每个个人区域网络(PAN)被设计成用一个边界路由器支持数千个路由器设备。一个FAN可以由多个pan组成，允许单个网络扩展到数百万个设备，见图196。

![messages](/assets/img/2022-03-17-dlms-green-1/wisunarch.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/wisuncommprofile.jpg)

支持层固定使用了UDP和IPV6，对传输层来说和UDP profile类似，wrapper和TCP-UDP/IP profile相同

### 10.10 Gateway protocol

![messages](/assets/img/2022-03-17-dlms-green-1/gatewayarch.jpg)

![messages](/assets/img/2022-03-17-dlms-green-1/gatewayapdu.jpg)

- Header

  - 0xE6:请求（服务端发起data notification也算）
  - 0xE7:响应

- Network ID

  目的网络ID，可以理解为[VLAN](https://zh.wikipedia.org/zh-cn/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91) ID

- Address length L

  目的物理地址长度

- Physical device address

  目的物理地址

只有网关设备处理该报文

