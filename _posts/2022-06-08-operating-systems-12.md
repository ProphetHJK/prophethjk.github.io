---
title: "《Operating Systems: Three Easy Pieces》学习笔记(十一) 机制：地址转换"
author: Jinkai
date: 2022-06-08 09:00:00 +0800
published: false
categories: [学习笔记]
tags: [Operating Systems, 操作系统导论]
---

高效、灵活地虚拟化内存。需要一种基于硬件的地址转换（hardware-based address translation），简称为地址转换（address translation）。将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。

## 虚拟地址映射

![F15.1](/assets/img/2022-06-08-operating-systems-11/F15.1.jpg)

用户进程在物理内存中并不是从0地址开始的

## 动态（基于硬件）重定位(dynamic relocation)

进程的虚拟地址都是从 0 开始的

进程中使用的内存引用都是`虚拟地址`（virtual address），硬件接下来将`虚拟地址`加上`基址寄存器`中的内容，得到`物理地址`（physical address），再发给内存系统。

还有个`界限寄存器`，用于限制进程地址空间范围，进程不能访问为超过该值限制的虚拟地址空间，比如限制 16KB，则不能访问 17KB 的内存，硬件应该`阻止`转换成物理地址

![T15.1](/assets/img/2022-06-08-operating-systems-11/T15.1.jpg)

## 硬件支持：总结

动态重定位：硬件要求

| 硬件要求                             | 解释                                                                     |
| :----------------------------------- | :----------------------------------------------------------------------- |
| `特权模式`                           | 需要，以防用户模式的进程执行`特权操作`                                   |
| `基址/界限寄存器`                    | 每个 CPU 需要一对寄存器来支持`地址转换`和`界限检查`                      |
| 能够`转换`虚拟地址并`检查`它是否越界 | `电路`来完成转换和检查界限，在这种情况下，非常简单                       |
| 修改基址/界限寄存器的`特权指令`      | 在让用户程序运行之前，操作系统必须能够`设置`这些值，需要特权模式         |
| 注册异常处理程序的`特权指令`         | 操作系统必须能告诉硬件，如果`异常`发生，那么`执行`哪些代码，需要特权模式 |
| 能够`触发异常`                       | 如果进程试图使用`特权指令`或`越界`的内存                                 |

## 操作系统的职责

- `进程创建`时，操作系统从`空闲列表`（free list）找到位置`分配`内存空间，并标记为已用
- `进程终止`时，操作系统需要`回收`内存到空闲列表
- `上下文切换`时，需要`保存/加载`基址和界限`寄存器`。比如放在进程结构或进程控制块PCB中。

  > 当进程`暂停`时，操作系统可以`切换`其地址空间，只要分配新空间，拷贝，然后修改进程结构/PCB里的`基址寄存器`就行

- 操作系统必须提供`异常处理程序`（exception handler），向硬件注册，当进程出现如越界访问等异常操作时，CPU会执行这段异常处理程序，如终止该进程。

受限直接执行协议（动态重定位）:

|操作系统@启动（内核模式）|硬件||
|:---|:---|:---|
|初始化陷阱表|||
||记住以下地址：<br>- 系统调用处理程序<br>- 时钟处理程序<br>- 非法内存处理程序<br>- 非常指令处理程序||
|开始中断时钟|||
||开始时钟，在 x ms 后中断||
|初始化进程表 初始化空闲列表 |||
|**操作系统@运行（核心模式）**|**硬件**|**程序（用户模式）**|
|为了启动进程A：<br>- 在进程表中分配条目<br>- 为进程分配内存<br>- 设置基址/界限寄存器(应该是写入进程结构)<br>- 从陷阱返回（进入A）|||
||恢复A的寄存器<br>转向用户模式<br>跳到A（最初）的程序计数器||
|||进程A运行<br>- 获取指令|
||转换虚拟地址并执行获取||
|||执行指令|
||如果显式加载/保存<br>- 确保地址不越界<br>- 转换虚拟地址并执行<br>- 加载/保存||
|||……|
||时钟中断<br>转向内核模式<br>跳到中断处理程序||
|处理陷阱<br>调用 switch()例程<br>- 将寄存器（A）保存到进程结构（A）（包括基址/界限）<br>- 从进程结构（B）恢复寄存器（B）（包括基址/界限）<br>从陷阱返回（进入B）|||
||恢复B的寄存器<br>转向用户模式<br>跳到B的程序计数器||
|||进程B运行<br>- 执行错误的加载 |
||加载越界<br>转向内核模式<br>跳到陷阱处理程序||
|处理本期报告<br>- 决定终止进程B<br>- 回收B的内存<br>- 移除B在进程表中的条目|||

## 参考

- [Operating Systems: Three Easy Pieces 中文版](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/15.pdf)
