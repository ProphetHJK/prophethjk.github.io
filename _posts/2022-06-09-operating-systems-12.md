---
title: "《Operating Systems: Three Easy Pieces》学习笔记(十二) 分段"
author: Jinkai
date: 2022-06-09 09:00:00 +0800
published: true
categories: [学习笔记]
tags: [Operating Systems, 操作系统导论]
---

结合上一节，堆和栈之间有一大块“空闲”空间，如果`没被使用`，也占用了`物理内存`。如果虚拟内存`地址空间`很大，对物理内存也是极大的`浪费`

## 分段：泛化的基址/界限

在 MMU 中引入`三对`基址和界限寄存器，每个`逻辑段`（segment）一对：`代码`、`栈`和`堆`

只有已用的内存才在物理内存中分配空间，因此可以容纳巨大的地址空间，其中包含大量未使用的地址空间（有时又称为`稀疏地址空间`，sparse address spaces）。

![F16.1](/assets/img/2022-06-09-operating-systems-12/F16.1.jpg)

段寄存器的值:

|  段  | 基址 | 大小 |
| :--: | :--: | :----: |
| 代码 | 32KB | 2KB  |
|  堆  | 34KB | 2KB  |
|  栈  | 28KB | 2KB  |

比如访问100，是在代码段中，物理地址则是32KB+100=32868，然后判断是否在界限32KB+2KB内，合法时发起对物理地址的访问

比如访问4200，是在堆段中，先找到相对于堆段起始位置偏移量4200-4096=104，物理地址是34KB+104=34920

> `段错误`指的是在支持分段的机器上发生了非法的内存访问。越界访问会造成段异常（segmentation violation）或段错误（segmentation fault）

## 引用段的方式

1. 显式（explicit）方式

    就是用虚拟地址的开头几位来标识不同的段

    ![explicit](/assets/img/2022-06-09-operating-systems-12/explicit.jpg)

    ```c
    // get top 2 bits of 14-bit VA 2
    Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT
    // now get offset
    Offset = VirtualAddress & OFFSET_MASK
    if (Offset >= Bounds[Segment])
        RaiseException(PROTECTION_FAULT)
    else
        PhysAddr = Base[Segment] + Offset
        Register = AccessMemory(PhysAddr)
    ```

2. 隐式（implicit）方式

    硬件通过地址`产生的方式`来确定段。例如，如果地址由`程序计数器`产生（即它是指令获取），那么地址在`代码段`。如果基于栈或基址指针，它一定在栈段。其他地址则在堆段

## 栈

栈的增长方向和代码及堆相反。

除了基址和界限外，硬件还需要知道段的增长方向（用
一位区分，比如 1 代表自小而大增长，0 反之）

![T16.2](/assets/img/2022-06-09-operating-systems-12/T16.2.jpg)

假设要访问虚拟地址 `15KB`，它应该映射到物理地址 `27KB`。该虚拟地址的二进制形式是：11 1100 0000 0000（十六进制 0x3C00）。硬件利用`前两位`（11）来指定段，但然后我们要处理偏移量 `3KB`。为了得到正确的反向偏移，我们必须从 3KB 中`减去`最大的段地址：在这个例子中，段可以是`4KB`(图上显示是2KB，假设最大是能到4KB的)，因此正确的偏移量是3KB减去4KB，即`−1KB`。 只要用这个反向偏移量（−1KB）`加上基址`（28KB），就得到了正确的物理地址 `27KB`。用户可以进行界限检查，确保反向偏移量的绝对值小于段的大小。

## 支持共享

要`节省内存`，有时候在地址空间之间`共享`（share）某些内存段是有用的

为了支持共享，需要一些额外的硬件支持，这就是`保护位`（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为`只读`，同样的代码可以被多个进程`共享`，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持

比如同一份二进制文件运行多个进程,可以共享代码段

![T16.3](/assets/img/2022-06-09-operating-systems-12/T16.3.jpg)

图中代码段的权限是`可读`和`可执行`，因此物理内存中的一个段可以映射到多个虚拟地址空间。

有了保护位，前面描述的硬件算法也必须改变。除了检查虚拟地址是否越界，硬件还需要检查特定`访问是否允许`。如果用户进程试图写入只读段，或从非执行段执行指令，硬件会触发异常，让操作系统来处理出错进程。

## 细粒度与粗粒度的分段

粗粒度的分段
: 比如只分成三个段，代码、栈、堆

细粒度的分段
: 将三个段进一步细分。操作系统可以更好地了解哪些段在使用哪些没有，从而可以更高效地利用内存。

## 操作系统支持

栈和堆之间没有使用的区域就不需要再分配物理内存

细分后会产生外部碎片（external fragmentation）

![F16.3](/assets/img/2022-06-09-operating-systems-12/F16.3.jpg)

解决方案：

- `紧凑（compact）物理内存`，重新安排原有的段

  操作系统先终止运行的进程，将它们的数据复制到连续的内存区域中去，改变它们的段寄存器中的值，指向新的物理地址，从而得到了足够大的连续空闲空间

- `空闲列表管理算法`

  试图`保留大的`内存块用于分配。相关的算法可能有成百上千种，包括传统的`最优匹配`（best-fit，从空闲链表中找最接近需要分配空间的空闲块返回）、`最坏匹配`（worst-fit）、`首次匹配`（first-fit）以及像`伙伴算法`（buddy algorithm） [K68]这样更复杂的算法

## 参考

- [Operating Systems: Three Easy Pieces 中文版](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/16.pdf)
