<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行" /><meta name="author" content="Jinkai" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本文中文版翻译质量堪忧，有不少名词翻译不知所云，建议对照英文版阅读" /><meta property="og:description" content="本文中文版翻译质量堪忧，有不少名词翻译不知所云，建议对照英文版阅读" /><link rel="canonical" href="https://hjk.life/posts/operating-systems-4/" /><meta property="og:url" content="https://hjk.life/posts/operating-systems-4/" /><meta property="og:site_name" content="普通人" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-16T09:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jinkai" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jinkai"},"dateModified":"2022-06-09T09:20:17+08:00","datePublished":"2021-03-16T09:00:00+08:00","description":"本文中文版翻译质量堪忧，有不少名词翻译不知所云，建议对照英文版阅读","headline":"《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行","mainEntityOfPage":{"@type":"WebPage","@id":"https://hjk.life/posts/operating-systems-4/"},"url":"https://hjk.life/posts/operating-systems-4/"}</script><title>《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行 | 普通人</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="普通人"><meta name="application-name" content="普通人"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/favicons/Humanity.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">普通人</a></div><div class="site-subtitle font-italic">潜龙勿用</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/prophethjk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['prophethjk','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/prophethjk">Jinkai</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1615856400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2021-03-16 </em> </span> <span> 更新于 <em class="timeago" data-ts="1654737617" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-06-09 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5785 字"> <em>32 分钟</em>阅读</span></div></div></div><div class="post-content"><p><em>本文中文版翻译质量堪忧，有不少名词翻译不知所云，建议对照英文版阅读</em></p><h2 id="前言"><span class="mr-2">前言</span><a href="#前言" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>在构建这样的虚拟化机制时存在一些挑战。</p><ul><li>第一个是性能：如何在不增加系统<code class="language-plaintext highlighter-rouge">开销</code>的情况下实现虚拟化？<li>第二个是控制权：如何有效地运行进程，同时保留对 CPU 的<code class="language-plaintext highlighter-rouge">控制</code>？</ul><blockquote><p>控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息</p></blockquote><h2 id="直接运行协议无限制"><span class="mr-2">直接运行协议（无限制）</span><a href="#直接运行协议无限制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><code class="language-plaintext highlighter-rouge">直接执行</code>指的是直接在 CPU 上运行程序，该操作没有任何限制。</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作系统<th style="text-align: left">程序<tbody><tr><td style="text-align: left">在进程列表上创建条目<br />为程序分配内存<br />将程序加载到内存中<br />根据 argc/argv 设置程序栈<td style="text-align: left"> <tr><td style="text-align: left">清除寄存器<br />执行 call main() 方法<td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">执行 main()<br />从 main 中执行 return<tr><td style="text-align: left">释放进程的内存将进程<br />从进程列表中清除<td style="text-align: left"> </table></div><p>直接运行性能肯定最高，但带来两个问题：</p><ul><li><a href="#问题-1受限制的操作"><code class="language-plaintext highlighter-rouge">受限制的操作</code></a>：操作系统怎么能确保程序不做任何我们<code class="language-plaintext highlighter-rouge">不希望</code>它做的事，同时仍然<code class="language-plaintext highlighter-rouge">高效</code>地运行它<li><a href="#问题-2在进程之间切换"><code class="language-plaintext highlighter-rouge">进程间切换</code></a>： 操作系统如何让一个进程停下来并<code class="language-plaintext highlighter-rouge">切换</code>到另一个进程，从而实现虚拟化 CPU 所需的<code class="language-plaintext highlighter-rouge">时分共享</code></ul><h2 id="问题-1受限制的操作"><span class="mr-2">问题 1：受限制的操作</span><a href="#问题-1受限制的操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p><strong>提示：采用受保护的控制权转移</strong></p><p>硬件通过提供不同的执行模式来协助操作系统。在<code class="language-plaintext highlighter-rouge">用户模式（user mode）</code>下，应用程序不能<code class="language-plaintext highlighter-rouge">完全访问</code>硬件资源。在<code class="language-plaintext highlighter-rouge">内核模式（kernel mode）</code>下，操作系统可以访问机器的<code class="language-plaintext highlighter-rouge">全部资源</code>。还提供了<code class="language-plaintext highlighter-rouge">陷入</code>（trap）内核和从<code class="language-plaintext highlighter-rouge">陷阱返回</code>（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。</p></blockquote><p>我们采用的方法是引入新的处理器模式:</p><h3 id="用户模式user-mode"><span class="mr-2">用户模式（user mode）</span><a href="#用户模式user-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>在用户模式下运行的代码会<code class="language-plaintext highlighter-rouge">受到限制</code>。例如，在用户模式下运行时，进程不能发出 I/O 请求。这样做会导致处理器引发异常，操作系统可能会终止进程。</p><h3 id="内核模式kernel-mode"><span class="mr-2">内核模式（kernel mode）</span><a href="#内核模式kernel-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括<code class="language-plaintext highlighter-rouge">特权操作</code>，如发出 I/O 请求和执行所有类型的受限指令。</p><h3 id="系统调用"><span class="mr-2">系统调用</span><a href="#系统调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">系统调用</code>允许内核小心地向用户程序暴露某些<code class="language-plaintext highlighter-rouge">关键功能</code>，例如<strong>访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存</strong>。大多数操作系统提供几百个调用（详见 <a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">POSIX 标准</a>）。早期的 UNIX 系统公开了更简洁的子集，大约 20 个调用。</p><p>如果用户希望执行某种<code class="language-plaintext highlighter-rouge">特权操作</code>（如从磁盘读取），可以借助硬件提供的<code class="language-plaintext highlighter-rouge">系统调用</code>功能。</p><p>要执行系统调用，程序必须执行特殊的<code class="language-plaintext highlighter-rouge">陷阱</code>（trap）指令。该指令同时跳入内核并将特权级别提升到<code class="language-plaintext highlighter-rouge">内核模式</code>。一旦进入内核，系统就可以执行任何需要的<code class="language-plaintext highlighter-rouge">特权操作</code>（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的<code class="language-plaintext highlighter-rouge">从陷阱返回</code>（return-from-trap）指令，如你期望的那样，<strong>该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</strong></p><p>执行陷阱时，硬件需要小心，因为它必须确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够<code class="language-plaintext highlighter-rouge">正确返回</code>。例如，在 x86 上，处理器会将程序计数器、标志和其他一些寄存器推送到<code class="language-plaintext highlighter-rouge">每个进程</code>的<code class="language-plaintext highlighter-rouge">内核栈</code>（kernel stack）上。从返回陷阱将从栈弹出这些值，并恢复执行用户模式程序（有关详细信息，请参阅英特尔系统手册）。其他硬件系统使用不同的约定，但基本概念在各个平台上是相似的。</p><blockquote><p><strong>补充：为什么系统调用看起来像过程调用</strong></p><p>你可能想知道，为什么对<code class="language-plaintext highlighter-rouge">系统调用</code>的调用（如 open()或 read()）看起来完全<code class="language-plaintext highlighter-rouge">就像</code> C 中的典型<code class="language-plaintext highlighter-rouge">过程调用</code>。也就是说，如果它看起来像一个过程调用，系统如何知道这是一个系统调用，并做所有正确的事情？原因很简单：<strong>它是一个过程调用，但隐藏在过程调用内部的是著名的陷阱指令</strong>。更具体地说，当你调用 open()（举个例子）时，你正在执行对 C 库的过程调用。其中，无论是对于 open()还是提供的其他系统调用，库都使用与内核一致的调用约定来将参数放在众所周知的位置（例如，在栈中或特定的寄存器中），将系统调用号也放入一个众所周知的位置（同样，放在栈或寄存器中），然后执行上述的陷阱指令。库中陷阱之后的代码准备好返回值，并将控制权返回给发出系统调用的程序。因此，<strong>C 库中进行系统调用的部分是用汇编手工编码的</strong>，因为它们需要仔细遵循约定，以便正确处理参数和返回值，以及执行硬件特定的陷阱指令。现在你知道为什么你自己不必写汇编代码来陷入操作系统了，<strong>因为有人已经为你写了这些汇编</strong>。</p></blockquote><h3 id="陷阱表trap-table"><span class="mr-2">陷阱表（trap table）</span><a href="#陷阱表trap-table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>内核通过在启动时设置<code class="language-plaintext highlighter-rouge">陷阱表</code>（trap table）来实现陷阱地址的初始化。</p><p>当机器启动时，系统在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是<strong>告诉硬件在发生某些异常事件时要运行哪些代码</strong>。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码？操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会<strong>记住这些处理程序的位置，直到下一次重新启动机器</strong>，并且硬件知道在<strong>发生系统调用和其他异常事件时要做什么</strong>（即跳转到哪段代码）。</p><h3 id="受限直接运行协议"><span class="mr-2">受限直接运行协议</span><a href="#受限直接运行协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>LDE 背后的想法很简单：让程序运行的<code class="language-plaintext highlighter-rouge">大部分</code>指令<code class="language-plaintext highlighter-rouge">直接访问硬件</code>，只在一些<code class="language-plaintext highlighter-rouge">关键点</code>（如进程发起系统调用或发生时钟中断）由操作系统<code class="language-plaintext highlighter-rouge">介入</code>来确保“在正确时间， 正确的地点，做正确的事”。为了实现<code class="language-plaintext highlighter-rouge">高效</code>的虚拟化，操作系统应该尽量让程序自己运行，同时通过在<code class="language-plaintext highlighter-rouge">关键点</code>的及时<code class="language-plaintext highlighter-rouge">介入</code>（interposing），来<code class="language-plaintext highlighter-rouge">保持</code>对硬件的<code class="language-plaintext highlighter-rouge">控制</code>。</p><p>LDE 协议有两个阶段:</p><p><strong>第一阶段：</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作系统@<code class="language-plaintext highlighter-rouge">启动</code>（内核模式）<th style="text-align: left">硬件<th style="text-align: left"> <tbody><tr><td style="text-align: left">初始化陷阱表<td style="text-align: left"> <td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">记住系统调用处理程序的地址<td style="text-align: left"> </table></div><p>第一个阶段（在系统引导时），内核初始化陷阱表，并且 CPU 记住它的位置以供随后使用。内核通过特权指令来执行此操作（所有特权指令均以粗体突出显示）。</p><p><strong>第二阶段：</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作系统@<code class="language-plaintext highlighter-rouge">运行</code>（内核模式）<th style="text-align: left">硬件<th style="text-align: left">程序（应用模式）<tbody><tr><td style="text-align: left">在进程列表上创建条目<br />为程序分配内存<br />将程序加载到内存中<br />根据 argv 设置程序栈<br />用寄存器/程序计数器填充内核栈<br />从陷阱返回<td style="text-align: left"> <td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">从内核栈恢复寄存器<br />转向用户模式<br />跳到 main<td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left"> <td style="text-align: left">运行 main <br />……<br />调用系统调用<br />陷入操作系统<tr><td style="text-align: left"> <td style="text-align: left">将寄存器保存到内核栈<br />转向内核模式<br />跳到陷阱处理程序<td style="text-align: left"> <tr><td style="text-align: left">处理陷阱<br />做系统调用的工作<br />从陷阱返回<td style="text-align: left"> <td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">从内核栈恢复寄存器<br />转向用户模式<br />跳到陷阱之后的程序计数器<td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left"> <td style="text-align: left">……从 main 返回<br />陷入（通过 exit()）<tr><td style="text-align: left">释放进程的内存将进程<br />从进程列表中清除<td style="text-align: left"> <td style="text-align: left"> </table></div><p>第二个阶段（运行进程时），在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容（例如，在进程列表中分配一个节点，分配内存）。这会将 CPU 切换到用户模式并开始运行该进程。当进程希望发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。该进程然后完成它的工作，并从 main()返回。这通常会返回到一些存根代码，它将正确退出该程序（例如，通过调用 exit()系统调用，这将陷入 OS 中）。此时，OS 清理干净，任务完成了。</p><h2 id="问题-2在进程之间切换"><span class="mr-2">问题 2：在进程之间切换</span><a href="#问题-2在进程之间切换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p><strong>关键问题：如何重获 CPU 的控制权</strong></p><p>操作系统如何重新获得 CPU 的控制权（regain control），以便它可以在进程之间切换？</p></blockquote><h3 id="协作方式等待系统调用"><span class="mr-2">协作方式：等待系统调用</span><a href="#协作方式等待系统调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>在<code class="language-plaintext highlighter-rouge">协作调度系统</code>中，OS 通过<code class="language-plaintext highlighter-rouge">等待系统调用</code>，或某种<code class="language-plaintext highlighter-rouge">非法操作发生</code>，从而重新获得 CPU 的<code class="language-plaintext highlighter-rouge">控制权</code></strong>。</p><p>过去某些系统采用的一种方式（例如，早期版本的 Macintosh 操作系统或旧的 Xerox Alto 系统）称为<code class="language-plaintext highlighter-rouge">协作</code>（cooperative）方式。在这种风格下，<strong>操作系统相信系统的进程会合理运行</strong>。运行时间过长的进程被假定会<code class="language-plaintext highlighter-rouge">定期放弃 CPU</code>，以便操作系统可以决定运行其他任务。</p><p>大多数进程通过进行<code class="language-plaintext highlighter-rouge">系统调用</code>，将 CPU 的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程</p><p>如果应用程序执行了某些<code class="language-plaintext highlighter-rouge">非法操作</code>，也会将控制转移给操作系统。例如，如果应用程序以 0 为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制 CPU（并可能终止违规进程）。</p><h3 id="非协作方式时钟中断"><span class="mr-2">非协作方式：时钟中断</span><a href="#非协作方式时钟中断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">时钟中断</code>（timer interrupt）。时钟设备可以编程为<strong>每隔几毫秒产生一次中断</strong>。产生中断时，当前正在运行的进程停止，操作系统中预先配置的<code class="language-plaintext highlighter-rouge">中断处理程序</code>（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p><p>请注意，<code class="language-plaintext highlighter-rouge">硬件</code>在<code class="language-plaintext highlighter-rouge">发生中断</code>时有一定的责任，尤其是在中断发生时，要为正在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复正在运行的程序。该操作可以视为隐式的操作，与显式的系统调用很相似。</p><h3 id="保存和恢复上下文"><span class="mr-2">保存和恢复上下文</span><a href="#保存和恢复上下文" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>当操作系统通过上述两种方式获取控制权后，就可以决定是否切换进程，这个决定是由调度程序（scheduler）做出</p><p>当操作系统决定切换进程时，需要首先进行<code class="language-plaintext highlighter-rouge">上下文切换</code>（context switch），就是为当前正在执行的进程<code class="language-plaintext highlighter-rouge">保存一些寄存器的值</code>（例如，到它的内核栈），并为即将执行的进程<code class="language-plaintext highlighter-rouge">恢复一些寄存器的值</code>（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p><blockquote><p>上下文切换并不仅仅保存和恢复寄存器，还包含了其他操作，如页表的切换等，在后续章节会提到</p></blockquote><h3 id="受限直接执行协议时钟中断"><span class="mr-2">受限直接执行协议（时钟中断）</span><a href="#受限直接执行协议时钟中断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>第一阶段：</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作系统@<code class="language-plaintext highlighter-rouge">启动</code>（内核模式）<th style="text-align: left">硬件<tbody><tr><td style="text-align: left">初始化陷阱表<td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">记住以下地址：<br /> -系统调用处理程序<br /> -时钟处理程序<tr><td style="text-align: left">启动中断时钟<td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">启动时钟<br />每隔 x ms 中断 CPU</table></div><p><strong>第二阶段：</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作系统@<code class="language-plaintext highlighter-rouge">运行</code>（内核模式）<th style="text-align: left">硬件<th style="text-align: left">程序（应用模式）<tbody><tr><td style="text-align: left"> <td style="text-align: left"> <td style="text-align: left">进程 A……<tr><td style="text-align: left"> <td style="text-align: left">时钟中断<br />将用户寄存器（A）保存到内核栈（A）<br />转向内核模式<br />跳到陷阱处理程序<td style="text-align: left"> <tr><td style="text-align: left">处理陷阱<br />调用 switch()例程<br /> -保存内核寄存器（A）-&gt;进程结构（A）<br /> -恢复内核寄存器（B）&lt;-进程结构（B）<br />-切换到内核栈（B）<br />从陷阱返回（进入 B）<td style="text-align: left"> <td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">恢复用户寄存器（B）&lt;-内核栈（B）<br />转向用户模式<br />跳到 B 的程序计数器<td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left"> <td style="text-align: left">进程 B……</table></div><p>该表展示了整个过程的时间线。在这个例子中，进程 A 正在运行，然后<code class="language-plaintext highlighter-rouge">被中断时钟中断</code>。<strong>硬件保存它的用户寄存器（到内核栈中），并进入内核（切换到内核模式）</strong>。在时钟中断处理程序中，操作系统决定从正在运行的进程 A 切换到进程 B。此时，它调用 switch()例程，该例程仔细保存当前内核寄存器的值（保存到 A 的进程结构(process structure)），恢复内核寄存器进程 B（从它的进程结构(process structure)），然后<code class="language-plaintext highlighter-rouge">切换上下文</code>（switch context），具体来说是<strong>通过改变栈指针来使用 B 的内核栈（而不是 A 的）</strong>。最后，操作系统从陷阱返回，恢复 B 的用户寄存器并开始运行它。</p><p>请注意，在此协议中，有<code class="language-plaintext highlighter-rouge">两种类型</code>的寄存器保存/恢复:</p><ul><li><p>第一种是发生<code class="language-plaintext highlighter-rouge">时钟中断</code>的时候。在这种情况下，运行进程的<code class="language-plaintext highlighter-rouge">用户寄存器</code>由<code class="language-plaintext highlighter-rouge">硬件</code>隐式保存，使用该进程的<code class="language-plaintext highlighter-rouge">内核栈</code>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  原文：the user registers of the running process are implicitly saved by the hardware, using the kernel stack of that process
</pre></table></code></div></div><p>根据英文原文，此处确实是保存到了内核栈中</p><blockquote><p><strong>扩展：内核栈与用户栈</strong></p><p>内核在创建进程时，会同时创建 task_struct 和进程相应堆栈。每个进程都会有两个堆栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，<code class="language-plaintext highlighter-rouge">CPU 堆栈寄存器(SP)</code>的内容是<code class="language-plaintext highlighter-rouge">用户堆栈地址</code>，使用用户栈。当进程在内核空间时，<code class="language-plaintext highlighter-rouge">CPU 堆栈寄存器(SP)</code>的内容是<code class="language-plaintext highlighter-rouge">内核栈地址</code>，使用的是内核栈。</p></blockquote><li><p>第二种是当<code class="language-plaintext highlighter-rouge">操作系统决定</code>从 A 切换到 B。在这种情况下，A 的<code class="language-plaintext highlighter-rouge">用户寄存器</code>先被<code class="language-plaintext highlighter-rouge">硬件</code>保存到<code class="language-plaintext highlighter-rouge">内核栈(A)</code>，之后进入<code class="language-plaintext highlighter-rouge">内核态</code>，此时，<strong>用户寄存器切换成内核寄存器，存放系统和进程 A 相关的值</strong>，操作系统接管后，调用 <code class="language-plaintext highlighter-rouge">switch()</code>通过<code class="language-plaintext highlighter-rouge">软件</code>方式将<code class="language-plaintext highlighter-rouge">内核寄存器</code>中的值保存到 A 的<code class="language-plaintext highlighter-rouge">进程结构</code>，之后从 B 的<code class="language-plaintext highlighter-rouge">进程结构</code>恢复值到<code class="language-plaintext highlighter-rouge">内核寄存器</code>，并切换到进程 B 的<code class="language-plaintext highlighter-rouge">内核栈(B)</code>，然后从陷阱返回，从<code class="language-plaintext highlighter-rouge">内核栈(B)</code>恢复 B 的<code class="language-plaintext highlighter-rouge">用户寄存器</code>，运行 B 进程</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  原文：the kernel registers are explicitly saved by the software (i.e., the OS), but this time into memory in the process structure of the process. The latter action moves the system from running as if it just trapped into the kernel from A to as if it just trapped into the kernel from B.
</pre></table></code></div></div><p>为了理解这个逻辑，首先把切换这步去掉，假设 A 不切换成 B，即 A 的<code class="language-plaintext highlighter-rouge">用户寄存器</code>先被<code class="language-plaintext highlighter-rouge">硬件</code>保存到<code class="language-plaintext highlighter-rouge">内核栈(A)</code>，此时，包括<code class="language-plaintext highlighter-rouge">PC寄存器</code>（需要执行的下一条指令地址）在内的寄存器都被压入内核栈(A)，从陷阱返回后，从<code class="language-plaintext highlighter-rouge">内核栈(A)</code>恢复 A 的用户寄存器，将包括 PC 寄存器在内的寄存器恢复，此时继续执行 PC 寄存器保存的下一条指令。然后加上<code class="language-plaintext highlighter-rouge">switch()</code>操作，保存/恢复内核寄存器到对应的进程结构中。</p><p>TODO:此处后面再用实际操作系统的例子补充</p></ul><h3 id="分享在-µcos-iii-中遇到的上下文切换问题"><span class="mr-2">分享：在 µC/OS-III 中遇到的上下文切换问题</span><a href="#分享在-µcos-iii-中遇到的上下文切换问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>在实际项目中使用 µC/OS-III 系统时遇到过一个问题，某个进程的值在没有任何修改的情况下变为了异常值。</p><p><strong>问题说明：</strong></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">wlm_do</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">the_wlm_routine</span><span class="p">[</span><span class="n">the_wlm</span><span class="p">.</span><span class="n">status</span><span class="p">].</span><span class="n">func</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">wlm_chk_baudrate</span><span class="p">()</span><span class="o">-&gt;</span>
<span class="n">atcmd</span><span class="p">(</span><span class="n">serfd</span><span class="p">(),</span><span class="err"> </span><span class="s">"AT</span><span class="se">\r</span><span class="s">"</span><span class="p">,</span><span class="err"> </span><span class="n">E_OK</span><span class="p">,</span><span class="err"> </span><span class="mi">500</span><span class="p">,</span><span class="err"> </span><span class="nb">NULL</span><span class="p">,</span><span class="err"> </span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">memset</span><span class="p">(</span><span class="n">prbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rbuf_len</span><span class="p">)</span>
</pre></table></code></div></div><p>rbuf_len 的值变为了 536890260，显然是个异常值。</p><p><strong>问题分析：</strong></p><p>通过分析后排除了程序本身的问题，打算从操作系统角度进行问题。</p><p>在关闭 GCC 优化的情况下，该值正常，也就是说可能和 GCC 的优化有关。GCC 优化会将部分常用的变量保持到寄存器中，从而提高读写速度。</p><p>通过内存和寄存器跟踪工具，定位了该变量确实被保存在了寄存器中，也就是说寄存器出现了问题，和寄存器操作相关的就极有可能是上下文切换操作。</p><p>通过跟踪发现寄存器的值在进程切换后出现了异常，导致该变量的值改变</p><p>查看上下文切换实现源码：</p><div class="language-armasm highlighter-rouge"><div class="code-header"> <span data-label-text="Armasm"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nl">OS_CPU_PendSVHandler</span><span class="err">:</span>
    <span class="nb">CPSID</span>   <span class="nv">I</span>                                                   <span class="no">@</span> <span class="nv">Prevent</span> <span class="nv">interruption</span> <span class="nv">during</span> <span class="nv">context</span> <span class="nv">switch</span>
    <span class="nb">MRS</span>     <span class="nv">R0</span><span class="o">,</span> <span class="nv">PSP</span>                                             <span class="no">@</span> <span class="nv">PSP</span> <span class="nv">is</span> <span class="nv">process</span> <span class="nv">stack</span> <span class="nv">pointer</span>

    <span class="nb">CMP</span>     <span class="nv">R0</span><span class="o">,</span> <span class="o">#</span><span class="mi">0</span>
    <span class="nb">BEQ</span>     <span class="nv">OS_CPU_PendSVHandler_nosave</span>                         <span class="no">@</span> <span class="nv">equivalent</span> <span class="nv">code</span> <span class="nv">to</span> <span class="nv">CBZ</span> <span class="nv">from</span> <span class="nv">M3</span> <span class="nv">arch</span> <span class="nv">to</span> <span class="nv">M0</span> <span class="nv">arch</span>
                                                                <span class="err">@</span> <span class="nv">Except</span> <span class="nv">that</span> <span class="nv">it</span> <span class="nv">does</span> <span class="nv">not</span> <span class="nv">change</span> <span class="nv">the</span> <span class="nv">condition</span> <span class="nv">code</span> <span class="nv">flags</span>

    <span class="nb">SUBS</span>    <span class="nv">R0</span><span class="o">,</span> <span class="nv">R0</span><span class="o">,</span> <span class="o">#</span><span class="mh">0x10</span>                                       <span class="no">@</span> <span class="nv">Adjust</span> <span class="nv">stack</span> <span class="nv">pointer</span> <span class="nv">to</span> <span class="nv">where</span> <span class="nv">memory</span> <span class="nv">needs</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">stored</span> <span class="nv">to</span> <span class="nv">avoid</span> <span class="nv">overwriting</span>
    <span class="nb">STM</span>     <span class="nv">R0</span><span class="o">!,</span> <span class="o">{</span><span class="nv">R4</span><span class="o">-</span><span class="nv">R7</span><span class="o">}</span>                                        <span class="no">@</span> <span class="nv">Stores</span> <span class="mi">4</span> <span class="mi">4</span><span class="o">-</span><span class="nv">byte</span> <span class="nv">registers</span><span class="o">,</span> <span class="nv">default</span> <span class="nv">increments</span> <span class="nv">SP</span> <span class="nv">after</span> <span class="nv">each</span> <span class="nv">storing</span>
    <span class="nb">SUBS</span>    <span class="nv">R0</span><span class="o">,</span> <span class="nv">R0</span><span class="o">,</span> <span class="o">#</span><span class="mh">0x10</span>                                       <span class="no">@</span> <span class="nv">STM</span> <span class="nv">does</span> <span class="nv">not</span> <span class="nv">automatically</span> <span class="nv">call</span> <span class="nv">back</span> <span class="nv">the</span> <span class="nv">SP</span> <span class="nv">to</span> <span class="nv">initial</span> <span class="nv">location</span> <span class="nv">so</span> <span class="nv">we</span> <span class="nv">must</span> <span class="nv">do</span> <span class="nv">this</span> <span class="nv">manually</span>

    <span class="nb">LDR</span>     <span class="nv">R1</span><span class="o">,</span> <span class="o">=</span><span class="nv">OSTCBCur</span>                                       <span class="no">@</span> <span class="nv">OSTCBCur</span><span class="o">-&gt;</span><span class="nv">OSTCBStkPtr</span> <span class="o">=</span> <span class="nv">SP</span><span class="c">;</span>
    <span class="nb">LDR</span>     <span class="nv">R1</span><span class="o">,</span> <span class="o">[</span><span class="nv">R1</span><span class="o">]</span>
    <span class="nb">STR</span>     <span class="nv">R0</span><span class="o">,</span> <span class="o">[</span><span class="nv">R1</span><span class="o">]</span>                                            <span class="no">@</span> <span class="nv">R0</span> <span class="nv">is</span> <span class="nv">SP</span> <span class="nv">of</span> <span class="nv">process</span> <span class="nv">being</span> <span class="nv">switched</span> <span class="nv">out</span>
                                                                <span class="err">@</span> <span class="nv">At</span> <span class="nv">this</span> <span class="nv">point</span><span class="o">,</span> <span class="nv">entire</span> <span class="nv">context</span> <span class="nv">of</span> <span class="nv">process</span> <span class="nv">has</span> <span class="nv">been</span> <span class="nv">saved</span>
</pre></table></code></div></div><p>此处仅保存了 r4-r7 寄存器，少了对 r8-r11 寄存器的保存</p><p>查看官网更新说明<a href="https://www.micrium.com/ucos-iii-v3-06-00/">µC/OS-III v3.06.00 Changelog</a>，有如下信息：</p><p><img data-src="/assets/img/2021-03-16-operating-systems-4/changelog.png" alt="changelog" data-proofer-ignore></p><p>bug 修复后的上下文切换源码如下：</p><div class="language-armasm highlighter-rouge"><div class="code-header"> <span data-label-text="Armasm"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="nl">PendSV_Handler</span><span class="err">:</span>
    <span class="nb">CPSID</span>   <span class="nv">I</span>                                                   <span class="no">@</span> <span class="nv">Prevent</span> <span class="nv">interruption</span> <span class="nv">during</span> <span class="nv">context</span> <span class="nv">switch</span>
    <span class="nb">MRS</span>     <span class="nv">R0</span><span class="o">,</span> <span class="nv">PSP</span>                                             <span class="no">@</span> <span class="nv">PSP</span> <span class="nv">is</span> <span class="nv">process</span> <span class="nv">stack</span> <span class="nv">pointer</span>

    <span class="nb">CMP</span>     <span class="nv">R0</span><span class="o">,</span> <span class="o">#</span><span class="mi">0</span>
    <span class="nb">BEQ</span>     <span class="nv">OS_CPU_PendSVHandler_nosave</span>                         <span class="no">@</span> <span class="nv">equivalent</span> <span class="nv">code</span> <span class="nv">to</span> <span class="nv">CBZ</span> <span class="nv">from</span> <span class="nv">M3</span> <span class="nv">arch</span> <span class="nv">to</span> <span class="nv">M0</span> <span class="nv">arch</span>
                                                                <span class="err">@</span> <span class="nv">Except</span> <span class="nv">that</span> <span class="nv">it</span> <span class="nv">does</span> <span class="nv">not</span> <span class="nv">change</span> <span class="nv">the</span> <span class="nv">condition</span> <span class="nv">code</span> <span class="nv">flags</span>

    <span class="nb">SUBS</span>    <span class="nv">R0</span><span class="o">,</span> <span class="nv">R0</span><span class="o">,</span> <span class="o">#</span><span class="mh">0x24</span>                                       <span class="no">@</span> <span class="nv">Adjust</span> <span class="nv">SP</span> <span class="nv">to</span> <span class="nv">make</span> <span class="nv">space</span> <span class="nv">for</span> <span class="nv">Low</span><span class="o">,</span> <span class="nv">High</span> <span class="o">&amp;</span> <span class="nv">LR</span> <span class="nv">registers</span>
    <span class="nb">LDR</span>     <span class="nv">R1</span><span class="o">,</span> <span class="o">=</span><span class="nv">OSTCBCur</span>                                       <span class="no">@</span> <span class="nv">OSTCBCur</span><span class="o">-&gt;</span><span class="nv">OSTCBStkPtr</span> <span class="o">=</span> <span class="nv">SP</span><span class="c">;</span>
    <span class="nb">LDR</span>     <span class="nv">R1</span><span class="o">,</span> <span class="o">[</span><span class="nv">R1</span><span class="o">]</span>
    <span class="nb">STR</span>     <span class="nv">R0</span><span class="o">,</span> <span class="o">[</span><span class="nv">R1</span><span class="o">]</span>                                            <span class="no">@</span> <span class="nv">R0</span> <span class="nv">is</span> <span class="nv">SP</span> <span class="nv">of</span> <span class="nv">process</span> <span class="nv">being</span> <span class="nv">switched</span> <span class="nv">out</span>

    <span class="nb">STMIA</span>   <span class="nv">R0</span><span class="o">!,</span> <span class="o">{</span><span class="nv">R4</span><span class="o">-</span><span class="nv">R7</span><span class="o">}</span>                                        <span class="no">@</span> <span class="nv">Store</span> <span class="nv">R4</span><span class="o">-</span><span class="nv">R7</span><span class="o">(</span><span class="nv">Low</span> <span class="nv">Registers</span><span class="o">)</span> <span class="nv">on</span> <span class="nv">process</span> <span class="nv">stack</span>
    <span class="nb">MOV</span>     <span class="nv">R4</span><span class="o">,</span> <span class="nv">R8</span>                                              <span class="no">@</span> <span class="nv">Move</span> <span class="nv">R8</span><span class="o">-</span><span class="nv">R11</span> <span class="nv">values</span> <span class="nv">to</span> <span class="nv">R4</span><span class="o">-</span><span class="nv">R7</span> <span class="nv">registers</span><span class="mf">.</span>
    <span class="nb">MOV</span>     <span class="nv">R5</span><span class="o">,</span> <span class="nv">R9</span>
    <span class="nb">MOV</span>     <span class="nv">R6</span><span class="o">,</span> <span class="nv">R10</span>
    <span class="nb">MOV</span>     <span class="nv">R7</span><span class="o">,</span> <span class="nv">R11</span>
    <span class="nb">STMIA</span>   <span class="nv">R0</span><span class="o">!,</span> <span class="o">{</span><span class="nv">R4</span><span class="o">-</span><span class="nv">R7</span><span class="o">}</span>                                        <span class="no">@</span> <span class="nv">Store</span> <span class="nv">R8</span><span class="o">-</span><span class="nv">R11</span><span class="o">(</span><span class="nv">High</span> <span class="nv">Registers</span><span class="o">)</span> <span class="nv">on</span> <span class="nv">process</span> <span class="nv">stack</span>
    <span class="nb">MOV</span>     <span class="nv">R3</span><span class="o">,</span> <span class="nv">R14</span>                                             <span class="no">@</span> <span class="nv">R3</span> <span class="nv">is</span> <span class="nv">LR</span> <span class="nv">of</span> <span class="nv">process</span> <span class="nv">being</span> <span class="nv">switched</span> <span class="nv">out</span>
    <span class="nb">STMIA</span>   <span class="nv">R0</span><span class="o">!,</span> <span class="o">{</span><span class="nv">R3</span><span class="o">}</span>                                           <span class="no">@</span> <span class="nv">Store</span> <span class="nv">LR</span> <span class="o">(</span><span class="nv">EXC_RETURN</span><span class="o">)</span> <span class="nv">on</span> <span class="nv">process</span> <span class="nv">stack</span><span class="mf">.</span>

                                                                <span class="err">@</span> <span class="nv">At</span> <span class="nv">this</span> <span class="nv">point</span><span class="o">,</span> <span class="nv">entire</span> <span class="nv">context</span> <span class="nv">of</span> <span class="nv">process</span> <span class="nv">has</span> <span class="nv">been</span> <span class="nv">saved</span>
</pre></table></code></div></div><p>此处保存了 r4-r11 寄存器</p><p>至此，问题原因已明确</p><p><strong>问题原因：</strong></p><p>代码优化时将 rbuf_len 保存在了寄存器 r8 上，在进行上下文切换时，r8 寄存器没有被保存，导致 r8 寄存器的值被其他进程修改，切换回本进程后，r8 的值也无法恢复。</p><h2 id="思考并发对中断的影响"><span class="mr-2">思考：并发对中断的影响</span><a href="#思考并发对中断的影响" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>处理一个中断时发生另一个中断，会发生什么？</p><p>一种方法是，在中断处理期间<code class="language-plaintext highlighter-rouge">禁止中断</code>（disable interrupt）。这样做可以确保在处理一个中断时，不会将其他中断交给 CPU。当然，操作系统这样做必须小心。禁用中断时间过长可能导致丢失中断，这（在技术上）是不好的。</p><p>操作系统还开发了许多复杂的<code class="language-plaintext highlighter-rouge">加锁</code>（locking）方案，以保护对内部数据结构的并发访问。这使得多个活动可以同时在内核中进行，特别适用于多处理器，在下一部分关于并发的章节中将会看到</p><h2 id="思考上下文切换的消耗"><span class="mr-2">思考：上下文切换的消耗</span><a href="#思考上下文切换的消耗" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>你可能有一个很自然的问题：上下文切换需要多长时间？甚至系统调用要多长时间？如果感到好奇，有一种称为 <code class="language-plaintext highlighter-rouge">lmbench</code>的工具，可以准确衡量这些事情，并提供其他一些可能相关的性能指标。随着时间的推移，结果有了很大的提高，大致跟上了处理器的性能提高。例如，1996 年在 200-MHz P6 CPU 上运行 Linux 1.3.37，系统调用花费了大约 4μs，上下文切换时间大约为 6μs。现代系统的性能几乎可以提高一个数量级，在具有 2 GHz 或 3 GHz 处理器的系统上的性能可以达到亚微秒级。应该注意的是，并非所有的操作系统操作都会跟踪 CPU 的性能。正如 Ousterhout 所说的，许多操作系统操作都是<code class="language-plaintext highlighter-rouge">内存密集型</code>的，而随着时间的推移，内存带宽并没有像处理器速度那样显著提高。因此，根据你的工作负载，购买最新、性能好的处理器可能不会像你希望的那样加速操作系统。</p><h2 id="参考"><span class="mr-2">参考</span><a href="#参考" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/06.pdf">Operating Systems: Three Easy Pieces 中文版</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-systems/" class="post-tag no-text-decoration" >Operating Systems</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" class="post-tag no-text-decoration" >操作系统导论</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行 - 普通人&amp;url=https://hjk.life/posts/operating-systems-4/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行 - 普通人&amp;u=https://hjk.life/posts/operating-systems-4/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://hjk.life/posts/operating-systems-4/&amp;text=《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行 - 普通人" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行 - 普通人&amp;url=https://hjk.life/posts/operating-systems-4/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/quantum-platform-1/">《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</a><li><a href="/posts/design-patterns-principles/">软件设计模式——七大设计原则</a><li><a href="/posts/const-c/">C语言中的const</a><li><a href="/posts/c-oop/">面向对象编程(OOP)的C语言实现</a><li><a href="/posts/operating-systems-28/">《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/operating-systems-27/"><div class="card-body"> <em class="timeago small" data-ts="1655344800" > 2022-06-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二十七) 基于事件的并发（进阶）</h3><div class="text-muted small"><p> 基于事件的并发（event-based concurrency），在一些现代系统中较为流行，比如 node.js，但它源自于 C/UNIX 系统，我们下面将讨论。 基于事件的并发针对两方面的问题。一方面是多线程应用中，正确处理并发很有难度。 正如我们讨论的，忘加锁、死锁和其他烦人的问题会发生。另一方面，开发者无法控制多线程在某一时刻的调度(由系统调度)。 基本想法：事件循环 我们使用的...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-28/"><div class="card-body"> <em class="timeago small" data-ts="1655348400" > 2022-06-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</h3><div class="text-muted small"><p> 系统架构 我们先看一个典型系统的架构（见图 36.1）。其中，CPU 通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能 I/O 设备通过常规的 I/O 总线（I/O bus）连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如 SCSI、SATA 或者 USB。它们将最慢的设备连接到系统，...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-34/"><div class="card-body"> <em class="timeago small" data-ts="1655427600" > 2022-06-17 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(三十四) 崩溃一致性：FSCK和日志(未完成)</h3><div class="text-muted small"><p> 文件系统面临的一个主要挑战在于，如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构。称为崩溃一致性问题（crash-consistency problem）。 崩溃一致性问题 理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地（atomically）移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/operating-systems-3/" class="btn btn-outline-primary" prompt="上一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API</p></a> <a href="/posts/operating-systems-5/" class="btn btn-outline-primary" prompt="下一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(五) 进程调度：介绍</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "ProphetHJK/prophethjk.github.io", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjk1MjU2NjI=", "data-category": "General", "data-category-id": "DIC_kwDOE6Qpns4CPYgF", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/prophethjk">Jinkai</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备20006745号-2</a> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VEN4M3BMXV"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VEN4M3BMXV'); }); </script>
