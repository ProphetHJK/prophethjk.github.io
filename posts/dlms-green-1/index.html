<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="DLMS Green Book学习笔记" /><meta name="author" content="Jinkai" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="s1 Scope s3 Terms, definitions and abbreviations and symbols s3.1 General DLMS/COSEM definitions s4 Information exchange in DLMS/COSEM s4.1 General s4.2 Communication model s4.3 Naming and addressing s4.3.3 Addressing s4.3.4 System title s4.3.5 Logical Device Name s4.4 Connection oriented operation s4.5 Application associations s4.5.2 Application context s4.5.3 Authentication s4.5.4 xDLMS context s4.5.5 Security context s4.5.6 Access rights s4.6 Messaging patterns s4.8 Communication profiles s4.9 Model of a DLMS/COSEM system s4.10 Model of DLMS servers s4.11 Model of a DLMS client s4.12 Interoperability and interconnectivity in DLMS/COSEM s4.13 Ensuring interconnectivity: the protocol identification service s4.14 System integration and installation s5 Physical layer services and procedures for connection-oriented asynchronous data exchange s5.1 Overview s5.2 Service specification s5.2.1 List of services s5.2.2 Use of the physical layer services s5.2.3 Service definitions s5.3 Protocol specification s5.3.1 Physical layer protocol data unit s5.3.2 Transmission order and characteristics s5.3.3 Physical layer operation – description of the procedures s5.3.3.1 General s5.3.3.2 Setting up a physical connection s5.3.3.3 The Identification service s5.3.3.4 Data transfer s5.3.3.5 Disconnection of an existing physical connection s5.4 example: PhL service primitives and Hayes commands s6 Direct Local Connection s7 DLMS/COSEM transport layer for IP networks s7.2 The TCP-UDP/IP based transport layers s7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer s7.2.3.3.2 The wrapper protocol data unit (WPDU) s7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer sTCP-CONNECT sTCP-DISCONNECT sTCP-ABORT sTCP-DATA s7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer s7.2.4.3.5 Definition of the procedures s7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls s7.2.5.1 Transport layer and TCP connection establishment s7.2.5.2 Closing a transport layer and a TCP connection s7.2.5.3 TCP connection abort s7.2.5.4 Data transfer using the TCP-DATA service s7.3 The DLMS/COSEM CoAP based transport layer s7.3.2 Overview s7.3.3 Structure of the DLMS/COSEM CoAP transport layer s7.3.3.2 Identification and addressing s7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer sDLMS/COSEM CoAP transport layer SAPs s7.3.4 Service specification for the DLMS/COSEM CoAP transport layer s7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives s7.3.4.2.1 CoAP-DATA.request s7.3.4.2.2 CoAP-DATA.indication s7.3.4.2.2 CoAP-DATA.confirm s7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer s7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU) s7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU) s7.3.5.4 The Constrained Application Protocol (CoAP) s7.3.5.4.2 The CoAP Message s7.3.5.4.3 CoAP retransmission and response piggybacking s7.3.5.4.5 CoAP Block Transfer s7.3.5.5 Error Handling s7.3.5.5.2 CoAP protocol layers s7.3.5.5.3 CoAP wrapper layer s7.3.5.5.4 Propagation of errors through CoAP wrapper layer s7.3.5.6 DLMS/COSEM CoAP TL confirmations s7.3.5.7 CoAP wrapper state machine s7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context s7.3.5.7.4 CoAP-DATA.request invocation handling s7.3.5.7.5 Handling of incoming CWPDU or CoAP layer transmission failures s7.3.5.7.6 Garbage collection s7.3.6 DLMS/COSEM CoAP TL Data Transfers s7.3.6.2 General transfer of confirmed DLMS/COSEM AL service requests s7.3.6.3 Reliable DLMS/COSEM CoAP TL operation s7.3.6.4 Unreliable DLMS/COSEM CoAP TL operation s7.3.6.5 DLMS/COSEM CoAP Block Transfer operation s7.3.6.6 DLMS GBT operation over DLMS/COSEM CoAP TL s8 Data Link Layer using the HDLC protocol s8.1 Overview s8.1.2 Structure of the data link layer s8.1.3 Specification method s8.2 Service specification s8.2.2 Setting up the data link connection: the DL-CONNECT and MA-CONNECT services s8.2.2.2 DL-CONNECT.request and MA-CONNECT.request s8.2.2.3 DL-CONNECT.indication and MA-CONNECT.indication s8.2.2.4 DL-CONNECT.response and MA-CONNECT.response s8.2.2.5 DL-CONNECT.confirm and MA-CONNECT.confirm s8.2.3 Disconnecting the data link connection: the DL-DISCONNECT and MA-DISCONNECT services s8.2.3.2 DL-DISCONNECT.request and MA-DISCONNECT.request s8.2.3.3 DL-DISCONNECT.indication and MA-DISCONNECT.indication s8.2.3.4 DL-DISCONNECT.response and MA-DISCONNECT.response s8.2.3.5 DL-DISCONNECT.confirm and MA-DISCONNECT.confirm s8.2.4 Data transfer: the DL-DATA and MA-DATA services s8.2.4.2 DL-DATA.request and MA-DATA.request s8.2.4.3 DL-DATA.indication and MA-DATA.indication s8.2.4.4 DL-DATA.confirm and MA-DATA.confirm s8.2.5 Physical layer services used by the MAC sublayer s8.2.5.4 Data transfer s8.3 Protocol specification for the LLC sublayer s8.3.2 LLC PDU format s8.3.3 State transition tables for the LLC sublayer s8.4 Protocol specification for the MAC sublayer s8.4.1 The MAC PDU and the HDLC frame s8.4.1.1 HDLC frame format type 3 s8.4.2 MAC addressing s8.4.2.2 Address field structure s8.4.2.3 Reserved special HDLC addresses s8.4.2.4 Handling special addresses s8.4.2.5 Handling inopportune address lengths in the server s8.4.3 Command and response frames s8.4.4 Elements of the procedures s8.4.4.2 Transmission considerations s8.4.4.3 HDLC channel states s8.4.5 HDLC channel operation – Description of the procedures s8.4.5.2 Data station characteristics s8.4.5.3 Procedures for setting up and disconnecting the data link s8.4.5.4 Procedures for data exchange s8.4.5.5 Exception recovery s8.4.5.6 Time-outs and other MAC sublayer parameters s8.4.5.7 State transition diagram for the server MAC sublayer s8.5 FCS calculation s8.5.1 Test sequence for the FCS calculation s8.5.2 Fast frame check sequence (FCS) implementation s8.5.3 16-bit FCS computation method s8.6 Data link layer management services s9 DLMS/COSEM application layer s9.1 DLMS/COSEM application layer main features s9.1.2 DLMS/COSEM application layer structure s9.1.3 The Association Control Service Element, ACSE s9.1.4 The xDLMS application service element s9.1.4.2 The xDLMS initiate service s9.1.4.3 COSEM object related xDLMS services s9.1.4.3.2 xDLMS services used by the client with LN referencing s9.1.4.3.3 xDLMS services used by the client with SN referencing s9.1.4.3.4 Unsolicited services s9.1.4.3.5 Selective access s9.1.4.3.6 Multiple references s9.1.4.3.7 Attribute_0 referencing s9.1.4.4 Additional mechanisms s9.1.4.4.2 Referencing methods and service mapping s9.1.4.4.3 Identification of service invocations: the Invoke_Id parameter s9.1.4.4.4 Priority handling s9.1.4.4.5 Transferring long messages s9.1.4.4.6 Composable xDLMS messages s9.1.4.4.7 Compression and decompression s9.1.4.4.8 General protection sGeneral block transfer (GBT) s9.1.4.5 Additional data types s9.1.4.6 xDLMS version number s9.1.4.7 xDLMS conformance block s9.1.4.8 Maximum PDU size s9.1.5 Layer management services s9.1.6 Summary of DLMS/COSEM application layer services s9.1.7 DLMS/COSEM application layer protocols s9.2 Information security in DLMS/COSEM s9.2.2 The DLMS/COSEM security concept s9.2.2.2 Identification and authentication s9.2.2.2.1 Identification s9.2.2.2.2 Authentication mechanisms s9.2.2.3 Security context s9.2.2.4 Access rights s9.2.2.5 Application layer message security s9.2.2.6 COSEM data security s9.2.3 Cryptographic algorithms s9.2.3.2 Hash function s9.2.3.3 Symmetric key algorithms s9.2.3.3.2 Encryption and decryption s9.2.3.3.3 Advanced Encryption Standard s9.2.3.3.4 Encryption Modes of Operation s9.2.3.3.5 Message Authentication Code s9.2.3.3.6 Key wrapping s9.2.3.3.7 Galois/Counter Mode s9.2.3.3.8 AES key wrap s9.2.3.4 Public key algorithms s9.2.3.4.2 Elliptic curve cryptography s9.2.3.4.3 Data conversions s9.2.3.4.4 Digital signature s9.2.3.4.5 Elliptic curve digital signature (ECDSA) s9.2.3.4.6 Key agreement s9.2.3.5 Random number generation s9.2.3.6 Compression s9.2.3.7 Security suite s9.2.4 Cryptographic keys – overview s9.2.5 Key used with symmetric key algorithms s9.2.5.1 Symmetric keys types s9.2.5.2 Key information with general-ciphering APDU and data protection s9.2.5.3 Key identification s9.2.5.4 Key wrapping s9.2.5.5 Key agreement s9.2.5.6 Symmetric key cryptoperiods s9.2.6 Keys used with public key algorithms s9.2.6.2 Key pair generation s9.2.6.3 Public key certificates and infrastructure s9.2.6.3.2 Trust model s9.2.6.3.3 PKI architecture – informative s9.2.6.4 Certificate and certificate extension profile s9.2.6.4.2 The X.509 v3 Certificate s9.2.6.5 Suite B end entity certificate types to be supported by DLMS servers s9.2.6.6 Management of certificates s9.2.6.6.2 Provisioning servers with trust anchors s9.2.6.6.3 Provisioning the server with further CA certificates s9.2.6.6.4 Security personalisation of the server s9.2.6.6.5 Provisioning servers with certificates of clients and third parties s9.2.6.6.6 Provisioning clients and third parties with certificates of servers s9.2.6.6.7 Certificate removal from the server s9.2.7 Applying cryptographic protection s9.2.7.2 Protecting xDLMS APDUs s9.2.7.2.2 Security policy and access rights values s9.2.7.2.3 Ciphered xDLMS APDUs s9.2.7.2.4 Encryption, authentication and compression s9.2.7.2.5 Digital signature s9.2.7.3 Multi-layer protection by multiple parties s9.2.7.4 HLS authentication mechanisms s9.2.7.5 Protecting COSEM data s9.3 DLMS/COSEM application layer service specification s9.3.1 Service primitives and parameters s9.3.2 The COSEM-OPEN service s9.3.2.3 Use s9.3.3 The COSEM-RELEASE service s9.3.4 The COSEM-ABORT service s9.3.5 Protection and general block transfer parameters s9.3.6 The GET service s9.3.7 The SET service s9.3.8 The ACTION service s9.3.9 The ACCESS service s9.3.9.2 Service specification s9.3.10 The DataNotification service s9.3.11 The EventNotification service s9.3.12 The TriggerEventNotificationSending service s9.3.13 Variable access specification s9.3.14 The Read service s9.3.15 The Write service s9.3.16 The UnconfirmedWrite service s9.3.17 The InformationReport service s9.3.18 Client side layer management services: the SetMapperTable.request s9.4 DLMS/COSEM application layer protocol specification s9.4.1 The control function (CF) s9.4.1.1 State definitions of the client side control function s9.4.1.2 State definitions of the server side control function s9.4.2 The ACSE services and APDUs s9.4.2.1 ACSE functional units, services and service parameters s9.4.2.2 Registered COSEM names s9.4.3 APDU encoding rules s9.4.3.1 Encoding of the ACSE APDUs s9.4.3.2 Encoding of the xDLMS APDUs s9.4.3.3 XML s9.4.4 Protocol for application association establishment s9.4.4.1 Protocol for the establishment of confirmed application associations s9.4.4.2 Repeated COSEM-OPEN service invocations s9.4.4.3 Establishment of unconfirmed application associations s9.4.4.4 Pre-established application associations s9.4.5 Protocol for application association release s9.4.6 Protocol for the data transfer services s9.4.6.1 Negotiation of services and options – the conformance block s9.4.6.2 Confirmed and unconfirmed xDLMS service invocations s9.4.6.3 Protocol for the GET service s9.4.6.4 Protocol for the SET service s9.4.6.5 Protocol for the ACTION service s9.4.6.6 Protocol for the ACCESS service s9.4.6.7 Protocol of the DataNotification service s9.4.6.8 Protocol for the EventNotification service s9.4.6.9 Protocol for the Read service s9.4.6.10 Protocol for the Write service s9.4.6.11 Protocol for the UnconfirmedWrite service s9.4.6.12 Protocol for the InformationReport service s9.4.6.13 Protocol of general block transfer mechanism s9.4.6.13.2 The GBT procedure s9.4.6.13.3 GBT procedure state variables s9.4.6.13.7 GBT protocol examples s9.4.6.13.8 Aborting the GBT procedure s9.4.6.14 Protocol of exception mechanism s9.5 Abstract syntax of COSEM PDUs s9.6 COSEM PDU XML schema s10 Using the DLMS/COSEM application layer in various communications profiles s10.1 Communication profile specific elements s10.2 The 3-layer, connection-oriented, HDLC based ommunication profile s10.2.2 The structure of the profile s10.2.3 Identification and addressing scheme s10.2.4 Supporting protocol layer services and service mapping s10.2.5 Communication profile specific service parameters of the DLMS/COSEM AL services s10.2.6 Specific considerations / constraints s10.2.6.1 Confirmed and unconfirmed AAs and data transfer service invocations, frame types used s10.2.6.2 Correspondence between AAs and data link layer connections, releasing AAs s10.2.6.3 Service parameters of the COSEM-OPEN / -RELEASE / -ABORT services s10.2.6.4 EventNotification service and protocol s10.2.6.5 Transporting long messages s10.2.6.6 Supporting multi-drop configurations s10.3 The TCP-UDP/IP based communication profiles (COSEM_on_IP) s10.3.6 Specific considerations / constraints s10.3.6.6 Transporting long messages s10.3.6.7 Allowing COSEM servers to establish the TCP connection s10.4 The CoAP based communication profile (DLMS/COSEM_on_CoAP) s10.4.3 Identification and addressing s10.4.4 Supporting layer services and service mapping s10.4.6 Specific considerations / constraints s10.8 LPWAN profile s10.9 Wi-SUN profile s10.10 Gateway protocol s11 AARQ and AARE encoding examples s12 Encoding examples: AARQ and AARE APDUs using a ciphered application context s13 S-FSK PLC encoding examples s14 Data transfer service examples s14.4 Profile generic IC buffer attribute encoding examples s14.4.3 Get-response with Profile generic null-data compressed encoding example s14.4.4 Get-response with Profile generic compact-array encoding example s14.4.5 Get-response with Profile generic null-data and delta-value encoding example" /><meta property="og:description" content="s1 Scope s3 Terms, definitions and abbreviations and symbols s3.1 General DLMS/COSEM definitions s4 Information exchange in DLMS/COSEM s4.1 General s4.2 Communication model s4.3 Naming and addressing s4.3.3 Addressing s4.3.4 System title s4.3.5 Logical Device Name s4.4 Connection oriented operation s4.5 Application associations s4.5.2 Application context s4.5.3 Authentication s4.5.4 xDLMS context s4.5.5 Security context s4.5.6 Access rights s4.6 Messaging patterns s4.8 Communication profiles s4.9 Model of a DLMS/COSEM system s4.10 Model of DLMS servers s4.11 Model of a DLMS client s4.12 Interoperability and interconnectivity in DLMS/COSEM s4.13 Ensuring interconnectivity: the protocol identification service s4.14 System integration and installation s5 Physical layer services and procedures for connection-oriented asynchronous data exchange s5.1 Overview s5.2 Service specification s5.2.1 List of services s5.2.2 Use of the physical layer services s5.2.3 Service definitions s5.3 Protocol specification s5.3.1 Physical layer protocol data unit s5.3.2 Transmission order and characteristics s5.3.3 Physical layer operation – description of the procedures s5.3.3.1 General s5.3.3.2 Setting up a physical connection s5.3.3.3 The Identification service s5.3.3.4 Data transfer s5.3.3.5 Disconnection of an existing physical connection s5.4 example: PhL service primitives and Hayes commands s6 Direct Local Connection s7 DLMS/COSEM transport layer for IP networks s7.2 The TCP-UDP/IP based transport layers s7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer s7.2.3.3.2 The wrapper protocol data unit (WPDU) s7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer sTCP-CONNECT sTCP-DISCONNECT sTCP-ABORT sTCP-DATA s7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer s7.2.4.3.5 Definition of the procedures s7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls s7.2.5.1 Transport layer and TCP connection establishment s7.2.5.2 Closing a transport layer and a TCP connection s7.2.5.3 TCP connection abort s7.2.5.4 Data transfer using the TCP-DATA service s7.3 The DLMS/COSEM CoAP based transport layer s7.3.2 Overview s7.3.3 Structure of the DLMS/COSEM CoAP transport layer s7.3.3.2 Identification and addressing s7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer sDLMS/COSEM CoAP transport layer SAPs s7.3.4 Service specification for the DLMS/COSEM CoAP transport layer s7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives s7.3.4.2.1 CoAP-DATA.request s7.3.4.2.2 CoAP-DATA.indication s7.3.4.2.2 CoAP-DATA.confirm s7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer s7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU) s7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU) s7.3.5.4 The Constrained Application Protocol (CoAP) s7.3.5.4.2 The CoAP Message s7.3.5.4.3 CoAP retransmission and response piggybacking s7.3.5.4.5 CoAP Block Transfer s7.3.5.5 Error Handling s7.3.5.5.2 CoAP protocol layers s7.3.5.5.3 CoAP wrapper layer s7.3.5.5.4 Propagation of errors through CoAP wrapper layer s7.3.5.6 DLMS/COSEM CoAP TL confirmations s7.3.5.7 CoAP wrapper state machine s7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context s7.3.5.7.4 CoAP-DATA.request invocation handling s7.3.5.7.5 Handling of incoming CWPDU or CoAP layer transmission failures s7.3.5.7.6 Garbage collection s7.3.6 DLMS/COSEM CoAP TL Data Transfers s7.3.6.2 General transfer of confirmed DLMS/COSEM AL service requests s7.3.6.3 Reliable DLMS/COSEM CoAP TL operation s7.3.6.4 Unreliable DLMS/COSEM CoAP TL operation s7.3.6.5 DLMS/COSEM CoAP Block Transfer operation s7.3.6.6 DLMS GBT operation over DLMS/COSEM CoAP TL s8 Data Link Layer using the HDLC protocol s8.1 Overview s8.1.2 Structure of the data link layer s8.1.3 Specification method s8.2 Service specification s8.2.2 Setting up the data link connection: the DL-CONNECT and MA-CONNECT services s8.2.2.2 DL-CONNECT.request and MA-CONNECT.request s8.2.2.3 DL-CONNECT.indication and MA-CONNECT.indication s8.2.2.4 DL-CONNECT.response and MA-CONNECT.response s8.2.2.5 DL-CONNECT.confirm and MA-CONNECT.confirm s8.2.3 Disconnecting the data link connection: the DL-DISCONNECT and MA-DISCONNECT services s8.2.3.2 DL-DISCONNECT.request and MA-DISCONNECT.request s8.2.3.3 DL-DISCONNECT.indication and MA-DISCONNECT.indication s8.2.3.4 DL-DISCONNECT.response and MA-DISCONNECT.response s8.2.3.5 DL-DISCONNECT.confirm and MA-DISCONNECT.confirm s8.2.4 Data transfer: the DL-DATA and MA-DATA services s8.2.4.2 DL-DATA.request and MA-DATA.request s8.2.4.3 DL-DATA.indication and MA-DATA.indication s8.2.4.4 DL-DATA.confirm and MA-DATA.confirm s8.2.5 Physical layer services used by the MAC sublayer s8.2.5.4 Data transfer s8.3 Protocol specification for the LLC sublayer s8.3.2 LLC PDU format s8.3.3 State transition tables for the LLC sublayer s8.4 Protocol specification for the MAC sublayer s8.4.1 The MAC PDU and the HDLC frame s8.4.1.1 HDLC frame format type 3 s8.4.2 MAC addressing s8.4.2.2 Address field structure s8.4.2.3 Reserved special HDLC addresses s8.4.2.4 Handling special addresses s8.4.2.5 Handling inopportune address lengths in the server s8.4.3 Command and response frames s8.4.4 Elements of the procedures s8.4.4.2 Transmission considerations s8.4.4.3 HDLC channel states s8.4.5 HDLC channel operation – Description of the procedures s8.4.5.2 Data station characteristics s8.4.5.3 Procedures for setting up and disconnecting the data link s8.4.5.4 Procedures for data exchange s8.4.5.5 Exception recovery s8.4.5.6 Time-outs and other MAC sublayer parameters s8.4.5.7 State transition diagram for the server MAC sublayer s8.5 FCS calculation s8.5.1 Test sequence for the FCS calculation s8.5.2 Fast frame check sequence (FCS) implementation s8.5.3 16-bit FCS computation method s8.6 Data link layer management services s9 DLMS/COSEM application layer s9.1 DLMS/COSEM application layer main features s9.1.2 DLMS/COSEM application layer structure s9.1.3 The Association Control Service Element, ACSE s9.1.4 The xDLMS application service element s9.1.4.2 The xDLMS initiate service s9.1.4.3 COSEM object related xDLMS services s9.1.4.3.2 xDLMS services used by the client with LN referencing s9.1.4.3.3 xDLMS services used by the client with SN referencing s9.1.4.3.4 Unsolicited services s9.1.4.3.5 Selective access s9.1.4.3.6 Multiple references s9.1.4.3.7 Attribute_0 referencing s9.1.4.4 Additional mechanisms s9.1.4.4.2 Referencing methods and service mapping s9.1.4.4.3 Identification of service invocations: the Invoke_Id parameter s9.1.4.4.4 Priority handling s9.1.4.4.5 Transferring long messages s9.1.4.4.6 Composable xDLMS messages s9.1.4.4.7 Compression and decompression s9.1.4.4.8 General protection sGeneral block transfer (GBT) s9.1.4.5 Additional data types s9.1.4.6 xDLMS version number s9.1.4.7 xDLMS conformance block s9.1.4.8 Maximum PDU size s9.1.5 Layer management services s9.1.6 Summary of DLMS/COSEM application layer services s9.1.7 DLMS/COSEM application layer protocols s9.2 Information security in DLMS/COSEM s9.2.2 The DLMS/COSEM security concept s9.2.2.2 Identification and authentication s9.2.2.2.1 Identification s9.2.2.2.2 Authentication mechanisms s9.2.2.3 Security context s9.2.2.4 Access rights s9.2.2.5 Application layer message security s9.2.2.6 COSEM data security s9.2.3 Cryptographic algorithms s9.2.3.2 Hash function s9.2.3.3 Symmetric key algorithms s9.2.3.3.2 Encryption and decryption s9.2.3.3.3 Advanced Encryption Standard s9.2.3.3.4 Encryption Modes of Operation s9.2.3.3.5 Message Authentication Code s9.2.3.3.6 Key wrapping s9.2.3.3.7 Galois/Counter Mode s9.2.3.3.8 AES key wrap s9.2.3.4 Public key algorithms s9.2.3.4.2 Elliptic curve cryptography s9.2.3.4.3 Data conversions s9.2.3.4.4 Digital signature s9.2.3.4.5 Elliptic curve digital signature (ECDSA) s9.2.3.4.6 Key agreement s9.2.3.5 Random number generation s9.2.3.6 Compression s9.2.3.7 Security suite s9.2.4 Cryptographic keys – overview s9.2.5 Key used with symmetric key algorithms s9.2.5.1 Symmetric keys types s9.2.5.2 Key information with general-ciphering APDU and data protection s9.2.5.3 Key identification s9.2.5.4 Key wrapping s9.2.5.5 Key agreement s9.2.5.6 Symmetric key cryptoperiods s9.2.6 Keys used with public key algorithms s9.2.6.2 Key pair generation s9.2.6.3 Public key certificates and infrastructure s9.2.6.3.2 Trust model s9.2.6.3.3 PKI architecture – informative s9.2.6.4 Certificate and certificate extension profile s9.2.6.4.2 The X.509 v3 Certificate s9.2.6.5 Suite B end entity certificate types to be supported by DLMS servers s9.2.6.6 Management of certificates s9.2.6.6.2 Provisioning servers with trust anchors s9.2.6.6.3 Provisioning the server with further CA certificates s9.2.6.6.4 Security personalisation of the server s9.2.6.6.5 Provisioning servers with certificates of clients and third parties s9.2.6.6.6 Provisioning clients and third parties with certificates of servers s9.2.6.6.7 Certificate removal from the server s9.2.7 Applying cryptographic protection s9.2.7.2 Protecting xDLMS APDUs s9.2.7.2.2 Security policy and access rights values s9.2.7.2.3 Ciphered xDLMS APDUs s9.2.7.2.4 Encryption, authentication and compression s9.2.7.2.5 Digital signature s9.2.7.3 Multi-layer protection by multiple parties s9.2.7.4 HLS authentication mechanisms s9.2.7.5 Protecting COSEM data s9.3 DLMS/COSEM application layer service specification s9.3.1 Service primitives and parameters s9.3.2 The COSEM-OPEN service s9.3.2.3 Use s9.3.3 The COSEM-RELEASE service s9.3.4 The COSEM-ABORT service s9.3.5 Protection and general block transfer parameters s9.3.6 The GET service s9.3.7 The SET service s9.3.8 The ACTION service s9.3.9 The ACCESS service s9.3.9.2 Service specification s9.3.10 The DataNotification service s9.3.11 The EventNotification service s9.3.12 The TriggerEventNotificationSending service s9.3.13 Variable access specification s9.3.14 The Read service s9.3.15 The Write service s9.3.16 The UnconfirmedWrite service s9.3.17 The InformationReport service s9.3.18 Client side layer management services: the SetMapperTable.request s9.4 DLMS/COSEM application layer protocol specification s9.4.1 The control function (CF) s9.4.1.1 State definitions of the client side control function s9.4.1.2 State definitions of the server side control function s9.4.2 The ACSE services and APDUs s9.4.2.1 ACSE functional units, services and service parameters s9.4.2.2 Registered COSEM names s9.4.3 APDU encoding rules s9.4.3.1 Encoding of the ACSE APDUs s9.4.3.2 Encoding of the xDLMS APDUs s9.4.3.3 XML s9.4.4 Protocol for application association establishment s9.4.4.1 Protocol for the establishment of confirmed application associations s9.4.4.2 Repeated COSEM-OPEN service invocations s9.4.4.3 Establishment of unconfirmed application associations s9.4.4.4 Pre-established application associations s9.4.5 Protocol for application association release s9.4.6 Protocol for the data transfer services s9.4.6.1 Negotiation of services and options – the conformance block s9.4.6.2 Confirmed and unconfirmed xDLMS service invocations s9.4.6.3 Protocol for the GET service s9.4.6.4 Protocol for the SET service s9.4.6.5 Protocol for the ACTION service s9.4.6.6 Protocol for the ACCESS service s9.4.6.7 Protocol of the DataNotification service s9.4.6.8 Protocol for the EventNotification service s9.4.6.9 Protocol for the Read service s9.4.6.10 Protocol for the Write service s9.4.6.11 Protocol for the UnconfirmedWrite service s9.4.6.12 Protocol for the InformationReport service s9.4.6.13 Protocol of general block transfer mechanism s9.4.6.13.2 The GBT procedure s9.4.6.13.3 GBT procedure state variables s9.4.6.13.7 GBT protocol examples s9.4.6.13.8 Aborting the GBT procedure s9.4.6.14 Protocol of exception mechanism s9.5 Abstract syntax of COSEM PDUs s9.6 COSEM PDU XML schema s10 Using the DLMS/COSEM application layer in various communications profiles s10.1 Communication profile specific elements s10.2 The 3-layer, connection-oriented, HDLC based ommunication profile s10.2.2 The structure of the profile s10.2.3 Identification and addressing scheme s10.2.4 Supporting protocol layer services and service mapping s10.2.5 Communication profile specific service parameters of the DLMS/COSEM AL services s10.2.6 Specific considerations / constraints s10.2.6.1 Confirmed and unconfirmed AAs and data transfer service invocations, frame types used s10.2.6.2 Correspondence between AAs and data link layer connections, releasing AAs s10.2.6.3 Service parameters of the COSEM-OPEN / -RELEASE / -ABORT services s10.2.6.4 EventNotification service and protocol s10.2.6.5 Transporting long messages s10.2.6.6 Supporting multi-drop configurations s10.3 The TCP-UDP/IP based communication profiles (COSEM_on_IP) s10.3.6 Specific considerations / constraints s10.3.6.6 Transporting long messages s10.3.6.7 Allowing COSEM servers to establish the TCP connection s10.4 The CoAP based communication profile (DLMS/COSEM_on_CoAP) s10.4.3 Identification and addressing s10.4.4 Supporting layer services and service mapping s10.4.6 Specific considerations / constraints s10.8 LPWAN profile s10.9 Wi-SUN profile s10.10 Gateway protocol s11 AARQ and AARE encoding examples s12 Encoding examples: AARQ and AARE APDUs using a ciphered application context s13 S-FSK PLC encoding examples s14 Data transfer service examples s14.4 Profile generic IC buffer attribute encoding examples s14.4.3 Get-response with Profile generic null-data compressed encoding example s14.4.4 Get-response with Profile generic compact-array encoding example s14.4.5 Get-response with Profile generic null-data and delta-value encoding example" /><link rel="canonical" href="https://hjk.life/posts/dlms-green-1/" /><meta property="og:url" content="https://hjk.life/posts/dlms-green-1/" /><meta property="og:site_name" content="普通人" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-19T09:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DLMS Green Book学习笔记" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jinkai" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jinkai"},"dateModified":"2022-09-27T14:32:10+08:00","datePublished":"2022-04-19T09:00:00+08:00","description":"s1 Scope s3 Terms, definitions and abbreviations and symbols s3.1 General DLMS/COSEM definitions s4 Information exchange in DLMS/COSEM s4.1 General s4.2 Communication model s4.3 Naming and addressing s4.3.3 Addressing s4.3.4 System title s4.3.5 Logical Device Name s4.4 Connection oriented operation s4.5 Application associations s4.5.2 Application context s4.5.3 Authentication s4.5.4 xDLMS context s4.5.5 Security context s4.5.6 Access rights s4.6 Messaging patterns s4.8 Communication profiles s4.9 Model of a DLMS/COSEM system s4.10 Model of DLMS servers s4.11 Model of a DLMS client s4.12 Interoperability and interconnectivity in DLMS/COSEM s4.13 Ensuring interconnectivity: the protocol identification service s4.14 System integration and installation s5 Physical layer services and procedures for connection-oriented asynchronous data exchange s5.1 Overview s5.2 Service specification s5.2.1 List of services s5.2.2 Use of the physical layer services s5.2.3 Service definitions s5.3 Protocol specification s5.3.1 Physical layer protocol data unit s5.3.2 Transmission order and characteristics s5.3.3 Physical layer operation – description of the procedures s5.3.3.1 General s5.3.3.2 Setting up a physical connection s5.3.3.3 The Identification service s5.3.3.4 Data transfer s5.3.3.5 Disconnection of an existing physical connection s5.4 example: PhL service primitives and Hayes commands s6 Direct Local Connection s7 DLMS/COSEM transport layer for IP networks s7.2 The TCP-UDP/IP based transport layers s7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer s7.2.3.3.2 The wrapper protocol data unit (WPDU) s7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer sTCP-CONNECT sTCP-DISCONNECT sTCP-ABORT sTCP-DATA s7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer s7.2.4.3.5 Definition of the procedures s7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls s7.2.5.1 Transport layer and TCP connection establishment s7.2.5.2 Closing a transport layer and a TCP connection s7.2.5.3 TCP connection abort s7.2.5.4 Data transfer using the TCP-DATA service s7.3 The DLMS/COSEM CoAP based transport layer s7.3.2 Overview s7.3.3 Structure of the DLMS/COSEM CoAP transport layer s7.3.3.2 Identification and addressing s7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer sDLMS/COSEM CoAP transport layer SAPs s7.3.4 Service specification for the DLMS/COSEM CoAP transport layer s7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives s7.3.4.2.1 CoAP-DATA.request s7.3.4.2.2 CoAP-DATA.indication s7.3.4.2.2 CoAP-DATA.confirm s7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer s7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU) s7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU) s7.3.5.4 The Constrained Application Protocol (CoAP) s7.3.5.4.2 The CoAP Message s7.3.5.4.3 CoAP retransmission and response piggybacking s7.3.5.4.5 CoAP Block Transfer s7.3.5.5 Error Handling s7.3.5.5.2 CoAP protocol layers s7.3.5.5.3 CoAP wrapper layer s7.3.5.5.4 Propagation of errors through CoAP wrapper layer s7.3.5.6 DLMS/COSEM CoAP TL confirmations s7.3.5.7 CoAP wrapper state machine s7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context s7.3.5.7.4 CoAP-DATA.request invocation handling s7.3.5.7.5 Handling of incoming CWPDU or CoAP layer transmission failures s7.3.5.7.6 Garbage collection s7.3.6 DLMS/COSEM CoAP TL Data Transfers s7.3.6.2 General transfer of confirmed DLMS/COSEM AL service requests s7.3.6.3 Reliable DLMS/COSEM CoAP TL operation s7.3.6.4 Unreliable DLMS/COSEM CoAP TL operation s7.3.6.5 DLMS/COSEM CoAP Block Transfer operation s7.3.6.6 DLMS GBT operation over DLMS/COSEM CoAP TL s8 Data Link Layer using the HDLC protocol s8.1 Overview s8.1.2 Structure of the data link layer s8.1.3 Specification method s8.2 Service specification s8.2.2 Setting up the data link connection: the DL-CONNECT and MA-CONNECT services s8.2.2.2 DL-CONNECT.request and MA-CONNECT.request s8.2.2.3 DL-CONNECT.indication and MA-CONNECT.indication s8.2.2.4 DL-CONNECT.response and MA-CONNECT.response s8.2.2.5 DL-CONNECT.confirm and MA-CONNECT.confirm s8.2.3 Disconnecting the data link connection: the DL-DISCONNECT and MA-DISCONNECT services s8.2.3.2 DL-DISCONNECT.request and MA-DISCONNECT.request s8.2.3.3 DL-DISCONNECT.indication and MA-DISCONNECT.indication s8.2.3.4 DL-DISCONNECT.response and MA-DISCONNECT.response s8.2.3.5 DL-DISCONNECT.confirm and MA-DISCONNECT.confirm s8.2.4 Data transfer: the DL-DATA and MA-DATA services s8.2.4.2 DL-DATA.request and MA-DATA.request s8.2.4.3 DL-DATA.indication and MA-DATA.indication s8.2.4.4 DL-DATA.confirm and MA-DATA.confirm s8.2.5 Physical layer services used by the MAC sublayer s8.2.5.4 Data transfer s8.3 Protocol specification for the LLC sublayer s8.3.2 LLC PDU format s8.3.3 State transition tables for the LLC sublayer s8.4 Protocol specification for the MAC sublayer s8.4.1 The MAC PDU and the HDLC frame s8.4.1.1 HDLC frame format type 3 s8.4.2 MAC addressing s8.4.2.2 Address field structure s8.4.2.3 Reserved special HDLC addresses s8.4.2.4 Handling special addresses s8.4.2.5 Handling inopportune address lengths in the server s8.4.3 Command and response frames s8.4.4 Elements of the procedures s8.4.4.2 Transmission considerations s8.4.4.3 HDLC channel states s8.4.5 HDLC channel operation – Description of the procedures s8.4.5.2 Data station characteristics s8.4.5.3 Procedures for setting up and disconnecting the data link s8.4.5.4 Procedures for data exchange s8.4.5.5 Exception recovery s8.4.5.6 Time-outs and other MAC sublayer parameters s8.4.5.7 State transition diagram for the server MAC sublayer s8.5 FCS calculation s8.5.1 Test sequence for the FCS calculation s8.5.2 Fast frame check sequence (FCS) implementation s8.5.3 16-bit FCS computation method s8.6 Data link layer management services s9 DLMS/COSEM application layer s9.1 DLMS/COSEM application layer main features s9.1.2 DLMS/COSEM application layer structure s9.1.3 The Association Control Service Element, ACSE s9.1.4 The xDLMS application service element s9.1.4.2 The xDLMS initiate service s9.1.4.3 COSEM object related xDLMS services s9.1.4.3.2 xDLMS services used by the client with LN referencing s9.1.4.3.3 xDLMS services used by the client with SN referencing s9.1.4.3.4 Unsolicited services s9.1.4.3.5 Selective access s9.1.4.3.6 Multiple references s9.1.4.3.7 Attribute_0 referencing s9.1.4.4 Additional mechanisms s9.1.4.4.2 Referencing methods and service mapping s9.1.4.4.3 Identification of service invocations: the Invoke_Id parameter s9.1.4.4.4 Priority handling s9.1.4.4.5 Transferring long messages s9.1.4.4.6 Composable xDLMS messages s9.1.4.4.7 Compression and decompression s9.1.4.4.8 General protection sGeneral block transfer (GBT) s9.1.4.5 Additional data types s9.1.4.6 xDLMS version number s9.1.4.7 xDLMS conformance block s9.1.4.8 Maximum PDU size s9.1.5 Layer management services s9.1.6 Summary of DLMS/COSEM application layer services s9.1.7 DLMS/COSEM application layer protocols s9.2 Information security in DLMS/COSEM s9.2.2 The DLMS/COSEM security concept s9.2.2.2 Identification and authentication s9.2.2.2.1 Identification s9.2.2.2.2 Authentication mechanisms s9.2.2.3 Security context s9.2.2.4 Access rights s9.2.2.5 Application layer message security s9.2.2.6 COSEM data security s9.2.3 Cryptographic algorithms s9.2.3.2 Hash function s9.2.3.3 Symmetric key algorithms s9.2.3.3.2 Encryption and decryption s9.2.3.3.3 Advanced Encryption Standard s9.2.3.3.4 Encryption Modes of Operation s9.2.3.3.5 Message Authentication Code s9.2.3.3.6 Key wrapping s9.2.3.3.7 Galois/Counter Mode s9.2.3.3.8 AES key wrap s9.2.3.4 Public key algorithms s9.2.3.4.2 Elliptic curve cryptography s9.2.3.4.3 Data conversions s9.2.3.4.4 Digital signature s9.2.3.4.5 Elliptic curve digital signature (ECDSA) s9.2.3.4.6 Key agreement s9.2.3.5 Random number generation s9.2.3.6 Compression s9.2.3.7 Security suite s9.2.4 Cryptographic keys – overview s9.2.5 Key used with symmetric key algorithms s9.2.5.1 Symmetric keys types s9.2.5.2 Key information with general-ciphering APDU and data protection s9.2.5.3 Key identification s9.2.5.4 Key wrapping s9.2.5.5 Key agreement s9.2.5.6 Symmetric key cryptoperiods s9.2.6 Keys used with public key algorithms s9.2.6.2 Key pair generation s9.2.6.3 Public key certificates and infrastructure s9.2.6.3.2 Trust model s9.2.6.3.3 PKI architecture – informative s9.2.6.4 Certificate and certificate extension profile s9.2.6.4.2 The X.509 v3 Certificate s9.2.6.5 Suite B end entity certificate types to be supported by DLMS servers s9.2.6.6 Management of certificates s9.2.6.6.2 Provisioning servers with trust anchors s9.2.6.6.3 Provisioning the server with further CA certificates s9.2.6.6.4 Security personalisation of the server s9.2.6.6.5 Provisioning servers with certificates of clients and third parties s9.2.6.6.6 Provisioning clients and third parties with certificates of servers s9.2.6.6.7 Certificate removal from the server s9.2.7 Applying cryptographic protection s9.2.7.2 Protecting xDLMS APDUs s9.2.7.2.2 Security policy and access rights values s9.2.7.2.3 Ciphered xDLMS APDUs s9.2.7.2.4 Encryption, authentication and compression s9.2.7.2.5 Digital signature s9.2.7.3 Multi-layer protection by multiple parties s9.2.7.4 HLS authentication mechanisms s9.2.7.5 Protecting COSEM data s9.3 DLMS/COSEM application layer service specification s9.3.1 Service primitives and parameters s9.3.2 The COSEM-OPEN service s9.3.2.3 Use s9.3.3 The COSEM-RELEASE service s9.3.4 The COSEM-ABORT service s9.3.5 Protection and general block transfer parameters s9.3.6 The GET service s9.3.7 The SET service s9.3.8 The ACTION service s9.3.9 The ACCESS service s9.3.9.2 Service specification s9.3.10 The DataNotification service s9.3.11 The EventNotification service s9.3.12 The TriggerEventNotificationSending service s9.3.13 Variable access specification s9.3.14 The Read service s9.3.15 The Write service s9.3.16 The UnconfirmedWrite service s9.3.17 The InformationReport service s9.3.18 Client side layer management services: the SetMapperTable.request s9.4 DLMS/COSEM application layer protocol specification s9.4.1 The control function (CF) s9.4.1.1 State definitions of the client side control function s9.4.1.2 State definitions of the server side control function s9.4.2 The ACSE services and APDUs s9.4.2.1 ACSE functional units, services and service parameters s9.4.2.2 Registered COSEM names s9.4.3 APDU encoding rules s9.4.3.1 Encoding of the ACSE APDUs s9.4.3.2 Encoding of the xDLMS APDUs s9.4.3.3 XML s9.4.4 Protocol for application association establishment s9.4.4.1 Protocol for the establishment of confirmed application associations s9.4.4.2 Repeated COSEM-OPEN service invocations s9.4.4.3 Establishment of unconfirmed application associations s9.4.4.4 Pre-established application associations s9.4.5 Protocol for application association release s9.4.6 Protocol for the data transfer services s9.4.6.1 Negotiation of services and options – the conformance block s9.4.6.2 Confirmed and unconfirmed xDLMS service invocations s9.4.6.3 Protocol for the GET service s9.4.6.4 Protocol for the SET service s9.4.6.5 Protocol for the ACTION service s9.4.6.6 Protocol for the ACCESS service s9.4.6.7 Protocol of the DataNotification service s9.4.6.8 Protocol for the EventNotification service s9.4.6.9 Protocol for the Read service s9.4.6.10 Protocol for the Write service s9.4.6.11 Protocol for the UnconfirmedWrite service s9.4.6.12 Protocol for the InformationReport service s9.4.6.13 Protocol of general block transfer mechanism s9.4.6.13.2 The GBT procedure s9.4.6.13.3 GBT procedure state variables s9.4.6.13.7 GBT protocol examples s9.4.6.13.8 Aborting the GBT procedure s9.4.6.14 Protocol of exception mechanism s9.5 Abstract syntax of COSEM PDUs s9.6 COSEM PDU XML schema s10 Using the DLMS/COSEM application layer in various communications profiles s10.1 Communication profile specific elements s10.2 The 3-layer, connection-oriented, HDLC based ommunication profile s10.2.2 The structure of the profile s10.2.3 Identification and addressing scheme s10.2.4 Supporting protocol layer services and service mapping s10.2.5 Communication profile specific service parameters of the DLMS/COSEM AL services s10.2.6 Specific considerations / constraints s10.2.6.1 Confirmed and unconfirmed AAs and data transfer service invocations, frame types used s10.2.6.2 Correspondence between AAs and data link layer connections, releasing AAs s10.2.6.3 Service parameters of the COSEM-OPEN / -RELEASE / -ABORT services s10.2.6.4 EventNotification service and protocol s10.2.6.5 Transporting long messages s10.2.6.6 Supporting multi-drop configurations s10.3 The TCP-UDP/IP based communication profiles (COSEM_on_IP) s10.3.6 Specific considerations / constraints s10.3.6.6 Transporting long messages s10.3.6.7 Allowing COSEM servers to establish the TCP connection s10.4 The CoAP based communication profile (DLMS/COSEM_on_CoAP) s10.4.3 Identification and addressing s10.4.4 Supporting layer services and service mapping s10.4.6 Specific considerations / constraints s10.8 LPWAN profile s10.9 Wi-SUN profile s10.10 Gateway protocol s11 AARQ and AARE encoding examples s12 Encoding examples: AARQ and AARE APDUs using a ciphered application context s13 S-FSK PLC encoding examples s14 Data transfer service examples s14.4 Profile generic IC buffer attribute encoding examples s14.4.3 Get-response with Profile generic null-data compressed encoding example s14.4.4 Get-response with Profile generic compact-array encoding example s14.4.5 Get-response with Profile generic null-data and delta-value encoding example","headline":"DLMS Green Book学习笔记","mainEntityOfPage":{"@type":"WebPage","@id":"https://hjk.life/posts/dlms-green-1/"},"url":"https://hjk.life/posts/dlms-green-1/"}</script><title>DLMS Green Book学习笔记 | 普通人</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="普通人"><meta name="application-name" content="普通人"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/favicons/Humanity.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">普通人</a></div><div class="site-subtitle font-italic">潜龙勿用</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/prophethjk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['prophethjk','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>DLMS Green Book学习笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img data-src="/assets/img/2022-03-17-dlms-green-1/dlms.jpg" class="preview-img bg" alt="image alternative text" data-proofer-ignore><h1 data-toc-skip>DLMS Green Book学习笔记</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/prophethjk">Jinkai</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1650330000" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-19 </em> </span> <span> 更新于 <em class="timeago" data-ts="1664260330" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-09-27 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="43743 字"> <em>243 分钟</em>阅读</span></div></div></div><div class="post-content"><ul><li><a href="#s1-scope">s1 Scope</a><li><a href="#s3-terms-definitions-and-abbreviations-and-symbols">s3 Terms, definitions and abbreviations and symbols</a><ul><li><a href="#s31-general-dlmscosem-definitions">s3.1 General DLMS/COSEM definitions</a></ul><li><a href="#s4-information-exchange-in-dlmscosem">s4 Information exchange in DLMS/COSEM</a><ul><li><a href="#s41-general">s4.1 General</a><li><a href="#s42-communication-model">s4.2 Communication model</a><li><a href="#s43-naming-and-addressing">s4.3 Naming and addressing</a><ul><li><a href="#s433-addressing">s4.3.3 Addressing</a><li><a href="#s434-system-title">s4.3.4 System title</a><li><a href="#s435-logical-device-name">s4.3.5 Logical Device Name</a></ul><li><a href="#s44-connection-oriented-operation">s4.4 Connection oriented operation</a><li><a href="#s45-application-associations">s4.5 Application associations</a><ul><li><a href="#s452-application-context">s4.5.2 Application context</a><li><a href="#s453-authentication">s4.5.3 Authentication</a><li><a href="#s454-xdlms-context">s4.5.4 xDLMS context</a><li><a href="#s455-security-context">s4.5.5 Security context</a><li><a href="#s456-access-rights">s4.5.6 Access rights</a></ul><li><a href="#s46-messaging-patterns">s4.6 Messaging patterns</a><li><a href="#s48-communication-profiles">s4.8 Communication profiles</a><li><a href="#s49-model-of-a-dlmscosem-system">s4.9 Model of a DLMS/COSEM system</a><li><a href="#s410-model-of-dlms-servers">s4.10 Model of DLMS servers</a><li><a href="#s411-model-of-a-dlms-client">s4.11 Model of a DLMS client</a><li><a href="#s412-interoperability-and-interconnectivity-in-dlmscosem">s4.12 Interoperability and interconnectivity in DLMS/COSEM</a><li><a href="#s413-ensuring-interconnectivity-the-protocol-identification-service">s4.13 Ensuring interconnectivity: the protocol identification service</a><li><a href="#s414-system-integration-and-installation">s4.14 System integration and installation</a></ul><li><a href="#s5-physical-layer-services-and-procedures-for-connection-oriented-asynchronous-data-exchange">s5 Physical layer services and procedures for connection-oriented asynchronous data exchange</a><ul><li><a href="#s51-overview">s5.1 Overview</a><li><a href="#s52-service-specification">s5.2 Service specification</a><ul><li><a href="#s521-list-of-services">s5.2.1 List of services</a><li><a href="#s522-use-of-the-physical-layer-services">s5.2.2 Use of the physical layer services</a><li><a href="#s523-service-definitions">s5.2.3 Service definitions</a></ul><li><a href="#s53-protocol-specification">s5.3 Protocol specification</a><ul><li><a href="#s531-physical-layer-protocol-data-unit">s5.3.1 Physical layer protocol data unit</a><li><a href="#s532-transmission-order-and-characteristics">s5.3.2 Transmission order and characteristics</a><li><a href="#s533-physical-layer-operation--description-of-the-procedures">s5.3.3 Physical layer operation – description of the procedures</a><ul><li><a href="#s5331-general">s5.3.3.1 General</a><li><a href="#s5332-setting-up-a-physical-connection">s5.3.3.2 Setting up a physical connection</a><li><a href="#s5333-the-identification-service">s5.3.3.3 The Identification service</a><li><a href="#s5334-data-transfer">s5.3.3.4 Data transfer</a><li><a href="#s5335-disconnection-of-an-existing-physical-connection">s5.3.3.5 Disconnection of an existing physical connection</a></ul></ul><li><a href="#s54-example-phl-service-primitives-and-hayes-commands">s5.4 example: PhL service primitives and Hayes commands</a></ul><li><a href="#s6-direct-local-connection">s6 Direct Local Connection</a><li><a href="#s7-dlmscosem-transport-layer-for-ip-networks">s7 DLMS/COSEM transport layer for IP networks</a><ul><li><a href="#s72-the-tcp-udpip-based-transport-layers">s7.2 The TCP-UDP/IP based transport layers</a><ul><li><a href="#s723-the-dlmscosem-connection-less-udp-based-transport-layer">s7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer</a><li><a href="#s72332-the-wrapper-protocol-data-unit-wpdu">s7.2.3.3.2 The wrapper protocol data unit (WPDU)</a><li><a href="#s724-the-dlmscosem-connection-oriented-tcp-based-transport-layer">s7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer</a><ul><li><a href="#stcp-connect">sTCP-CONNECT</a><li><a href="#stcp-disconnect">sTCP-DISCONNECT</a><li><a href="#stcp-abort">sTCP-ABORT</a><li><a href="#stcp-data">sTCP-DATA</a><li><a href="#s7243-protocol-specification-for-the-dlmscosem-tcp-based-transport-layer">s7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer</a><ul><li><a href="#s72435-definition-of-the-procedures">s7.2.4.3.5 Definition of the procedures</a></ul></ul><li><a href="#s725-converting-osi-style-tl-services-to-and-from-rfc-style-tcp-function-calls">s7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls</a><ul><li><a href="#s7251-transport-layer-and-tcp-connection-establishment">s7.2.5.1 Transport layer and TCP connection establishment</a><li><a href="#s7252-closing-a-transport-layer-and-a-tcp-connection">s7.2.5.2 Closing a transport layer and a TCP connection</a><li><a href="#s7253-tcp-connection-abort">s7.2.5.3 TCP connection abort</a><li><a href="#s7254-data-transfer-using-the-tcp-data-service">s7.2.5.4 Data transfer using the TCP-DATA service</a></ul></ul><li><a href="#s73-the-dlmscosem-coap-based-transport-layer">s7.3 The DLMS/COSEM CoAP based transport layer</a><ul><li><a href="#s732-overview">s7.3.2 Overview</a><li><a href="#s733-structure-of-the-dlmscosem-coap-transport-layer">s7.3.3 Structure of the DLMS/COSEM CoAP transport layer</a><ul><li><a href="#s7332-identification-and-addressing">s7.3.3.2 Identification and addressing</a><ul><li><a href="#s73322-dlmscosem-al-identification-within-the-coap-transport-layer">s7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer</a><li><a href="#sdlmscosem-coap-transport-layer-saps">sDLMS/COSEM CoAP transport layer SAPs</a></ul></ul><li><a href="#s734-service-specification-for-the-dlmscosem-coap-transport-layer">s7.3.4 Service specification for the DLMS/COSEM CoAP transport layer</a><ul><li><a href="#s7342-the-dlmscosem-coap-data-service-primitives">s7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives</a><ul><li><a href="#s73421-coap-datarequest">s7.3.4.2.1 CoAP-DATA.request</a><li><a href="#s73422-coap-dataindication">s7.3.4.2.2 CoAP-DATA.indication</a><li><a href="#s73422-coap-dataconfirm">s7.3.4.2.2 CoAP-DATA.confirm</a></ul></ul><li><a href="#s735-protocol-specification-of-the-dlmscosem-coap-transport-layer">s7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer</a><ul><li><a href="#s7352-the-dlmscosem-coap-tl-protocol-data-unit-coap-pdu">s7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU)</a><li><a href="#s7353-the-dlmscosem-coap-wrapper-protocol-data-unit-cwpdu">s7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU)</a><li><a href="#s7354-the-constrained-application-protocol-coap">s7.3.5.4 The Constrained Application Protocol (CoAP)</a><ul><li><a href="#s73542-the-coap-message">s7.3.5.4.2 The CoAP Message</a><li><a href="#s73543-coap-retransmission-and-response-piggybacking">s7.3.5.4.3 CoAP retransmission and response piggybacking</a><li><a href="#s73545-coap-block-transfer">s7.3.5.4.5 CoAP Block Transfer</a></ul><li><a href="#s7355-error-handling">s7.3.5.5 Error Handling</a><ul><li><a href="#s73552-coap-protocol-layers">s7.3.5.5.2 CoAP protocol layers</a><li><a href="#s73553-coap-wrapper-layer">s7.3.5.5.3 CoAP wrapper layer</a><li><a href="#s73554-propagation-of-errors-through-coap-wrapper-layer">s7.3.5.5.4 Propagation of errors through CoAP wrapper layer</a></ul><li><a href="#s7356-dlmscosem-coap-tl-confirmations">s7.3.5.6 DLMS/COSEM CoAP TL confirmations</a><li><a href="#s7357-coap-wrapper-state-machine">s7.3.5.7 CoAP wrapper state machine</a><ul><li><a href="#s73572-coap-dlmscosem-wrapper-requestresponse-context">s7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context</a><li><a href="#s73574-coap-datarequest-invocation-handling">s7.3.5.7.4 CoAP-DATA.request invocation handling</a><li><a href="#s73575-handling-of-incoming-cwpdu-or-coap-layer-transmission-failures">s7.3.5.7.5 Handling of incoming CWPDU or CoAP layer transmission failures</a><li><a href="#s73576-garbage-collection">s7.3.5.7.6 Garbage collection</a></ul></ul><li><a href="#s736-dlmscosem-coap-tl-data-transfers">s7.3.6 DLMS/COSEM CoAP TL Data Transfers</a><ul><li><a href="#s7362-general-transfer-of-confirmed-dlmscosem-al-service-requests">s7.3.6.2 General transfer of confirmed DLMS/COSEM AL service requests</a><li><a href="#s7363-reliable-dlmscosem-coap-tl-operation">s7.3.6.3 Reliable DLMS/COSEM CoAP TL operation</a><li><a href="#s7364-unreliable-dlmscosem-coap-tl-operation">s7.3.6.4 Unreliable DLMS/COSEM CoAP TL operation</a><li><a href="#s7365-dlmscosem-coap-block-transfer-operation">s7.3.6.5 DLMS/COSEM CoAP Block Transfer operation</a><li><a href="#s7366-dlms-gbt-operation-over-dlmscosem-coap-tl">s7.3.6.6 DLMS GBT operation over DLMS/COSEM CoAP TL</a></ul></ul></ul><li><a href="#s8-data-link-layer-using-the-hdlc-protocol">s8 Data Link Layer using the HDLC protocol</a><ul><li><a href="#s81-overview">s8.1 Overview</a><ul><li><a href="#s812-structure-of-the-data-link-layer">s8.1.2 Structure of the data link layer</a><li><a href="#s813-specification-method">s8.1.3 Specification method</a></ul><li><a href="#s82-service-specification">s8.2 Service specification</a><ul><li><a href="#s822-setting-up-the-data-link-connection-the-dl-connect-and-ma-connect-services">s8.2.2 Setting up the data link connection: the DL-CONNECT and MA-CONNECT services</a><ul><li><a href="#s8222-dl-connectrequest-and-ma-connectrequest">s8.2.2.2 DL-CONNECT.request and MA-CONNECT.request</a><li><a href="#s8223-dl-connectindication-and-ma-connectindication">s8.2.2.3 DL-CONNECT.indication and MA-CONNECT.indication</a><li><a href="#s8224-dl-connectresponse-and-ma-connectresponse">s8.2.2.4 DL-CONNECT.response and MA-CONNECT.response</a><li><a href="#s8225-dl-connectconfirm-and-ma-connectconfirm">s8.2.2.5 DL-CONNECT.confirm and MA-CONNECT.confirm</a></ul><li><a href="#s823-disconnecting-the-data-link-connection-the-dl-disconnect-and-ma-disconnect-services">s8.2.3 Disconnecting the data link connection: the DL-DISCONNECT and MA-DISCONNECT services</a><ul><li><a href="#s8232-dl-disconnectrequest-and-ma-disconnectrequest">s8.2.3.2 DL-DISCONNECT.request and MA-DISCONNECT.request</a><li><a href="#s8233-dl-disconnectindication-and-ma-disconnectindication">s8.2.3.3 DL-DISCONNECT.indication and MA-DISCONNECT.indication</a><li><a href="#s8234-dl-disconnectresponse-and-ma-disconnectresponse">s8.2.3.4 DL-DISCONNECT.response and MA-DISCONNECT.response</a><li><a href="#s8235-dl-disconnectconfirm-and-ma-disconnectconfirm">s8.2.3.5 DL-DISCONNECT.confirm and MA-DISCONNECT.confirm</a></ul><li><a href="#s824-data-transfer-the-dl-data-and-ma-data-services">s8.2.4 Data transfer: the DL-DATA and MA-DATA services</a><ul><li><a href="#s8242-dl-datarequest-and-ma-datarequest">s8.2.4.2 DL-DATA.request and MA-DATA.request</a><li><a href="#s8243-dl-dataindication-and-ma-dataindication">s8.2.4.3 DL-DATA.indication and MA-DATA.indication</a><li><a href="#s8244-dl-dataconfirm-and-ma-dataconfirm">s8.2.4.4 DL-DATA.confirm and MA-DATA.confirm</a></ul><li><a href="#s825-physical-layer-services-used-by-the-mac-sublayer">s8.2.5 Physical layer services used by the MAC sublayer</a><ul><li><a href="#s8254-data-transfer">s8.2.5.4 Data transfer</a></ul></ul><li><a href="#s83-protocol-specification-for-the-llc-sublayer">s8.3 Protocol specification for the LLC sublayer</a><ul><li><a href="#s832-llc-pdu-format">s8.3.2 LLC PDU format</a><li><a href="#s833-state-transition-tables-for-the-llc-sublayer">s8.3.3 State transition tables for the LLC sublayer</a></ul><li><a href="#s84-protocol-specification-for-the-mac-sublayer">s8.4 Protocol specification for the MAC sublayer</a><ul><li><a href="#s841-the-mac-pdu-and-the-hdlc-frame">s8.4.1 The MAC PDU and the HDLC frame</a><ul><li><a href="#s8411-hdlc-frame-format-type-3">s8.4.1.1 HDLC frame format type 3</a></ul><li><a href="#s842-mac-addressing">s8.4.2 MAC addressing</a><ul><li><a href="#s8422-address-field-structure">s8.4.2.2 Address field structure</a><li><a href="#s8423-reserved-special-hdlc-addresses">s8.4.2.3 Reserved special HDLC addresses</a><li><a href="#s8424-handling-special-addresses">s8.4.2.4 Handling special addresses</a><li><a href="#s8425-handling-inopportune-address-lengths-in-the-server">s8.4.2.5 Handling inopportune address lengths in the server</a></ul><li><a href="#s843-command-and-response-frames">s8.4.3 Command and response frames</a><li><a href="#s844-elements-of-the-procedures">s8.4.4 Elements of the procedures</a><ul><li><a href="#s8442-transmission-considerations">s8.4.4.2 Transmission considerations</a><li><a href="#s8443-hdlc-channel-states">s8.4.4.3 HDLC channel states</a></ul><li><a href="#s845-hdlc-channel-operation--description-of-the-procedures">s8.4.5 HDLC channel operation – Description of the procedures</a><ul><li><a href="#s8452-data-station-characteristics">s8.4.5.2 Data station characteristics</a><li><a href="#s8453-procedures-for-setting-up-and-disconnecting-the-data-link">s8.4.5.3 Procedures for setting up and disconnecting the data link</a><li><a href="#s8454-procedures-for-data-exchange">s8.4.5.4 Procedures for data exchange</a><li><a href="#s8455-exception-recovery">s8.4.5.5 Exception recovery</a><li><a href="#s8456-time-outs-and-other-mac-sublayer-parameters">s8.4.5.6 Time-outs and other MAC sublayer parameters</a><li><a href="#s8457-state-transition-diagram-for-the-server-mac-sublayer">s8.4.5.7 State transition diagram for the server MAC sublayer</a></ul></ul><li><a href="#s85-fcs-calculation">s8.5 FCS calculation</a><ul><li><a href="#s851-test-sequence-for-the-fcs-calculation">s8.5.1 Test sequence for the FCS calculation</a><li><a href="#s852-fast-frame-check-sequence-fcs-implementation">s8.5.2 Fast frame check sequence (FCS) implementation</a><li><a href="#s853-16-bit-fcs-computation-method">s8.5.3 16-bit FCS computation method</a></ul><li><a href="#s86-data-link-layer-management-services">s8.6 Data link layer management services</a></ul><li><a href="#s9-dlmscosem-application-layer">s9 DLMS/COSEM application layer</a><ul><li><a href="#s91-dlmscosem-application-layer-main-features">s9.1 DLMS/COSEM application layer main features</a><ul><li><a href="#s912-dlmscosem-application-layer-structure">s9.1.2 DLMS/COSEM application layer structure</a><li><a href="#s913-the-association-control-service-element-acse">s9.1.3 The Association Control Service Element, ACSE</a><li><a href="#s914-the-xdlms-application-service-element">s9.1.4 The xDLMS application service element</a><ul><li><a href="#s9142-the-xdlms-initiate-service">s9.1.4.2 The xDLMS initiate service</a><li><a href="#s9143-cosem-object-related-xdlms-services">s9.1.4.3 COSEM object related xDLMS services</a><ul><li><a href="#s91432-xdlms-services-used-by-the-client-with-ln-referencing">s9.1.4.3.2 xDLMS services used by the client with LN referencing</a><li><a href="#s91433-xdlms-services-used-by-the-client-with-sn-referencing">s9.1.4.3.3 xDLMS services used by the client with SN referencing</a></ul><li><a href="#s91434-unsolicited-services">s9.1.4.3.4 Unsolicited services</a><ul><li><a href="#s91435-selective-access">s9.1.4.3.5 Selective access</a><li><a href="#s91436-multiple-references">s9.1.4.3.6 Multiple references</a><li><a href="#s91437-attribute_0-referencing">s9.1.4.3.7 Attribute_0 referencing</a></ul><li><a href="#s9144-additional-mechanisms">s9.1.4.4 Additional mechanisms</a><ul><li><a href="#s91442-referencing-methods-and-service-mapping">s9.1.4.4.2 Referencing methods and service mapping</a><li><a href="#s91443-identification-of-service-invocations-the-invoke_id-parameter">s9.1.4.4.3 Identification of service invocations: the Invoke_Id parameter</a><li><a href="#s91444-priority-handling">s9.1.4.4.4 Priority handling</a><li><a href="#s91445-transferring-long-messages">s9.1.4.4.5 Transferring long messages</a><li><a href="#s91446-composable-xdlms-messages">s9.1.4.4.6 Composable xDLMS messages</a><li><a href="#s91447-compression-and-decompression">s9.1.4.4.7 Compression and decompression</a><li><a href="#s91448-general-protection">s9.1.4.4.8 General protection</a><li><a href="#sgeneral-block-transfer-gbt">sGeneral block transfer (GBT)</a></ul><li><a href="#s9145-additional-data-types">s9.1.4.5 Additional data types</a><li><a href="#s9146-xdlms-version-number">s9.1.4.6 xDLMS version number</a><li><a href="#s9147-xdlms-conformance-block">s9.1.4.7 xDLMS conformance block</a><li><a href="#s9148-maximum-pdu-size">s9.1.4.8 Maximum PDU size</a></ul><li><a href="#s915-layer-management-services">s9.1.5 Layer management services</a><li><a href="#s916-summary-of-dlmscosem-application-layer-services">s9.1.6 Summary of DLMS/COSEM application layer services</a><li><a href="#s917-dlmscosem-application-layer-protocols">s9.1.7 DLMS/COSEM application layer protocols</a></ul><li><a href="#s92-information-security-in-dlmscosem">s9.2 Information security in DLMS/COSEM</a><ul><li><a href="#s922-the-dlmscosem-security-concept">s9.2.2 The DLMS/COSEM security concept</a><ul><li><a href="#s9222-identification-and-authentication">s9.2.2.2 Identification and authentication</a><ul><li><a href="#s92221-identification">s9.2.2.2.1 Identification</a><li><a href="#s92222-authentication-mechanisms">s9.2.2.2.2 Authentication mechanisms</a></ul><li><a href="#s9223-security-context">s9.2.2.3 Security context</a><li><a href="#s9224-access-rights">s9.2.2.4 Access rights</a><li><a href="#s9225-application-layer-message-security">s9.2.2.5 Application layer message security</a><li><a href="#s9226-cosem-data-security">s9.2.2.6 COSEM data security</a></ul><li><a href="#s923-cryptographic-algorithms">s9.2.3 Cryptographic algorithms</a><ul><li><a href="#s9232-hash-function">s9.2.3.2 Hash function</a><li><a href="#s9233-symmetric-key-algorithms">s9.2.3.3 Symmetric key algorithms</a><ul><li><a href="#s92332-encryption-and-decryption">s9.2.3.3.2 Encryption and decryption</a><li><a href="#s92333-advanced-encryption-standard">s9.2.3.3.3 Advanced Encryption Standard</a><li><a href="#s92334-encryption-modes-of-operation">s9.2.3.3.4 Encryption Modes of Operation</a></ul><li><a href="#s92335-message-authentication-code">s9.2.3.3.5 Message Authentication Code</a><li><a href="#s92336-key-wrapping">s9.2.3.3.6 Key wrapping</a><ul><li><a href="#s92337-galoiscounter-mode">s9.2.3.3.7 Galois/Counter Mode</a><li><a href="#s92338-aes-key-wrap">s9.2.3.3.8 AES key wrap</a></ul><li><a href="#s9234-public-key-algorithms">s9.2.3.4 Public key algorithms</a><ul><li><a href="#s92342-elliptic-curve-cryptography">s9.2.3.4.2 Elliptic curve cryptography</a><li><a href="#s92343-data-conversions">s9.2.3.4.3 Data conversions</a><li><a href="#s92344-digital-signature">s9.2.3.4.4 Digital signature</a><li><a href="#s92345-elliptic-curve-digital-signature-ecdsa">s9.2.3.4.5 Elliptic curve digital signature (ECDSA)</a><li><a href="#s92346-key-agreement">s9.2.3.4.6 Key agreement</a></ul><li><a href="#s9235-random-number-generation">s9.2.3.5 Random number generation</a><li><a href="#s9236-compression">s9.2.3.6 Compression</a><li><a href="#s9237-security-suite">s9.2.3.7 Security suite</a></ul><li><a href="#s924-cryptographic-keys--overview">s9.2.4 Cryptographic keys – overview</a><li><a href="#s925-key-used-with-symmetric-key-algorithms">s9.2.5 Key used with symmetric key algorithms</a><ul><li><a href="#s9251-symmetric-keys-types">s9.2.5.1 Symmetric keys types</a><li><a href="#s9252-key-information-with-general-ciphering-apdu-and-data-protection">s9.2.5.2 Key information with general-ciphering APDU and data protection</a><li><a href="#s9253-key-identification">s9.2.5.3 Key identification</a><li><a href="#s9254-key-wrapping">s9.2.5.4 Key wrapping</a><li><a href="#s9255-key-agreement">s9.2.5.5 Key agreement</a><li><a href="#s9256-symmetric-key-cryptoperiods">s9.2.5.6 Symmetric key cryptoperiods</a></ul><li><a href="#s926-keys-used-with-public-key-algorithms">s9.2.6 Keys used with public key algorithms</a><ul><li><a href="#s9262-key-pair-generation">s9.2.6.2 Key pair generation</a><li><a href="#s9263-public-key-certificates-and-infrastructure">s9.2.6.3 Public key certificates and infrastructure</a><ul><li><a href="#s92632-trust-model">s9.2.6.3.2 Trust model</a><li><a href="#s92633-pki-architecture--informative">s9.2.6.3.3 PKI architecture – informative</a></ul><li><a href="#s9264-certificate-and-certificate-extension-profile">s9.2.6.4 Certificate and certificate extension profile</a><ul><li><a href="#s92642-the-x509-v3-certificate">s9.2.6.4.2 The X.509 v3 Certificate</a></ul><li><a href="#s9265-suite-b-end-entity-certificate-types-to-be-supported-by-dlms-servers">s9.2.6.5 Suite B end entity certificate types to be supported by DLMS servers</a><li><a href="#s9266-management-of-certificates">s9.2.6.6 Management of certificates</a><ul><li><a href="#s92662-provisioning-servers-with-trust-anchors">s9.2.6.6.2 Provisioning servers with trust anchors</a><li><a href="#s92663-provisioning-the-server-with-further-ca-certificates">s9.2.6.6.3 Provisioning the server with further CA certificates</a><li><a href="#s92664-security-personalisation-of-the-server">s9.2.6.6.4 Security personalisation of the server</a><li><a href="#s92665-provisioning-servers-with-certificates-of-clients-and-third-parties">s9.2.6.6.5 Provisioning servers with certificates of clients and third parties</a><li><a href="#s92666-provisioning-clients-and-third-parties-with-certificates-of-servers">s9.2.6.6.6 Provisioning clients and third parties with certificates of servers</a><li><a href="#s92667-certificate-removal-from-the-server">s9.2.6.6.7 Certificate removal from the server</a></ul></ul><li><a href="#s927-applying-cryptographic-protection">s9.2.7 Applying cryptographic protection</a><ul><li><a href="#s9272-protecting-xdlms-apdus">s9.2.7.2 Protecting xDLMS APDUs</a><ul><li><a href="#s92722-security-policy-and-access-rights-values">s9.2.7.2.2 Security policy and access rights values</a><li><a href="#s92723-ciphered-xdlms-apdus">s9.2.7.2.3 Ciphered xDLMS APDUs</a><li><a href="#s92724-encryption-authentication-and-compression">s9.2.7.2.4 Encryption, authentication and compression</a><li><a href="#s92725-digital-signature">s9.2.7.2.5 Digital signature</a></ul><li><a href="#s9273-multi-layer-protection-by-multiple-parties">s9.2.7.3 Multi-layer protection by multiple parties</a><li><a href="#s9274-hls-authentication-mechanisms">s9.2.7.4 HLS authentication mechanisms</a><li><a href="#s9275-protecting-cosem-data">s9.2.7.5 Protecting COSEM data</a></ul></ul><li><a href="#s93-dlmscosem-application-layer-service-specification">s9.3 DLMS/COSEM application layer service specification</a><ul><li><a href="#s931-service-primitives-and-parameters">s9.3.1 Service primitives and parameters</a><li><a href="#s932-the-cosem-open-service">s9.3.2 The COSEM-OPEN service</a><ul><li><a href="#s9323-use">s9.3.2.3 Use</a></ul><li><a href="#s933-the-cosem-release-service">s9.3.3 The COSEM-RELEASE service</a><li><a href="#s934-the-cosem-abort-service">s9.3.4 The COSEM-ABORT service</a><li><a href="#s935-protection-and-general-block-transfer-parameters">s9.3.5 Protection and general block transfer parameters</a><li><a href="#s936-the-get-service">s9.3.6 The GET service</a><li><a href="#s937-the-set-service">s9.3.7 The SET service</a><li><a href="#s938-the-action-service">s9.3.8 The ACTION service</a><li><a href="#s939-the-access-service">s9.3.9 The ACCESS service</a><ul><li><a href="#s9392-service-specification">s9.3.9.2 Service specification</a></ul><li><a href="#s9310-the-datanotification-service">s9.3.10 The DataNotification service</a><li><a href="#s9311-the-eventnotification-service">s9.3.11 The EventNotification service</a><li><a href="#s9312-the-triggereventnotificationsending-service">s9.3.12 The TriggerEventNotificationSending service</a><li><a href="#s9313-variable-access-specification">s9.3.13 Variable access specification</a><li><a href="#s9314-the-read-service">s9.3.14 The Read service</a><li><a href="#s9315-the-write-service">s9.3.15 The Write service</a><li><a href="#s9316-the-unconfirmedwrite-service">s9.3.16 The UnconfirmedWrite service</a><li><a href="#s9317-the-informationreport-service">s9.3.17 The InformationReport service</a><li><a href="#s9318-client-side-layer-management-services-the-setmappertablerequest">s9.3.18 Client side layer management services: the SetMapperTable.request</a></ul><li><a href="#s94-dlmscosem-application-layer-protocol-specification">s9.4 DLMS/COSEM application layer protocol specification</a><ul><li><a href="#s941-the-control-function-cf">s9.4.1 The control function (CF)</a><ul><li><a href="#s9411-state-definitions-of-the-client-side-control-function">s9.4.1.1 State definitions of the client side control function</a><li><a href="#s9412-state-definitions-of-the-server-side-control-function">s9.4.1.2 State definitions of the server side control function</a></ul><li><a href="#s942-the-acse-services-and-apdus">s9.4.2 The ACSE services and APDUs</a><ul><li><a href="#s9421-acse-functional-units-services-and-service-parameters">s9.4.2.1 ACSE functional units, services and service parameters</a><li><a href="#s9422-registered-cosem-names">s9.4.2.2 Registered COSEM names</a></ul><li><a href="#s943-apdu-encoding-rules">s9.4.3 APDU encoding rules</a><ul><li><a href="#s9431-encoding-of-the-acse-apdus">s9.4.3.1 Encoding of the ACSE APDUs</a><li><a href="#s9432-encoding-of-the-xdlms-apdus">s9.4.3.2 Encoding of the xDLMS APDUs</a><li><a href="#s9433-xml">s9.4.3.3 XML</a></ul><li><a href="#s944-protocol-for-application-association-establishment">s9.4.4 Protocol for application association establishment</a><ul><li><a href="#s9441-protocol-for-the-establishment-of-confirmed-application-associations">s9.4.4.1 Protocol for the establishment of confirmed application associations</a><li><a href="#s9442-repeated-cosem-open-service-invocations">s9.4.4.2 Repeated COSEM-OPEN service invocations</a><li><a href="#s9443-establishment-of-unconfirmed-application-associations">s9.4.4.3 Establishment of unconfirmed application associations</a><li><a href="#s9444-pre-established-application-associations">s9.4.4.4 Pre-established application associations</a></ul><li><a href="#s945-protocol-for-application-association-release">s9.4.5 Protocol for application association release</a><li><a href="#s946-protocol-for-the-data-transfer-services">s9.4.6 Protocol for the data transfer services</a><ul><li><a href="#s9461-negotiation-of-services-and-options--the-conformance-block">s9.4.6.1 Negotiation of services and options – the conformance block</a><li><a href="#s9462-confirmed-and-unconfirmed-xdlms-service-invocations">s9.4.6.2 Confirmed and unconfirmed xDLMS service invocations</a><li><a href="#s9463-protocol-for-the-get-service">s9.4.6.3 Protocol for the GET service</a><li><a href="#s9464-protocol-for-the-set-service">s9.4.6.4 Protocol for the SET service</a><li><a href="#s9465-protocol-for-the-action-service">s9.4.6.5 Protocol for the ACTION service</a><li><a href="#s9466-protocol-for-the-access-service">s9.4.6.6 Protocol for the ACCESS service</a><li><a href="#s9467-protocol-of-the-datanotification-service">s9.4.6.7 Protocol of the DataNotification service</a><li><a href="#s9468-protocol-for-the-eventnotification-service">s9.4.6.8 Protocol for the EventNotification service</a><li><a href="#s9469-protocol-for-the-read-service">s9.4.6.9 Protocol for the Read service</a><li><a href="#s94610-protocol-for-the-write-service">s9.4.6.10 Protocol for the Write service</a><li><a href="#s94611-protocol-for-the-unconfirmedwrite-service">s9.4.6.11 Protocol for the UnconfirmedWrite service</a><li><a href="#s94612-protocol-for-the-informationreport-service">s9.4.6.12 Protocol for the InformationReport service</a><li><a href="#s94613-protocol-of-general-block-transfer-mechanism">s9.4.6.13 Protocol of general block transfer mechanism</a><ul><li><a href="#s946132-the-gbt-procedure">s9.4.6.13.2 The GBT procedure</a><li><a href="#s946133-gbt-procedure-state-variables">s9.4.6.13.3 GBT procedure state variables</a><li><a href="#s946137-gbt-protocol-examples">s9.4.6.13.7 GBT protocol examples</a><li><a href="#s946138-aborting-the-gbt-procedure">s9.4.6.13.8 Aborting the GBT procedure</a></ul><li><a href="#s94614-protocol-of-exception-mechanism">s9.4.6.14 Protocol of exception mechanism</a></ul></ul><li><a href="#s95-abstract-syntax-of-cosem-pdus">s9.5 Abstract syntax of COSEM PDUs</a><li><a href="#s96-cosem-pdu-xml-schema">s9.6 COSEM PDU XML schema</a></ul><li><a href="#s10-using-the-dlmscosem-application-layer-in-various-communications-profiles">s10 Using the DLMS/COSEM application layer in various communications profiles</a><ul><li><a href="#s101-communication-profile-specific-elements">s10.1 Communication profile specific elements</a><li><a href="#s102-the-3-layer-connection-oriented-hdlc-based-ommunication-profile">s10.2 The 3-layer, connection-oriented, HDLC based ommunication profile</a><ul><li><a href="#s1022-the-structure-of-the-profile">s10.2.2 The structure of the profile</a><li><a href="#s1023-identification-and-addressing-scheme">s10.2.3 Identification and addressing scheme</a><li><a href="#s1024-supporting-protocol-layer-services-and-service-mapping">s10.2.4 Supporting protocol layer services and service mapping</a><li><a href="#s1025-communication-profile-specific-service-parameters-of-the-dlmscosem-al-services">s10.2.5 Communication profile specific service parameters of the DLMS/COSEM AL services</a><li><a href="#s1026-specific-considerations--constraints">s10.2.6 Specific considerations / constraints</a><ul><li><a href="#s10261-confirmed-and-unconfirmed-aas-and-data-transfer-service-invocations-frame-types-used">s10.2.6.1 Confirmed and unconfirmed AAs and data transfer service invocations, frame types used</a><li><a href="#s10262-correspondence-between-aas-and-data-link-layer-connections-releasing-aas">s10.2.6.2 Correspondence between AAs and data link layer connections, releasing AAs</a><li><a href="#s10263-service-parameters-of-the-cosem-open---release---abort-services">s10.2.6.3 Service parameters of the COSEM-OPEN / -RELEASE / -ABORT services</a><li><a href="#s10264-eventnotification-service-and-protocol">s10.2.6.4 EventNotification service and protocol</a><li><a href="#s10265-transporting-long-messages">s10.2.6.5 Transporting long messages</a><li><a href="#s10266-supporting-multi-drop-configurations">s10.2.6.6 Supporting multi-drop configurations</a></ul></ul><li><a href="#s103-the-tcp-udpip-based-communication-profiles-cosem_on_ip">s10.3 The TCP-UDP/IP based communication profiles (COSEM_on_IP)</a><ul><li><a href="#s1036-specific-considerations--constraints">s10.3.6 Specific considerations / constraints</a><ul><li><a href="#s10366-transporting-long-messages">s10.3.6.6 Transporting long messages</a><li><a href="#s10367-allowing-cosem-servers-to-establish-the-tcp-connection">s10.3.6.7 Allowing COSEM servers to establish the TCP connection</a></ul></ul><li><a href="#s104-the-coap-based-communication-profile-dlmscosem_on_coap">s10.4 The CoAP based communication profile (DLMS/COSEM_on_CoAP)</a><ul><li><a href="#s1043-identification-and-addressing">s10.4.3 Identification and addressing</a><li><a href="#s1044-supporting-layer-services-and-service-mapping">s10.4.4 Supporting layer services and service mapping</a><li><a href="#s1046-specific-considerations--constraints">s10.4.6 Specific considerations / constraints</a></ul><li><a href="#s108-lpwan-profile">s10.8 LPWAN profile</a><li><a href="#s109-wi-sun-profile">s10.9 Wi-SUN profile</a><li><a href="#s1010-gateway-protocol">s10.10 Gateway protocol</a></ul><li><a href="#s11-aarq-and-aare-encoding-examples">s11 AARQ and AARE encoding examples</a><li><a href="#s12-encoding-examples-aarq-and-aare-apdus-using-a-ciphered-application-context">s12 Encoding examples: AARQ and AARE APDUs using a ciphered application context</a><li><a href="#s13-s-fsk-plc-encoding-examples">s13 S-FSK PLC encoding examples</a><li><a href="#s14-data-transfer-service-examples">s14 Data transfer service examples</a><ul><li><a href="#s144-profile-generic-ic-buffer-attribute-encoding-examples">s14.4 Profile generic IC buffer attribute encoding examples</a><ul><li><a href="#s1443-get-response-with-profile-generic-null-data-compressed-encoding-example">s14.4.3 Get-response with Profile generic null-data compressed encoding example</a><li><a href="#s1444-get-response-with-profile-generic-compact-array-encoding-example">s14.4.4 Get-response with Profile generic compact-array encoding example</a><li><a href="#s1445-get-response-with-profile-generic-null-data-and-delta-value-encoding-example">s14.4.5 Get-response with Profile generic null-data and delta-value encoding example</a></ul></ul></ul><h2 id="s1-scope"><span class="mr-2">s1 Scope</span><a href="#s1-scope" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li><code class="language-plaintext highlighter-rouge">建模</code>: 包括设备的<code class="language-plaintext highlighter-rouge">接口模型</code>和数据识别规则;在 blue book 中定义<li><code class="language-plaintext highlighter-rouge">消息</code>: 这涵盖了将接口模型<code class="language-plaintext highlighter-rouge">映射</code>到协议数据单元(APDU)的服务，以及这个 APDU 的<code class="language-plaintext highlighter-rouge">编码</code>。在本 green book 中定义<li><code class="language-plaintext highlighter-rouge">传输</code>: 通过通信通道<code class="language-plaintext highlighter-rouge">传输消息</code>。在本 green book 中定义</ol><p>通信模型：</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/DLMS1.png" alt="comm-module" data-proofer-ignore></p><h2 id="s3-terms-definitions-and-abbreviations-and-symbols"><span class="mr-2">s3 Terms, definitions and abbreviations and symbols</span><a href="#s3-terms-definitions-and-abbreviations-and-symbols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s31-general-dlmscosem-definitions"><span class="mr-2">s3.1 General DLMS/COSEM definitions</span><a href="#s31-general-dlmscosem-definitions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>ACSE APDU：Association Control Service Element (ACSE)标准 A-ASSOCIATE/A-RELEASE 实现的 APDU，AARQ/AARE/RLRQ/RLRE<li>application association：两个应用实体 AEs 之间的合作关系<li>application entity,AE: 独立于系统的应用活动，这些活动作为应用服务提供给应用代理，例如，一组应用服务元素，它们共同执行应用程序的所有或部分通信方面。<li>xDLMS APDU：xDLMS Application Service Element (xDLMS ASE)使用的 APDU</ul><h2 id="s4-information-exchange-in-dlmscosem"><span class="mr-2">s4 Information exchange in DLMS/COSEM</span><a href="#s4-information-exchange-in-dlmscosem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s41-general"><span class="mr-2">s4.1 General</span><a href="#s41-general" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The key characteristics of data exchange using DLMS/COSEM are the following:</p><ul><li><p>devices can be accessed by various parties: clients and third parties;</p><p>使用 DLMS/COSEM 进行数据交换的主要特点如下:设备可以被各种各方访问:客户端和第三方;</p><li><p>mechanisms to control access to the resources of the device are provided;</p><p>提供了控制对设备资源的访问的机制;</p><li><p>these mechanisms are made available by the DLMS/COSEM AL and the COSEM objects ( Association SN / LN object, Security setup object);</p><p>这些机制是由 DLMS/COSEM AL 和 COSEM 对象(关联 SN / LN 对象，安全设置对象)提供的;</p><li><p>security and privacy is ensured by applying cryptographical protection to xDLMS messages and to COSEM data;</p><p>通过对 xDLMS 消息和 COSEM 数据应用加密保护来确保安全性和私密性;</p><li><p>low overhead and efficiency is ensured by various mechanisms including selective access, compact encoding and compression;</p><p>通过各种机制，包括选择性访问、压缩编码和压缩，确保了低开销和效率;</p><li><p>at a site, there may be single or multiple devices.</p><p>在一个站点，可能有单个或多个设备。</p><li><p>In the case of multiple devices at a site, a single access point can be made available;</p><p>在一个站点有多个设备的情况下，可以提供一个单一的接入点;</p><li><p>data exchange may take place either remotely or locally.</p><p>数据交换可以在远程或本地进行。</p><li><p>Depending on the capabilities of the device, local and remote data exchange may be performed simultaneously without interfering with each other;</p><p>根据设备的能力，本地和远程数据交换可以在不相互干扰的情况下同时进行;</p><li><p>various communication media can be used on local networks (LN), neighbourhood networks (NN) and wide area networks (WAN).</p><p>各种通信媒体可用于局域网(LN)、邻网(NN)和广域网(WAN)。</p></ul><h3 id="s42-communication-model"><span class="mr-2">s4.2 Communication model</span><a href="#s42-communication-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>application processes(<code class="language-plaintext highlighter-rouge">APs</code>)之间的通信通过<code class="language-plaintext highlighter-rouge">应用程序实体</code>(application entities,<code class="language-plaintext highlighter-rouge">AEs</code>)之间的通信进行建模。AE 代表 AP 的<code class="language-plaintext highlighter-rouge">通信功能</code>。</p><p>AP 中可能有<code class="language-plaintext highlighter-rouge">多组</code>OSI 通信功能，因此<code class="language-plaintext highlighter-rouge">一个AP</code>可以用<code class="language-plaintext highlighter-rouge">多种AEs</code>来表示（比如一个 AP 可以使用 HDLC-based profile，也可以使用 TCP-IP based profile）。一个 AE 只对应一个 AP（可能两个 AP 都使用 HDLC-based profile，这两个 AE 也是不同的，可以理解为类和对象的关系，基于同一个类的两个对象实例化后是不同的）。一个 AE 包含一组称为 application service elements(<code class="language-plaintext highlighter-rouge">ASEs</code>)的通信功能</p><blockquote class="prompt-danger"><div><p>TODO:AE 的意思还不明确</p></div></blockquote><h3 id="s43-naming-and-addressing"><span class="mr-2">s4.3 Naming and addressing</span><a href="#s43-naming-and-addressing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>一个<code class="language-plaintext highlighter-rouge">server AP</code>对应一个<code class="language-plaintext highlighter-rouge">logical device</code>,<code class="language-plaintext highlighter-rouge">client AP</code>可以不对应 logical device。<code class="language-plaintext highlighter-rouge">每个AP</code>绑定一个 Service Access Point(<code class="language-plaintext highlighter-rouge">SAP</code>)，<code class="language-plaintext highlighter-rouge">SAP</code>位于 application layer(<code class="language-plaintext highlighter-rouge">AL</code>)层。<strong>也就是说 SAP 用于区分基于同一个 AL 的不同 AP</strong>(对服务端也可以说是 logical device).</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/address.jpg" alt="comm-module" data-proofer-ignore></p><h4 id="s433-addressing"><span class="mr-2">s4.3.3 Addressing</span><a href="#s433-addressing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/sap.jpg" alt="comm-module" data-proofer-ignore></p><p>SAP 用于区分基于同一个 AL 的不同 AP</p><h4 id="s434-system-title"><span class="mr-2">s4.3.4 System title</span><a href="#s434-system-title" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>按单一 DLMS/COSEM 实体<code class="language-plaintext highlighter-rouge">唯一</code>，和逻辑设备名不同，一个实体可以有多个逻辑设备(名)，但只能有一个<code class="language-plaintext highlighter-rouge">systemtitle</code>,实体中的逻辑设备<code class="language-plaintext highlighter-rouge">共享</code>该 systemtitle<li>固定<code class="language-plaintext highlighter-rouge">8字节</code>长，前 3 字节厂家 ID，和逻辑设备名相同，后面的 5 字节，应为 0-999,999,999,999(0x0-0xE8D4A50FFF)</ul><p>交换方式（见 10.4.3.3）：</p><ul><li>通信配置注册过程<li>在明确建立 AA 的情况下，在 AA 建立期间使用<code class="language-plaintext highlighter-rouge">COSEM-OPEN</code>服务;<li>通过在“<code class="language-plaintext highlighter-rouge">Security setup</code>”对象写入 client_system_title 属性和读取的 server_system_title 属性。适用于预连接 AA<li>加密 APDU 交换，general-ciphering (originator and recipient system title)或 general-glo-ciphering (originator system title).</ul><h4 id="s435-logical-device-name"><span class="mr-2">s4.3.5 Logical Device Name</span><a href="#s435-logical-device-name" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>蓝皮书 part2 4.1.8</p><h3 id="s44-connection-oriented-operation"><span class="mr-2">s4.4 Connection oriented operation</span><a href="#s44-connection-oriented-operation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Phase 1: AA establishment<li>Phase 2: Message exchange<li>Phase 3: AA Release</ul><p><code class="language-plaintext highlighter-rouge">预连接AA</code>不需要 1 和 3</p><h3 id="s45-application-associations"><span class="mr-2">s4.5 Application associations</span><a href="#s45-application-associations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Application Associations (<code class="language-plaintext highlighter-rouge">AAs</code>)是一个客户端<code class="language-plaintext highlighter-rouge">AE</code>和一个服务端<code class="language-plaintext highlighter-rouge">AE</code>间的<code class="language-plaintext highlighter-rouge">逻辑连接</code>。可以使用 ACSE 服务建立，也可以是预连接的</p><p>一个 COSEM 逻辑设备可以支持一个或多个 AAs，每个 AAs 有一个<code class="language-plaintext highlighter-rouge">不同的客户端</code>。每个 AA 决定发生信息交换的上下文。</p><ul><li><p>confirmed AA:</p><p><code class="language-plaintext highlighter-rouge">confirmed AA</code>由客户端提出并被服务器<code class="language-plaintext highlighter-rouge">接受</code>，前提是：</p><ul><li>客户端用户为服务器所知，见 4.3.6;<li>客户端在 4.5.2 中提出的应用上下文对于服务器来说是可接受的;<li>客户端(见 4.5.3)提出的认证机制对服务器来说是可接受的，认证是成功的;<li>xDLMS 上下文的元素参见 4.5.4 可以在客户端和服务器之间成功协商。</ul><li><p>unconfirmed AA:</p><p>客户端也会提出<code class="language-plaintext highlighter-rouge">未经确认的AA</code>，并<code class="language-plaintext highlighter-rouge">假设</code>服务器会接受它。 <code class="language-plaintext highlighter-rouge">没有协商</code>发生。 未确认的 AA 对于从客户端向服务器发送<code class="language-plaintext highlighter-rouge">广播消息</code>很有用。</p></ul><h4 id="s452-application-context"><span class="mr-2">s4.5.2 Application context</span><a href="#s452-application-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>应用程序上下文确定：</p><ul><li>AL 中存在的一组应用服务元素（Application Service Elements,ASEs）<li>COSEM 对象属性和方法的引用方式：短名称(SN) 引用或逻辑名称(LN) 引用。 另见 9.1.4.3.1<li>传输语法<li>是否使用加密</ul><h4 id="s453-authentication"><span class="mr-2">s4.5.3 Authentication</span><a href="#s453-authentication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>DLMS 中的认证发生在 AA 建立阶段</p><ul><li>在<code class="language-plaintext highlighter-rouge">confirmed AAs</code>中，客户端(<code class="language-plaintext highlighter-rouge">单向认证</code>)或客户端和服务器(<code class="language-plaintext highlighter-rouge">双向认证</code>)都可以对对端进行认证。<li>对于<code class="language-plaintext highlighter-rouge">unconfirmed AA</code>，只有客户端可以验证对端。<li>在<code class="language-plaintext highlighter-rouge">预连接AA</code>中，身份验证不可用。</ul><h4 id="s454-xdlms-context"><span class="mr-2">s4.5.4 xDLMS context</span><a href="#s454-xdlms-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>xDLMS 上下文确定可以在给定的 AA 中使用的 xDLMS 服务和功能集。见 9.1.4。</p><ul><li>additional services, see 9.1.4.3;<li>additional mechanisms, see 9.1.4.4;<li>additional data types, see 9.1.4.5;<li>new DLMS version number, see 9.1.4.6;<li>new conformance block, see 9.1.4.7;<li>clarification of the meaning of the PDU size, see 9.1.4.8.</ul><h4 id="s455-security-context"><span class="mr-2">s4.5.5 Security context</span><a href="#s455-security-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>当应用程序上下文规定加密时，安全上下文是相关的。 它包括<code class="language-plaintext highlighter-rouge">安全套件</code>、<code class="language-plaintext highlighter-rouge">安全策略</code>、<code class="language-plaintext highlighter-rouge">安全密钥</code>和<code class="language-plaintext highlighter-rouge">其他安全材料</code>。 另见 9.2.2.3。 它由“<code class="language-plaintext highlighter-rouge">Security setup</code>”对象管理。</p><h4 id="s456-access-rights"><span class="mr-2">s4.5.6 Access rights</span><a href="#s456-access-rights" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>访问权限确定客户访问 AA 内的 COSEM 对象属性和方法的<code class="language-plaintext highlighter-rouge">权限</code>。 访问权限集取决于<code class="language-plaintext highlighter-rouge">客户端的角色</code>，并在服务器中<code class="language-plaintext highlighter-rouge">预先配置</code>。 另见 9.2.2.4。</p><h3 id="s46-messaging-patterns"><span class="mr-2">s4.6 Messaging patterns</span><a href="#s46-messaging-patterns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-03-17-dlms-green-1/messagepatterns.jpg" alt="messages" data-proofer-ignore></p><p>在<code class="language-plaintext highlighter-rouge">confirmed AA</code> 中：</p><ul><li>客户端可以发送确认的服务请求，服务器响应：<code class="language-plaintext highlighter-rouge">pull操作</code><li>客户端可以发送未经确认的服务请求。 服务器没有响应<li>服务器可以向客户端发送未经请求的服务请求：<code class="language-plaintext highlighter-rouge">push操作</code></ul><blockquote class="prompt-tip"><div><p>note:主动推送的服务可以是 InformationReport（使用 SN 引用）、EventNotification（使用 LN 引用）或 DataNotification（同时使用 SN 和 LN 引用）。</p></div></blockquote><p>在<code class="language-plaintext highlighter-rouge">unconfirmed AA</code> 中：</p><ul><li>只有客户端可以发起服务请求，并且只有未确认的请求。 服务器无法响应，也无法发起服务请求。</ul><h3 id="s48-communication-profiles"><span class="mr-2">s4.8 Communication profiles</span><a href="#s48-communication-profiles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>通信配置文件指定了 <em><code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code></em> 和<em>建模 Application Process (AP) 的 <code class="language-plaintext highlighter-rouge">COSEM 数据模型</code></em>如何由较低的通信媒体特定协议层支持。</p><p>通信配置文件包括许多<code class="language-plaintext highlighter-rouge">协议层</code>。 每一层都有不同的任务并为其上层<code class="language-plaintext highlighter-rouge">提供服务</code>并使用其支持协议层的服务。 客户端和服务器 <code class="language-plaintext highlighter-rouge">COSEM AP</code> 使用最高协议层的服务，即 <code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code> 的服务。 这是唯一包含 COSEM 特定元素(<code class="language-plaintext highlighter-rouge">xDLMS ASE</code>)的协议层； 见 9.1.4。 任何能够提供 DLMS/COSEM AL 所需服务的层都可以支持它。 较低层的数量和类型取决于所使用的通信媒体。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/commprofile.jpg" alt="messages" data-proofer-ignore></p><h3 id="s49-model-of-a-dlmscosem-system"><span class="mr-2">s4.9 Model of a DLMS/COSEM system</span><a href="#s49-model-of-a-dlmscosem-system" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>设备被建模为<code class="language-plaintext highlighter-rouge">一组逻辑设备</code>，托管在<code class="language-plaintext highlighter-rouge">单个物理设备</code>中。 <strong>每个逻辑设备代表一个服务器 AP</strong>，并对<code class="language-plaintext highlighter-rouge">设备功能</code>的一个<code class="language-plaintext highlighter-rouge">子集</code>进行建模，这些功能子集可以通过其通信接口看到。使用 COSEM 对象对各种功能进行建模。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/model.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">数据采集系统</code>被建模为<code class="language-plaintext highlighter-rouge">一组客户端ap</code>，可以由<code class="language-plaintext highlighter-rouge">一个或多个物理设备</code>托管。每个客户端 AP 可能有<code class="language-plaintext highlighter-rouge">不同</code>的角色和访问权限，由设备授予。</p><p><code class="language-plaintext highlighter-rouge">公共客户端0x10</code>和<code class="language-plaintext highlighter-rouge">管理逻辑设备0x01</code>APs 有一个特殊的角色，它们应该一直存在。</p><h3 id="s410-model-of-dlms-servers"><span class="mr-2">s4.10 Model of DLMS servers</span><a href="#s410-model-of-dlms-servers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-03-17-dlms-green-1/dlmsservermodel.jpg" alt="messages" data-proofer-ignore></p><ul><li>IP based profiles:</ul><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>由 DLMS/COSEM Transport layer(<code class="language-plaintext highlighter-rouge">TL</code>)支持，该 TL 由 internet TCP 或 UDP 层和一个包装器(wrapper)组成。<code class="language-plaintext highlighter-rouge">包装器</code>的主要作用是适应<code class="language-plaintext highlighter-rouge">OSI风格</code>的服务集，该服务集由 DLMS/COSEM TL 在 TCP 和 UDP 函数调用<code class="language-plaintext highlighter-rouge">之间</code>提供。它还为逻辑设备提供寻址，将它们<code class="language-plaintext highlighter-rouge">绑定</code>到一个称为包装器端口的<code class="language-plaintext highlighter-rouge">SAP</code>。<code class="language-plaintext highlighter-rouge">管理逻辑设备</code>总是绑定到包装器端口<code class="language-plaintext highlighter-rouge">0x01</code>。最后，<code class="language-plaintext highlighter-rouge">包装器</code>提供有关 APDU 传输<code class="language-plaintext highlighter-rouge">长度的信息</code>，以帮助对等端识别 APDU 的<code class="language-plaintext highlighter-rouge">末端</code>。由于 TCP 的流特性，这是必要的。</p><p>如果没有包装器这层，APDU 直接通过 TCP 发出去，由于 TCP 是<code class="language-plaintext highlighter-rouge">流式</code>的，APDU 不包含<code class="language-plaintext highlighter-rouge">头尾信息</code>，对端不知道是否是个<code class="language-plaintext highlighter-rouge">完整</code>的 APDU，<code class="language-plaintext highlighter-rouge">无法解析</code></p><ul><li>3-layer,CO,HDLC based profile:</ul><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code> 由基于 <code class="language-plaintext highlighter-rouge">HDLC</code> 的数据链路层支持。 它的主要作用是在对等层之间提供可靠的数据传输。 它还以这样一种方式提供逻辑设备的<code class="language-plaintext highlighter-rouge">寻址</code>，即每个逻辑设备都<code class="language-plaintext highlighter-rouge">绑定</code>到<code class="language-plaintext highlighter-rouge">单个 HDLC 地址</code>。 管理逻辑设备始终绑定到地址 0x01。 为了允许创建一个<code class="language-plaintext highlighter-rouge">本地网络</code>，以便通过一个<code class="language-plaintext highlighter-rouge">单一的接入点</code>可以到达特定站点的<code class="language-plaintext highlighter-rouge">几个物理设备</code>，另一个地址，即<code class="language-plaintext highlighter-rouge">物理设备地址</code>也由数据链路层提供。 逻辑设备地址被称为高 HDLC 地址，而物理设备地址被称为低 HDLC 地址。 另见 8.4.2</p><h3 id="s411-model-of-a-dlms-client"><span class="mr-2">s4.11 Model of a DLMS client</span><a href="#s411-model-of-a-dlms-client" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>客户端模型</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/modelclient.jpg" alt="messages" data-proofer-ignore></p><ul><li>DLMS/COSEM AL 使用 HDLC 或 IP-based TLs 提供的服务，<code class="language-plaintext highlighter-rouge">由AP决定</code>使用哪种。<li>与服务器端不同，客户端的 HDLC 层提供的寻址只有<code class="language-plaintext highlighter-rouge">一个级别</code>，即每个应用程序流程(AP)的服务接入点(SAP)的级别。(<em>也就是没有物理地址级别，见<code class="language-plaintext highlighter-rouge">8.4.2</code>，原语参数中客户端地址只有一个字节，就是 SAP 地址</em>)</ul><p>客户端 AP 和服务器端 AP 由各自的<code class="language-plaintext highlighter-rouge">SAP</code>识别，因此，客户端和服务器端 AP 之间的<code class="language-plaintext highlighter-rouge">AA</code>可以由<code class="language-plaintext highlighter-rouge">一对</code>客户端和服务器端<code class="language-plaintext highlighter-rouge">SAP</code>识别。</p><h3 id="s412-interoperability-and-interconnectivity-in-dlmscosem"><span class="mr-2">s4.12 Interoperability and interconnectivity in DLMS/COSEM</span><a href="#s412-interoperability-and-interconnectivity-in-dlmscosem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>互操作性和互联性</p><ul><li><p>Interoperability：</p><p>双方的 COSEM 对象定义相同，都使用 DLMS/COSEM AL 层</p><li><p>interconnectivity：</p><p>AEs 互联。如果两个 AEs 使用<code class="language-plaintext highlighter-rouge">相同</code>的<code class="language-plaintext highlighter-rouge">通信配置文件</code>，则它们是可<code class="language-plaintext highlighter-rouge">互联</code>的</p></ul><h3 id="s413-ensuring-interconnectivity-the-protocol-identification-service"><span class="mr-2">s4.13 Ensuring interconnectivity: the protocol identification service</span><a href="#s413-ensuring-interconnectivity-the-protocol-identification-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">协议识别服务</code></p><p>在 DLMS/COSEM 中，AA 的建立总是由<code class="language-plaintext highlighter-rouge">客户端AE</code>发起。然而，在某些情况下，它可能<code class="language-plaintext highlighter-rouge">不了解</code>未知服务器设备所使用的<code class="language-plaintext highlighter-rouge">协议栈</code>（例如，当服务器启动物理连接建立时）。在这种情况下，客户端 AE 需要获得关于服务器中实现的<code class="language-plaintext highlighter-rouge">协议栈的信息</code>。 为此，提供了一种特定的应用级服务：<code class="language-plaintext highlighter-rouge">协议识别服务</code>。它是一种可选的应用级服务，允许客户机 AE 在建立物理连接后获得关于服务器中实现的协议栈的信息。5.3.3.3 中规定的协议识别服务直接使用 PhL 的数据传输服务（<code class="language-plaintext highlighter-rouge">PH-DATA</code>.request /.indicat）；它绕过了其他协议层。建议在所有可以访问 PhL 的通信配置文件中支持它。</p><h3 id="s414-system-integration-and-installation"><span class="mr-2">s4.14 System integration and installation</span><a href="#s414-system-integration-and-installation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">系统集成和安装</code></p><p>DLMS/COSEM 以多种方式支持系统集成。这里描述了一个可能的过程。</p><p>如图 7 所示，<code class="language-plaintext highlighter-rouge">Public Client</code>(在任何配置文件中绑定到地址<code class="language-plaintext highlighter-rouge">0x10</code>)在每个客户端系统中都是必需的。它的主要作用是揭示一个<code class="language-plaintext highlighter-rouge">未知的</code>–例如<code class="language-plaintext highlighter-rouge">新安装</code>的–设备的结构。这发生在公共客户端和管理逻辑设备之间的<code class="language-plaintext highlighter-rouge">强制AA</code>中，没有安全预防措施。一旦知道了结构，就可以使用<code class="language-plaintext highlighter-rouge">适当的身份验证机制</code>和 xDLMS 的<code class="language-plaintext highlighter-rouge">密码保护</code>来访问数据</p><p>当<code class="language-plaintext highlighter-rouge">系统</code>中安装了<code class="language-plaintext highlighter-rouge">新设备</code>时，可能会<code class="language-plaintext highlighter-rouge">向客户端</code>生成<code class="language-plaintext highlighter-rouge">事件报告</code>。一旦检测到这一点，客户机就可以检索设备的<code class="language-plaintext highlighter-rouge">内部结构</code>，然后向设备发送必要的<code class="language-plaintext highlighter-rouge">配置信息</code>(例如关税时间表和特定于安装的参数)。这样，设备就可以使用了</p><h2 id="s5-physical-layer-services-and-procedures-for-connection-oriented-asynchronous-data-exchange"><span class="mr-2">s5 Physical layer services and procedures for connection-oriented asynchronous data exchange</span><a href="#s5-physical-layer-services-and-procedures-for-connection-oriented-asynchronous-data-exchange" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>物理层</p><h3 id="s51-overview"><span class="mr-2">s5.1 Overview</span><a href="#s51-overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>通信是<code class="language-plaintext highlighter-rouge">点对点</code>或<code class="language-plaintext highlighter-rouge">点对多点</code><li><code class="language-plaintext highlighter-rouge">至少</code>可以有<code class="language-plaintext highlighter-rouge">半双工</code>连接<li>异步传输 1 位起始位，8 位数据位，无奇偶校验和 1 位停止位(<code class="language-plaintext highlighter-rouge">8N1</code>)</ul><blockquote class="prompt-tip"><div><p><strong>串口通信原理</strong></p><p>9600 8N1 代表着波特为 9600，8 个数据位，无奇偶校验和 1 个停止位，这一种是较为常用的串行协议配置方法。那么，9600 8N1 的数据包是什么样的呢？举个例子吧！传输 ASCII 字符’<code class="language-plaintext highlighter-rouge">O</code>‘和’<code class="language-plaintext highlighter-rouge">K</code>‘的设备必须创建两个数据包。O 的 ASCII 值（大写）为 79，则二进制值<code class="language-plaintext highlighter-rouge">01001111</code>，而 K 的二进制值为<code class="language-plaintext highlighter-rouge">01001011</code>。剩下的就是追加同步位。假设传输数据时首先传输<code class="language-plaintext highlighter-rouge">最低位</code>：</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/8n1.jpg" alt="messages" data-proofer-ignore></p></div></blockquote><h3 id="s52-service-specification"><span class="mr-2">s5.2 Service specification</span><a href="#s52-service-specification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s521-list-of-services"><span class="mr-2">s5.2.1 List of services</span><a href="#s521-list-of-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>建立/发布相关业务 PH-CONNECT, PH-ABORT;<li>数据传输业务 PH-DATA;<li><p>层管理服务</p><p>层管理服务由<code class="language-plaintext highlighter-rouge">层管理进程</code>使用或为<code class="language-plaintext highlighter-rouge">层管理进程</code>提供，层管理进程是<code class="language-plaintext highlighter-rouge">AP</code>的一部分。下面给出一些示例:</p><ul><li>PH-INITIALIZE.request / PH-INITIALIZE.confirm;<li>PH-GET_VALUE.request / PH-GET_VALUE.confirm<li>PH-SET_VALUE.request / PH-SET_VALUE.confirm<li>PH-LM_EVENT.indication</ul></ul><h4 id="s522-use-of-the-physical-layer-services"><span class="mr-2">s5.2.2 Use of the physical layer services</span><a href="#s522-use-of-the-physical-layer-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>物理连接建立/释放服务是由<code class="language-plaintext highlighter-rouge">物理连接管理器AP</code>使用并为<code class="language-plaintext highlighter-rouge">物理连接管理器AP</code>提供的，而不是<code class="language-plaintext highlighter-rouge">数据链路层</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/physervices.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">注意这张图很关键，表明了管理器AP用于管理物理层的关系，包括管理器AP和物理层的原语，链路层和物理层的原语</code></p><h4 id="s523-service-definitions"><span class="mr-2">s5.2.3 Service definitions</span><a href="#s523-service-definitions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><p>PH-CONNECT.request <code class="language-plaintext highlighter-rouge">连接建立服务</code>的服务请求原语</p><p>在 DLMS/COSEM 环境中，PH-CONNECT.request 原语的<code class="language-plaintext highlighter-rouge">用户</code>是物理连接管理器<code class="language-plaintext highlighter-rouge">AP</code>。它被用于建立一个物理连接。收到该基元后，PhL 实体将执行所需的动作–例如拨号（如物理层 PhL 向 modem 发送<code class="language-plaintext highlighter-rouge">AT指令</code>）–以与对等 PhL 实体建立物理连接。5.4 中给出了智能 Hayes 调制解调器情况下的这些动作的例子。</p><li><p>PH-CONNECT.indication 连接建立服务的服务指示原语</p><p>PH-CONNECT.indication 由 PhL 实体基元生成，用于向服务用户实体指示一个远程设备要求建立物理连接。</p><li><p>PH-CONNECT.confirm 连接建立服务的服务确认原语</p><p>PhL 实体用来传递相关联的 PH-CONNECT.request 的结果。如果由于本地错误(例如电话线不可用)而无法建立连接，则是本地生成的。</p><li><p>PH-DATA.request <code class="language-plaintext highlighter-rouge">数据传输服务</code>的服务请求原语</p><p>求使用 PhL 传输过程向一个或多个远程 PhL 实体发送数据字节</p><li><p>PH-DATA.indication 数据传输服务的服务指示原语。</p><p>向服务用户实体指示有效数据字节的到达</p><li><p>PH-ABORT.request 连接中止服务的服务请求原语</p><p>请求原语由服务用户实体 Physical Connection Manager 调用，以请求 PhL 实体终止现有的物理连接</p><li><p>PH-ABORT.confirm 连接<code class="language-plaintext highlighter-rouge">中止服务</code>的服务确认原语</p><p>PH-ABORT.confirm 原语由 PhL 实体生成，用于向服务用户实体 Physical Connection Manager 确认物理断开尝试的结果</p><li><p>PH-ABORT.indication 连接中止服务的服务指示原语。</p><p>原语由 PhL 实体生成，用于通知服务用户实体物理连接已意外终止。</p></ul><h3 id="s53-protocol-specification"><span class="mr-2">s5.3 Protocol specification</span><a href="#s53-protocol-specification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s531-physical-layer-protocol-data-unit"><span class="mr-2">s5.3.1 Physical layer protocol data unit</span><a href="#s531-physical-layer-protocol-data-unit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>Physical layer protocol data unit,<code class="language-plaintext highlighter-rouge">PHPDU</code>被指定为<code class="language-plaintext highlighter-rouge">一个字节</code>。然而，为了传输目的，这个数据字节可能被<code class="language-plaintext highlighter-rouge">调制解调器</code>设备<code class="language-plaintext highlighter-rouge">扩展</code>(错误检测/校正)或<code class="language-plaintext highlighter-rouge">修改</code>(位填充)，这取决于所使用的调制方案。</p><h4 id="s532-transmission-order-and-characteristics"><span class="mr-2">s5.3.2 Transmission order and characteristics</span><a href="#s532-transmission-order-and-characteristics" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">PHSDU</code>字节——PH-DATA 服务的 Data 参数——在传输前应以一个开始位和一个停止位完成。产生的帧应该从起始位开始传输，首先是最低有效位，最低有效位标识为位 0，最高有效位标识为位 7。</p><h4 id="s533-physical-layer-operation--description-of-the-procedures"><span class="mr-2">s5.3.3 Physical layer operation – description of the procedures</span><a href="#s533-physical-layer-operation--description-of-the-procedures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s5331-general"><span class="mr-2">s5.3.3.1 General</span><a href="#s5331-general" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>连接的建立和释放由<code class="language-plaintext highlighter-rouge">物理连接管理器AP</code>管理。任何希望使用 DLMS/COSEM 协议的<code class="language-plaintext highlighter-rouge">AP</code>应在请求连接之前<code class="language-plaintext highlighter-rouge">检查PhL</code>的连接状态。如果 PhL 处于<code class="language-plaintext highlighter-rouge">非连接</code>状态，它将请求<code class="language-plaintext highlighter-rouge">物理连接管理器</code>建立连接</p><p>(结合 5.3.3.3 和 5.3.3.4 就是说<code class="language-plaintext highlighter-rouge">建立和释放</code>还有<code class="language-plaintext highlighter-rouge">识别</code>服务由 AP 来做，这些做完后的数据<code class="language-plaintext highlighter-rouge">传输阶段</code>AP 就不管了，通过<code class="language-plaintext highlighter-rouge">数据链路层</code>直接调用)</p><h5 id="s5332-setting-up-a-physical-connection"><span class="mr-2">s5.3.3.2 Setting up a physical connection</span><a href="#s5332-setting-up-a-physical-connection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>客户机和服务器设备都可以充当<code class="language-plaintext highlighter-rouge">主叫设备</code>，初始化到远程设备(即<code class="language-plaintext highlighter-rouge">被叫设备</code>)的物理连接。在这个<code class="language-plaintext highlighter-rouge">DLMS/COSEM配置文件</code>中，这些原语的服务用户只能是<code class="language-plaintext highlighter-rouge">物理连接管理器进程</code></p><p>在<code class="language-plaintext highlighter-rouge">被叫设备端</code>，当检测到物理连接的启动时，需要对连接进行管理：<code class="language-plaintext highlighter-rouge">协商</code>、<code class="language-plaintext highlighter-rouge">接受</code>或<code class="language-plaintext highlighter-rouge">拒绝</code>。这些动作–与执行 PH-CONNECT.request 原语类似–取决于<code class="language-plaintext highlighter-rouge">物理连接类型</code>和使用的<code class="language-plaintext highlighter-rouge">调制解调器</code>，并可能以<code class="language-plaintext highlighter-rouge">自主方式</code>或由<code class="language-plaintext highlighter-rouge">PhL本身</code>完成(该过程不需要 Physical connection manager process 参与)。</p><p>当主叫和被叫设备的<code class="language-plaintext highlighter-rouge">PhL完成建立</code>（或<code class="language-plaintext highlighter-rouge">不建立</code>）所需的物理连接时，它们使用<code class="language-plaintext highlighter-rouge">PH-CONNECT.confirm</code>（主叫方）和<code class="language-plaintext highlighter-rouge">PH-CONNECT.indicat</code>（被叫方）基元将结果通知服务用户实体。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/physicalconn.jpg" alt="messages" data-proofer-ignore></p><h5 id="s5333-the-identification-service"><span class="mr-2">s5.3.3.3 The Identification service</span><a href="#s5333-the-identification-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>用于客户端读取协议栈识别信息</p><p>可选的<code class="language-plaintext highlighter-rouge">识别服务</code>是一种<code class="language-plaintext highlighter-rouge">应用层面</code>（<em>特别注意，应用层面</em>）的服务。它的目的是让客户获得关于服务器中实现的<code class="language-plaintext highlighter-rouge">协议栈</code>的信息。因此，它不使用整个协议栈；识别信息在<code class="language-plaintext highlighter-rouge">客户端AP</code>和<code class="language-plaintext highlighter-rouge">服务器AP</code>之间使用<code class="language-plaintext highlighter-rouge">PhL数据data服务</code>直接交换。如果在<code class="language-plaintext highlighter-rouge">多播</code>配置中使用了一个以上的服务器，客户端能够识别<code class="language-plaintext highlighter-rouge">每个</code>服务器中的协议栈。</p><p>该服务在<code class="language-plaintext highlighter-rouge">PH-CONNECT后</code>CONNECTED 状态才能调用</p><p>只能由<code class="language-plaintext highlighter-rouge">客户端</code>发起请求</p><ul><li>IDENTIFY.request 请求识别信息<li><p>IDENTIFY.response IDENTIFY.response 消息由<code class="language-plaintext highlighter-rouge">服务器AP</code>调用，携带识别请求的<code class="language-plaintext highlighter-rouge">结果</code>：</p><ul><li><code class="language-plaintext highlighter-rouge">协议标准</code><li><code class="language-plaintext highlighter-rouge">版本</code><li><code class="language-plaintext highlighter-rouge">修订信息</code><li><code class="language-plaintext highlighter-rouge">错误信息</code></ul><p>在客户端，这是一个 IDENTIFY.confirm 原语。</p></ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/identify.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/identifystate.jpg" alt="messages" data-proofer-ignore></p><p>IDENTIFY.request <code class="language-plaintext highlighter-rouge">APDU</code>包含<code class="language-plaintext highlighter-rouge">一个或三个</code>字节。为了保持一致性，它的发送应受到数据链路层的<code class="language-plaintext highlighter-rouge">时间限制</code>（帧间和响应超时）。</p><p>当收到这<code class="language-plaintext highlighter-rouge">第一个字符</code>时，PhL 进入 “<code class="language-plaintext highlighter-rouge">识别中</code>“状态，等待更多的字节或帧间超时(意味着消息的结束)。</p><ul><li><p>identify<code class="language-plaintext highlighter-rouge">识别阶段</code>过程：</p><p>如果在收到三个以上的字节之前检测到<code class="language-plaintext highlighter-rouge">消息结束</code>条件(<code class="language-plaintext highlighter-rouge">超时也算</code>结束标志)，PhL 将收到的 APDU 视为<code class="language-plaintext highlighter-rouge">IDENTIFY.request</code> APDU。它使用 PH-DATA.indicaton 原语将收到的字节发送到<code class="language-plaintext highlighter-rouge">（物理连接管理器）AP</code>，并返回到 “<code class="language-plaintext highlighter-rouge">等待接收</code>“状态，允许解决最终的错误。</p><li><p>跳过 identify<code class="language-plaintext highlighter-rouge">识别阶段</code>，直接进入<code class="language-plaintext highlighter-rouge">数据传输阶段</code>：</p><p>另一方面，如果在收到<code class="language-plaintext highlighter-rouge">第四个</code>传入字节之前没有检测到<code class="language-plaintext highlighter-rouge">消息结束</code>的条件（因为 IDENTIFY.request 最大就是 3 字节，收到第 4 个字节还没有结束标志，说明就不是 IDENTIFY.request 了，同时要保证正确的数据 PDU 长度是大于 3 字节的），PhL 认为识别过程已经结束，并进入 “<code class="language-plaintext highlighter-rouge">数据传输</code>“状态。传入的字节应使用<code class="language-plaintext highlighter-rouge">PH-DATA.indicaton</code>服务发送至服务用户的上层协议层。在 3 层的 CO、HDLC 的 COSEM 配置文件中，这是 MAC 子层。在这种连接中，PhL<code class="language-plaintext highlighter-rouge">不能返回</code>到<code class="language-plaintext highlighter-rouge">识别阶段</code>。</p></ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/phlstatemachine.jpg" alt="messages" data-proofer-ignore></p><p>PhL 有参数 Destination_process 表示数据发到哪一层去，默认为 NULL 表示发给物理层管理 AP，进入数据传输模式后为其他值表示发给 MAC 层。</p><h5 id="s5334-data-transfer"><span class="mr-2">s5.3.3.4 Data transfer</span><a href="#s5334-data-transfer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>一旦<code class="language-plaintext highlighter-rouge">PhL</code>退出<code class="language-plaintext highlighter-rouge">识别阶段</code>，它就进入了<code class="language-plaintext highlighter-rouge">数据传输阶段</code>，其中<code class="language-plaintext highlighter-rouge">PH-DATA.request</code>和<code class="language-plaintext highlighter-rouge">PH-DATA.indicative</code>原语完全由上层协议层即<code class="language-plaintext highlighter-rouge">数据链路层</code>使用。</p><p>在<code class="language-plaintext highlighter-rouge">识别阶段</code>AP 是可以通过 PH-DATA 原语向物理层传数据的，进<code class="language-plaintext highlighter-rouge">数据传输阶</code>段就不行了</p><p>PhL<code class="language-plaintext highlighter-rouge">不负责</code>任何数据<code class="language-plaintext highlighter-rouge">流控</code>制功能：通过 PH-DATA.request primitive 收到的数据应<code class="language-plaintext highlighter-rouge">立即传输</code>，或者–当实施物理数据<code class="language-plaintext highlighter-rouge">流控</code>制时–应<code class="language-plaintext highlighter-rouge">覆盖</code>之前尚未传输的字节。由于 PH-DATA 服务既不是本地确认，也不是远程确认，因此在后一种情况下，不应发出错误信号。</p><h5 id="s5335-disconnection-of-an-existing-physical-connection"><span class="mr-2">s5.3.3.5 Disconnection of an existing physical connection</span><a href="#s5335-disconnection-of-an-existing-physical-connection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>客户端或服务器都可以启动现有物理连接的断开连接。这通过调用 <code class="language-plaintext highlighter-rouge">PH-ABORT.request</code> 原语的<code class="language-plaintext highlighter-rouge">物理连接管理器 AP</code> 来实现</p><p>PH-ABORT.request 的调用者，会收到 PH-ABORT.confirm 作为通知(在本地处理，本地的物理层通知本地的调用 AP，不外发，断开操作无需通知对方)</p><p>对方<code class="language-plaintext highlighter-rouge">不会收到</code>任何关于<code class="language-plaintext highlighter-rouge">断开</code>的消息，只能通过<code class="language-plaintext highlighter-rouge">检测物理连接</code>断开来发现物 Qq 理通道断开了。然后物理层生成 PH-ABORT.indication</p><p>如果是信道异常导致的断开，双方应该都会收到物理层传来的 PH-ABORT.indication，双方都断开。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/phydisconn.jpg" alt="messages" data-proofer-ignore></p><h3 id="s54-example-phl-service-primitives-and-hayes-commands"><span class="mr-2">s5.4 example: PhL service primitives and Hayes commands</span><a href="#s54-example-phl-service-primitives-and-hayes-commands" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>PH-CONNECT:</p><p>对于<code class="language-plaintext highlighter-rouge">主叫者</code>，physical connection manager AP 向物理层 PhL 发送<code class="language-plaintext highlighter-rouge">PH-CONNECT</code>.request，物理层 PhL 向 modem(DCE)发送<code class="language-plaintext highlighter-rouge">AT拨号</code>命令，并返回拨号结果，物理层将结果转换为<code class="language-plaintext highlighter-rouge">PH-CONNECT.confirm</code>返回给 AP</p><p>对于<code class="language-plaintext highlighter-rouge">被叫者</code>，AP 会被物理层通知<code class="language-plaintext highlighter-rouge">PH-CONNECT.indication</code>表示物理层已连接</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/phyconn.jpg" alt="messages" data-proofer-ignore></p><p>PH-DATA:</p><p>假设之前<code class="language-plaintext highlighter-rouge">建立了</code>与远程 DCE 的<code class="language-plaintext highlighter-rouge">连接</code>，并且 DCE 现在处于<code class="language-plaintext highlighter-rouge">数据传输模式</code>，那么传递到本地 DCE 的所有数据都将被传输到远程 DCE（不是透明传输，每一层都会对 data 数据做处理，比如添加开始停止位，校验位等）。</p><p>PH-ABORT：</p><p>在可以终止连接之前，必须首先将调制解调器切换到本地<code class="language-plaintext highlighter-rouge">命令模式</code>(从数据传输模式)</p><h2 id="s6-direct-local-connection"><span class="mr-2">s6 Direct Local Connection</span><a href="#s6-direct-local-connection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>光口物理层连接</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/modechange.jpg" alt="messages" data-proofer-ignore></p><h2 id="s7-dlmscosem-transport-layer-for-ip-networks"><span class="mr-2">s7 DLMS/COSEM transport layer for IP networks</span><a href="#s7-dlmscosem-transport-layer-for-ip-networks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>基于 UDP 的无连接传输层;<li>面向连接的基于 TCP 的传输层;<li>一个基于无连接 CoAP 的传输层</ul><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM TL</code>由<code class="language-plaintext highlighter-rouge">CoAP、UDP或TCP传输层</code>和一个称为<code class="language-plaintext highlighter-rouge">包装器wrapper</code>的额外子层组成</p><h3 id="s72-the-tcp-udpip-based-transport-layers"><span class="mr-2">s7.2 The TCP-UDP/IP based transport layers</span><a href="#s72-the-tcp-udpip-based-transport-layers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>DLMS/COSEM_on_IP</p><p>可以把 DLMS/COSEM AL 视为和 HTTP 一样的网络应用，使用 TCP-UDP 传输层服务</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/cosemalprofile.jpg" alt="messages" data-proofer-ignore></p><p>IANA 中注册了 4059/TCP-UDP 端口</p><p>DLMS/COSEM <code class="language-plaintext highlighter-rouge">AL</code>只监听<code class="language-plaintext highlighter-rouge">一个UDP或TCP端口</code>。另一方面，如 4.9 和 DLMS UA 1000-1 所示，<code class="language-plaintext highlighter-rouge">一个物理设备</code>可能承载<code class="language-plaintext highlighter-rouge">多个</code>客户端或服务器<code class="language-plaintext highlighter-rouge">ap</code>。包装器子层提供的<code class="language-plaintext highlighter-rouge">附加寻址</code>功能允许寻址这些<code class="language-plaintext highlighter-rouge">ap</code>。</p><p>包装<code class="language-plaintext highlighter-rouge">wrapper</code>子层具有以下功能:</p><ul><li>它在 UDP/TCP 端口上提供了一个<code class="language-plaintext highlighter-rouge">额外的寻址</code>能力(<code class="language-plaintext highlighter-rouge">wPort</code>);<li>它提供有关数据<code class="language-plaintext highlighter-rouge">传输长度</code>的信息。这个特性可以帮助发送方和接收方识别一个<code class="language-plaintext highlighter-rouge">完整的APDU</code>的接收，它可以在<code class="language-plaintext highlighter-rouge">多个TCP包</code>中发送和接收</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tlcosemonip.jpg" alt="messages" data-proofer-ignore></p><p>TCP-CONNECT and TCP-DISCONNECT services 的用户是 TCP Connection Manager Process，就是说 TCP 连接和释放不是 AL 管理的，由专门的管理进程管的，当然 AL 也要了解 TCP 当前的连接状态。</p><h4 id="s723-the-dlmscosem-connection-less-udp-based-transport-layer"><span class="mr-2">s7.2.3 The DLMS/COSEM connection-less, UDP-based transport layer</span><a href="#s723-the-dlmscosem-connection-less-udp-based-transport-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">无连接</code>，可实现<code class="language-plaintext highlighter-rouge">多播广播</code>；<code class="language-plaintext highlighter-rouge">开销小</code></p><p>缺点：<code class="language-plaintext highlighter-rouge">不可靠</code>（可以由上层实现可靠，当然 DLMS AL 层不会这么做，但是 CoAP 协议是个例子，基于 UDP 实现了可靠传输），无重复发送保护</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/udptl.jpg" alt="messages" data-proofer-ignore></p><p>.request 和.indication 服务原语是必需的。本地的.confirm 服务原语的实现是可选的。</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="go">UDP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length, Data
)
</span></pre></table></code></div></div><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="go">UDP-DATA.indication
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
</span></pre></table></code></div></div><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="go">UDP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_UDP_Port,
    Remote_UDP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Result</code>参数的值表示基于 DLMS/COSEM UDP 的 TL 是否能够发送请求的 UDP 数据报:<code class="language-plaintext highlighter-rouge">能(OK)</code>或<code class="language-plaintext highlighter-rouge">不能(NOK)</code>。result 为 OK 只能表示数据已发送，不保证能送达</p><p>UDP-DATA.confirm 是<code class="language-plaintext highlighter-rouge">可选的</code></p><p>在这个通信配置文件中，包装子层是一个无状态的实体：它的唯一作用是确保使用 wPort 号码的源和目的地 DLMS/COSEM AE 识别，并提供<code class="language-plaintext highlighter-rouge">OSI风格</code>的<code class="language-plaintext highlighter-rouge">UDP-DATA.xxx服务调用</code>与<code class="language-plaintext highlighter-rouge">标准UDP</code>提供的 SEND()和 RECEIVE()接口函数之间的<code class="language-plaintext highlighter-rouge">转换</code>。</p><p>对于 UDP 这种<code class="language-plaintext highlighter-rouge">面向数据报</code>而非<code class="language-plaintext highlighter-rouge">面向流</code>的协议，包装器中的长度字段并非必要，因为每个 udp 报文就是完整单一的，不存在分好几包还要拼包拆包处理粘包等操作，但为了和 TCP<code class="language-plaintext highlighter-rouge">兼容</code>还是需要该字段</p><h4 id="s72332-the-wrapper-protocol-data-unit-wpdu"><span class="mr-2">s7.2.3.3.2 The wrapper protocol data unit (WPDU)</span><a href="#s72332-the-wrapper-protocol-data-unit-wpdu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/wrapperwpdu.jpg" alt="messages" data-proofer-ignore></p><ul><li>version:始终为 0x0001<li>source/destination wPort:DLMS/COSEM AE 的端口<li>Data length:APDU 数据长度</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/udppdu.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/wrapperport.jpg" alt="messages" data-proofer-ignore></p><h4 id="s724-the-dlmscosem-connection-oriented-tcp-based-transport-layer"><span class="mr-2">s7.2.4 The DLMS/COSEM connection-oriented, TCP-based transport layer</span><a href="#s724-the-dlmscosem-connection-oriented-tcp-based-transport-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>面向流的，可靠，包括重传、全双工、流控</p><p>缺点：端到端，不支持广播和多播</p><p><code class="language-plaintext highlighter-rouge">TCP</code>作为一种面向连接的传输协议，涉及到<code class="language-plaintext highlighter-rouge">建立连接</code>、<code class="language-plaintext highlighter-rouge">交换数据</code>和<code class="language-plaintext highlighter-rouge">释放连接</code>三个阶段。因此，基于 TCP 的<code class="language-plaintext highlighter-rouge">DLMS/COSEM TL</code>为服务用户提供三个阶段的<code class="language-plaintext highlighter-rouge">OSIstyle</code>服务:</p><ul><li>在<code class="language-plaintext highlighter-rouge">连接建立</code>阶段，将<code class="language-plaintext highlighter-rouge">TCP-CONNECT</code>服务提供给服务用户<code class="language-plaintext highlighter-rouge">TCP连接管理器进程</code>;<li>在<code class="language-plaintext highlighter-rouge">数据传输</code>阶段，<code class="language-plaintext highlighter-rouge">TCP-DATA</code>服务提供给服务用户<code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>;<li>在<code class="language-plaintext highlighter-rouge">连接关闭</code>阶段，<code class="language-plaintext highlighter-rouge">TCP-DISCONNECT</code>服务被提供给服务用户<code class="language-plaintext highlighter-rouge">TCP连接管理进程</code>;<li>此外，一个<code class="language-plaintext highlighter-rouge">TCP-ABORT</code>服务被提供给服务用户<code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>。</ul><p><code class="language-plaintext highlighter-rouge">TCP连接管理服务</code>的服务用户<code class="language-plaintext highlighter-rouge">不是DLMS/COSEM AL</code>，而是<code class="language-plaintext highlighter-rouge">TCP连接管理进程</code>。该工艺的规范超出了本技术报告的范围</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcptl.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">TCP-DATA</code>可<code class="language-plaintext highlighter-rouge">本地或远程</code>确认，<code class="language-plaintext highlighter-rouge">UDP-DATA</code>只能<code class="language-plaintext highlighter-rouge">本地</code>确认</p><h5 id="stcp-connect"><span class="mr-2">sTCP-CONNECT</span><a href="#stcp-connect" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="go">TCP-CONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)

TCP-CONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)

TCP-CONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
</span></pre></table></code></div></div><p>TCP-CONNECT 由 TCP 连接管理进程和 TCP 层进行交互</p><p>TCP 连接管理进程不能拒绝 TCP 连接请求，所以 TCP-CONNECT.response 总是成功的</p><p>TCP-CONNECT.confirm 一般来说需要远程确认，如果是本地确认，可能回失败</p><h5 id="stcp-disconnect"><span class="mr-2">sTCP-DISCONNECT</span><a href="#stcp-disconnect" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="go">TCP-DISCONNECT.request
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address
)
</span></pre></table></code></div></div><p>TCP-DISCONNECT.request 用于断开请求</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="go">TCP-DISCONNECT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
</span></pre></table></code></div></div><p>TCP-DISCONNECT.indication 中<code class="language-plaintext highlighter-rouge">Reason</code>参数:</p><ul><li><code class="language-plaintext highlighter-rouge">对端设备</code>请求了 TCP 断开(Reason == <code class="language-plaintext highlighter-rouge">REMOTE_REQ</code>)<li><code class="language-plaintext highlighter-rouge">本地检测</code>到 TCP 连接断开(Reason == <code class="language-plaintext highlighter-rouge">ABORT</code>)</ul><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="go">TCP-DISCONNECT.response
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result
)
</span></pre></table></code></div></div><p>TCP 连接管理进程<code class="language-plaintext highlighter-rouge">不能拒绝</code>TCP 断开请求，表示远程断开 Reason == REMOTE_REQ</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="go">TCP-DISCONNECT.confirm
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Result,
    Reason_of_Failure
)
</span></pre></table></code></div></div><p>同 TCP-CONNECT.confirm</p><h5 id="stcp-abort"><span class="mr-2">sTCP-ABORT</span><a href="#stcp-abort" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>见 7.2 图 27，TCP-ABORT 是<code class="language-plaintext highlighter-rouge">AL</code>层和<code class="language-plaintext highlighter-rouge">TL</code>层交互的原语</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="go">TCP-ABORT.indication
(
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Reason
)
</span></pre></table></code></div></div><p>由基于 DLMS/COSEM TCP 的<code class="language-plaintext highlighter-rouge">TL</code>生成，用于向服务用户<code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>表示支持 TCP 连接的<code class="language-plaintext highlighter-rouge">非请求中断</code>。</p><p>当收到此指示时，<code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>应释放所有使用此 TCP 连接建立的<code class="language-plaintext highlighter-rouge">AAs</code>，并应使用 <code class="language-plaintext highlighter-rouge">COSEM-ABORT.indivation</code>服务原语向 COSEM AP 表明这一点。</p><h5 id="stcp-data"><span class="mr-2">sTCP-DATA</span><a href="#stcp-data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="go">TCP-DATA.request
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
</span></pre></table></code></div></div><p>Data 是 APDU</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="go">TCP-DATA.indication (
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Data_Length,
    Data
)
</span></pre></table></code></div></div><p>TCP-DATA.indication 基元由 DLMS/COSEM <code class="language-plaintext highlighter-rouge">TL</code>生成，用于向服务用户 DLMS/COSEM <code class="language-plaintext highlighter-rouge">AL</code>指示已从远程设备收到 xDLMS <code class="language-plaintext highlighter-rouge">APDU</code>。如果携带 APDU 的 TCP 数据包中的 Local_TCP_Port 和 Local_wPort 参数都包含<code class="language-plaintext highlighter-rouge">有效的端口号</code>，即接收设备中存在一个与给定端口号绑定的 DLMS/COSEM AE，则在基于 DLMS/COSEM TCP 的 TL<code class="language-plaintext highlighter-rouge">接收完整的APDU</code>（在<code class="language-plaintext highlighter-rouge">一个或多个</code>TCP 数据包中）后生成。否则，收到的消息将被直接丢弃。</p><p>TCP-DATA.indication 需要在接收完完整包并解包后交给 AL,Data 是 APDU</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="go">TCP-DATA.confirm
(
    Local_wPort,
    Remote_wPort,
    Local_TCP_Port,
    Remote_TCP_Port,
    Local_IP_Address,
    Remote_IP_Address,
    Confirmation_Type,
    Result
)
</span></pre></table></code></div></div><p>可选的，request 的确认</p><h5 id="s7243-protocol-specification-for-the-dlmscosem-tcp-based-transport-layer"><span class="mr-2">s7.2.4.3 Protocol specification for the DLMS/COSEM TCP-based transport layer</span><a href="#s7243-protocol-specification-for-the-dlmscosem-tcp-based-transport-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>wrapper 层和 UDP 的不同，因为 TCP 是流式的，需要发送/接收全 APDU，还要处理<code class="language-plaintext highlighter-rouge">粘包</code>等</p><h6 id="s72435-definition-of-the-procedures">s7.2.4.3.5 Definition of the procedures</h6><p>wrapper 层<code class="language-plaintext highlighter-rouge">透传</code><strong>TCP 连接管理器 AP</strong>和<strong>TCP 层</strong>之间的调用。</p><blockquote class="prompt-danger"><div><p>TODO:该设计是否合理，wrapper 层又多做了判断操作，直接管理 TCP 层是否更合理</p></div></blockquote><ul><li>TCP connection</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpconn.jpg" alt="messages" data-proofer-ignore></p><p>为了能够响应，响应方必须在接收第一个 SYN 包之前执行一个<code class="language-plaintext highlighter-rouge">“被动”打开</code>。为此，它必须联系本地操作系统(OS)，以表明它已经<code class="language-plaintext highlighter-rouge">准备好</code>接受传入的连接请求。作为这个联系的结果，操作系统分配一个<code class="language-plaintext highlighter-rouge">TCP端口号</code>给连接的端点(开启 TCP<code class="language-plaintext highlighter-rouge">端口监听</code>)，并为将来的连接保留所需的资源——但是没有发送消息。</p><ul><li>TCP disconnection</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpdisconn.jpg" alt="messages" data-proofer-ignore></p><p>客户端和服务端<code class="language-plaintext highlighter-rouge">TCP连接管理器进程</code>可以通过调用<code class="language-plaintext highlighter-rouge">TCP-DISCONNECT.request</code>来启动该过程。</p><ul><li>TCP connection abort</ul><p>基于 DLMS/COSEM TCP 的 <code class="language-plaintext highlighter-rouge">TL</code> 在 <code class="language-plaintext highlighter-rouge">TCP-ABORT.indication</code> 原语的帮助下指示支持 <code class="language-plaintext highlighter-rouge">TCP 连接</code>到 DLMS/COSEM <code class="language-plaintext highlighter-rouge">AL</code> 的<code class="language-plaintext highlighter-rouge">中断或断开</code>。 请注意，这是提供给 DLMS/COSEM AL 的<code class="language-plaintext highlighter-rouge">唯一</code> TCP 连接管理服务(其他服务都是提供给 TCP 连接管理进程的)。</p><p>当 <code class="language-plaintext highlighter-rouge">TCP 连接</code>被 <code class="language-plaintext highlighter-rouge">TCP 连接管理器进程</code>断开时调用该服务（<code class="language-plaintext highlighter-rouge">优雅断开</code>的情况），或者当 TCP 断开以<code class="language-plaintext highlighter-rouge">非请求方式</code>发生时，例如 TCP 子层<code class="language-plaintext highlighter-rouge">检测</code>到不可解决的<code class="language-plaintext highlighter-rouge">错误</code>或 <code class="language-plaintext highlighter-rouge">物理连接</code>被<code class="language-plaintext highlighter-rouge">关闭</code>。</p><blockquote class="prompt-danger"><div><p>TODO:前文 TCP-ABORT 一节提到 TCP-ABORT 不是非请求中断才生成吗?为什么请求中断也会生成</p></div></blockquote><p>该服务的目的是<code class="language-plaintext highlighter-rouge">通知</code> DLMS/COSEM <code class="language-plaintext highlighter-rouge">AL</code> TCP 连接<code class="language-plaintext highlighter-rouge">中断</code>，以便它可以<code class="language-plaintext highlighter-rouge">释放</code>所有现有的 <code class="language-plaintext highlighter-rouge">AA</code>。</p><ul><li>Data transfer using the TCP-DATA service</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpdata.jpg" alt="messages" data-proofer-ignore></p><p>可选<code class="language-plaintext highlighter-rouge">TCP-DATA.confirm</code>原语表示 TCP-DATA<code class="language-plaintext highlighter-rouge">结果</code>。请求原语之前调用，这是 OK 或 NOK。然而，这个结果的含义取决于实现。当.confirm 原语被实现为<code class="language-plaintext highlighter-rouge">本地确认</code>时，结果 t 表示 DLMS/COSEM TL 是否能够<code class="language-plaintext highlighter-rouge">缓冲发送</code>APDU 或<code class="language-plaintext highlighter-rouge">发送</code>APDU。当它作为<code class="language-plaintext highlighter-rouge">远程确认</code>实现时，结果表明 APDU 是否已<code class="language-plaintext highlighter-rouge">成功交付</code>到目的地。</p><p>WPDU 由 wrapper 层打包组包解包，TCP 是流式的，不关心字节范围，WPDU 可能被分为好几个 TCP 包发送</p><h4 id="s725-converting-osi-style-tl-services-to-and-from-rfc-style-tcp-function-calls"><span class="mr-2">s7.2.5 Converting OSI-style TL services to and from RFC-style TCP function calls</span><a href="#s725-converting-osi-style-tl-services-to-and-from-rfc-style-tcp-function-calls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s7251-transport-layer-and-tcp-connection-establishment"><span class="mr-2">s7.2.5.1 Transport layer and TCP connection establishment</span><a href="#s7251-transport-layer-and-tcp-connection-establishment" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcphandshake.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpmsc.jpg" alt="messages" data-proofer-ignore></p><h5 id="s7252-closing-a-transport-layer-and-a-tcp-connection"><span class="mr-2">s7.2.5.2 Closing a transport layer and a TCP connection</span><a href="#s7252-closing-a-transport-layer-and-a-tcp-connection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpmscclose.jpg" alt="messages" data-proofer-ignore></p><h5 id="s7253-tcp-connection-abort"><span class="mr-2">s7.2.5.3 TCP connection abort</span><a href="#s7253-tcp-connection-abort" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpabort.jpg" alt="messages" data-proofer-ignore></p><p>通过 TCP Wrapper 层轮询 TCP 层状态</p><h5 id="s7254-data-transfer-using-the-tcp-data-service"><span class="mr-2">s7.2.5.4 Data transfer using the TCP-DATA service</span><a href="#s7254-data-transfer-using-the-tcp-data-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpsenddata.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">AL层</code>通过 request 原语发送一个<code class="language-plaintext highlighter-rouge">992</code>字节的<code class="language-plaintext highlighter-rouge">APDU</code>，<code class="language-plaintext highlighter-rouge">Wrapper层</code>加上<code class="language-plaintext highlighter-rouge">8字节</code>的头，第一次发送<code class="language-plaintext highlighter-rouge">1000</code>字节，实际一包发出去 476 字节，还剩 524 字节，以此类推<code class="language-plaintext highlighter-rouge">直到发完</code>，向 AL 层回复 confirm 原语。该过程由 Wrapper 层控制。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpwrapperreceive.jpg" alt="messages" data-proofer-ignore></p><p>Wrapper 层接收到完整的 wrapper 头+APDU 后，解开 wrapper 头，将 APDU 放在<code class="language-plaintext highlighter-rouge">TCP-DATA.ind</code>原语中发送给 AL 层。</p><h3 id="s73-the-dlmscosem-coap-based-transport-layer"><span class="mr-2">s7.3 The DLMS/COSEM CoAP based transport layer</span><a href="#s73-the-dlmscosem-coap-based-transport-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s732-overview"><span class="mr-2">s7.3.2 Overview</span><a href="#s732-overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>受限应用协议 (Constrained Application Protocol,<code class="language-plaintext highlighter-rouge">CoAP</code>) 是由 IETF 核心工作组定义的专用互联网应用协议。 CoAP 专为在<code class="language-plaintext highlighter-rouge">资源受限</code>的设备中使用而设计，用于通过非受限或受限的互联网通信网络（例如，<code class="language-plaintext highlighter-rouge">低功耗</code>、<code class="language-plaintext highlighter-rouge">有损网络</code>）进行通信。 CoAP 旨在提供高效的数据传输能力，同时满足<code class="language-plaintext highlighter-rouge">可靠性</code>、<code class="language-plaintext highlighter-rouge">多播支持</code>、<code class="language-plaintext highlighter-rouge">极低开销</code>、<code class="language-plaintext highlighter-rouge">效率</code>和<code class="language-plaintext highlighter-rouge">简单性</code>等特殊要求。</p><p>基于 CoAP 的<code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP TL</code>提供<code class="language-plaintext highlighter-rouge">不可靠</code>和<code class="language-plaintext highlighter-rouge">可靠</code>的传输服务(CoAP 原来是属于<code class="language-plaintext highlighter-rouge">应用层</code>的，这里 DLMS 协议里把它做成了<code class="language-plaintext highlighter-rouge">传输层</code>，用来给 AL 提供服务)。<code class="language-plaintext highlighter-rouge">不可靠</code>的 CoAP 服务支持<code class="language-plaintext highlighter-rouge">组播</code>和<code class="language-plaintext highlighter-rouge">广播</code>。DLMS/COSEM CoAP TL 为服务用户 DLMS/COSEM AL 提供<code class="language-plaintext highlighter-rouge">OSI风格</code>的服务。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coaposi.jpg" alt="messages" data-proofer-ignore></p><p>整个<code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP TL</code>层包括了 Wrapper 层、CoAP 层、UDP 层，和标准 OSI 模型中的不同</p><h4 id="s733-structure-of-the-dlmscosem-coap-transport-layer"><span class="mr-2">s7.3.3 Structure of the DLMS/COSEM CoAP transport layer</span><a href="#s733-structure-of-the-dlmscosem-coap-transport-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coaplayer.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP TL</code>提供<code class="language-plaintext highlighter-rouge">不可靠</code>和<code class="language-plaintext highlighter-rouge">可靠</code>的运输服务。</p><ul><li>不可靠的 DLMS/COSEM CoAP 传输服务使用<code class="language-plaintext highlighter-rouge">non-confirmable (NON)</code> CoAP 消息<li>可靠的 DLMS/COSEM CoAP TL 服务使用<code class="language-plaintext highlighter-rouge">confirmable (CON)</code> CoAP 消息，并带有 CoAP 消息层提供的<code class="language-plaintext highlighter-rouge">重试机制</code>。</ul><p><code class="language-plaintext highlighter-rouge">CoAP wrapper</code>层提供的服务：</p><ul><li>通过与<code class="language-plaintext highlighter-rouge">CoAP请求/响应层</code>操作的交互，将<code class="language-plaintext highlighter-rouge">OSI风格</code>的数据服务<code class="language-plaintext highlighter-rouge">原语</code>(CoAP-DATA)传递给<code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>，以实现<code class="language-plaintext highlighter-rouge">CoAP POST方法</code>的使用<li>DLMS/COSEM<code class="language-plaintext highlighter-rouge">服务接入点SAP寻址</code>功能，从而允许<code class="language-plaintext highlighter-rouge">多个</code>DLMS/COSEM <code class="language-plaintext highlighter-rouge">AEs</code>驻留在物理设备的同一个 CoAP 客户机和服务器端点上</ul><h5 id="s7332-identification-and-addressing"><span class="mr-2">s7.3.3.2 Identification and addressing</span><a href="#s7332-identification-and-addressing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>识别与寻址</p><p>默认 5683 端口，同一个物理机里的客户端和服务端可以共用该端口</p><blockquote class="prompt-warning"><div><p>TODO: 结合 Bluebook 4.9 关于 CoAP 配置的对象</p></div></blockquote><h6 id="s73322-dlmscosem-al-identification-within-the-coap-transport-layer">s7.3.3.2.2 DLMS/COSEM AL identification within the CoAP transport layer</h6><p>一个 CoAP 端口可以为<code class="language-plaintext highlighter-rouge">不同的应用</code>（如除了 DLMS 的应用）提供服务，用<code class="language-plaintext highlighter-rouge">URIPath</code>区分(CoAP 类似于 HTTP，可以通过 URI 区分接入点)，IANA 规定的默认端口为 5683</p><p>默认情况下，DLMS/COSEM AL，无论是 DLMS 客户端 AL 还是 DLMS 服务器 AL，都使用该<code class="language-plaintext highlighter-rouge">URI-Path</code>: “<code class="language-plaintext highlighter-rouge">dlms</code>”</p><p>coap://127.0.0.1:5683/dlms</p><h6 id="sdlmscosem-coap-transport-layer-saps">sDLMS/COSEM CoAP transport layer SAPs</h6><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapsap.jpg" alt="messages" data-proofer-ignore></p><h4 id="s734-service-specification-for-the-dlmscosem-coap-transport-layer"><span class="mr-2">s7.3.4 Service specification for the DLMS/COSEM CoAP transport layer</span><a href="#s734-service-specification-for-the-dlmscosem-coap-transport-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coaploop.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">远程环回确认</code>(积极（传输成功的情况）的 TL 确认，用于<code class="language-plaintext highlighter-rouge">可靠</code>传输)，表示报文被<code class="language-plaintext highlighter-rouge">远端</code>确认，确认发送给本地 CoAP client，再由<code class="language-plaintext highlighter-rouge">本地wrapper层</code>返回给 AL 层 confirm 原语</p><p><code class="language-plaintext highlighter-rouge">本地环回确认</code>(消极（失败的情况，比如发生了什么错误）的 TL 确认，用于<code class="language-plaintext highlighter-rouge">可靠和不可靠</code>传输，可靠传输中可能是对方超时没回确认，视为失败，不可靠传输中可能是 udp 层有错误导致调用发送函数失败，视为失败)，用于失败的情况，由<code class="language-plaintext highlighter-rouge">本地CoAP client</code>返回给 wrapper 层错误信息，<code class="language-plaintext highlighter-rouge">本地wrapper层</code>返回给 AL 层 confirm 原语</p><h5 id="s7342-the-dlmscosem-coap-data-service-primitives"><span class="mr-2">s7.3.4.2 The DLMS/COSEM CoAP-DATA service primitives</span><a href="#s7342-the-dlmscosem-coap-data-service-primitives" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h6 id="s73421-coap-datarequest">s7.3.4.2.1 CoAP-DATA.request</h6><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="go">CoAP-DATA.request
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Remote_Path [Optional Use],
    Response_Mode,
    Request_ID [Optional Use],
    Data_Length,
    Data
)
</span></pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">Transport_Mode</code>: CoAP 传输模式，“<code class="language-plaintext highlighter-rouge">RELIABLE</code>”可靠，“<code class="language-plaintext highlighter-rouge">UNRELIABLE</code>”不可靠（这里的可靠其实是对于整个DLMS/COSEM传输层来说的，首先由 wrapper 层负责，当然底层还是需要 CoAP 可靠或不可靠模式的支持）,见7.3.5.6。对于CoAP协议提供的不可靠传输模式主要还是在广播的时候用的<li><code class="language-plaintext highlighter-rouge">Remote_Path</code>： CoAP <code class="language-plaintext highlighter-rouge">Uri-Path</code>。Response_Mode 为“RESPONSE”忽略该参数<li><code class="language-plaintext highlighter-rouge">Response_Mode</code>：表示是否期望返回 DLMS/COSEM 响应 APDU。影响CWPDU中的<code class="language-plaintext highlighter-rouge">WRM</code>。它取值:”<code class="language-plaintext highlighter-rouge">CONFIRMED</code>“， “<code class="language-plaintext highlighter-rouge">UNCONFIRMED</code>“， “<code class="language-plaintext highlighter-rouge">RESPONSE</code>“。<li><p><code class="language-plaintext highlighter-rouge">Request_ID</code>：标识了特定的数据请求操作。Request_ID 将在可能产生的<code class="language-plaintext highlighter-rouge">CoAP-DATA.confirm</code>原语中返回，表明 DLMS/COSEM CoAP TL<code class="language-plaintext highlighter-rouge">传送数据</code>参数中给出的 APDU 的<code class="language-plaintext highlighter-rouge">成功或失败</code>。见7.3.5.6Request_ID 被指定为支持在<code class="language-plaintext highlighter-rouge">已发送多个</code>携带请求的 APDU 且 DLMS/COSEM CoAP TL 确认尚未完成的情况下，以<code class="language-plaintext highlighter-rouge">每个</code>APDU 为基础返回 DLMS/COSEM CoAP TL<code class="language-plaintext highlighter-rouge">确认</code>(类似于 TCP 的<code class="language-plaintext highlighter-rouge">滑动窗口</code>，可以<code class="language-plaintext highlighter-rouge">异步确认</code>)。以下情况适用:</p><ul><li>如果 Request_ID 未被指定，CoAP-DATA.confirm 原语中 Request_ID 也不被指定。<li>如果 Transport_Mode 被设置为<code class="language-plaintext highlighter-rouge">UNRELIABLE</code>，并且 DLMS/COSEM CoAP TL 实现<code class="language-plaintext highlighter-rouge">不支持</code>这种操作模式的 CoAP-DATA.confirm 原语，那么 Request_ID 可以不被指定。<li>如果 DLMS/COSEM CoAP TL 服务<code class="language-plaintext highlighter-rouge">不支持</code>CoAP-DATA.<code class="language-plaintext highlighter-rouge">confirm</code>原语，CoAP wrapper 将<code class="language-plaintext highlighter-rouge">忽略</code>指定的 Request_ID 标识。</ul></ul><p><strong>使用场景</strong>：</p><ul><li><p>发送<code class="language-plaintext highlighter-rouge">DLMS/COSEM请求</code>（单播或多播广播）：</p><ul><li><code class="language-plaintext highlighter-rouge">Remote_Path</code>指定为对方 Uri-Path<li><code class="language-plaintext highlighter-rouge">Local_Port and Local_IP_address</code>可选<li><p><code class="language-plaintext highlighter-rouge">Response_Mode</code>：</p><ul><li><code class="language-plaintext highlighter-rouge">需确认</code>的请求，使用<code class="language-plaintext highlighter-rouge">CONFIRMED</code><li><code class="language-plaintext highlighter-rouge">无需确认</code>的请求，使用<code class="language-plaintext highlighter-rouge">UNCONFIRMED</code><li>General Block Transfer(<code class="language-plaintext highlighter-rouge">GBT</code>)<code class="language-plaintext highlighter-rouge">分块传输</code>的请求,视情况，比如<code class="language-plaintext highlighter-rouge">单播或广播</code>，可用<code class="language-plaintext highlighter-rouge">CONFIRMED或UNCONFIRMED</code></ul></ul><li><p>发送<code class="language-plaintext highlighter-rouge">DLMS/COSEM响应</code>（也为 CoAP-DATA.request，只要是发送就是request，和 AL 层的报文类型无关）：</p><ul><li><code class="language-plaintext highlighter-rouge">Remote_Path不指定</code><li><code class="language-plaintext highlighter-rouge">Local_Port and Local_IP_address</code>需要指定，和请求匹配<li>Transport_mode, Local_SAP, Remote_SAP, Remote_IP_address, Remote_Port 需匹配请求<li><p><code class="language-plaintext highlighter-rouge">Response_Mode</code>：</p><ul><li>一般为<code class="language-plaintext highlighter-rouge">RESPONSE</code><li><p>APDU 为 GBT 时，为<code class="language-plaintext highlighter-rouge">CONFIRMED</code>，Remote_Path 需指定</p><blockquote class="prompt-danger"><div><p>TODO:这不是和上面说的不指定矛盾了吗</p></div></blockquote></ul></ul></ul><h6 id="s73422-coap-dataindication">s7.3.4.2.2 CoAP-DATA.indication</h6><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="go">CoAP-DATA.indication
(
    Transport_Mode,
    Local_SAP,
    Remote_SAP,
    Local_IP_address,
    Local_Port,
    Remote_IP_address,
    Remote_Port,
    Data_Length,
    Data
)
</span></pre></table></code></div></div><ul><li>Transport_Mode: CoAP 传输模式，“RELIABLE”可靠，“UNRELIABLE”不可靠</ul><h6 id="s73422-coap-dataconfirm">s7.3.4.2.2 CoAP-DATA.confirm</h6><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="go">CoAP-DATA.confirm
(
    Local_SAP,
    Remote_SAP,
    Local_IP_address [Optional Use],
    Local_Port [Optional Use],
    Remote_IP_address,
    Remote_Port,
    Request_ID [Optional Use],
    Result
)
</span></pre></table></code></div></div><ul><li>Local_SAP：本地 DLMS/COSEM AE 的 SAP<li>Request_ID：对应的 CoAP-DATA.request 中携带的，如果 request 没有指定就是未定义<li>Result：“REMOTE OK”表示远端已接收，“NOT OK”表示发送失败</ul><p><strong>使用场景</strong>：</p><p>CoAP-DATA.confirm 由 wrapper 层生成</p><p>对于<code class="language-plaintext highlighter-rouge">不可靠</code>的传输模式，Result 没有“REMOTE OK”<code class="language-plaintext highlighter-rouge">远程确认</code>，但可以生成“NOT OK”表示<code class="language-plaintext highlighter-rouge">本地错误</code>，对不可靠传输模式该原语是可选的</p><h4 id="s735-protocol-specification-of-the-dlmscosem-coap-transport-layer"><span class="mr-2">s7.3.5 Protocol specification of the DLMS/COSEM CoAP transport layer</span><a href="#s735-protocol-specification-of-the-dlmscosem-coap-transport-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s7352-the-dlmscosem-coap-tl-protocol-data-unit-coap-pdu"><span class="mr-2">s7.3.5.2 The DLMS/COSEM CoAP TL Protocol Data Unit (CoAP-PDU)</span><a href="#s7352-the-dlmscosem-coap-tl-protocol-data-unit-coap-pdu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>CoAP-PDU = UDP header + CoAP header + CWPDU(wrapper header + APDU)</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coaplayer2.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP TL PDU</code>是一个<code class="language-plaintext highlighter-rouge">UDP数据报</code>，携带<code class="language-plaintext highlighter-rouge">CoAP消息</code>作为其<code class="language-plaintext highlighter-rouge">有效载荷</code>。该 CoAP 消息携带<code class="language-plaintext highlighter-rouge">CoAP头</code>和 DLMS/COSEM CoAP Wrapper PDU（<code class="language-plaintext highlighter-rouge">CWPDU</code>）。CWPDU 携带 DLMS/COSEM <code class="language-plaintext highlighter-rouge">APDU</code>作为其有效载荷加上 DLMS/COSEM CoAP <code class="language-plaintext highlighter-rouge">TL控制信息</code>，。</p><h5 id="s7353-the-dlmscosem-coap-wrapper-protocol-data-unit-cwpdu"><span class="mr-2">s7.3.5.3 The DLMS/COSEM CoAP Wrapper Protocol Data Unit (CWPDU)</span><a href="#s7353-the-dlmscosem-coap-wrapper-protocol-data-unit-cwpdu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>CWPDU = wrapper header + APDU</p><p>DLMS/COSEM CoAP 包装协议数据单元(<code class="language-plaintext highlighter-rouge">CWPDU</code>)由一个可选的<code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP wrapper头</code>和它的有效负载<code class="language-plaintext highlighter-rouge">APDU</code>组成。</p><p><code class="language-plaintext highlighter-rouge">CoAP请求</code>中 CWPDU<code class="language-plaintext highlighter-rouge">才包含</code>DLMS/COSEM CoAP <code class="language-plaintext highlighter-rouge">wrapper</code>报头。</p><p><code class="language-plaintext highlighter-rouge">CoAP响应</code>中 CWPDU<code class="language-plaintext highlighter-rouge">不包含</code>DLMS/COSEM CoAP <code class="language-plaintext highlighter-rouge">wrapper</code>头，</p><blockquote class="prompt-tip"><div><p>不同于 TCP 或 UDP，CoAP 是<code class="language-plaintext highlighter-rouge">请求响应模型</code>的，所以请求和回应在 DLMS 的 TL 层也是一一对应的（通过 Token 匹配），客户端完全可以知道回应的 wrapper 头中的<code class="language-plaintext highlighter-rouge">SAP</code>应该是什么。所以响应中的 wrapper 头可以省略</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapcwpdu.jpg" alt="messages" data-proofer-ignore></p><p>CoAP 不是流式传输，报文也是完整的，不需要<code class="language-plaintext highlighter-rouge">长度</code>信息</p><ul><li>The DLMS/COSEM CoAP TL version：TL 版本号，0-15，目前为 0<li>Reserved bits：保留<li>The CoAP Wrapper Response Mode (<code class="language-plaintext highlighter-rouge">WRM</code>)：通知对方的 wrapper 层是否应该期望收到对方的 AL 层响应，(为 1 时，服务端 wrapper 层就知道不需要等待服务端 AL 层响应，客户端 AL 也不会收到传输层给它的确认，但当启用了传输层可靠传输时，传输层自己要保证发送成功，包括超时重发和失败重发)，见 7.3.5.6<li>Remote SAP：接收站点的 SAP<li>Local SAP：发送站点的 SAP</ul><h5 id="s7354-the-constrained-application-protocol-coap"><span class="mr-2">s7.3.5.4 The Constrained Application Protocol (CoAP)</span><a href="#s7354-the-constrained-application-protocol-coap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h6 id="s73542-the-coap-message">s7.3.5.4.2 The CoAP Message</h6><p>CoAP 消息以简单的<code class="language-plaintext highlighter-rouge">二进制格式</code>编码。消息由一个固定大小的<code class="language-plaintext highlighter-rouge">4字节头</code>、一个<code class="language-plaintext highlighter-rouge">可变长</code>度的<code class="language-plaintext highlighter-rouge">Token值</code>(0-8 字节)、<code class="language-plaintext highlighter-rouge">0个或多个tlv编码</code>的选项(可选地)和<code class="language-plaintext highlighter-rouge">负载</code>组成。</p><p>一个<code class="language-plaintext highlighter-rouge">非空的CWPDU</code>作为<code class="language-plaintext highlighter-rouge">有效负载</code>在 CoAP 消息中携带。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapprotocol.png" alt="messages" data-proofer-ignore></p><p>本节其实就是介绍标准 coap 协议，可以看其他文章，见<a href="https://blog.csdn.net/weixin_41572450/article/details/103549125">CoAP 学习笔记（1）CoAP 报文结构</a></p><p>DLMS/COSEM CoAP TL 层只用到了其中的一部分的 code</p><ul><li><p>CoAP Request method codes</p><p>在<code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP TL</code>的<code class="language-plaintext highlighter-rouge">CoAP消息</code>中使用的请求方法代码如下</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Request<th style="text-align: center">method<th style="text-align: center">Meaning Use<tbody><tr><td style="text-align: center">0.02<td style="text-align: center">POST method<td style="text-align: center">发送<code class="language-plaintext highlighter-rouge">新的</code>包含 CWPDU 的<code class="language-plaintext highlighter-rouge">请求或响应</code><tr><td style="text-align: center">0.00<td style="text-align: center">空报文 ACK message without piggybacked response<td style="text-align: center">在可靠传输中用于<code class="language-plaintext highlighter-rouge">ACKs</code>确认，不带响应</table></div><li><p>CoAP Success Response codes</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Success Response code<th style="text-align: center">Meaning<th style="text-align: center">Use<tbody><tr><td style="text-align: center">2.04<td style="text-align: center">Success (Changed)<td style="text-align: center">对<code class="language-plaintext highlighter-rouge">已存在</code>的请求/响应回复包含 CWPDU 的<code class="language-plaintext highlighter-rouge">响应</code></table></div></ul><p>三种响应模式见上述文章</p><p>客户端错误和服务器<code class="language-plaintext highlighter-rouge">错误响应代码</code>由<code class="language-plaintext highlighter-rouge">CoAP协议层</code>或<code class="language-plaintext highlighter-rouge">CoAP包装器</code>根据错误条件<code class="language-plaintext highlighter-rouge">填充</code></p><ul><li><p>Token(可选，TKL 指定是否存在)</p><p>令牌用于配置响应和请求</p><li><p>Token Length(TKL 指定)</p><p>建议 DLMS/COSEM CoAP TL 实施的 CoAP 请求/响应层使用的令牌长度限制为<code class="language-plaintext highlighter-rouge">0-4字节</code>，以平衡令牌传输成本和上下文不匹配的风险，或者当令牌在相同的 CoAP 端点之间重复使用时可能出现的重复检测失败。进一步参考 RFC 7252。</p><p>DLMS 服务器的 DLMS/COSEM CoAP TL 的 CoAP 协议层使用的 Token 长度可在<code class="language-plaintext highlighter-rouge">CoAP设置对象</code>中指定，见 DLMS UA 1000-1 Part 2 Ed.15:2021, 4.9.8。</p><li><p>Options</p><p>Options 也只用到了标准中的一部分,当然没有规定只能用这些，但要保证双方能处理这些选项</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapoption.jpg" alt="messages" data-proofer-ignore></p><ul><li><code class="language-plaintext highlighter-rouge">Uri-Path</code>: CoAP uri 路径，默认是 dlms<li><code class="language-plaintext highlighter-rouge">Content-Format</code>：允许的传输格式，和 HTTP 类似，可以不指定，因为默认都是<code class="language-plaintext highlighter-rouge">application/octet-stream</code><li><code class="language-plaintext highlighter-rouge">Block1</code> and <code class="language-plaintext highlighter-rouge">Block2</code>：在 RFC 7959 中新增的两个 option，用于表示分块传输，见 7.3.5.4.5，另见<a href="https://zhuanlan.zhihu.com/p/461498161">CoAP 分块传输</a></ul></ul><h6 id="s73543-coap-retransmission-and-response-piggybacking">s7.3.5.4.3 CoAP retransmission and response piggybacking</h6><p>当 CWPDU 在<code class="language-plaintext highlighter-rouge">可靠</code>的 CoAP 消息层支持的新 CoAP 请求/响应上下文中传输时（即通过可确认的（CON）CoAP 消息），那么，正如 RFC 7252 所规定的，CoAP 消息层将继续<code class="language-plaintext highlighter-rouge">重传</code>CoAP 请求消息，直到它被 CoAP 服务器终端<code class="language-plaintext highlighter-rouge">确认</code>。这可以是单独的<code class="language-plaintext highlighter-rouge">CoAP确认消息ACK</code>的返回形式，也可以是<code class="language-plaintext highlighter-rouge">附带</code>CWPDU 或错误响应的<code class="language-plaintext highlighter-rouge">piggybacked ACK消息</code></p><blockquote class="prompt-tip"><div><p>关于<a href="https://en.wikipedia.org/wiki/Piggybacking_(data_transmission)">piggybacking 技术</a>：</p><p>在双向通信中，每当收到帧时，<code class="language-plaintext highlighter-rouge">接收方</code>都会<code class="language-plaintext highlighter-rouge">等待</code>，并且<code class="language-plaintext highlighter-rouge">不会立即</code>将控制帧（<code class="language-plaintext highlighter-rouge">确认</code>或<code class="language-plaintext highlighter-rouge">ACK</code>）发送回<code class="language-plaintext highlighter-rouge">发送方</code>。</p><p><code class="language-plaintext highlighter-rouge">接收方等待</code>，直到其网络层传入下一个<code class="language-plaintext highlighter-rouge">数据包</code>。然后，<code class="language-plaintext highlighter-rouge">延迟的确认</code>将<code class="language-plaintext highlighter-rouge">附加</code>到此传出数据帧。</p><p>这种暂时<code class="language-plaintext highlighter-rouge">延迟确认</code>以便可以与下一个传出数据帧挂钩的技术称为<code class="language-plaintext highlighter-rouge">piggybacking</code>。</p><p><code class="language-plaintext highlighter-rouge">优点</code>：提高效率，更好地利用可用信道带宽。</p><p><code class="language-plaintext highlighter-rouge">缺点</code>：如果<code class="language-plaintext highlighter-rouge"> 接收方</code><code class="language-plaintext highlighter-rouge">没有要发送 </code>的内容，则接收器可能会<code class="language-plaintext highlighter-rouge">阻塞</code>服务。这可以通过在接收到数据帧时启用计数器（<code class="language-plaintext highlighter-rouge">接收器超时</code>）来解决。如果<code class="language-plaintext highlighter-rouge">计数结束</code>并且没有要发送的数据帧，则<code class="language-plaintext highlighter-rouge">接收方将发送 ACK</code> 控制帧。<code class="language-plaintext highlighter-rouge">发送方</code>还会添加一个<code class="language-plaintext highlighter-rouge">计数器</code>（发送器超时），如果计数器在没有收到<code class="language-plaintext highlighter-rouge">确认</code>的情况下结束，则发送方将假定数据包丢失，然后<code class="language-plaintext highlighter-rouge">再次发送</code>帧。</p><p>该技术主要是为了<code class="language-plaintext highlighter-rouge">减轻网络负担</code>,这个附带内容可以是接收器对于<code class="language-plaintext highlighter-rouge">上一帧的回复</code>（如果处理快的话也可以是本次请求的回复），也可以是<code class="language-plaintext highlighter-rouge">主动上报</code>等</p></div></blockquote><p>CoAP 层会考虑使用<code class="language-plaintext highlighter-rouge">piggybacking</code>的可能性，<code class="language-plaintext highlighter-rouge">ACK</code>会<code class="language-plaintext highlighter-rouge">延时发送</code>，直到本地 wrapper 层收到 AL 层的数据并打包成 CWPDU 或超时，再发送<code class="language-plaintext highlighter-rouge">附带或不附带数据</code>的<code class="language-plaintext highlighter-rouge">ACK</code>。要是超时的话这个 CWPDU 单独发送，不附带在这个 ACK 中</p><p>7.3.5.4.3.2 <strong>CoAP Retransmission Parameters</strong></p><p>DLMS/COSEM CoAP TL 中的可靠 CoAP 消息传递层使用许多参数来控制 RFC 7252 定义的 CoAP 重传算法。这些参数在 CoAP setup interface class 类中指定</p><ul><li><p>ack_timeout</p><p>需确认消息的最小初始 ACK 超时</p><p><code class="language-plaintext highlighter-rouge">initial_ack_timeout</code>是在<code class="language-plaintext highlighter-rouge">ack_timeout</code>和<code class="language-plaintext highlighter-rouge">ack_timeout x ack_random_factor</code>之间<code class="language-plaintext highlighter-rouge">随机选择</code>的值。</p><p><code class="language-plaintext highlighter-rouge">initial_ack_timeout</code>是可靠的 CoAP 消息层的<code class="language-plaintext highlighter-rouge">初始重传延迟</code>。</p><li><p>ack_random_factor</p><p>用于申请初始 ACK 超时随机性的随机因子。</p><li><p>max_retransmit</p><p>需确认消息的最大重传次数。</p><li><p>delay_ack_timeout</p><p>CoAP 消息传递层在<code class="language-plaintext highlighter-rouge">返回确认</code>之前<code class="language-plaintext highlighter-rouge">等待</code>应用层返回响应的时间（以毫秒为单位），piggybacking 相关的，防止太久不回 ACK 触发对方重传</p><p>7.3.5.4.3.3 <strong>CoAP Congestion Control Parameters</strong></p></ul><p>拥塞控制</p><ul><li><p>NSTART</p><p>以下任一形式的同时<code class="language-plaintext highlighter-rouge">未完成</code>的 CoAP 请求消息的<code class="language-plaintext highlighter-rouge">数量</code>：</p><ul><li>没收到 ACK 的 CON 消息(需确认消息)<li>没收到响应的 NON 消息(无需确认消息)</ul><li><p>PROBING_RATE</p><p>探测速率</p><p>定义一个端点发送到另一个没有响应的端点时不应超过的平均<code class="language-plaintext highlighter-rouge">数据速率</code>(字节/秒)。</p></ul><h6 id="s73545-coap-block-transfer">s7.3.5.4.5 CoAP Block Transfer</h6><p>见 7.3.5.4.2</p><p><a href="https://zhuanlan.zhihu.com/p/461498161">第 31 篇：CoAP 分块传输</a></p><p>在 APDU 大于 MTU，且小于 receiver_max_pdu_size 时生效（大于 receiver_max_pdu_size 本身就不合法，AL 或 TL 应该屏蔽该报文）</p><blockquote class="prompt-danger"><div><p>TODO:为什么是 APDU 大于 MTU，MTU 不是链路层的限制吗，就算要分也是加上 IP 头，UDP 头和 CoAP 头，wrapper 头后的 APDU 的长度作为基准吧</p></div></blockquote><p>DLMS/COSEM CoAP TL 中的 CoAP 块传输层应按照<code class="language-plaintext highlighter-rouge">RFC 7959</code>的建议，在没有不当延迟的情况下完成 CoAP 块传输</p><h5 id="s7355-error-handling"><span class="mr-2">s7.3.5.5 Error Handling</span><a href="#s7355-error-handling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h6 id="s73552-coap-protocol-layers">s7.3.5.5.2 CoAP protocol layers</h6><p>CoAP<code class="language-plaintext highlighter-rouge">消息层</code>或<code class="language-plaintext highlighter-rouge">请求/响应层</code>的错误通过<code class="language-plaintext highlighter-rouge">重置消息</code>(名词)或 CoAP 协议层实体根据 RFC 7252 和 RFC 7959<code class="language-plaintext highlighter-rouge">自动生成</code>的 CoAP 客户端和服务器<code class="language-plaintext highlighter-rouge">错误响应</code>传递给发送的 CoAP 实体</p><h6 id="s73553-coap-wrapper-layer">s7.3.5.5.3 CoAP wrapper layer</h6><p><code class="language-plaintext highlighter-rouge">wrapper层</code>的<code class="language-plaintext highlighter-rouge">错误处理</code>，就是从一个 wrapper 层发给另一个 wrapper 层</p><ul><li><p>Unreliable CoAP transport <code class="language-plaintext highlighter-rouge">不可靠传输</code></p><p>一般是多播，在多播情况下 wrapper 将接收到的不能处理的 CWPDU<code class="language-plaintext highlighter-rouge">丢弃</code></p><blockquote class="prompt-warning"><div><p>TODO:wrapper 层是不是通过 CWPDU 中的客户端 SAP 参数知道是否是多播的 更新：有可能，或者是CoAP协议会带这个原语参数通知wrapper层是否是广播多播。然后其实这个丢弃和多播无关，不是多播也会丢弃。因为是不可靠传输，所以不需要 wrapper 层回确认（空报文）或否认</p></div></blockquote><li><p>Reliable CoAP transport <code class="language-plaintext highlighter-rouge">可靠传输</code></p><p>接收端 wrapper 层无法处理接收到的 CWPDU(由 CoAP request 携带)时返回错误</p><p>这种错误响应可能有助于诊断，也可能有助于主动纠正措施。通常，当传入的请求由于<code class="language-plaintext highlighter-rouge">语法错误</code>而无法提供服务时，将返回<code class="language-plaintext highlighter-rouge">CoAP客户端错误</code>(类似 HTTP 状态码里的 4xx 表示客户端错误，5xx 表示服务器错误，<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码</a>)，而当 CoAP 包装器<code class="language-plaintext highlighter-rouge">无法处理</code>明显<code class="language-plaintext highlighter-rouge">有效</code>的请求时，将返回<code class="language-plaintext highlighter-rouge">CoAP服务器错误</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapwrappererror.jpg" alt="messages" data-proofer-ignore></p></ul><h6 id="s73554-propagation-of-errors-through-coap-wrapper-layer">s7.3.5.5.4 Propagation of errors through CoAP wrapper layer</h6><p>返回到发送端 CoAP 协议层的错误响应应该以所产生的<code class="language-plaintext highlighter-rouge">CoAP消息层交付失败</code>（见下）的形式传播到<code class="language-plaintext highlighter-rouge">发送端CoAP wrapper层</code>，或者以<code class="language-plaintext highlighter-rouge">返回的错误本身</code>的直接形式传播，<code class="language-plaintext highlighter-rouge">无论</code>它们是由<code class="language-plaintext highlighter-rouge">接收CoAP协议层</code>还是由<code class="language-plaintext highlighter-rouge">接收CoAP包装器层</code>产生的。</p><ul><li><p>CoAP 消息层交付失败原因：</p><ul><li>接收到重置消息<li>放弃 CoAP block transfer 操作<li>可靠 CoAP 消息传递层放弃可靠传输的 CoAP 消息<li>CoAP 层错误或 UDP 或 IP 层错误</ul></ul><p>如果是可靠传输，CWPDU 的交付失败必须从 CoAP 协议层传播到 wrapper 层，以便其酌情通知 AL 层。</p><h5 id="s7356-dlmscosem-coap-tl-confirmations"><span class="mr-2">s7.3.5.6 DLMS/COSEM CoAP TL confirmations</span><a href="#s7356-dlmscosem-coap-tl-confirmations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><code class="language-plaintext highlighter-rouge">CoAP包装器请求/响应上下文</code>（见 7.3.5.7）对于在本地发起的 CoAP 请求/响应上下文中传送的任何<code class="language-plaintext highlighter-rouge">未完成</code>的 CWPDU（还没有收到 CoAP 响应）<code class="language-plaintext highlighter-rouge">保持</code>给定<code class="language-plaintext highlighter-rouge">Request_ID</code>的<code class="language-plaintext highlighter-rouge">状态</code>，以便 wrapper 层在返回<code class="language-plaintext highlighter-rouge">负面</code>（比如有错误发生）或<code class="language-plaintext highlighter-rouge">正面</code>（比如传输成功）的 DLMS/COSEM CoAP TL 确认时可以用 CoAP-DATA.confirm 原语向 AL 层返回 Request_ID。</p><p>对于<code class="language-plaintext highlighter-rouge">不可靠</code>的 DLMS/COSEM CoAP TL，这个是<code class="language-plaintext highlighter-rouge">可选的</code>，也就是无需维护维护<code class="language-plaintext highlighter-rouge">Request_ID</code>的状态。也只能回复<code class="language-plaintext highlighter-rouge">负面</code>的确认（无需正面确认，因为不可靠就是无确认的）</p><ul><li><p>CoAP 传输层错误指示</p><p>如果<strong>CoAP 包装器从 CoAP 协议层</strong><code class="language-plaintext highlighter-rouge">收到</code>在本地发起的 CoAP 请求/响应上下文中传输的 CWPDU 的<code class="language-plaintext highlighter-rouge">交付失败指示</code>，则<code class="language-plaintext highlighter-rouge">CoAP包装器</code>通过 CoAP-DATA.confirm 原语（结果为 “<code class="language-plaintext highlighter-rouge">NOT OK</code>“）和与 CoAP-DATA.request 原语中的 APDU 提供的 Request_ID 相匹配的<code class="language-plaintext highlighter-rouge">Request_ID</code>来传达相关 APDU 的<code class="language-plaintext highlighter-rouge">交付失败</code>。参见 7.3.5.7.5。</p><li><p>CoAP 传输层确认</p><p>支持 DLMS/COSEM CoAP TL 确认，如果接收端的 AL 层不会对这条报文回确认，那这个确认可以由接收端传输层自己生成并回复(AL 层面无需响应，也就不会回响应，但传输层可靠传输层面需要确认)。使用带有 push_operation_method (1) 的<code class="language-plaintext highlighter-rouge">无需确认</code> DataNotification 的<code class="language-plaintext highlighter-rouge">可靠数据推送</code>操作需要 DLMS/COSEM CoAP TL 确认。 参见 DLMS UA 1000-1 第 2 部分 Ed.15:2021, 4.4.8.2.2.11)，就是蓝皮书中的 push_operation_method 为 1 这种情况，需要传输层确认，而无需 AL 层确认，当然确认结果也不用给 AL 层，重发也是传输层自己负责</p><p>CoAP 包装层支持 DLMS/COSEM CoAP TL 确认，用于在 CoAPDATA.request 原语中以 <code class="language-plaintext highlighter-rouge">Response_Mode = UNCONFIRMED</code> 和 <code class="language-plaintext highlighter-rouge">Transport_Mode = RELIABLE</code> 提供的 APDU。(服务端 AL 层无需响应，客户端 AL 也不会收到传输层给它的确认，但传输层自己要保证发送成功，包括超时重发和失败重发。</p><blockquote class="prompt-tip"><div><p><strong>注意，CoAP 层只会在未收到 ACK 时重发，对于 wrapper 层 CWPDU 未收到的情况需要 wrapper 层自己重发</strong></p></div></blockquote><blockquote class="prompt-warning"><div><p>TODO:可靠传输不是靠 CoAP 的 ACK 吗，为什么还要单独再搞个 wrapper 层的确认 更新：DLMS/COSEM TL 层的可靠传输，属于整一层的，CoAP 的 ACK 也是 wrapper 层用于判断传输成功的一种依据。比如还有明明收到了 ACK 但没收到对方 wrapper 层的响应，就要由 wrapper 层自己重发，来保证可靠传输</p></div></blockquote><p>过程：</p><ol><li>在 <code class="language-plaintext highlighter-rouge">Response_Mode = UNCONFIRMED</code> 的 CoAP-DATA.request 原语中提供给 CoAP 包装器的 APDU 应由 CoAP 包装器在 <code class="language-plaintext highlighter-rouge">CoAP 包装器响应模式</code>(WRM)设置为 1 的 CWPDU 中的新本地发起 CoAP 请求/响应上下文中传输（<code class="language-plaintext highlighter-rouge">WRM = 1</code>)（WRM 见 7.3.5.2，关于 CWPDU 的定义）。 这指示接收 CoAP 包装器<code class="language-plaintext highlighter-rouge">不要等待</code>返回 DLMS AL 响应或 DLMS AP 响应；<li>接收 CoAP 包装器应在将接收到的嵌入的 APDU 成功交付给 DLMS AL 时，当通过<code class="language-plaintext highlighter-rouge">可靠</code> CoAP 消息传递层 在 <code class="language-plaintext highlighter-rouge">WRM = 1</code> 的 CWPDU 中接收到 APDU 时，<code class="language-plaintext highlighter-rouge">返回</code>一个<code class="language-plaintext highlighter-rouge">空的 CWPDU</code> 作为对发送 CoAP 包装器的<code class="language-plaintext highlighter-rouge">成功响应</code>实体<li>对于 WRM = 1 接收到的 CWPDU 的错误处理遵循上面描述的一般错误处理</ol></ul><h5 id="s7357-coap-wrapper-state-machine"><span class="mr-2">s7.3.5.7 CoAP wrapper state machine</span><a href="#s7357-coap-wrapper-state-machine" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>wrapper 层状态机</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapwrapperstate.jpg" alt="messages" data-proofer-ignore></p><ul><li><p><code class="language-plaintext highlighter-rouge">空闲Idle</code>：<code class="language-plaintext highlighter-rouge">关闭状态</code>，没有关联状态，CoAP 请求/响应层中<code class="language-plaintext highlighter-rouge">没有</code>相应的 CoAP 请求/响应上下文</p><li><p><code class="language-plaintext highlighter-rouge">客户端等待模式Client Waiting Mode</code>：接收到 AL 层传来的 CoAP-DATA.req，直到把该 req 处理完,包括等待结果，进入 Idle 模式。</p><li><p><code class="language-plaintext highlighter-rouge">服务器等待模式Server Waiting Mode</code>：接收 CoAP 层传来的非空且需 AL 层回复（WRM=0）消息，发给 AL 层后，<code class="language-plaintext highlighter-rouge">等待</code>AL 层回复 CoAP-DATA.req 消息</p><li><p><code class="language-plaintext highlighter-rouge">服务Serving</code>：接收到 CoAP 层传来的非空且无需 AL 层回复(WRM=1)消息，发给 AL 层后直接结束，进入 Idle</p></ul><h6 id="s73572-coap-dlmscosem-wrapper-requestresponse-context">s7.3.5.7.2 CoAP DLMS/COSEM wrapper request/response context</h6><p>在<code class="language-plaintext highlighter-rouge">客户端等待模式</code>状态下维护的<code class="language-plaintext highlighter-rouge">参数</code>取自 <code class="language-plaintext highlighter-rouge">CoAP-DATA.request</code> 服务原语的服务参数(AL 层发来的)</p><p>在<code class="language-plaintext highlighter-rouge">服务器等待模式</code>和<code class="language-plaintext highlighter-rouge">服务状态</code>下维护的<code class="language-plaintext highlighter-rouge">参数</code>取自较低的 <code class="language-plaintext highlighter-rouge">CoAP 协议层</code>和传入 CWPDU 的 <code class="language-plaintext highlighter-rouge">CWPDU 标头</code>(远端客户端发来的)</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapwrapperparam1.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapwrapperparam2.jpg" alt="messages" data-proofer-ignore></p><ul><li><p>空闲到客户端等待模式</p><ul><li>收到 AL 层 CoAP-DATA.request 调用，且 Response_Mode = UNCONFIRMED（UNCONFIRMED无需回应，不可能是回应，只能是请求），CWPDU中的WRM置1<li>收到 AL 层 CoAP-DATA.request 调用，且 Response_Mode = CONFIRMED，且是个请求（没找到对应请求，说明不是回应）<li>收到 AL 层 CoAP-DATA.request 调用，且 Response_Mode = RESPONSE，且是个请求（没找到对应请求，说明不是回应），和GBT相关</ul><li><p>空闲到服务器等待模式</p><p>收到 CoAP 层传来的非空且<code class="language-plaintext highlighter-rouge">需AL层回复</code>（WRM=0）消息，发给 AL 层后，<code class="language-plaintext highlighter-rouge">等待</code>AL 层回复 CoAP-DATA.req 消息</p><li><p>服务器等待模式到空闲状态：</p><p>在服务器等待模式下收到 AL 层传来的<code class="language-plaintext highlighter-rouge">CoAP-DATA.request</code>原语，且该原语中的 Transport_Mode, the Local SAP, the Remote SAP, the Local_IP_address, the Local_port, the Remote_IP_address and the Remote_Port<code class="language-plaintext highlighter-rouge">参数与当前wrapper层上下文中的对应</code></p><ul><li>收到 AL 层 CoAP-DATA.request 调用，且 Response_Mode = RESPONSE，且是个回应（找的到对应的请求）<li>收到 AL 层 CoAP-DATA.request 调用，且 Response_Mode = CONFIRMED，且是个回应（找的到对应的请求）（GBT 相关）</ul><li><p>客户端等待模式到空闲状态</p><ul><li>收到 CoAP 层失败信息<li>收空(确认)或非空(响应)CWPDU</ul><p>然后根据情况处理后回给 AL 层</p><li><p>空闲状态到服务状态</p><p>接收到 CoAP 层传来的非空且无需 AL 层回复(WRM=1)消息，发给 AL 层后直接结束，进入 Idle（可能还要回个空 CWPDU 给对方 wrapper 层表示确认）</p></ul><h6 id="s73574-coap-datarequest-invocation-handling">s7.3.5.7.4 CoAP-DATA.request invocation handling</h6><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapdatareqinv.jpg" alt="messages" data-proofer-ignore></p><h6 id="s73575-handling-of-incoming-cwpdu-or-coap-layer-transmission-failures">s7.3.5.7.5 Handling of incoming CWPDU or CoAP layer transmission failures</h6><p><img data-src="/assets/img/2022-03-17-dlms-green-1/cwpdufailure.jpg" alt="messages" data-proofer-ignore></p><h6 id="s73576-garbage-collection">s7.3.5.7.6 Garbage collection</h6><p>CoAP 相关的<code class="language-plaintext highlighter-rouge">缓存清理</code>，和实现相关。</p><h4 id="s736-dlmscosem-coap-tl-data-transfers"><span class="mr-2">s7.3.6 DLMS/COSEM CoAP TL Data Transfers</span><a href="#s736-dlmscosem-coap-tl-data-transfers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s7362-general-transfer-of-confirmed-dlmscosem-al-service-requests"><span class="mr-2">s7.3.6.2 General transfer of confirmed DLMS/COSEM AL service requests</span><a href="#s7362-general-transfer-of-confirmed-dlmscosem-al-service-requests" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coaptlconfirmed.jpg" alt="messages" data-proofer-ignore></p><h5 id="s7363-reliable-dlmscosem-coap-tl-operation"><span class="mr-2">s7.3.6.3 Reliable DLMS/COSEM CoAP TL operation</span><a href="#s7363-reliable-dlmscosem-coap-tl-operation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>Piggybacked 模式下，ACK 和 response 同时回复，由客户端掌握重发权，没收到 ACK 就重发</p><p>separate 模式下，ACK 先发，response 后发，在响应阶段服务端掌握重发权，如果 response 没收到对方 ACK 则重发</p><blockquote class="prompt-warning"><div><p>TODO:如果是服务端发给客户端的 ACK 丢了呢 更新：客户端没收到ACK重发请求</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/reliablecoaptl.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coaptlloss.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/relicoaptluncondatanoti.jpg" alt="messages" data-proofer-ignore></p><h5 id="s7364-unreliable-dlmscosem-coap-tl-operation"><span class="mr-2">s7.3.6.4 Unreliable DLMS/COSEM CoAP TL operation</span><a href="#s7364-unreliable-dlmscosem-coap-tl-operation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coaptluncondatanoti.jpg" alt="messages" data-proofer-ignore></p><h5 id="s7365-dlmscosem-coap-block-transfer-operation"><span class="mr-2">s7.3.6.5 DLMS/COSEM CoAP Block Transfer operation</span><a href="#s7365-dlmscosem-coap-block-transfer-operation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>CoAP 块传输，用于 APDU 大于 MTU 但小于 receiver_max_pdu_size 的情况，主要是用于让 IP 层无需再分片，属于 CoAP 标准中的一部分。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapbt.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapbtrequest.jpg" alt="messages" data-proofer-ignore></p><p>对于 UNRELIABLE 服务，图 58 中的 Transport_Mode 替换为<code class="language-plaintext highlighter-rouge">UNRELIABLE</code>，CoAP type 替换为<code class="language-plaintext highlighter-rouge">NON</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapbtreqresp.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapbtdatanoti.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapbtuncondatanoti.jpg" alt="messages" data-proofer-ignore></p><h5 id="s7366-dlms-gbt-operation-over-dlmscosem-coap-tl"><span class="mr-2">s7.3.6.6 DLMS GBT operation over DLMS/COSEM CoAP TL</span><a href="#s7366-dlms-gbt-operation-over-dlmscosem-coap-tl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>DLMS GBT 分块，区别于 CoAP 块传输，属于 DLMS/COSEM AL 层实现的分块传输，在某些方面优于 CoAP 块传输。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapbtgbt.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-warning"><div><p>TODO:FIRST-PART 是不是就只是用来交换 GBT 参数的，此时直接发出去应该 data 是个空的也行 更新：22年5月26日已经讨论，这确实是用来请求GBT参数的，这种情况发生在所有GBT参数由AP层管理的情况下。照理说如果AL可以管理这个参数，AL可以不向AP层申请。9.4.6.13.3中Table 96写明了AL有默认参数，而且需要AP提供一个参数用于更新该默认值，也就是官方建议使用AL向AP请求参数的方式。如果AL和AP层合并也可以避免该问题。</p></div></blockquote><blockquote class="prompt-danger"><div><p>TODO:后面是有关GBT的部分</p></div></blockquote><h2 id="s8-data-link-layer-using-the-hdlc-protocol"><span class="mr-2">s8 Data Link Layer using the HDLC protocol</span><a href="#s8-data-link-layer-using-the-hdlc-protocol" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s81-overview"><span class="mr-2">s8.1 Overview</span><a href="#s81-overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>本章指定数据链路层为三层，<code class="language-plaintext highlighter-rouge">面向连接</code>，<code class="language-plaintext highlighter-rouge">基于HDLC</code>，<code class="language-plaintext highlighter-rouge">异步通信配置文件</code>。</p><p>本规范支持以下通信环境:</p><ul><li>点对点和点对多点配置<li>专用和交换数据传输设施<li>半双工和全双工连接<li>异步 启动/停止 传输，1 个启动位，8 个数据位，无奇偶校验，1 个停止位</ul><h4 id="s812-structure-of-the-data-link-layer"><span class="mr-2">s8.1.2 Structure of the data link layer</span><a href="#s812-structure-of-the-data-link-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>为了确保面向连接和无连接两种操作模式都有一致的数据链路层服务规范，数据链路层被划分为两个子层:<code class="language-plaintext highlighter-rouge">逻辑链路控制(LLC)</code>子层和<code class="language-plaintext highlighter-rouge">媒体访问控制(MAC)</code>子层</p><p><a href="https://zh.wikipedia.org/zh-hans/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6">LLC 层</a></p><ul><li>类型 1：<code class="language-plaintext highlighter-rouge">无连接</code>。该方式对信息的发送通常无法保证接收。<li>类型 2：<code class="language-plaintext highlighter-rouge">面向连接</code>。该方式提供了四种服务：连接的<code class="language-plaintext highlighter-rouge">建立</code>、确认和承认<code class="language-plaintext highlighter-rouge">响应</code>、<code class="language-plaintext highlighter-rouge">差错恢复</code>（通过请求重发接收到的错误数据实现）以及<code class="language-plaintext highlighter-rouge">滑动窗口</code>（系数：128）。通过改变滑动窗口可以提高数据传输速率。<li>类型 3：<code class="language-plaintext highlighter-rouge">无连接承认响应服务</code>。</ul><p><code class="language-plaintext highlighter-rouge">类型1</code>的 LLC <code class="language-plaintext highlighter-rouge">无连接</code>服务中规定了一种静态帧格式，并支持运行网络协议。有关<code class="language-plaintext highlighter-rouge">传输层网络协议</code>通常是使用服务类型 1 方式。</p><p><code class="language-plaintext highlighter-rouge">类型2</code>的 LLC <code class="language-plaintext highlighter-rouge">面向连接</code>服务支持<code class="language-plaintext highlighter-rouge">可靠数据传输</code>，运用于<code class="language-plaintext highlighter-rouge">不需要</code>调用网络层和传输层协议的局域网环境。(相当于把 TCP 层的事情干了)</p><p><a href="https://blog.csdn.net/dadoneo/article/details/8315833">MAC 子层</a>（该数据链路层规范的主要部分）基于 ISO/IEC 13239。与原始 HDLC 标准相比，该标准的<code class="language-plaintext highlighter-rouge">第二版</code>包括许多增强功能，例如在<code class="language-plaintext highlighter-rouge">寻址</code>、<code class="language-plaintext highlighter-rouge">错误保护</code>和<code class="language-plaintext highlighter-rouge">分段</code>。 <code class="language-plaintext highlighter-rouge">第三版</code>采用了一种新的帧格式，可满足<code class="language-plaintext highlighter-rouge">电表</code>和类似行业<code class="language-plaintext highlighter-rouge">遥测应用</code>中的环境要求。</p><p>MAC 子层的主要功能包括数据<code class="language-plaintext highlighter-rouge">帧的封装/卸装</code>，<code class="language-plaintext highlighter-rouge">帧的寻址和识别</code>，帧的<code class="language-plaintext highlighter-rouge">接收与发送</code>，<code class="language-plaintext highlighter-rouge">链路的管理</code>，帧的<code class="language-plaintext highlighter-rouge">差错控制</code>等。MAC 子层的存在屏蔽了不同物理链路种类的差异性;非常重要的一项功能是仲裁<code class="language-plaintext highlighter-rouge">介质的使用权</code>，即规定站点何时可以使用通信介质。实际上，局域网技术中是采用具有冲突检测的<code class="language-plaintext highlighter-rouge">载波侦听多路访问</code>（Carrier Sense Multiple Access / Collision Detection，<code class="language-plaintext highlighter-rouge">CSMA/CD</code>）这种介质访问方法的。</p><p>为本技术报告的目的，已从 HDLC 标准中做出以下选择：</p><blockquote class="prompt-danger"><div><p>TODO:后面都看不懂</p></div></blockquote><h4 id="s813-specification-method"><span class="mr-2">s8.1.3 Specification method</span><a href="#s813-specification-method" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>数据链路层的子层根据服务和协议(services and protocols)进行划分</p><p>层间交互原语<code class="language-plaintext highlighter-rouge">参数类型</code>：</p><ul><li>传输至对端对等层的参数，包含在帧报文中，如地址、控制信息<li>局部使用的参数<li>透明传输的参数，收到后本层不处理，直接给下一层</ul><h3 id="s82-service-specification"><span class="mr-2">s8.2 Service specification</span><a href="#s82-service-specification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>本节规定了服务用户层使用<code class="language-plaintext highlighter-rouge">面向连接</code>的程序对数据链路层<code class="language-plaintext highlighter-rouge">要求</code>的服务。</p><p><code class="language-plaintext highlighter-rouge">事实上</code>，所有 DL 服务都由 MAC 子层提供：LLC 子层将 DL-CONNECT.xxx 服务原语作为适当的 MA-CONNECT.xxx 服务原语<code class="language-plaintext highlighter-rouge">透明地传输</code>到“真实”服务提供者 MAC 子层或从“真实”服务提供者 MAC 子层接收。</p><p>由于客户端和服务器端 LLC 和 MAC 子层不同，因此为双方指定了服务原语。</p><p>MAC 子层的寻址方案在 8.4.2 中规定。</p><h4 id="s822-setting-up-the-data-link-connection-the-dl-connect-and-ma-connect-services"><span class="mr-2">s8.2.2 Setting up the data link connection: the DL-CONNECT and MA-CONNECT services</span><a href="#s822-setting-up-the-data-link-connection-the-dl-connect-and-ma-connect-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/hdlcservicespec.jpg" alt="messages" data-proofer-ignore></p><p>数据链路连接的建立<code class="language-plaintext highlighter-rouge">只能</code>由<code class="language-plaintext highlighter-rouge">客户端请求</code>。因此，DL-CONNECT / MA-CONNECT <code class="language-plaintext highlighter-rouge">.request</code>和<code class="language-plaintext highlighter-rouge">.confirm</code>原语仅在<code class="language-plaintext highlighter-rouge">客户端</code>(主站)提供。另一方面，MA-CONNECT / DL-CONNECT <code class="language-plaintext highlighter-rouge">.indication</code>和<code class="language-plaintext highlighter-rouge">.response</code>原语仅在<code class="language-plaintext highlighter-rouge">服务器</code>(辅助站点)端提供。</p><p>在<code class="language-plaintext highlighter-rouge">本地检测到错误</code>的情况下，DL-CONNECT / MA-CONNECT .request 原语也可以在<code class="language-plaintext highlighter-rouge">本地进行确认</code>。(虚线部分)</p><h5 id="s8222-dl-connectrequest-and-ma-connectrequest"><span class="mr-2">s8.2.2.2 DL-CONNECT.request and MA-CONNECT.request</span><a href="#s8222-dl-connectrequest-and-ma-connectrequest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="go">DL-CONNECT.request
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)

MA-CONNECT.request
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)
</span></pre></table></code></div></div><ul><li>Destination_MSAP 和 Source_MSAP: 标识要建立的<code class="language-plaintext highlighter-rouge">引用数据链路层连接</code>。<li>User_Information：为<code class="language-plaintext highlighter-rouge">可选配置</code>。其内容的规范不属于本技术报告的范围。</ul><p>服务用户层调用 DL-CONNECT.request 原语，LLC 层接收后调用 MA-CONNECT.request 原语发给 MAC 层，MAC 层发送格式化后的<code class="language-plaintext highlighter-rouge">SNRM帧</code>(Set Normal Response Mode (a HDLC frame type,HDLC 协议的一部分))</p><h5 id="s8223-dl-connectindication-and-ma-connectindication"><span class="mr-2">s8.2.2.3 DL-CONNECT.indication and MA-CONNECT.indication</span><a href="#s8223-dl-connectindication-and-ma-connectindication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="go">DL-CONNECT.indication
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)

MA-CONNECT.indication
(
    Destination_MSAP,
    Source_MSAP,
    User_Information
)
</span></pre></table></code></div></div><p>和上面的相反，接收 SRNM 转换报文</p><h5 id="s8224-dl-connectresponse-and-ma-connectresponse"><span class="mr-2">s8.2.2.4 DL-CONNECT.response and MA-CONNECT.response</span><a href="#s8224-dl-connectresponse-and-ma-connectresponse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="go">DL-CONNECT.response
(
    Destination_MSAP,
    Source_MSAP,
    Result,
    User_Information
)
MA-CONNECT.response
(
    Destination_MSAP,
    Source_MSAP,
    Result,
    User_Information
)
</span></pre></table></code></div></div><p>Result 指示提议的连接<code class="language-plaintext highlighter-rouge">是否可以被接受</code>，以及<code class="language-plaintext highlighter-rouge">是否应该发送响应帧</code>。它可以有以下值之一:</p><ul><li>Result == <code class="language-plaintext highlighter-rouge">OK</code>这意味着接收到的连接请求<code class="language-plaintext highlighter-rouge">可以</code>被服务用户层<code class="language-plaintext highlighter-rouge">接受</code>。MAC 层收到后发送<code class="language-plaintext highlighter-rouge">UA帧</code><li>Result == <code class="language-plaintext highlighter-rouge">NOK</code>。这意味着接收到的连接请求<code class="language-plaintext highlighter-rouge">不能</code>被服务用户层<code class="language-plaintext highlighter-rouge">接受</code>;（如果链路层收到第二个连接请求，但同时只能有一个，即使服务用户层接受，连接也不能建立），MAC 层收到后发送<code class="language-plaintext highlighter-rouge">DM帧</code><li>Result == <code class="language-plaintext highlighter-rouge">NO-RESPONSE</code>。这意味着不应发送对 DL-CONNECT.indication 的响应。MAC 层收到 MA-CONNECT.response 后不发送任何帧</ul><blockquote class="prompt-danger"><div><p>TODO:这里的 MA-DISCONNECT.response 写错了</p></div></blockquote><h5 id="s8225-dl-connectconfirm-and-ma-connectconfirm"><span class="mr-2">s8.2.2.5 DL-CONNECT.confirm and MA-CONNECT.confirm</span><a href="#s8225-dl-connectconfirm-and-ma-connectconfirm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="go">DL-CONNECT.confirm
(
    Destination_MSAP,
    Source_MSAP,
    Result,
    User_Information
)

MA-CONNECT.confirm
(
    Destination_MSAP,
    Source_MSAP,
    Result,
    User_Information
)
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Result</code> 表示之前调用的 DL-CONNECT / MA-CONNECT.request 服务调用的结果。 它可以具有以下值之一：</p><ul><li>Result == OK。 这意味着远程站<code class="language-plaintext highlighter-rouge">接受</code>了连接请求；<li>Result == NOK-REMOTE。 这意味着远程站<code class="language-plaintext highlighter-rouge">没有接受</code>连接请求；<li>Result == NOK-LOCAL。 这意味着发生了<code class="language-plaintext highlighter-rouge">本地错误</code>，例如服务用户层试图建立一个已经存在的数据链路连接；<li>Result == NO-RESPONSE。 这意味着远程站<code class="language-plaintext highlighter-rouge">没有响应</code>连接请求。</ul><h4 id="s823-disconnecting-the-data-link-connection-the-dl-disconnect-and-ma-disconnect-services"><span class="mr-2">s8.2.3 Disconnecting the data link connection: the DL-DISCONNECT and MA-DISCONNECT services</span><a href="#s823-disconnecting-the-data-link-connection-the-dl-disconnect-and-ma-disconnect-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/hdlcservicespec.jpg" alt="messages" data-proofer-ignore></p><h5 id="s8232-dl-disconnectrequest-and-ma-disconnectrequest"><span class="mr-2">s8.2.3.2 DL-DISCONNECT.request and MA-DISCONNECT.request</span><a href="#s8232-dl-disconnectrequest-and-ma-disconnectrequest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>同上 8.2.2.2</p><h5 id="s8233-dl-disconnectindication-and-ma-disconnectindication"><span class="mr-2">s8.2.3.3 DL-DISCONNECT.indication and MA-DISCONNECT.indication</span><a href="#s8233-dl-disconnectindication-and-ma-disconnectindication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="go">DL-DISCONNECT.indication (
    Destination_MSAP,
    Source_MSAP,
    Reason,
    Unnumbered_Send_Status,
    User_Information
)

MA-DISCONNECT.indication (
    Destination_MSAP,
    Source_MSAP,
    Reason,
    Unnumbered_Send_Status,
    User_Information
)
</span></pre></table></code></div></div><ul><li><p>Reason</p><ul><li>Reason == REMOTE：数据链路层收到来自<code class="language-plaintext highlighter-rouge">客户端</code>的断开连接请求。 这种情况可能只发生在<code class="language-plaintext highlighter-rouge">服务器端</code>；<li>Reason == LOCAL-DL：出现致命的<code class="language-plaintext highlighter-rouge">数据链路连接失败</code>；<li>Reason == LOCAL-PHY：出现致命的<code class="language-plaintext highlighter-rouge">物理连接故障</code>。 后两种情况可能同时发生在<code class="language-plaintext highlighter-rouge">客户端和服务器端</code>。</ul><li>Unnumbered_Send_Status，USS，参数的值指示在 DL-DISCONNECT / MA-DISCONNECT .indication 原语调用的时刻，MAC 子层是否具有（USS == TRUE）或不具有（USS == FALSE) 待处理的 UI 消息。<li>User_Information 可选</ul><h5 id="s8234-dl-disconnectresponse-and-ma-disconnectresponse"><span class="mr-2">s8.2.3.4 DL-DISCONNECT.response and MA-DISCONNECT.response</span><a href="#s8234-dl-disconnectresponse-and-ma-disconnectresponse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>service user layer 不能拒绝该服务，结果仅表明指定的 DL connection 是否存在</p><p>RESULT == NO-RESPONSE 表明 MAC 不应该发送任何响应</p><h5 id="s8235-dl-disconnectconfirm-and-ma-disconnectconfirm"><span class="mr-2">s8.2.3.5 DL-DISCONNECT.confirm and MA-DISCONNECT.confirm</span><a href="#s8235-dl-disconnectconfirm-and-ma-disconnectconfirm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>和 response 类似</p><h4 id="s824-data-transfer-the-dl-data-and-ma-data-services"><span class="mr-2">s8.2.4 Data transfer: the DL-DATA and MA-DATA services</span><a href="#s824-data-transfer-the-dl-data-and-ma-data-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用 I 帧或 UI 帧</p><blockquote class="prompt-tip"><div><p>和 DL-DISCONNECT 及 DL-CONNECT 的区别是这个 DL-DATA 不再是<code class="language-plaintext highlighter-rouge">透传</code>了，LLC 层需要组 LSDU 作为 data，前面两个 LLC 就是什么也不干，直接把参数和 data 给 MAC 层。</p></div></blockquote><h5 id="s8242-dl-datarequest-and-ma-datarequest"><span class="mr-2">s8.2.4.2 DL-DATA.request and MA-DATA.request</span><a href="#s8242-dl-datarequest-and-ma-datarequest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>Frame_type：</p><ul><li>client: I-COMPLETE and UI;(这里假设了 client 的资源足够大（比如缓冲区），所以调用原语时不需要分包，直接用完整的)<li>server: I-COMPLETE, I-FIRST-FRAGMENT, I-FRAGMENT, ILAST-FRAGMENT, and UI</ul><p>收到调用后，LLC 层组装<code class="language-plaintext highlighter-rouge">LSDU</code>，其中包括<code class="language-plaintext highlighter-rouge">LLC specific fields</code> (the two LLC addresses and the LLC_Quality parameter)，不在 Frame_type == I-FRAGMENT or I-LAST-FRAGMENT 中添加，因为这个是<code class="language-plaintext highlighter-rouge">头信息</code>，只要在 I-FIRST-FRAGMENT 和 I-COMPLETE 中添加就行</p><h5 id="s8243-dl-dataindication-and-ma-dataindication"><span class="mr-2">s8.2.4.3 DL-DATA.indication and MA-DATA.indication</span><a href="#s8243-dl-dataindication-and-ma-dataindication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>LLC 层要解 LSDU，校验<code class="language-plaintext highlighter-rouge">LLC specific fields</code> (the two LLC addresses and the LLC_Quality parameter)</p><h5 id="s8244-dl-dataconfirm-and-ma-dataconfirm"><span class="mr-2">s8.2.4.4 DL-DATA.confirm and MA-DATA.confirm</span><a href="#s8244-dl-dataconfirm-and-ma-dataconfirm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>MAC 层生成，MAC 层判断是否发送成功</p><p>Frame_type = I-FIRST-FRAGMENT, I-FRAGMENT or I-LAST-FRAGMENT</p><h4 id="s825-physical-layer-services-used-by-the-mac-sublayer"><span class="mr-2">s8.2.5 Physical layer services used by the MAC sublayer</span><a href="#s825-physical-layer-services-used-by-the-mac-sublayer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>物理层<code class="language-plaintext highlighter-rouge">配置</code>还有<code class="language-plaintext highlighter-rouge">断开</code>不是 MAC 层管的（见5.2.2）</p><p>物理层<code class="language-plaintext highlighter-rouge">断开</code>会通过<code class="language-plaintext highlighter-rouge">PH-ABORT.indication原语</code>通知 MAC 层</p><h5 id="s8254-data-transfer"><span class="mr-2">s8.2.5.4 Data transfer</span><a href="#s8254-data-transfer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>PH-DATA.request and .indication 原语</p><h3 id="s83-protocol-specification-for-the-llc-sublayer"><span class="mr-2">s8.3 Protocol specification for the LLC sublayer</span><a href="#s83-protocol-specification-for-the-llc-sublayer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s832-llc-pdu-format"><span class="mr-2">s8.3.2 LLC PDU format</span><a href="#s832-llc-pdu-format" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/llcpdu.jpg" alt="messages" data-proofer-ignore></p><ul><li><code class="language-plaintext highlighter-rouge">Source_LSAP</code>: 最低位表示 command(0)/response(1)<li><code class="language-plaintext highlighter-rouge">Control byte</code>: LLC_Quality，保留，固定 0x00</ul><p>destination LSAP <code class="language-plaintext highlighter-rouge">0xFF</code>用于<code class="language-plaintext highlighter-rouge">广播</code></p><h4 id="s833-state-transition-tables-for-the-llc-sublayer"><span class="mr-2">s8.3.3 State transition tables for the LLC sublayer</span><a href="#s833-state-transition-tables-for-the-llc-sublayer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/statetransitionclientllc.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/statetransitionserverllc.jpg" alt="messages" data-proofer-ignore></p><p>区别是 client 端没有 I-FRAGMENT or ILAST-FRAGMENT，就不用判断类型，LSDU 里全部加上 LLC 头就行</p><h3 id="s84-protocol-specification-for-the-mac-sublayer"><span class="mr-2">s8.4 Protocol specification for the MAC sublayer</span><a href="#s84-protocol-specification-for-the-mac-sublayer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s841-the-mac-pdu-and-the-hdlc-frame"><span class="mr-2">s8.4.1 The MAC PDU and the HDLC frame</span><a href="#s841-the-mac-pdu-and-the-hdlc-frame" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s8411-hdlc-frame-format-type-3"><span class="mr-2">s8.4.1.1 HDLC frame format type 3</span><a href="#s8411-hdlc-frame-format-type-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/macframe.jpg" alt="messages" data-proofer-ignore></p><ul><li>Flag field:固定<code class="language-plaintext highlighter-rouge">0x7E</code>，在帧<code class="language-plaintext highlighter-rouge">头尾</code>,连续发送时头尾可以互连<li>Frame format field:<ul><li>Format type sub-field (4 bit):3，表示<code class="language-plaintext highlighter-rouge">type3</code>(HDLC frame format type 3)<li>the Segmentation bit (S, 1 bit):<code class="language-plaintext highlighter-rouge">类型细分</code>，对上面的 format type 的继续细分<li>the frame length sub-field (11 bit):除了 flag 外的<code class="language-plaintext highlighter-rouge">长度</code></ul><li>Destination and source address fields:见 8.4.2<li>Control field：<code class="language-plaintext highlighter-rouge">控制字段</code>，见 8.4.3<li>Header check sequence (HCS) field：对头部序列的<code class="language-plaintext highlighter-rouge">校验</code>，计算<code class="language-plaintext highlighter-rouge">opening flag和HCS之间</code>的部分，如 Frame format+Dest. address+Src. address+Control，不包括后面的信息域和 FCS。当信息域不存在或者为空时，则 HCS 不存在，仅有 FCS<li>Information field：携带<code class="language-plaintext highlighter-rouge">信息域</code>（比如 MSDU）,I and UI 帧可用(其他类型帧可能也有，后面提到了 Disconnect (DISC) command)<li>Frame check sequence (FCS) field：计算<code class="language-plaintext highlighter-rouge">校验</code>，除 flag 和 FCS</ul><h4 id="s842-mac-addressing"><span class="mr-2">s8.4.2 MAC addressing</span><a href="#s842-mac-addressing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s8422-address-field-structure"><span class="mr-2">s8.4.2.2 Address field structure</span><a href="#s8422-address-field-structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>HDLC 地址：HDLC 帧格式<code class="language-plaintext highlighter-rouge">type 3</code>(参见 8.4.1.1)包含两个地址字段:<code class="language-plaintext highlighter-rouge">目的地址</code>和<code class="language-plaintext highlighter-rouge">源地址</code>。根据数据<code class="language-plaintext highlighter-rouge">传输的方向</code>，客户端地址和服务器地址<code class="language-plaintext highlighter-rouge">都可以</code>是目的地址或源地址。</p><ul><li><p>client address：总是 1 字节，不能扩展</p><li><p>server address：只允许 1，2，4 字节</p><ul><li><code class="language-plaintext highlighter-rouge">upper</code> HDLC address：<code class="language-plaintext highlighter-rouge">Logical Device</code>(在物理设备内的一个单独的可寻址的实体)<li><code class="language-plaintext highlighter-rouge">lower</code> HDLC address：<code class="language-plaintext highlighter-rouge">Physical Device</code>,可选</ul></ul><h5 id="s8423-reserved-special-hdlc-addresses"><span class="mr-2">s8.4.2.3 Reserved special HDLC addresses</span><a href="#s8423-reserved-special-hdlc-addresses" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/hdlcaddress.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/reservedaddress.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-tip"><div><p>每个字节的 LSB 用于标识是否有后续字节，所以<code class="language-plaintext highlighter-rouge">不计入</code>实际字节的表示，也就是一个字节就<code class="language-plaintext highlighter-rouge">7个有效位</code>。1111 1111 表示一个字节，后续无字节，然后把 LSB 去掉就是 1111 111，前面补 0 就是 0111 1111，一个字节最大就能表示<code class="language-plaintext highlighter-rouge">0x7F</code>。如果要表示<code class="language-plaintext highlighter-rouge">0xFF</code>,就是，0000 0010 1111 1111，去掉无效位（每个字节的 LSB），0000 001 1111 111，合并填 0，就是 0000 0000 1111 1111。对于 4 个字节的情况，分高 upper 地址 2 字节和低 lower 地址 2 字节考虑。</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/addressexample.jpg" alt="messages" data-proofer-ignore></p><h5 id="s8424-handling-special-addresses"><span class="mr-2">s8.4.2.4 Handling special addresses</span><a href="#s8424-handling-special-addresses" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>源地址不能用 All-station or the Nostation address</p><h5 id="s8425-handling-inopportune-address-lengths-in-the-server"><span class="mr-2">s8.4.2.5 Handling inopportune address lengths in the server</span><a href="#s8425-handling-inopportune-address-lengths-in-the-server" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>对于<code class="language-plaintext highlighter-rouge">服务端接收</code>，源地址(就是客户端地址)固定 1 字节，超过 1 字节的帧丢弃（client address 仅允许 1 字节）</p><p>对于目的地址长度，有如下要求：</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/dalength.jpg" alt="messages" data-proofer-ignore></p><h4 id="s843-command-and-response-frames"><span class="mr-2">s8.4.3 Command and response frames</span><a href="#s843-command-and-response-frames" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/controlfieldbit.jpg" alt="messages" data-proofer-ignore></p><p>RRR is the receive sequence number N(R)</p><p>SSS is the send sequence number N(S)</p><p>P/F is the poll/final bit.</p><p>P 表示<code class="language-plaintext highlighter-rouge">poll bit</code>，表示是否交出<code class="language-plaintext highlighter-rouge">发送权</code>，一般需要响应的请求的最后一帧会置为<code class="language-plaintext highlighter-rouge">TRUE</code></p><ul><li><p><code class="language-plaintext highlighter-rouge">I帧</code>，Information transfer command and response</p><p>信息传递</p><ul><li><code class="language-plaintext highlighter-rouge">N(S)</code>：发送帧的<code class="language-plaintext highlighter-rouge">序号</code><li><code class="language-plaintext highlighter-rouge">N(R)</code>：<code class="language-plaintext highlighter-rouge">期望接收</code>到的下一帧的<code class="language-plaintext highlighter-rouge">序号</code>，表明<code class="language-plaintext highlighter-rouge">N(R)-1</code>序号的帧已被<code class="language-plaintext highlighter-rouge">正确接收</code>。</ul><p>发送接收最大<code class="language-plaintext highlighter-rouge">information field</code>长度<code class="language-plaintext highlighter-rouge">默认为128字节</code></p><li><p>Receive ready (<code class="language-plaintext highlighter-rouge">RR</code>) command and response</p><ul><li>通知<code class="language-plaintext highlighter-rouge">准备好</code>接收 I 帧<li>确认之前收到的 N(R)-1 序号的 I 帧</ul><li><p>Receive not ready (<code class="language-plaintext highlighter-rouge">RNR</code>) command and response</p><ul><li>通知<code class="language-plaintext highlighter-rouge">未准备好</code>接收 I 帧<li>确认之前收到的 N(R)-1 序号的 I 帧</ul><p>RNR 接收方应该要知道，N(R)-1 之后的 I 帧发送都是无效的，也不应该再发 I 帧了</p><li><p>Set normal response mode (<code class="language-plaintext highlighter-rouge">SNRM</code>) command</p><p>SNRM 命令应用于将已分配地址的从站置于<code class="language-plaintext highlighter-rouge">正常响应模式</code>（<code class="language-plaintext highlighter-rouge">NRM</code>），其中所有控制字段的长度应为一个八位字节。 次站应通过在第一个响应机会时发送 <code class="language-plaintext highlighter-rouge">UA</code> 响应来确认 SNRM 命令的接受。 在接受该命令后，从站发送和接收状态变量应设置为零。</p><p>此命令执行后，原来由 DL 层管理的未被确认的 I 帧需要交还给更高层管理，是否重新交给 DL 层发送取决于该高层。</p><blockquote class="prompt-warning"><div><p>TODO:什么是正常响应模式。更新：见 8.4.4</p></div></blockquote><li><p>Disconnect (<code class="language-plaintext highlighter-rouge">DISC</code>) command</p><p>终止之前配置的可操作或初始化模式，从站应进入逻辑断开模式。</p><blockquote class="prompt-warning"><div><p>TODO:逻辑断开模式和正常断开模式区别？更新：应该是同一个概念，就是 NDM</p></div></blockquote><p>从站应发 UA 响应表示确认收到</p><p>（同 SNRM）此命令执行后，原来由 DL 层管理的未被确认的 I 帧需要交还给更高层管理，是否重新交给 DL 层发送取决于该高层。</p><blockquote class="prompt-tip"><div><p>可以理解为 SNRM 的逆操作</p></div></blockquote><p>可能携带 information field</p><li><p>Unnumbered acknowledge (<code class="language-plaintext highlighter-rouge">UA</code>) response</p><p>对 SNRM 和 DISC 的响应</p><p>可能携带 information field,用于传递 DL 层参数</p><li><p>Disconnected mode (<code class="language-plaintext highlighter-rouge">DM</code>) response</p><p>报告自身处于 Normal Disconnected Mode(NDM)状态</p><ul><li>请求主站或其他关联站向自己发送模式设置命令，如切成 NRM<li>响应模式设置请求，报告自己仍处于 NDM</ul><p>例如，可以通过 SNRM 命令退出 NDM，进入 NRM</p><li><p>Frame reject (<code class="language-plaintext highlighter-rouge">FRMR</code>) response</p><p>从站<code class="language-plaintext highlighter-rouge">报告接收到的帧的错误</code>，该错误<code class="language-plaintext highlighter-rouge">不能通过重传相同的</code>解决，且该错误不是由于 FCS 错误引起的：</p><li><p>Unnumbered information (<code class="language-plaintext highlighter-rouge">UI</code>) command and response</p><ul><li><p>command</p><p>发送信息给从站，不影响 V(S)和 V(R)，可以在任何模式（NRM,NDM）下使用</p><p>UI请求不指定从站响应，可能丢失或重复</p><p>V(S)：Send state Variable</p><p>V(R)：Receive state Variable</p><p>不影响 I 帧或其他帧的序号</p><li><p>response</p><p>发送信息给主站，不影响 V(S)和 V(R)，可以在任何模式（NRM,NDM）下使用</p><p>可能丢失或重复</p></ul></ul><h4 id="s844-elements-of-the-procedures"><span class="mr-2">s8.4.4 Elements of the procedures</span><a href="#s844-elements-of-the-procedures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>当主备用站点之间建立了物理链路，但没有建立活动的数据链路通道时，客户端和服务器端的 MAC 子层都处于<code class="language-plaintext highlighter-rouge">正常断开模式</code>Normal Disconnected Mode(<code class="language-plaintext highlighter-rouge">NDM</code>);不传送或不接受任何信息或编号的监控帧。从站功能限制为：</p><ul><li>接收与响应 SNRM<li>接收 UI<li>发送 UI 响应<li>收到 DISC 后发送 DM 响应</ul><p>当 MAC 连接建立后，MAC 层工作在正常响应模式(NRM)。从站(服务器)只有在从主站(客户端)获得明确的许可后才可以开始数据传输。在收到许可(POLL BIT == TRUE)后，从站发起响应传输。响应传输可以由一个或多个帧组成，同时保持活跃的数据链路通道状态(见 8.4.4.3.1)。响应传输的最后一帧应由从站明确表示(FINAL BIT == TRUE)。在最后一帧指示之后，从站应停止发送，直到再次收到主站的明确许可。</p><h5 id="s8442-transmission-considerations"><span class="mr-2">s8.4.4.2 Transmission considerations</span><a href="#s8442-transmission-considerations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><blockquote class="prompt-danger"><div><p>TODO:透明传输需要查看文档ISO/IEC 13239:2002, 4.3</p></div></blockquote><p>按照一个字节内<code class="language-plaintext highlighter-rouge">低位优先</code>传输，多个字节按照<code class="language-plaintext highlighter-rouge">最高有效</code>字节优先，如0x1234，先传0x12</p><h5 id="s8443-hdlc-channel-states"><span class="mr-2">s8.4.4.3 HDLC channel states</span><a href="#s8443-hdlc-channel-states" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li><p>Active HDLC channel state</p><p>当主站或从站处于传输帧中的一个字节状态时，就是 active 状态，保留有继续传输权</p><li><p>Abort sequence</p><p>不适用</p><li><p>Start/stop transmission inter-octet time-out</p><p>字节间超时等待状态，接收完一个字节开始等待，直到收到下个字节或超时，超时要结束接收。</p><li><p>Idle HDLC channel state</p><p>当连续标记保持条件持续一段系统特定的时间($T_{idle}$)时，数据链路通道进入空闲状态。</p></ul><h4 id="s845-hdlc-channel-operation--description-of-the-procedures"><span class="mr-2">s8.4.5 HDLC channel operation – Description of the procedures</span><a href="#s845-hdlc-channel-operation--description-of-the-procedures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>选择了<code class="language-plaintext highlighter-rouge">非平衡连接模式</code>(unbalanced connection-mode)的数据链路操作。不平衡数据链路包括<code class="language-plaintext highlighter-rouge">一个主站</code>和<code class="language-plaintext highlighter-rouge">一个或多个</code>从站。数据链路的整体错误恢复最终由主站负责</p><p>选择了<code class="language-plaintext highlighter-rouge">NRM</code>和<code class="language-plaintext highlighter-rouge">NDM</code>模式。</p><h5 id="s8452-data-station-characteristics"><span class="mr-2">s8.4.5.2 Data station characteristics</span><a href="#s8452-data-station-characteristics" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>主站负责:</p><ul><li>设置数据链路，断开数据链路;<li>发送信息传递、监督和无序号命令;<li>检查收到的响应。</ul><p>从站应负责:</p><ul><li>检查收到的命令;<li>根据接收到的指令，发送信息，监督和无序号命令的回复。</ul><h5 id="s8453-procedures-for-setting-up-and-disconnecting-the-data-link"><span class="mr-2">s8.4.5.3 Procedures for setting up and disconnecting the data link</span><a href="#s8453-procedures-for-setting-up-and-disconnecting-the-data-link" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li><p>Setting up the data link</p><p>主站发 SNRM，从站回 UA 表示确认并进入 NRM，回 DM 表示无法进入 NRM</p><p>主站未收到回应等待超时重发，直到 MAX_NB_OF_RETRIES 次数停止</p><li><p>HDLC parameter negotiation during the connection phase</p><p>SNRM/UA 消息交换不仅可以建立连接，还可以协商一些数据链路参数</p><ul><li><p>最大 information field 长度参数，默认 128 字节</p><ul><li>发送<li>接收</ul><li><p>Window size 窗口大小，默认 1，最大 7.</p><ul><li>发送<li>接收</ul></ul><p>SNRM 中的 Window size – receive 是强制的，UA 中的‘Max_info_field_length– receive’ (0x40), and the ‘Window size – transmit’ (0x07)是强制的</p><li><p>Disconnecting the data link</p><p>主站发<code class="language-plaintext highlighter-rouge">DISC</code>，从站回<code class="language-plaintext highlighter-rouge">UA</code>响应，并进入 NDM。如果已经处于断开模式 NDM，将发送<code class="language-plaintext highlighter-rouge">DM</code>响应。</p><p>超时重发和 Setting up the data link 相同</p></ul><h5 id="s8454-procedures-for-data-exchange"><span class="mr-2">s8.4.5.4 Procedures for data exchange</span><a href="#s8454-procedures-for-data-exchange" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>收到 MA-DATA.request 调用后，发送<code class="language-plaintext highlighter-rouge">I帧</code>，只能在<code class="language-plaintext highlighter-rouge">NRM</code>下发送。若 Frame_type == UI，则发送<code class="language-plaintext highlighter-rouge">UI帧</code>，一般用于<code class="language-plaintext highlighter-rouge">广播多播</code>，且可以在<code class="language-plaintext highlighter-rouge">NRM或NDM</code>状态发送。</p><ul><li><p>Exchange of information frames</p><p>主站请求的最后一帧<code class="language-plaintext highlighter-rouge">poll bit</code>置 1，表示<code class="language-plaintext highlighter-rouge">等待响应</code>，从站响应的最后一帧<code class="language-plaintext highlighter-rouge">final bit</code>置位表示发送结束。</p><li><p>8.4.5.4.5 Transferring long MSDUs from the server to the client</p><p>服务端<code class="language-plaintext highlighter-rouge">资源有限</code>，客户端资源较多，对 dl-data 进行<code class="language-plaintext highlighter-rouge">分段</code>，Frame_type == IFIRST-FRAGMENT、I-FRAGMENT、I-LAST-FRAGMENT</p><li><p>8.4.5.4.6 Multi- and broadcasting</p><p>对使用<code class="language-plaintext highlighter-rouge">UI帧</code>实现<code class="language-plaintext highlighter-rouge">多播广播</code>的情况，仅允许<code class="language-plaintext highlighter-rouge">客户端</code>发送，服务端不允许</p><p>只有 UI(和 DISC)消息可以作为广播或组播消息，此时 UI 帧的<code class="language-plaintext highlighter-rouge">Poll bit</code>必须为<code class="language-plaintext highlighter-rouge">FALSE</code>,表示<code class="language-plaintext highlighter-rouge">无需响应</code>（就是不会把发送权交给从站）</p><p><code class="language-plaintext highlighter-rouge">DISC</code>一般用于在<code class="language-plaintext highlighter-rouge">通过断开低层连接方式断开AA</code>时发送的命令。</p><p>多播广播支持对一个物理设备的多个逻辑设备，或多个物理设备，根据 HDLC 目的地址的 upper 和 lower 字节</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/broadcastui.jpg" alt="messages" data-proofer-ignore></p><li><p>8.4.5.4.7 Sending an UI frame from the server to the client</p><p>服务端发送 UI 帧的情况</p><p>在 HDLC 中因为是<code class="language-plaintext highlighter-rouge">主从模型</code>，服务器作为从站<code class="language-plaintext highlighter-rouge">没有权利</code>主动上报，需要等客户端作为主站发送任意请求后，因为需要回复，从站获得<code class="language-plaintext highlighter-rouge">发送权</code>，再趁机发送该上报 UI 帧，且应在响应的最后一帧前发送</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/serveruievent.jpg" alt="messages" data-proofer-ignore></p><p>其他情况：</p><ul><li>客户端发送 RR 帧，P=1<li>客户端发送空的 UI 帧，P=1</ul><li><p>8.4.5.4.8 Handling the CALLING device physical address</p><p>CALLING Physical Device address，见 8.4.2.3</p><p>允许服务端发起物理连接请求，以便自己能上报数据（8.4.5.4.7那些数据）</p><p>客户端需要发送<code class="language-plaintext highlighter-rouge">SNRM</code>为服务端配置模式，其中 Lower MAC Address 的值应该为<code class="language-plaintext highlighter-rouge">CALLING Physical Device Address (0x7E)</code>，表示该报文是给<code class="language-plaintext highlighter-rouge">正在寻求发起连接</code>的服务端。</p><p>多点 multi-drop 网络中，所有服务端收到后首先判断自身的<code class="language-plaintext highlighter-rouge">CALLING DEVICE</code>标志，如为<code class="language-plaintext highlighter-rouge">TRUE</code>，表示自己正在寻求发起连接，则接收，如果为 FALSE，则丢弃。（收到 PH-ABORT.indication 物理层断开后应该置为 FALSE）</p><p>服务端接收后需要回复<code class="language-plaintext highlighter-rouge">UA</code>（确认）或<code class="language-plaintext highlighter-rouge">DM</code>（否认），此时源地址的<code class="language-plaintext highlighter-rouge">Lower MAC Address</code>字段应为正确的本机 MAC 物理地址，而不是 CALLING Physical Device Address</p></ul><h5 id="s8455-exception-recovery"><span class="mr-2">s8.4.5.5 Exception recovery</span><a href="#s8455-exception-recovery" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li><p>Response time-out</p><p>响应超时</p><p>发送完 poll bit 为 1 的帧后开始计时，收到 final bit 为 0 的帧时刷新计时，收到 final bit 为 1 的帧时结束计时</p><p>超时应该重发，当该帧时 I 帧时不应该重发，应该发 RR 帧同步 I 帧序号，确认丢失的是哪帧（TODO:是否同步完再重发 I 帧）</p><li><p>FCS and HCS error</p><blockquote class="prompt-warning"><div><p>TODO：引用了一些其他标准</p></div></blockquote><p>有错误帧时，所有的连续帧都应被丢弃。</p><li><p>N(S) sequence error</p><li><p>Command/response frame rejection</p><p>FRMR 回应</p><li><p>Busy</p></ul><h5 id="s8456-time-outs-and-other-mac-sublayer-parameters"><span class="mr-2">s8.4.5.6 Time-outs and other MAC sublayer parameters</span><a href="#s8456-time-outs-and-other-mac-sublayer-parameters" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li><p>Time-out 1: Response time-out (TO_WAIT_RESP)</p><p>等待响应超时时间，所有命令和信息帧，客户端参数</p><p>TO_WAIT_RESP &gt; RespTime + 2*MaxTxTime</p><li><p>Layer Parameter 1: Maximum number of retries (MAX_NB_OF_RETRIES)</p><p>最大超时重发次数</p><li><p>Time-out 2: Inactivity time-out</p><p>未向 PhL 发送或接收超时，每次发送或接收时重置。调用DL-LM_EVENT.indication原语，见8.6.2.7。超时应断开 DL 层连接</p><li><p>Time-out 3: Inter-frame time-out</p><p>帧间超时，接收端参数，超时未收到下一帧表示已经结束</p><li><p>Maximum information field length</p><p>最大 information field 长度，默认 128</p><li><p>Window size</p><p>窗口大小，默认 1</p></ul><h5 id="s8457-state-transition-diagram-for-the-server-mac-sublayer"><span class="mr-2">s8.4.5.7 State transition diagram for the server MAC sublayer</span><a href="#s8457-state-transition-diagram-for-the-server-mac-sublayer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/statemacsublayer.jpg" alt="messages" data-proofer-ignore></p><h3 id="s85-fcs-calculation"><span class="mr-2">s8.5 FCS calculation</span><a href="#s85-fcs-calculation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s851-test-sequence-for-the-fcs-calculation"><span class="mr-2">s8.5.1 Test sequence for the FCS calculation</span><a href="#s851-test-sequence-for-the-fcs-calculation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><blockquote class="prompt-danger"><div><p>TODO：计算规则不明确</p></div></blockquote><h4 id="s852-fast-frame-check-sequence-fcs-implementation"><span class="mr-2">s8.5.2 Fast frame check sequence (FCS) implementation</span><a href="#s852-fast-frame-check-sequence-fcs-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>16 位的 FCS 计算参考 RFC 1662</p><h4 id="s853-16-bit-fcs-computation-method"><span class="mr-2">s8.5.3 16-bit FCS computation method</span><a href="#s853-16-bit-fcs-computation-method" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h3 id="s86-data-link-layer-management-services"><span class="mr-2">s8.6 Data link layer management services</span><a href="#s86-data-link-layer-management-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-03-17-dlms-green-1/layermanage.jpg" alt="messages" data-proofer-ignore></p><ul><li><p>DL-INITIALIZE</p><p>初始化 DL 层参数</p><li><p>DL-GET_VALUE</p><p>从 DL 层获取一个或多个参数</p><li><p>DL-SET_VALUE</p><p>设置 DL 层的一个或多个参数</p><li><p>DL-LM_EVENT</p><p>通知 DL 层的事件</p></ul><h2 id="s9-dlmscosem-application-layer"><span class="mr-2">s9 DLMS/COSEM application layer</span><a href="#s9-dlmscosem-application-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s91-dlmscosem-application-layer-main-features"><span class="mr-2">s9.1 DLMS/COSEM application layer main features</span><a href="#s91-dlmscosem-application-layer-main-features" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s912-dlmscosem-application-layer-structure"><span class="mr-2">s9.1.2 DLMS/COSEM application layer structure</span><a href="#s912-dlmscosem-application-layer-structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/applayer.jpg" alt="messages" data-proofer-ignore></p><p>DLMS/COSEM AL 的主要组成部分是<code class="language-plaintext highlighter-rouge">应用服务对象</code>Application Service Object(<code class="language-plaintext highlighter-rouge">ASO</code>)。它向其服务用户 COSEM Application Process (<code class="language-plaintext highlighter-rouge">APs</code>)<code class="language-plaintext highlighter-rouge">提供</code>服务，并<code class="language-plaintext highlighter-rouge">使用</code>支持协议层提供的服务。它在客户端和服务器端都包含三个必需的组件:</p><ul><li>关联控制服务元素，Association Control Service Element，<code class="language-plaintext highlighter-rouge">ACSE</code><li>扩展 DLMS 应用服务元素 the extended DLMS Application Service Elemen，<code class="language-plaintext highlighter-rouge">xDLMS ASE</code>;<li>控制功能 the Control Function，<code class="language-plaintext highlighter-rouge">CF</code>。<li>Client SN_Mapper ASE 是客户端专有可选项</ul><p>xDLMS <code class="language-plaintext highlighter-rouge">ASE</code>提供在 COSEM <code class="language-plaintext highlighter-rouge">APs之间</code>传输数据的服务,见 9.1.4</p><p>Control Function (<code class="language-plaintext highlighter-rouge">CF</code>)元素指定<code class="language-plaintext highlighter-rouge">ASO服务</code>如何调用<code class="language-plaintext highlighter-rouge">ACSE</code>、<code class="language-plaintext highlighter-rouge">xDLMS ASE</code>和<code class="language-plaintext highlighter-rouge">支持协议层</code>的服务的<code class="language-plaintext highlighter-rouge">适当服务原语</code>。见 9.4.1。</p><p>客户端和服务器 DLMS/COSEM <code class="language-plaintext highlighter-rouge">ASO</code>都可能包含其他可选的应用程序协议组件。</p><p>当<code class="language-plaintext highlighter-rouge">服务器</code>使用<code class="language-plaintext highlighter-rouge">SN引用</code>时，<code class="language-plaintext highlighter-rouge">可选的</code>Client SN_Mapper ASE 出现在<code class="language-plaintext highlighter-rouge">客户端AL ASO</code>中。它使用 LN 和 SN 引用提供服务之间的<code class="language-plaintext highlighter-rouge">映射</code>。见 9.1.5。</p><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>也执行 OSI 表示层的一些功能:</p><ul><li>对<code class="language-plaintext highlighter-rouge">ACSE</code>和<code class="language-plaintext highlighter-rouge">xDLMS APDUs</code>进行<code class="language-plaintext highlighter-rouge">编码和解码</code>，参见 9.4.3;<li>另外，生成和使用代表<code class="language-plaintext highlighter-rouge">ACSE</code>和<code class="language-plaintext highlighter-rouge">xDLMS APDUs</code>的<code class="language-plaintext highlighter-rouge">XML文档</code>;<li>用于<code class="language-plaintext highlighter-rouge">压缩和解压</code>;<li>启用、验证和删除<code class="language-plaintext highlighter-rouge">密码保护</code>。</ul><h4 id="s913-the-association-control-service-element-acse"><span class="mr-2">s9.1.3 The Association Control Service Element, ACSE</span><a href="#s913-the-association-control-service-element-acse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>用于面向连接（connection oriented (CO)）通信</p><p>提供 application association 建立与释放服务：</p><ul><li><p>COSEM-OPEN;</p><p>COSEM-OPEN 服务用于<code class="language-plaintext highlighter-rouge">建立AAs</code>。它基于 ACSE A-ASSOCIATE 服务。基于 ASE 过程中的 Application_Context_Name, Security_Mechanism_Name and xDLMS context 参数</p><ul><li><p><code class="language-plaintext highlighter-rouge">confirmed AAs</code>使用 COSEM-OPEN 服务，可以在单个客户端和单个服务器之间建立；</p><li><p><code class="language-plaintext highlighter-rouge">unconfirmed AAs</code>使用 COSEM-OPEN 服务，可以在单个客户端和多个服务器见建立，只有客户端发送，服务端不回应。（多播，广播）</p><li><p><code class="language-plaintext highlighter-rouge">pre-established AAs</code> 可能预先存在。 不使用 COSEM-OPEN 服务。 客户端必须知道服务器支持的上下文。 预先建立的 AA 可以是确认或未确认。</p></ul><li><p>COSEM-RELEASE</p><p><code class="language-plaintext highlighter-rouge">不丢失信息</code>，<code class="language-plaintext highlighter-rouge">优雅释放</code>AAs</p><ul><li>TCP-UDP/IP based profile：基于<code class="language-plaintext highlighter-rouge">ACSE A-RELEASE</code> 服务<li>3-layer, CO, HDLC based profile：confirmed AAs<code class="language-plaintext highlighter-rouge">直接断开</code>对应协议层连接，Pre-established AAs 无需断开</ul><li><p>COSEM-ABORT</p><p><code class="language-plaintext highlighter-rouge">异常释放</code>，可能<code class="language-plaintext highlighter-rouge">丢失信息</code>，它不依赖于 ACSE A-ABORT 服务</p></ul><h4 id="s914-the-xdlms-application-service-element"><span class="mr-2">s9.1.4 The xDLMS application service element</span><a href="#s914-the-xdlms-application-service-element" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>为了访问 COSEM 对象的属性和方法，使用了<code class="language-plaintext highlighter-rouge">xDLMS ASE</code>的服务</p><h5 id="s9142-the-xdlms-initiate-service"><span class="mr-2">s9.1.4.2 The xDLMS initiate service</span><a href="#s9142-the-xdlms-initiate-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>建立<code class="language-plaintext highlighter-rouge">xDLMS上下文</code></p><h5 id="s9143-cosem-object-related-xdlms-services"><span class="mr-2">s9.1.4.3 COSEM object related xDLMS services</span><a href="#s9143-cosem-object-related-xdlms-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>与 COSEM 对象相关的 xDLMS 服务用于访问 COSEM<code class="language-plaintext highlighter-rouge">对象属性和方法</code>。</p><ul><li>Logical Name (LN) referencing<li>Short Name (SN) referencing</ul><p><code class="language-plaintext highlighter-rouge">客户端ASO</code>总是使用带有<code class="language-plaintext highlighter-rouge">LN引用</code>的 xDLMS <code class="language-plaintext highlighter-rouge">ASE</code>。<code class="language-plaintext highlighter-rouge">服务器ASO</code>可以使用带有<code class="language-plaintext highlighter-rouge">LN引用</code>的 xDLMS <code class="language-plaintext highlighter-rouge">ASE</code>，也可以使用带有<code class="language-plaintext highlighter-rouge">SN引用</code>的 xDLMS ASE，或者<code class="language-plaintext highlighter-rouge">两者都使用</code></p><p>服务可以是：</p><ul><li><p>requested / solicited：客户端请求</p><p>客户端<code class="language-plaintext highlighter-rouge">请求</code>的服务也可以(见 9.4.6.2):</p><ul><li>confirmed:在这种情况下，服务器提供对请求的响应;<li>unconfirmed:在这种情况下，服务器不提供对请求的响应。</ul><li><p>unsolicited: 由服务器端发起，无需请求</p><p>来自服务器的<code class="language-plaintext highlighter-rouge">未经请求</code>的<code class="language-plaintext highlighter-rouge">DataNotification</code>也可能是(见 9.3.10):</p><ul><li>confirmed:在这种情况下，客户端提供一个<code class="language-plaintext highlighter-rouge">响应</code>来确认收到了未经请求的 DataNotification<li>unconfirmed:在这种情况下，客户端没有对未经请求的 DataNotification 提供响应</ul></ul><p><code class="language-plaintext highlighter-rouge">附加服务</code>-不是基于 IEC 61334-4-41:1996 规定的 DLMS 服务-是:</p><ul><li>使用 LN 引用访问 COSEM 对象属性和方法的<code class="language-plaintext highlighter-rouge">GET、SET、ACTION和ACCESS</code>;<li>服务器用于向客户端推送数据的<code class="language-plaintext highlighter-rouge">DataNotification</code>服务;<li>服务端使用<code class="language-plaintext highlighter-rouge">EventNotification</code>服务通知客户端服务器发生的事件。</ul><blockquote class="prompt-tip"><div><p><code class="language-plaintext highlighter-rouge">IEC 61334-4-41:1996</code>规定的是早期的 DLMS，后面有扩充的叫做 xDLMS,多了很多重要的东西</p></div></blockquote><h6 id="s91432-xdlms-services-used-by-the-client-with-ln-referencing">s9.1.4.3.2 xDLMS services used by the client with LN referencing</h6><p>GET9.3.6、SET9.3.7、ACTION9.3.8、ACCESS9.3.9</p><h6 id="s91433-xdlms-services-used-by-the-client-with-sn-referencing">s9.1.4.3.3 xDLMS services used by the client with SN referencing</h6><p>Read9.3.14、Write9.3.15、UnconfirmedWrite9.3.16</p><h5 id="s91434-unsolicited-services"><span class="mr-2">s9.1.4.3.4 Unsolicited services</span><a href="#s91434-unsolicited-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>主动上报</p><p>共有 DataNotification，LN 有 EventNotification，SN 有 InformationReport</p><h6 id="s91435-selective-access">s9.1.4.3.5 Selective access</h6><p>选择性访问属性内部分内容</p><h6 id="s91436-multiple-references">s9.1.4.3.6 Multiple references</h6><p>在 COSEM 对象相关的服务调用中，可以<code class="language-plaintext highlighter-rouge">引用</code>一个或<code class="language-plaintext highlighter-rouge">多个</code>命名变量、属性和/或方法，见 9.4.6.1的<code class="language-plaintext highlighter-rouge">multiple-references</code>参数，比如ACCESS总是支持这个特性</p><h6 id="s91437-attribute_0-referencing">s9.1.4.3.7 Attribute_0 referencing</h6><p><code class="language-plaintext highlighter-rouge">属性0</code>表示<code class="language-plaintext highlighter-rouge">引用所有</code>公共属性（属性号为正），</p><h5 id="s9144-additional-mechanisms"><span class="mr-2">s9.1.4.4 Additional mechanisms</span><a href="#s9144-additional-mechanisms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>与 IEC 61334-4-41:1996 中规定的 DLMS 相比，xDLMS 指定了一些新的机制来提高功能、灵活性和效率。其他机制包括:</p><ul><li>使用逻辑名 logical names 进行引用;<li>识别服务调用;<li>优先处理;<li>传输较长的应用信息;<li>可组合的 xDLMS 消息;<li>压缩解压;<li>通用密码保护;<li>通用块传输 general block transfer(GBT)</ul><p>下面逐个介绍</p><h6 id="s91442-referencing-methods-and-service-mapping">s9.1.4.4.2 Referencing methods and service mapping</h6><p>在<code class="language-plaintext highlighter-rouge">confirmed AAs</code>的情况下，<code class="language-plaintext highlighter-rouge">引用方法</code>在 AA 建立阶段通过 COSEM 应用上下文进行<code class="language-plaintext highlighter-rouge">协商</code>。在 AA 成立期间<code class="language-plaintext highlighter-rouge">不得改变</code>。在给定的 AA 中使用 LN 或 SN 服务是独占的。</p><p>在<code class="language-plaintext highlighter-rouge">unconfirmed</code> and <code class="language-plaintext highlighter-rouge">pre-established</code> AAs 的情况下，客户端 AL 需要<code class="language-plaintext highlighter-rouge">提前知道</code>服务器支持的<code class="language-plaintext highlighter-rouge">引用方法</code>。</p><h6 id="s91443-identification-of-service-invocations-the-invoke_id-parameter">s9.1.4.4.3 Identification of service invocations: the Invoke_Id parameter</h6><p>在 client/server 模型中，请求由客户机发送，响应由服务器发送。允许客户端在接收到对前一个请求的响应之前发送<code class="language-plaintext highlighter-rouge">多个请求</code>，前提是<code class="language-plaintext highlighter-rouge">较低层允许</code>这样做。</p><p>需要用<code class="language-plaintext highlighter-rouge">Invoke_Id</code>来<code class="language-plaintext highlighter-rouge">标识</code>数据包，这样客户端才能判断响应是<code class="language-plaintext highlighter-rouge">对应</code>哪个请求的</p><p>在<code class="language-plaintext highlighter-rouge">ACCESS</code>和<code class="language-plaintext highlighter-rouge">DataNotification</code>服务(参见 9.3.9 和 9.3.10)中，使用<code class="language-plaintext highlighter-rouge">Long-Invoke-Id</code>参数来<code class="language-plaintext highlighter-rouge">代替</code>Invoke_Id 参数。</p><p><code class="language-plaintext highlighter-rouge">EventNotification</code>服务<code class="language-plaintext highlighter-rouge">不包含</code>Invoke_Id 参数。</p><p>此功能仅在<code class="language-plaintext highlighter-rouge">LN引用</code>时可用</p><h6 id="s91444-priority-handling">s9.1.4.4.4 Priority handling</h6><p>对于使用<code class="language-plaintext highlighter-rouge">LN引用</code>的数据传输服务，有两个<code class="language-plaintext highlighter-rouge">优先级</code>可用:<code class="language-plaintext highlighter-rouge">normal (FALSE)</code>和<code class="language-plaintext highlighter-rouge">high (TRUE)</code>。</p><p>服务器不按先来先服务<code class="language-plaintext highlighter-rouge">FIFS</code>，而是根据<code class="language-plaintext highlighter-rouge">优先级</code>处理</p><p>此功能仅在<code class="language-plaintext highlighter-rouge">LN引用</code>时可用</p><h6 id="s91445-transferring-long-messages">s9.1.4.4.5 Transferring long messages</h6><p>xDLMS 服务原语由<code class="language-plaintext highlighter-rouge">xDLMS APDUs</code>以编码形式携带。这种编码形式可能比客户端/服务器<code class="language-plaintext highlighter-rouge">协商</code>的<code class="language-plaintext highlighter-rouge">最大接收PDU大小</code>长</p><p>两种方案：</p><ul><li><code class="language-plaintext highlighter-rouge">通用块传输</code>(GBT)机制<li><code class="language-plaintext highlighter-rouge">特定于服务</code>的块传输机制</ul><p>如果最大接收 PDU 大小很大，超过了下一层的限制，APDUs 符合条件，不用分块，那就需要下一层进行分包操作</p><p>特定于服务的块传输机制用于：</p><ul><li>使用 LN 参引用的 confirmed services:GET、SET、ACTION;<li>使用 SN 参引用的 confirmed services:Read、Write</ul><p>特定于服务的块传输在以下情况下不可用:</p><ul><li>unconfirmed services<li>unsolicited services (DataNotification, EventNotification and InformationReport)<li>the ACCESS service</ul><p><code class="language-plaintext highlighter-rouge">特定于服务的块传输</code>只能一包一包顺序传，不支持流式传输，不支持恢复丢失块。加密是加一个 block，而不是整个 APDU，服务专用数字签名不可用。TODO：服务专用数字签名是什么</p><p>相反，<code class="language-plaintext highlighter-rouge">GBT机制</code>可以与任何 xDLMS APDU 一起使用，包括<code class="language-plaintext highlighter-rouge">通用密码和通用签名APDU</code>。它提供<code class="language-plaintext highlighter-rouge">双向块传输</code>、<code class="language-plaintext highlighter-rouge">流</code>和<code class="language-plaintext highlighter-rouge">丢失块恢复</code>。当需要加密保护时，对<code class="language-plaintext highlighter-rouge">完整的APDU</code>进行<code class="language-plaintext highlighter-rouge">加密保护</code>，然后被保护的 APDU 以<code class="language-plaintext highlighter-rouge">块的形式</code>传输，如图 87 所示。</p><h6 id="s91446-composable-xdlms-messages">s9.1.4.4.6 Composable xDLMS messages</h6><p>可组合的 xDLMS 消息</p><p>处理 xDLMS 消息的三个重要方面是<code class="language-plaintext highlighter-rouge">编码/解码</code>、<code class="language-plaintext highlighter-rouge">应用、验证/删除密码保护</code>和<code class="language-plaintext highlighter-rouge">块传输</code>，见9.3.5。</p><p>可组合 xDLMS 消息的概念将这<code class="language-plaintext highlighter-rouge">三个方面</code>分开</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/xdlmscomp.jpg" alt="messages" data-proofer-ignore></p><p>一旦 AL 构建了与 AP 调用的服务原语对应的 APDU，就可以使用通用保护机制来应用密码保护。然后产生不受保护或受保护的 APDU ，当长度超过协商的 APDU 长度时，可以采用<code class="language-plaintext highlighter-rouge">通用块传输机制</code>。</p><h6 id="s91447-compression-and-decompression">s9.1.4.4.7 Compression and decompression</h6><p>For details, see 9.2.3.6.</p><h6 id="s91448-general-protection">s9.1.4.4.8 General protection</h6><p>此机制可用于对任何 xDLMS APDU 应用密码保护，这允许在客户机和服务器之间或第三方和服务器之间应用多层保护。见 9.2.2.5。</p><ul><li>the general-ded-ciphering and the general-glo-ciphering APDUs;<li>the general-ciphering APDUs;<li>the general-signing APDU.</ul><h6 id="sgeneral-block-transfer-gbt">sGeneral block transfer (GBT)</h6><p>GBT 机制可用于块内传输任何长或短<code class="language-plaintext highlighter-rouge">xDLMS APDU</code>。在 GBT 中，块由<code class="language-plaintext highlighter-rouge">通用块传输APDU</code>携带，而不是由特定于服务的“with-datablock”APDUs 携带。</p><p>GBT 机制支持<code class="language-plaintext highlighter-rouge">双向块传输</code>、<code class="language-plaintext highlighter-rouge">流传输</code>和<code class="language-plaintext highlighter-rouge">丢失块恢复</code>:</p><ul><li><code class="language-plaintext highlighter-rouge">双向块传输</code>意味着当一方发送块时，另一方不仅可以确认接收到的块，而且如果它有块可以发送，它也可以发送它们，就是<code class="language-plaintext highlighter-rouge">全双工</code>模式;<li><code class="language-plaintext highlighter-rouge">流式传输</code>意味着一方可以发送<code class="language-plaintext highlighter-rouge">多个区块</code>，而无需另一方对每个区块进行确认,有一个发送窗口;参考 TCP 传输<li><code class="language-plaintext highlighter-rouge">丢失块恢复</code>意味着如果发送的块的接收未被确认，它可以被<code class="language-plaintext highlighter-rouge">再次发送</code>。如果使用流，丢失的块恢复发生在每个<code class="language-plaintext highlighter-rouge">流窗口的结束</code>。</ul><p>通用块传输机制的协议在 9.4.6.13 中指定</p><h5 id="s9145-additional-data-types"><span class="mr-2">s9.1.4.5 Additional data types</span><a href="#s9145-additional-data-types" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h5 id="s9146-xdlms-version-number"><span class="mr-2">s9.1.4.6 xDLMS version number</span><a href="#s9146-xdlms-version-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>6</p><h5 id="s9147-xdlms-conformance-block"><span class="mr-2">s9.1.4.7 xDLMS conformance block</span><a href="#s9147-xdlms-conformance-block" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><code class="language-plaintext highlighter-rouge">xDLMS一致性块</code>支持具有扩展功能的优化的 DLMS 服务实现。它可以通过标记“Application 31”与 DLMS 一致性块区分开来。请参见 9.4.6.1、9.5 和 9.6。</p><p><code class="language-plaintext highlighter-rouge">confirmed AAs</code>可以在<code class="language-plaintext highlighter-rouge">AA建立期间</code>协商一致性块，<code class="language-plaintext highlighter-rouge">unconfirmed and pre-established AAs</code>需要客户端<code class="language-plaintext highlighter-rouge">提前知道</code>server 的一致性块</p><h5 id="s9148-maximum-pdu-size"><span class="mr-2">s9.1.4.8 Maximum PDU size</span><a href="#s9148-maximum-pdu-size" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><dl><dt>Client Max Receive PDU Size<dd>Unsigned16，必须能满足 AARE APDU 大小<dd>低于 12 的值被保留，0 表示无限制<dt>Server Max Receive PDU Size<dd>Unsigned16<dd>低于 12 的值被保留，0 表示无限制</dl><h4 id="s915-layer-management-services"><span class="mr-2">s9.1.5 Layer management services</span><a href="#s915-layer-management-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>这些服务的规范不在本技术报告的范围内。</p><h4 id="s916-summary-of-dlmscosem-application-layer-services"><span class="mr-2">s9.1.6 Summary of DLMS/COSEM application layer services</span><a href="#s916-summary-of-dlmscosem-application-layer-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>The DLMS/COSEM AL services are specified in 9.3.<li>The DLMS/COSEM AL protocol is specified in 9.4.<li>The abstract syntax of the ACSE and xDLMS APDUs is specified in 9.5.<li>The XML schema is defined in 9.6.</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/dlmsal.jpg" alt="messages" data-proofer-ignore></p><h4 id="s917-dlmscosem-application-layer-protocols"><span class="mr-2">s9.1.7 DLMS/COSEM application layer protocols</span><a href="#s917-dlmscosem-application-layer-protocols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM AL</code>协议是基于<code class="language-plaintext highlighter-rouge">ISO/IEC 15954:1999</code>中规定的<code class="language-plaintext highlighter-rouge">ACSE标准</code>和<code class="language-plaintext highlighter-rouge">IEC 61334-4-41:1996</code>中规定的<code class="language-plaintext highlighter-rouge">DLMS标准</code>，并扩展了 DLMS/COSEM。</p><h3 id="s92-information-security-in-dlmscosem"><span class="mr-2">s9.2 Information security in DLMS/COSEM</span><a href="#s92-information-security-in-dlmscosem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>DLMS/COSEM 安全概念 security concept，见 9.2.2;<li>选择的加密算法，见 9.2.3;<li>安全密钥，见 9.2.4、9.2.5、9.2.6;<li>使用加密算法进行实体认证，xDLMS APDU 保护和 COSEM 数据保护，见 9.2.7。</ul><h4 id="s922-the-dlmscosem-security-concept"><span class="mr-2">s9.2.2 The DLMS/COSEM security concept</span><a href="#s922-the-dlmscosem-security-concept" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s9222-identification-and-authentication"><span class="mr-2">s9.2.2.2 Identification and authentication</span><a href="#s9222-identification-and-authentication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h6 id="s92221-identification">s9.2.2.2.1 Identification</h6><p>如 4.3.3 所述，DLMS/COSEM <code class="language-plaintext highlighter-rouge">AEs</code>被绑定到支持 AL 的<code class="language-plaintext highlighter-rouge">协议层</code>中的服务接入点(<code class="language-plaintext highlighter-rouge">SAPs</code>)。这些 SAPs 存在于 AA 中包含 xDLMS APDUs 的 PDUs。</p><p>客户端<code class="language-plaintext highlighter-rouge">用户识别机制</code>使<code class="language-plaintext highlighter-rouge">服务器</code>能够区分<code class="language-plaintext highlighter-rouge">客户端的不同用户</code>(可能是运营商或第三方)，以记录他们访问设备的活动。也看到 4.3.6。</p><h6 id="s92222-authentication-mechanisms">s9.2.2.2.2 Authentication mechanisms</h6><p>身份验证机制确定通信实体在 AA 建立期间使用的协议来证明自己。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/dlmsauth.jpg" alt="messages" data-proofer-ignore></p><ul><li><p>No security (Lowest Level Security) authentication</p><p><code class="language-plaintext highlighter-rouge">无安全性</code>(最低级别安全性)身份验证的目的是允许客户机从服务器检索一些<code class="language-plaintext highlighter-rouge">基本信息</code>。这种身份验证机制不需要任何身份验证;客户端可以访问安全上下文中的 COSEM 对象属性和方法，以及给定 AA 中普遍存在的访问权限。</p><li><p>Low Level Security (LLS) authentication</p><p>服务器要求<code class="language-plaintext highlighter-rouge">客户端</code>通过提供服务器知道的密码来<code class="language-plaintext highlighter-rouge">证明自己</code>。该密码是由当前持有的“<code class="language-plaintext highlighter-rouge">Association SN / LN</code>”对象建模的 AA 来建立的。“Association SN / LN”对象提供了更改密码的方法。</p><li><p>High Level Security (HLS) authentication</p><p>客户端和服务器都必须成功地证明自己（<code class="language-plaintext highlighter-rouge">双向认证</code>），以建立一个 AA。</p><ul><li>Pass 1:客户端发送一个“challenge”CtoS 信息，以及根据身份验证机制附加的信息给服务器;<li><p>Pass 2:服务器发送一个“challenge”StoC 信息，以及根据身份验证机制附加的信息给客户端;</p><blockquote class="prompt-tip"><div><p>如果 StoC 与 CtoS<code class="language-plaintext highlighter-rouge">相同</code>，客户应<code class="language-plaintext highlighter-rouge">拒绝并中止</code>AA 建立过程。所以 StoC 与 CtoS 必须是独立生成的且不同的。</p></div></blockquote><li>Pass 3:<code class="language-plaintext highlighter-rouge">客户端</code>根据对给定 AA 有效的 HLS 身份验证机制的规则处理<code class="language-plaintext highlighter-rouge">StoC</code>和<code class="language-plaintext highlighter-rouge">其他信息</code>，并将结果<code class="language-plaintext highlighter-rouge">发送</code>给服务器。服务器检查<code class="language-plaintext highlighter-rouge">f(StoC)</code>是否是正确处理的结果，如果是，则<code class="language-plaintext highlighter-rouge">接受</code>客户端的身份验证<li>Pass 4:<code class="language-plaintext highlighter-rouge">服务器</code>根据对给定 AA 有效的 HLS 身份验证机制的规则处理<code class="language-plaintext highlighter-rouge">CtoS</code>和<code class="language-plaintext highlighter-rouge">附加信息</code>，并将结果<code class="language-plaintext highlighter-rouge">发送</code>给客户端。客户端检查<code class="language-plaintext highlighter-rouge">f(CtoS)</code>是否是正确处理的结果，如果是，则<code class="language-plaintext highlighter-rouge">接受</code>服务器的身份验证。</ul></ul><p>总结，由服务端先校验客户端合法性，再由客户端校验服务端合法性</p><p><code class="language-plaintext highlighter-rouge">pass2后</code>，如果 application context and xDLMS context<code class="language-plaintext highlighter-rouge">合法</code>（这两个参数再 pass1 和 2 交换或生成，pass2 后已存在，只不过要到 pass4 全走完才激活），则<code class="language-plaintext highlighter-rouge">授予</code>当前”Association SN / LN”对象的<code class="language-plaintext highlighter-rouge">reply_to_HLS_authentication</code>方法<code class="language-plaintext highlighter-rouge">权限</code></p><p>pass3 和 4 依赖于 reply_to_HLS_authentication</p><h5 id="s9223-security-context"><span class="mr-2">s9.2.2.3 Security context</span><a href="#s9223-security-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li><code class="language-plaintext highlighter-rouge">安全套件security suite</code>，确定可用的安全算法，参见 9.2.3.7;<li><code class="language-plaintext highlighter-rouge">安全策略security policy</code>，确定在 AA 内交换的所有 xDLMS APDUs 的保护类型。可能的安全策略在 9.2.7.2.2 中指定;<li><code class="language-plaintext highlighter-rouge">安全材料security material</code>，与给定安全算法相关的，包括安全密钥、初始化向量、公钥证书等。由于每个安全算法的安全材料都是特定的，因此在相关条款中详细指定了元素。</ul><h5 id="s9224-access-rights"><span class="mr-2">s9.2.2.4 Access rights</span><a href="#s9224-access-rights" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>属性的访问权限包括:no_access、read_only、write_only 或 read_and_write。</p><p>方法的访问权限可以是 no_access 或 access。</p><p>可以对访问特定的属性或方法的 APDUs 单独配置加密，.request 和.response 也可以</p><h5 id="s9225-application-layer-message-security"><span class="mr-2">s9.2.2.5 Application layer message security</span><a href="#s9225-application-layer-message-security" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>就是对称加密传输的过程，AA 已经建立的情况下</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/applayersecurity.jpg" alt="messages" data-proofer-ignore></p><p>为了确保端到端消息安全性，第三方必须能够与 DLMS 服务器交换受保护的 xDLMS 服务请求。在这种情况下，客户端充当代理</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/endtoend.jpg" alt="messages" data-proofer-ignore></p><ul><li><p><code class="language-plaintext highlighter-rouge">第三方Third party</code>:</p><ul><li>感知 DLMS/COSEM，即它可以<code class="language-plaintext highlighter-rouge">生成和处理</code>封装了携带 COSEM 对象相关的服务请求和响应的 xDLMS <code class="language-plaintext highlighter-rouge">APDUs</code>的消息;<li><p>它能够对携带请求的 xDLMS APDU 应用<code class="language-plaintext highlighter-rouge">自己的保护</code></p><blockquote class="prompt-danger"><div><p>TODO：这个保护是不是不在 DLMS 规定的范围内，比如用 HTTP 传输，TLS 保护。但是接受服务端消息时又写到能够处理 server - client general protected APDU，AA 不是 client 和 server 建立的吗，third party 的密钥是哪里来的，对应9.2.7.3一起</p></div></blockquote><li>它能够<code class="language-plaintext highlighter-rouge">验证</code>由服务器和/或客户端应用的保护响应。</ul><li><p><code class="language-plaintext highlighter-rouge">The DLMS client</code></p><ul><li>作为第三方和服务器之间的中间人<code class="language-plaintext highlighter-rouge">broker</code>;<li>根据<code class="language-plaintext highlighter-rouge">TP-client</code>消息中包含的信息，<code class="language-plaintext highlighter-rouge">为第三方提供适当的AA</code>;<li><p>验证 TP <code class="language-plaintext highlighter-rouge">有权使用</code>该 AA;验证方法超出了本技术报告的范围。</p><blockquote class="prompt-tip"><div><p>这里提到了AA是client和server维护的，和third party无关，但third party可以利用这个AA传递消息</p></div></blockquote><li>它可以验证第三方申请的保护;<li><code class="language-plaintext highlighter-rouge">封装</code>第三方客户端消息到一个通用的受保护的 xDLMS APDU;<li>它可以验证服务器对封装 COSEM 对象相关服务响应或未经请求的服务请求的 APDU 应用的保护;(Push 操作时);<li>它可以对发送到 TP 的受保护的 xDLMS APDU 应用自己的保护。</ul><li><p><code class="language-plaintext highlighter-rouge">The server</code></p><ul><li>与第三方使用的<code class="language-plaintext highlighter-rouge">客户端</code>(预先)<code class="language-plaintext highlighter-rouge">建立AA</code>;<li>它可以检查使用 AA 的第三方的身份;<li>一旦客户端和/或第三方应用的保护被服务端成功验证，服务端将提供访问 COSEM 对象属性和方法的权限，这些属性和方法由安全策略和访问权限确定;<li>它应该准备响应——或者，在推送操作的情况下，一个未经请求的服务请求——并应用由传入请求的保护、访问权限和安全策略决定的保护。</ul></ul><h5 id="s9226-cosem-data-security"><span class="mr-2">s9.2.2.6 COSEM data security</span><a href="#s9226-cosem-data-security" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>对<code class="language-plaintext highlighter-rouge">具体</code>COSEM 对象内属性、方法参数等的<code class="language-plaintext highlighter-rouge">保护</code>，与 AL 层整体加密整个 xDLMS APDU 有区别。</p><h4 id="s923-cryptographic-algorithms"><span class="mr-2">s9.2.3 Cryptographic algorithms</span><a href="#s923-cryptographic-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>散列函数 hash functions<li>对称加密 symmetric key algorithms<li>非对称加密 asymmetric key algorithms</ul><h5 id="s9232-hash-function"><span class="mr-2">s9.2.3.2 Hash function</span><a href="#s9232-hash-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>一个好的哈希函数是<code class="language-plaintext highlighter-rouge">单向函数</code>（逆过程很难），且要找到产生相同哈希值的两个特定输入也是极其困难的。</p><p>哈希函数接受任意长度的输入，输出固定长度的值。</p><p>一般用于校验完整性</p><p>在 DLMS/COSEM 中使用哈希算法的目的如下:</p><ul><li>数字签名，见 9.2.3.4.4;<li>密钥协议，见 9.2.3.4.6;<li>HLS 认证。具体算法与认证机制有关，请参见 9.2.7.4。</ul><h5 id="s9233-symmetric-key-algorithms"><span class="mr-2">s9.2.3.3 Symmetric key algorithms</span><a href="#s9233-symmetric-key-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>对称密钥算法在 DLMS/COSEM 中用于以下目的:</p><ul><li>使用 HLS 认证机制对通信伙伴进行认证，参见 9.2.7.4;<li>xDLMS 消息的认证和加密，参见 9.2.7.2;<li>COSEM 数据认证和加密，参见 9.2.7.5。</ul><h6 id="s92332-encryption-and-decryption">s9.2.3.3.2 Encryption and decryption</h6><h6 id="s92333-advanced-encryption-standard">s9.2.3.3.3 Advanced Encryption Standard</h6><p>AES 算法，属于分组加密算法</p><p>AES 结合了安全性、性能、效率、易于实现和灵活性。具体来说，该算法在各种计算环境的硬件和软件上都有良好的性能。此外，该算法对内存的要求非常低，这使得它非常适合于空间受限的环境。</p><blockquote class="prompt-warning"><div><p>TODO:内存占用少是不是因为是分组加密，每一块加解密时占用少导致的</p></div></blockquote><h6 id="s92334-encryption-modes-of-operation">s9.2.3.3.4 Encryption Modes of Operation</h6><p>AES-GCM 可规避相同明文块加密成相同密文块带来的重复特征检测，密文块批量篡改的问题。</p><h5 id="s92335-message-authentication-code"><span class="mr-2">s9.2.3.3.5 Message Authentication Code</span><a href="#s92335-message-authentication-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>消息验证码 MAC</p><p>MAC 作用与 HASH 函数相似，都可以验证<code class="language-plaintext highlighter-rouge">完整性</code>，不同的是 MAC<code class="language-plaintext highlighter-rouge">需要密钥</code>而 HASH 不需要密钥。MAC 还能验证<code class="language-plaintext highlighter-rouge">真实性</code>，即使内容被篡改因为没有密钥也无法生成 MAC</p><h5 id="s92336-key-wrapping"><span class="mr-2">s9.2.3.3.6 Key wrapping</span><a href="#s92336-key-wrapping" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>可以使用对称密钥算法使用密钥封装密钥(也称为<code class="language-plaintext highlighter-rouge">密钥加密密钥</code>)来封装(即加密)密钥材料。</p><p>master key</p><p>见 9.2.3.3.8</p><h6 id="s92337-galoiscounter-mode">s9.2.3.3.7 Galois/Counter Mode</h6><p>GCM 是 AES 算法的一种运行模式。</p><p>加密或认证可选，可以仅加密或仅认证</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/aesgcm.jpg" alt="messages" data-proofer-ignore></p><ul><li><p><strong>认证加密函数</strong></p><ul><li><p>输入:</p><ul><li><code class="language-plaintext highlighter-rouge">密钥</code>，<code class="language-plaintext highlighter-rouge">EK</code><li><code class="language-plaintext highlighter-rouge">明文</code>，表示为<code class="language-plaintext highlighter-rouge">P</code>;<li><code class="language-plaintext highlighter-rouge">附加认证数据</code>Additional Authenticated Data(<code class="language-plaintext highlighter-rouge">AAD</code>)，记为<code class="language-plaintext highlighter-rouge">A</code>;<li><code class="language-plaintext highlighter-rouge">初始化向量</code>initialization vector(IV)表示为<code class="language-plaintext highlighter-rouge">IV</code>。</ul><p>明文和 AAD 是 GCM 保护的两类数据。GCM 保护了明文和 AAD 的真实性;GCM 还保护明文的机密性，而 AAD 则是透明的（<code class="language-plaintext highlighter-rouge">明文加密认证，AAD仅认证</code>）</p><p>长度要求（bit）：</p><ul><li>len(P) &lt; 2^39-256;<li>len(A) &lt; 2^64-1;<li>1 &lt;= len(IV) &lt;= 2^64-1.</ul><p>P、A、IV 的位长都是<code class="language-plaintext highlighter-rouge">8的倍数</code>，所以这些值都是<code class="language-plaintext highlighter-rouge">字节串</code>。</p><li><p>输出：</p><ul><li>一个与明文 P 位<code class="language-plaintext highlighter-rouge">长度相同</code>的<code class="language-plaintext highlighter-rouge">密文C</code><li>一个<code class="language-plaintext highlighter-rouge">身份验证标记</code>或<code class="language-plaintext highlighter-rouge">标记</code>，简称<code class="language-plaintext highlighter-rouge">T</code></ul></ul><li><p><strong>认证解密函数</strong></p><ul><li><p>输入：</p><ul><li><code class="language-plaintext highlighter-rouge">密钥</code>，<code class="language-plaintext highlighter-rouge">EK</code><li>密文 C<li><code class="language-plaintext highlighter-rouge">附加认证数据</code>Additional Authenticated Data(<code class="language-plaintext highlighter-rouge">AAD</code>)，记为<code class="language-plaintext highlighter-rouge">A</code>;<li>一个<code class="language-plaintext highlighter-rouge">身份验证标记</code>，简称<code class="language-plaintext highlighter-rouge">T</code></ul><li><p>输出：</p><ul><li>一个与密文 C<code class="language-plaintext highlighter-rouge">长度相同</code>的<code class="language-plaintext highlighter-rouge">明文P</code><li>一个特殊的<code class="language-plaintext highlighter-rouge">错误代码</code>，在本技术报告中表示为 FAIL</ul></ul><li><p>The initialization vector, IV</p><p>就是 frame counter，每加密一次加 1,DLMS 协议里是 systemtitle + IC</p><dl><dt>systemtitle<dd>又称<code class="language-plaintext highlighter-rouge">固定字段</code><dd>64位（8字节）<dt>IC<dd>又称<code class="language-plaintext highlighter-rouge">调用字段</code><dd>32位（4字节）</dl><p>任意两个物理设备的<code class="language-plaintext highlighter-rouge">固定字段</code>不能相同（由systemtitle保证唯一），对同一逻辑设备的任意两次请求的<code class="language-plaintext highlighter-rouge">调用字段</code>不能相同（每次请求递增）</p><p><code class="language-plaintext highlighter-rouge">固定字段</code>的位长将可以为给定密钥实现<code class="language-plaintext highlighter-rouge">验证加密功能</code>的不同物理设备的数量限制为 2^64。<code class="language-plaintext highlighter-rouge">调用字段</code>的位长将<code class="language-plaintext highlighter-rouge">验证加密功能</code>的调用次数限制为 2^32 输入集而不违反唯一性要求。</p><p>每个加密密钥(EK)都有<code class="language-plaintext highlighter-rouge">两个</code>相关联的调用计数器(IC)，一个用于经过身份验证的加密函数，另一个用于经过身份验证的解密函数。</p><ul><li>当密钥建立时，对应的<code class="language-plaintext highlighter-rouge">IC</code>复位为 0;<li>使用<code class="language-plaintext highlighter-rouge">认证加密</code>功能后，对应的 IC<code class="language-plaintext highlighter-rouge">加1</code>。如果 IC 已达到<code class="language-plaintext highlighter-rouge">最大值</code>，任何进一步调用认证加密函数将<code class="language-plaintext highlighter-rouge">返回错误</code>，且 IC<code class="language-plaintext highlighter-rouge">不得增加</code>。<li><p>使用<code class="language-plaintext highlighter-rouge">鉴权解密</code>功能时，验证<code class="language-plaintext highlighter-rouge">IC</code>的值。该值必须等于或大于<code class="language-plaintext highlighter-rouge">最低可接受值</code>。</p><p>如果被验证的值满足此要求，则使用认证解密功能后，<code class="language-plaintext highlighter-rouge">最低可接受值</code>为<code class="language-plaintext highlighter-rouge"> 已验证的IC值</code><code class="language-plaintext highlighter-rouge">加1 </code>。如果<code class="language-plaintext highlighter-rouge"> 被验证的值</code><code class="language-plaintext highlighter-rouge">小于 </code>最低可接受值，则<code class="language-plaintext highlighter-rouge">验证失败</code>，经过验证的解密功能也会<code class="language-plaintext highlighter-rouge">失败</code>。如果被验证的值等于最大值，则经过验证的解密函数将返回一个错误。</p><blockquote class="prompt-danger"><div><p>TODO:这里有个问题，如果客户端出现异常，被验证值设置得很大，那不是会很快到达最大值，导致设备不可用</p></div></blockquote></ul><li><p>The encryption key, EK</p><p><code class="language-plaintext highlighter-rouge">GCM</code>只使用<code class="language-plaintext highlighter-rouge">一个密钥</code>，即分组密码密钥。在 DLMS/COSEM 中，这被称为<code class="language-plaintext highlighter-rouge">加密密钥</code>，表示为<code class="language-plaintext highlighter-rouge">EK</code>。它的<code class="language-plaintext highlighter-rouge">大小</code>取决于安全套件(参见 9.2.3.7)，应该是:</p><ul><li>for security suite 0 and 1, 128 bits (16 octets): len(EK) = 128;<li>for security suite 2, 256 bits (32 octets): len(EK) = 256;</ul><p>密钥应该<code class="language-plaintext highlighter-rouge">随机均匀生成</code>，或者<code class="language-plaintext highlighter-rouge">近似随机</code>均匀生成，即每个可能的密钥生成的概率(几乎)相等。因此，该键将是<code class="language-plaintext highlighter-rouge">新的</code>，即，不等于任何以前的键，且概率很高。密钥应该是秘密的，应使用只适用于 GCM 和选定的分组密码 AES。密钥建立和管理的附加要求在 NIST SP 800-38D:2007, 8.1 中进行了讨论。</p><li><p>The authentication key, AK</p><p>作为附加认证数据(<code class="language-plaintext highlighter-rouge">AAD</code>)的<code class="language-plaintext highlighter-rouge">一部分</code></p><li><p>Length of the authentication tag</p><p>身份验证标记的<code class="language-plaintext highlighter-rouge">位长t</code>是一个安全参数。在安全套件 0、1 和 2 中，其值应为 96 位。</p></ul><h6 id="s92338-aes-key-wrap">s9.2.3.3.8 AES key wrap</h6><p>对于封装密钥数据，DLMS/COSEM 选择了<code class="language-plaintext highlighter-rouge">RFC 3394</code>中指定的 AES 密钥封装算法。该算法旨在包装或加密关键数据。它对<code class="language-plaintext highlighter-rouge">64位块</code>进行操作。在 wrap 之前，关键数据被解析为<code class="language-plaintext highlighter-rouge">n个64位</code>的块,<code class="language-plaintext highlighter-rouge">n至少为2</code>。(AES 密钥长度是 128、192、256，所以肯定满足要求)</p><p>加密输入<code class="language-plaintext highlighter-rouge">密钥加密密钥KEK</code>和<code class="language-plaintext highlighter-rouge">明文密钥</code>，明文密钥为<code class="language-plaintext highlighter-rouge">n个64bit</code>块，输出<code class="language-plaintext highlighter-rouge">(n+1)*64bit</code>长度密文</p><p>解密相反。</p><p><a href="https://blog.csdn.net/miaouu/article/details/6063227">AES-WRAP algorithm</a></p><p><a href="/assets/doc/2022-03-17-dlms-green-1/GB∕T%2036624-2018%20信息技术%20安全技术%20可鉴别的加密机制.pdf">GB∕T 36624-2018 信息技术 安全技术 可鉴别的加密机制</a></p><ul><li><p>概述</p><p>AES-WRAP: Advanced Encryption Standard (AES) Key Wrap Algorithm。本文的总结均来自《<a href="https://datatracker.ietf.org/doc/html/rfc3394">RFC-3394</a>》。</p><p>Any data being wrapped will be referred to as the key data; The key used to do the wrapping will be referred to as the key-encryption key (KEK)。</p><p>The term “key data” is used broadly to mean any data being wrapped, but particularly keys, since this is primarily a key wrap algorithm。</p><p>A KEK can be a 128-bit key, a 192-bit key, or a 256-bit key。</p><p>下面的 key wrap 和 key unwrap 都是 index based 模式的。</p><li><p>IV 分两种：Default 和 Alternative。Default 时， <code class="language-plaintext highlighter-rouge">IV = A6A6A6A6A6A6A6A6</code></p><li>key wrap<ul><li>Inputs: Plaintext, n 64-bit values {P1, P2, …, Pn}, and Key, K (the KEK).<li>Outputs: Ciphertext, (n+1) 64-bit values {C0, C1, …, Cn}.<li><p>Steps:</p><ol><li>Initialize variables</ol><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="go">  Set A = IV, an initial value (see 2.2.3)
</span><span class="gp">  For i = 1 to n      {  R[i] = P[i];</span><span class="w">  </span><span class="o">}</span>
</pre></table></code></div></div><ol><li>Calculate intermediate values.</ol><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="go">  For j=0 to 5
    For i=1 to n
      B =    AES(K, A | R[i])
      A =    MSB(64, B) ^ t where t = (n*j)+i
      R[i] = LSB(64, B)
</span></pre></table></code></div></div><ol><li>Output the results.</ol><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">  Set C[0] = A
  For i = 1 to n
    C[i] = R[i]
</span></pre></table></code></div></div></ul><li>key unwrap<ul><li>Inputs: Ciphertext, (n+1) 64-bit values {C0, C1, …, Cn}, and Key, K (the KEK).<li>Outputs: Plaintext, n 64-bit values {P0, P1, K, Pn}.<li>Steps:<ol><li>Initialize variables.</ol><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">  Set A = C[0]
  For i = 1 to n
    R[i] = C[i]
</span></pre></table></code></div></div><ol><li>Compute intermediate values.</ol><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="go">  For j = 5 to 0
    For i = n to 1
      B =    AES-1(K, (A ^ t) | R[i]) where t = n*j+i
      A =    MSB(64, B)
      R[i] = LSB(64, B)
</span></pre></table></code></div></div><ol><li>Output results.</ol><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="go">  If A is an appropriate initial value (see 2.2.3)
  Then
    For i = 1 to n
      P[i] = R[i]
  Else
    Return an error
</span></pre></table></code></div></div></ul><li><p>模块W</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/aeskeywrap1.png" alt="messages" data-proofer-ignore> <img data-src="/assets/img/2022-03-17-dlms-green-1/aeskeywrap2.png" alt="messages" data-proofer-ignore></p><blockquote><p>图中的S是明文64bit块，输入输出等长</p></blockquote><li><p>说明</p><p>AES(K, W) Encrypt W using the AES codebook with key K</p><p>AES-1(K, W) Decrypt W using the AES codebook with key K</p><p>MSB(j, W) Return the most significant j bits of</p><p>LSB(j, W) Return the least significant j bits of W</p></ul><p>在 DLMS/COSEM 中，KEK 的大小取决于<code class="language-plaintext highlighter-rouge">安全套件</code>(参见 9.2.3.7)，并应是:</p><ul><li>对于安全套件<code class="language-plaintext highlighter-rouge">0和1</code>,128 位(16 位):len(KEK) = <code class="language-plaintext highlighter-rouge">128</code>;<li>对于安全套件<code class="language-plaintext highlighter-rouge">2</code>,256 位(32 位):len(KEK) = <code class="language-plaintext highlighter-rouge">256</code>。</ul><h5 id="s9234-public-key-algorithms"><span class="mr-2">s9.2.3.4 Public key algorithms</span><a href="#s9234-public-key-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>公钥密码系统一般采用难以解决的问题作为算法的基础。RSA 算法是基于非常大的整数的质因数分解。椭圆曲线密码体制(ECC)是基于求解椭圆曲线离散对数问题(ECDLP)的难度。</p><ul><li>通信双方<code class="language-plaintext highlighter-rouge">认证</code><li>xDLMS APDUs 和 COSEM 数据的<code class="language-plaintext highlighter-rouge">数字签名</code><li><code class="language-plaintext highlighter-rouge">密钥协商</code>key agreement</ul><p>一些非对称密钥算法可以用于<code class="language-plaintext highlighter-rouge">多种目的</code>(例如，用于数字签名和密钥建立)。用于一种目的的密钥<code class="language-plaintext highlighter-rouge">不得</code>用于<code class="language-plaintext highlighter-rouge">其他目的</code>。(只对公钥有这个要求，不过公私钥一般是一一配对的)</p><h6 id="s92342-elliptic-curve-cryptography">s9.2.3.4.2 Elliptic curve cryptography</h6><p>椭圆曲线密码学 ECC</p><p>素数域上的椭圆曲线由实数(x, y)组成，满足下列方程:</p>\[y^2=x^3+ax+b\]<p>曲线的形状由 a 和 b 两个参数决定</p><ul><li>NIST 推荐使用椭圆曲线</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/recommandcurves.jpg" alt="messages" data-proofer-ignore></p><h6 id="s92343-data-conversions">s9.2.3.4.3 Data conversions</h6><p>本节描述了数据转换原语，用于在用于指定公钥算法的不同数据类型之间进行转换：八位字节串 (OS)、位串 (BS)、整数 (I)、字段元素 (FE) 和椭圆曲线点 （ECP）。 DLMS/COSEM 使用八位组字符串来表示公钥算法的元素，并使用这些数据类型与八位组字符串之间的转换原语。 长度为 d 的<code class="language-plaintext highlighter-rouge">八位字节串</code> $M_{d–1}$ $M_{d–2}$ … $M_0$ 被编码为 <code class="language-plaintext highlighter-rouge">A-XDR</code> OCTET STRING，其中最左边的八位字节$M_{d–1}$对应于八位字节串的编码值的第一个八位位组</p><ul><li><p>Conversion between Bit Strings and Octet Strings (BS2OS)</p><p>位串转换为八位串的数据转换原语称为位串到八位串转换原语，或称 BS2OS。它以位字符串作为输入，输出八位字符串。长度为 l 的字节串$b_{l-1} b_{l-2}…b_{0}$应该转换为长度为$d=⌈l/8⌉$的八位字符串$M_{d-1} M_{d-2}…M_{0}$。</p><blockquote class="prompt-tip"><div><p>位串在内存中的编码非常密集。每个位只<code class="language-plaintext highlighter-rouge">占用一位</code>存储空间，整个位串的开销由一个小常数限定。但是，与访问向量或字符串的元素相比，访问位串中的位要慢。如果性能是最重要的问题，最好使用字符串来存储布尔值集，即使它们占用更多空间。</p><p>位串和八位字节串的区别就是位串的位长<code class="language-plaintext highlighter-rouge">不需要是8的倍数</code>，而可以是任意值，转换的时候需要<code class="language-plaintext highlighter-rouge">补足8的倍数</code></p></div></blockquote><p>转换器在左边<code class="language-plaintext highlighter-rouge">填充足够的零</code>，使位数为<code class="language-plaintext highlighter-rouge">8的倍数</code>，然后将其分解为八位。</p><ul><li>for $0 \le i \lt d – 1$, let the octet $M_i = b_{8i+7} b_{8i+6} … b_{8i},$;<li>the leftmost octet $M_{d–1}$ shall have its leftmost $8d – l$ bits set to zero;最左边的 OS 字节需要包含位串最左边填 0 部分<li>its rightmost $8 – (8d – l)$ bits shall be $b_{l–1} b_{l–2} … b_{8d–8}$.</ul><li><p>Conversion between Octet Strings and Bit Strings (OS2BS)</p><p>和上面相反</p><p>最左一字节的最左位必须是 0</p><li><p>Conversion between Integers and Octet Strings (I2OS)</p><p>输入为<code class="language-plaintext highlighter-rouge">非负整数</code>$x$，预期长度$d$，需要满足$256^d \gt x$</p><p>每个整数的位用一个字节表示：</p><ul><li>$x = x_{d-1} \cdot 256^{d-1} + x_{d-2} \cdot 256^{d-2} + \cdots + x_1 \cdot 256 + x_0$;<li>where $0 ≤ x_i &lt; 256$ for $0 ≤ i ≤ d-1$;<li>$M_i = x_i$, for $0 ≤ i ≤ d-1$.</ul><blockquote><p>256正好是二进制0b100000000，1在8位，这样的话0-7位就表示$x_0$，通过$x_1 \cdot 256$让8-15位表示$x_1$</p><p>例：十进制1234，转为OS为$0 \cdot 256^3+0 \cdot 256^2+4 \cdot 256^1+210$结果为0x000004D2。其实就是把数字转换为16进制数用<code class="language-plaintext highlighter-rouge">HEX</code>表示</p></blockquote><li><p>Conversion between Octet Strings and Integers (OS2I)</p><p>和上面相反</p><p>0 字节的 OS 输出整数 0</p><li><p>Conversion between Field Elements and Octet Strings (FE2OS)</p><p>将<code class="language-plaintext highlighter-rouge">字段元素</code>转换为八位字符串的数据转换原语称为字段元素到八位字符串转换原语，或<code class="language-plaintext highlighter-rouge">FE2OS</code>。它接受一个<code class="language-plaintext highlighter-rouge">字段元素</code>作为<code class="language-plaintext highlighter-rouge">输入</code>，并<code class="language-plaintext highlighter-rouge">输出</code>相应的<code class="language-plaintext highlighter-rouge">八位字符串</code>。应用 I2OS 转换原语，参数$l$将域元素$x \in F_p$转换为长度为$d =⌈\log_{256}p⌉$的八位字符串$M_{d-1} M_{d-2} … M_0$，其中</p><p>$FE2OS(x) = I2OS(x,l)$</p><li><p>Conversion between Octet Strings and Field Elements (OS2FE)</p><p>与上面相反</p><p>$OS2FE(x) = OS2I(x) \mod p$</p></ul><blockquote class="prompt-warning"><div><p>TODO:Field Elements 是什么，FE2OS 不懂 更新：域元素应该就是某个域范围内的一个值，比如域为0-9999，这个值可能就是3456。$log_{256}45768865=3.18098289749$，所以长度就至少是4，结果为0x02BA60A1，其实就是把数字转换为16进制数用HEX表示</p></div></blockquote><h6 id="s92344-digital-signature">s9.2.3.4.4 Digital signature</h6><p>数字签名是书面签名的电子模拟，可用于向收件人或第三方证明消息是由发信人签名的(这种特性称为<code class="language-plaintext highlighter-rouge">不可否认性</code>)。还可以为所存储的数据和程序生成数字签名，以便可以在稍后时间验证数据和程序的<code class="language-plaintext highlighter-rouge">完整性</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/digitalsign.jpg" alt="messages" data-proofer-ignore></p><h6 id="s92345-elliptic-curve-digital-signature-ecdsa">s9.2.3.4.5 Elliptic curve digital signature (ECDSA)</h6><p>对于 DLMS/COSEM，选择了 FIPS PUB 186-4:2013 中指定的<code class="language-plaintext highlighter-rouge">椭圆曲线数字签名(ECDSA)算法</code>。NSA1 提供了一个实现指南。</p><ul><li><p>在 DLMS/COSEM 中使用的椭圆曲线和算法为:</p><ul><li>in the case of Security Suite <code class="language-plaintext highlighter-rouge">1</code>, the elliptic curve <code class="language-plaintext highlighter-rouge">P-256</code> with the <code class="language-plaintext highlighter-rouge">SHA-256</code> hash algorithm;<li>in the case of Security Suite <code class="language-plaintext highlighter-rouge">2</code>, the elliptic curve <code class="language-plaintext highlighter-rouge">P-384</code> with the <code class="language-plaintext highlighter-rouge">SHA-384</code> hash algorithm.</ul><li><p>签名</p><ul><li>输入：<ul><li>要签名的消息 M;<li>签名者的私钥 d</ul><li>输出：<ul><li>ECDSA signature (r, s) over M.</ul></ul><li><p>验签</p><ul><li>输入：<ul><li>已签名的消息 M’<li>ECDSA signature (r’,s’)<li>签名者的公钥 Q</ul></ul></ul><p>在 DLMS/COSEM 中，应使用纯文本格式：签名 (r, s) 被编码为八位字节串 $R || S$(表示<code class="language-plaintext highlighter-rouge">串联</code>，不是逻辑运算符的或)，即作为八位字节串 <code class="language-plaintext highlighter-rouge">R = I2OS(r,l)</code> 和 <code class="language-plaintext highlighter-rouge">S = I2OS(s,l)</code> 的<code class="language-plaintext highlighter-rouge">串联</code>, $l = [\log_{256} n]$。 因此，签名具有 <code class="language-plaintext highlighter-rouge">2l</code> 个八位字节的<code class="language-plaintext highlighter-rouge">固定长度</code>。</p><h6 id="s92346-key-agreement">s9.2.3.4.6 Key agreement</h6><p>密钥协商允许两个实体联合计算共享密钥并从中派生密钥材料。</p><p>对于 DLMS/COSEM，已从 NIST SP 80056A Rev. 2: 2013 中选择了三种椭圆曲线密钥协商方案</p><ul><li><p>椭圆曲线密钥协商方案：</p><ul><li><p>the Ephemeral Unified Model C(2e, 0s, ECC CDH) scheme;</p><p>此方案用于 DLMS 客户机和服务器之间就主密钥、全局加密密钥和/或身份验证密钥达成一致。<code class="language-plaintext highlighter-rouge">客户端</code>扮演<code class="language-plaintext highlighter-rouge">U</code>方角色，<code class="language-plaintext highlighter-rouge">服务器</code>扮演<code class="language-plaintext highlighter-rouge">V</code>方角色。流程由“<code class="language-plaintext highlighter-rouge">Security setup</code>”接口类的方法支持;见 DLMS UA 1000-1 Part 2 Ed.15:2021, 4.4.7.</p><p>双方从<code class="language-plaintext highlighter-rouge">域参数</code> d中生成一个<code class="language-plaintext highlighter-rouge">临时密钥对</code>。双方<code class="language-plaintext highlighter-rouge">交换临时公钥</code>，然后使用<code class="language-plaintext highlighter-rouge">域参数</code>、<code class="language-plaintext highlighter-rouge">各自的临时私钥</code>和<code class="language-plaintext highlighter-rouge">对方的临时公钥</code>计算<code class="language-plaintext highlighter-rouge">共享密钥Z</code>。<code class="language-plaintext highlighter-rouge">密钥材料</code>是使用 9.2.3.4.6.5 中指定的<code class="language-plaintext highlighter-rouge">密钥派生函数</code>从<code class="language-plaintext highlighter-rouge">共享密钥Z</code>和<code class="language-plaintext highlighter-rouge">其他输入</code>中派生出来的。()</p><blockquote class="prompt-danger"><div><p>TODO:域参数是什么</p><p>TODO:密钥材料，密钥派生是什么。</p></div></blockquote><li><p>the One-Pass Diffie-Hellman C(1e,1s, ECC CDH) scheme;</p><p>和上面的类似，主要是静态动态公钥的区别，就是不需要服务端把动态公钥给客户端，客户端可以通过预先导入的证书（可信 CA 签名）获得对方的静态公钥</p><p>全程只需要发送一次公钥</p><li><p>the Static Unified Model C(0e, 2s, ECC CDH) scheme.</p><p>和上面的类似，将动态公钥变成了静态公钥，不需要发送公钥，只需要 Nonce，Nonce 用于计算密钥材料，保证每次生成的密钥材料不同。</p></ul><li><p>Key Derivation Function – The NIST Concatenation KDF</p><p>密钥派生函数</p><p>Function call: <code class="language-plaintext highlighter-rouge">kdf(Z, OtherInput)</code></p><ul><li><code class="language-plaintext highlighter-rouge">Z</code> 共享密钥，byte string<li><p><code class="language-plaintext highlighter-rouge">OtherInput</code></p><ul><li>keydatalen 一个整数，表示要生成的<code class="language-plaintext highlighter-rouge">密钥材料</code>的<code class="language-plaintext highlighter-rouge">长度</code>(以<code class="language-plaintext highlighter-rouge">位</code>为单位):安全套件<code class="language-plaintext highlighter-rouge">1</code>为<code class="language-plaintext highlighter-rouge">128</code>位，安全套件<code class="language-plaintext highlighter-rouge">2</code>为<code class="language-plaintext highlighter-rouge">256</code>位;<li><p>OtherInfo 等于下列串联的位字符串</p><p>$AlgorithmID || PartyUInfo || PartyVInfo {||SuppPubInfo}{||SuppPrivInfo}$</p><ul><li><p>AlgorithmID bit string，指示如何<code class="language-plaintext highlighter-rouge">解析</code>派生的密钥材料,以及派生的密钥材料将用于哪种<code class="language-plaintext highlighter-rouge">算法</code></p><p>GUEK and GAK：AES-GCM-128 / AES-GCM-256.</p><p>KEK：AES-WRAP-128 / AES-WRAP-256</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/algorithmid.jpg" alt="messages" data-proofer-ignore></p><li>PartyUInfo U 方提供的公开信息，用于派生过程，bit string<li>PartyVInfo V 方提供的公开信息，用于派生过程，bit string<li>SuppPubInfo (Optional),额外的公开信息，DLMS/COSEM 不使用<li>SuppPrivInfo (Optional),额外的非公开信息，DLMS/COSEM 不使用</ul></ul></ul></ul><h5 id="s9235-random-number-generation"><span class="mr-2">s9.2.3.5 Random number generation</span><a href="#s9235-random-number-generation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>应提供强随机数生成器(RNG)，以生成 DLMS/COSEM 中使用的各种算法所需的随机数。</p><h5 id="s9236-compression"><span class="mr-2">s9.2.3.6 Compression</span><a href="#s9236-compression" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>和加密无关，只是放在一起</p><h5 id="s9237-security-suite"><span class="mr-2">s9.2.3.7 Security suite</span><a href="#s9237-security-suite" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>安全套件确定可用于各种密码原语的<code class="language-plaintext highlighter-rouge">密码算法集</code>和<code class="language-plaintext highlighter-rouge">密钥长度</code>。</p><p><code class="language-plaintext highlighter-rouge">DLMS/COSEM安全套件</code>(见表 27)基于<a href="https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography">NSA suite B</a>，包括用于`身份验证、加密、密钥协议、数字签名和哈希的加密算法</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/securitysuite.jpg" alt="messages" data-proofer-ignore></p><h4 id="s924-cryptographic-keys--overview"><span class="mr-2">s9.2.4 Cryptographic keys – overview</span><a href="#s924-cryptographic-keys--overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>密钥作用：</p><ul><li>明文到密文的转换;<li>密文到明文的转换;<li>验证码(MAC)的计算和验证;<li>密钥包装 wrapping;<li>应用和验证数字签名;<li>密钥协商。</ul><h4 id="s925-key-used-with-symmetric-key-algorithms"><span class="mr-2">s9.2.5 Key used with symmetric key algorithms</span><a href="#s925-key-used-with-symmetric-key-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s9251-symmetric-keys-types"><span class="mr-2">s9.2.5.1 Symmetric keys types</span><a href="#s9251-symmetric-keys-types" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>对称密钥的分类：</p><ul><li>按目的分类<ul><li>key encrypting key (KEK)用于加密其他对称加密密钥，master key<li>encryption key 用于 AES-GCM 算法的块加密<li>authentication key 用于 AES-GCM 算法的 AAD</ul><li>按生命周期分类<ul><li>打算使用<code class="language-plaintext highlighter-rouge">较长时间</code>的<code class="language-plaintext highlighter-rouge">静态密钥</code>。 在 DLMS/COSEM 中，它们可能是：<ul><li>一个<code class="language-plaintext highlighter-rouge">全局密钥</code>，可用于在相同合作伙伴之间重复建立的多个 AA。 全局密钥可以是单播加密密钥（<code class="language-plaintext highlighter-rouge">GUEK</code>）、广播加密密钥（<code class="language-plaintext highlighter-rouge">GBEK</code>）或认证密钥（<code class="language-plaintext highlighter-rouge">GAK</code>）；<li>在两个合作伙伴之间建立的单个 AA 期间可以重复使用的<code class="language-plaintext highlighter-rouge">专用密钥</code>。 因此，其生命周期与 <code class="language-plaintext highlighter-rouge">AA 的生命周期</code>相同。 专用密钥只能是<code class="language-plaintext highlighter-rouge">单播加密密钥</code>。</ul><li><code class="language-plaintext highlighter-rouge">临时密钥</code>通常用于 一个 AA 内的单个交换。</ul></ul><blockquote class="prompt-warning"><div><p>TODO:InitiateRequest APDU 和 AARQ 是什么关系？答：见 12.3 Table 133 最后，InitiateRequest APDU 是 AARQ 中 user-information 字段的一部分，是可以加密的</p></div></blockquote><p><code class="language-plaintext highlighter-rouge">专用密钥</code>由 AARQ APDU 中的<code class="language-plaintext highlighter-rouge">InitiateRequest APDU</code>携带，这个 InitiateRequest APDU<code class="language-plaintext highlighter-rouge">本身</code>要被全局单播加密密钥（<code class="language-plaintext highlighter-rouge">GUEK</code>）加密，AARE 中的<code class="language-plaintext highlighter-rouge">InitiateResponse APDU</code>也要用相同的方式加密。</p><blockquote class="prompt-tip"><div><p>AARQ 和 AARE APDUs 本身<code class="language-plaintext highlighter-rouge">不受保护</code>。</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/symmetrickeytypes.jpg" alt="messages" data-proofer-ignore></p><h5 id="s9252-key-information-with-general-ciphering-apdu-and-data-protection"><span class="mr-2">s9.2.5.2 Key information with general-ciphering APDU and data protection</span><a href="#s9252-key-information-with-general-ciphering-apdu-and-data-protection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>当 <code class="language-plaintext highlighter-rouge">general-ciphering</code> APDU 用于保护 <code class="language-plaintext highlighter-rouge">xDLMS APDU</code> 或 <code class="language-plaintext highlighter-rouge">COSEM 数据</code>时，发送方不仅要发送<code class="language-plaintext highlighter-rouge">加密后的</code>xDLMS APDU / COSEM 数据，同时也要发送<code class="language-plaintext highlighter-rouge">密钥的必要信息</code>，该信息已经或将用于<code class="language-plaintext highlighter-rouge">加密/解密</code> xDLMS APDU/COSEM 数据，包括EK、AK、MK等</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/T29.jpg" alt="messages" data-proofer-ignore></p><h5 id="s9253-key-identification"><span class="mr-2">s9.2.5.3 Key identification</span><a href="#s9253-key-identification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><blockquote class="prompt-danger"><div><p>TODO:没看懂</p></div></blockquote><h5 id="s9254-key-wrapping"><span class="mr-2">s9.2.5.4 Key wrapping</span><a href="#s9254-key-wrapping" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>可以用 key wrapping 加密的：</p><ul><li>the master key, KEK; and/or<li>the global unicast encryption key GUEK; and/or<li>the global broadcast encryption key GBEK; and/or<li>the (global) authentication key, GAK.</ul><p>“Security setup” 对象的 key_transfer 方法。</p><h5 id="s9255-key-agreement"><span class="mr-2">s9.2.5.5 Key agreement</span><a href="#s9255-key-agreement" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>可以用 The <code class="language-plaintext highlighter-rouge">Ephemeral</code> Unified Model C(2e,0s, ECC CDH) scheme 协商的密钥：</p><ul><li>the master key, KEK; and/or<li>the global unicast encryption key GUEK; and/or<li>the global broadcast encryption key GBEK; and/or<li>the (global) authentication key, GAK.</ul><h5 id="s9256-symmetric-key-cryptoperiods"><span class="mr-2">s9.2.5.6 Symmetric key cryptoperiods</span><a href="#s9256-symmetric-key-cryptoperiods" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>对称密钥的加密周期应在项目特定的配套规范中确定。</p><h4 id="s926-keys-used-with-public-key-algorithms"><span class="mr-2">s9.2.6 Keys used with public key algorithms</span><a href="#s926-keys-used-with-public-key-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>非对称加密算法密钥分类：</p><ul><li><p>按目的：数字签名、密钥协商</p><li><p>按生命周期：静态密钥、临时密钥</p></ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/asymmetrickeytypes.jpg" alt="messages" data-proofer-ignore></p><h5 id="s9262-key-pair-generation"><span class="mr-2">s9.2.6.2 Key pair generation</span><a href="#s9262-key-pair-generation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>由(q, FR, a, b {, domain_parameter_seed}, G, n, h)生成私钥 d 和公钥 Q</p><h5 id="s9263-public-key-certificates-and-infrastructure"><span class="mr-2">s9.2.6.3 Public key certificates and infrastructure</span><a href="#s9263-public-key-certificates-and-infrastructure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>Public Key Infrastructure (PKI)</p><h6 id="s92632-trust-model">s9.2.6.3.2 Trust model</h6><p>DLMS servers 设备制造过程应该预先导入<code class="language-plaintext highlighter-rouge">trust anchors</code>信任锚、自己的证书、CA 证书、DLMS clients and third parties 证书。</p><blockquote class="prompt-tip"><div><p>设备制造导入证书或信任锚属于<code class="language-plaintext highlighter-rouge">Out of Band (OOB)</code>带外过程，也就是<code class="language-plaintext highlighter-rouge">正规操作以外</code>的过程，正常导入证书应该是通过“Security setup”对象</p></div></blockquote><blockquote class="prompt-tip"><div><p><a href="https://ldapwiki.com/wiki/Trust%20Anchor">信任锚</a>见<a href="https://stackoverflow.com/questions/56061101/trust-anchor-certificates-in-pki">这篇文章</a>，信任锚就是最终信任的那个实体，可以有多个，可以是 root CA，一般操作系统预装了可以信赖的 root CA 列表</p></div></blockquote><p>“Security setup”类提供：</p><ul><li>提供关于存储在服务器上的<code class="language-plaintext highlighter-rouge">证书</code>的信息的<code class="language-plaintext highlighter-rouge">属性</code>;<li>用于<code class="language-plaintext highlighter-rouge">生成</code>服务器<code class="language-plaintext highlighter-rouge">密钥对</code>的方法和用于<code class="language-plaintext highlighter-rouge">生成</code>服务器上的证书签名请求(<code class="language-plaintext highlighter-rouge">CSR</code>)信息的方法,CSR 由客户端<code class="language-plaintext highlighter-rouge">代为发送给CA</code>;<li><code class="language-plaintext highlighter-rouge">导入、导出、移除证书</code>的方法</ul><p>证书一般都有一个<code class="language-plaintext highlighter-rouge">有效期限</code>。但是，颁发给<code class="language-plaintext highlighter-rouge">DLMS服务器</code>的证书可能<code class="language-plaintext highlighter-rouge">无限期有效</code>。证书到期后，可能需要进行<code class="language-plaintext highlighter-rouge">替换</code>。</p><p>在服务器使用证书之前，必须对其进行验证。验证包括:</p><ul><li>检查证书的<code class="language-plaintext highlighter-rouge">语法</code>有效性;<li>检查证书包含的<code class="language-plaintext highlighter-rouge">属性</code>;<li>检查证书有效期是否<code class="language-plaintext highlighter-rouge">未过期</code>;<li>检查<code class="language-plaintext highlighter-rouge">信任锚点</code>的认证路径;<li>检查证书<code class="language-plaintext highlighter-rouge">颁发者</code>的<code class="language-plaintext highlighter-rouge">签名</code></ul><h6 id="s92633-pki-architecture--informative">s9.2.6.3.3 PKI architecture – informative</h6><p>PKI 是一种安全基础设施，它<code class="language-plaintext highlighter-rouge">创建</code>和<code class="language-plaintext highlighter-rouge">管理公钥证书</code>，以方便使用公钥(即，非对称密钥)加密。</p><ul><li>在验证绑定的准确性后，<code class="language-plaintext highlighter-rouge">生成并分发公钥证书</code>，以将公钥绑定到其他信息上（证书包含了公钥和部分设备自定义信息，最后加上数字签名）<li>维护和分发未过期证书的证书<code class="language-plaintext highlighter-rouge">状态信息</code>。</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/pkiarch.jpg" alt="messages" data-proofer-ignore></p><ul><li><p>Root-CA 提供 PKI 的<code class="language-plaintext highlighter-rouge">信任锚点</code>。它为 Sub-CAs 颁发证书，并维护一个证书撤销列表(<code class="language-plaintext highlighter-rouge">CRL</code>)。Root-CA 证书策略定义了处理证书颁发的规则</p><p>Root-CA 拥有根证书“<code class="language-plaintext highlighter-rouge">C(Root)</code>”。Root-CA 的证书是用 Root-CA 的私钥<code class="language-plaintext highlighter-rouge">自签名</code>的。<code class="language-plaintext highlighter-rouge">Sub-CAs</code>证书也使用 Root-CA<code class="language-plaintext highlighter-rouge">私钥签名</code>。</p><li><p>Sub-CA Sub-CA 是为终端实体颁发证书的组织，被 Root-CA 授权</p><p>每个 Sub-CA Certificate Policy 证书策略必须遵守 Root-CA Certificate Policy</p><p>备存发给终端实体 End entity 的<code class="language-plaintext highlighter-rouge">证书清单</code>及<code class="language-plaintext highlighter-rouge">证书撤销清单</code></p><p>Sub-CA 拥有证书<code class="language-plaintext highlighter-rouge">C(sub-CA)</code>。此证书由 Root-CA 颁发。Sub-CA 的私钥用于签名终端实体 End entity 证书。</p><li><p>End entities</p><ul><li>数字签名密钥证书<code class="language-plaintext highlighter-rouge">C(digitalSignature)</code>，用于数字签名;<li>静态密钥协商密钥证书<code class="language-plaintext highlighter-rouge">C(keyAgreement)</code>，用于密钥密钥协商;<li>（可选）TLS- certificate <code class="language-plaintext highlighter-rouge">C(TLS)</code>，用于在建立 TLS 安全通道之前在 DLMS 客户端和 DLMS 服务器之间进行认证。</ul></ul><h5 id="s9264-certificate-and-certificate-extension-profile"><span class="mr-2">s9.2.6.4 Certificate and certificate extension profile</span><a href="#s9264-certificate-and-certificate-extension-profile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>所有证书都应具有为<code class="language-plaintext highlighter-rouge">X.509 V3</code>证书指定的结构。</p><h6 id="s92642-the-x509-v3-certificate">s9.2.6.4.2 The X.509 v3 Certificate</h6><ul><li>m (mandatory): 强制使用;<li>o (optional): 可选;<li>x (do not use): 不要使用.</ul><p>Certificate：</p><ul><li><p>tbsCertificate 包含主题和颁发者的名称、与主题关联的公钥、有效期和其他相关信息</p><ul><li>Version V3 为 2<li>Serial number 序列号必须为 CA 分配给每个证书的<code class="language-plaintext highlighter-rouge">正整数</code>。对于给定 CA 颁发的每个证书，它必须是<code class="language-plaintext highlighter-rouge">唯一</code>的。上限<code class="language-plaintext highlighter-rouge">20个字节</code><li><p>Issuer and Subject 颁发者字段标识签名和颁发证书的实体。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/rootcasubject.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/subcasubject.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/entitysubject.jpg" alt="messages" data-proofer-ignore></p><p>Common Name 需要是 DLMS/COSEM System title</p><li><p>Validity period 证书有效期</p><ul><li>开始生效(notBefore)<li>无效时间(notAfter)</ul><p>DLMS 服务器可以获得无法指定有效过期日期的证书;这样的证书将在设备的<code class="language-plaintext highlighter-rouge">整个生命周期</code>内使用</p><p>为了表明证书没有明确定义的到期日期，<code class="language-plaintext highlighter-rouge">notAfter</code> 应该被分配 <code class="language-plaintext highlighter-rouge">99991231235959Z</code> 的 <code class="language-plaintext highlighter-rouge">GeneralizedTime</code> 值。</p><li><p>SubjectPublicKeyInfo 标识公钥和密钥算法</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="go">SubjectPublicKeyInfo ::= SEQUENCE
{
  Algorithm               AlgorithmIdentifier,
  subjectPublicKey        BIT STRING
}
AlgorithmIdentifier ::= SEQUENCE
{
  algorithm               OBJECT IDENTIFIER,
  parameters              ANY DEFINED BY algorithm OPTIONAL
}
</span></pre></table></code></div></div><p>AlgorithmIdentifier 用于识别密钥算法</p><p>OBJECT IDENTIFIER：</p><ul><li>OID value: 1.2.840.10045.2.1;<li>OID description: ECDSA and ECDH Public Key.</ul><p>parameter：</p><ul><li>1.2.840.10045.3.1.7：NIST P-256<li>1.3.132.0.34：NIST P-384</ul><li>Subject Unique ID 主题唯一 id 可以选择性地用于终端设备证书，而不是服务器证书。</ul><li><p>Certificate extensions</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/x509v3ext.jpg" alt="messages" data-proofer-ignore></p><ul><li>Authority Key Identifier 标识公钥，公钥是和用于签名证书的私钥对应的<li>SubjectKeyIdentifier 标识包含特定公钥的证书<li>KeyUsage 密钥用途，keyAgreement、digitalSignature 等<li>CertificatePolicies 证书策略<li>SubjectAltNames 主题备用名称,可以当作 subject 的扩展<li>IssuerAltName 签发者备用名称<li>Basic constraints 标识本证书所有者是否为 CA<li>Extended Key Usage 该证书可作为 TLS 服务器证书使用<li>cRLDistributionPoints 标识如何获取 CRL<li>Other extensions</ul><li><p>signatureAlgorithm 包含 CA 用于签名此证书的<code class="language-plaintext highlighter-rouge">签名算法</code>的标识符。和<code class="language-plaintext highlighter-rouge">signatureValue</code>相关</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="go">AlgorithmIdentifier ::= SEQUENCE
{
  algorithm         OBJECT IDENTIFIER
  parameters        ANY DEFINED BY algorithm OPTIONAL
}
</span></pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">ecdsa-with-SHA256</code>, OID 1.2.840.10045.4.3.2 in the case of security suite 1;<li><code class="language-plaintext highlighter-rouge">ecdsa-with-SHA384</code>, OID 1.2.840.10045.4.3.3 in the case of security suite 2;</ul><li><p>signatureValue 由<code class="language-plaintext highlighter-rouge">ASN.1 DER编码的tbsCertificate</code>生成的<code class="language-plaintext highlighter-rouge">数字签名</code></p><p>用于验证 tbsCertificate 的有效性</p></ul><h5 id="s9265-suite-b-end-entity-certificate-types-to-be-supported-by-dlms-servers"><span class="mr-2">s9.2.6.5 Suite B end entity certificate types to be supported by DLMS servers</span><a href="#s9265-suite-b-end-entity-certificate-types-to-be-supported-by-dlms-servers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>终端设备包含的证书类型</p><p>证书必须用 ECDSA 签名，证书中的<code class="language-plaintext highlighter-rouge">P-256</code>类型密钥必须用<code class="language-plaintext highlighter-rouge">P-256或P-384</code>类型密钥签名，证书中的<code class="language-plaintext highlighter-rouge">P-384</code>类型密钥必须用<code class="language-plaintext highlighter-rouge">P-384</code>类型密钥签名</p><ul><li>Root-CA 自签名证书（信任锚）<li>Sub-CA 证书<li>用于 <code class="language-plaintext highlighter-rouge">ECDSA</code> 签名生成和验签的证书<li>Key Establishment(Key agreement)用证书（<code class="language-plaintext highlighter-rouge">ECDH</code>算法，One-Pass Diffie-Hellman C(1e, 1s) scheme or with the Static Unified Model C(0e, 2s, ECC CDH) scheme）<li>TLS 证书</ul><h5 id="s9266-management-of-certificates"><span class="mr-2">s9.2.6.6 Management of certificates</span><a href="#s9266-management-of-certificates" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>证书管理</p><h6 id="s92662-provisioning-servers-with-trust-anchors">s9.2.6.6.2 Provisioning servers with trust anchors</h6><p>为服务器提供<code class="language-plaintext highlighter-rouge">信任锚</code>，需要再设备<code class="language-plaintext highlighter-rouge">正常运行前</code>导入<code class="language-plaintext highlighter-rouge">Root-CA,Sub-CA证书</code>或<code class="language-plaintext highlighter-rouge">直接信任的CA公钥</code>。可以有多个信任锚</p><p>信任锚的部署或替换是<code class="language-plaintext highlighter-rouge">带外操作</code>，out of band (<code class="language-plaintext highlighter-rouge">OOB</code>)</p><p>信任锚证书和其他证书<code class="language-plaintext highlighter-rouge">存储在一起</code></p><blockquote class="prompt-waring"><div><p>TODO:这个是否有安全问题，比如 windows 有专门的受信任根证书区域，每个分类都有专属区域。 更新:见下句</p></div></blockquote><p>可以<code class="language-plaintext highlighter-rouge">导出</code>，不能<code class="language-plaintext highlighter-rouge">导入或删除</code>，解释了上面的安全问题，是有防篡改保护的</p><p>直接信任的 CA 公钥不能导出</p><h6 id="s92663-provisioning-the-server-with-further-ca-certificates">s9.2.6.6.3 Provisioning the server with further CA certificates</h6><p>为服务器提供<code class="language-plaintext highlighter-rouge">进一步的CA证书</code>（应该是 Sub-CA，非信任锚）</p><p>“<code class="language-plaintext highlighter-rouge">Security setup</code>”对象中的<code class="language-plaintext highlighter-rouge">import_certificate</code>方法</p><p>导入的 CA 证书需要使用信任锚校验</p><h6 id="s92664-security-personalisation-of-the-server">s9.2.6.6.4 Security personalisation of the server</h6><p>安全个性化导入非对称密钥：</p><ul><li>通过设备商专有方式导入私钥和公钥证书<li><p>“Security setup”相关函数产生</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/mscpersonal.jpg" alt="messages" data-proofer-ignore></p><ol><li>客户端调用<code class="language-plaintext highlighter-rouge">generate_key_pair</code>方法。方法调用参数指定要生成的特定用途的<code class="language-plaintext highlighter-rouge">密钥对</code>:数字签名、密钥协商或 TLS;<li>客户端调用<code class="language-plaintext highlighter-rouge">generate_certificate_request</code>方法。方法调用参数标识生成证书签名请求(<code class="language-plaintext highlighter-rouge">CSR</code>)所需的密钥对。返回参数包括 CSR，由新生成的密钥对的私钥签名;</ol><blockquote class="prompt-danger"><div><p>TODO:CSR 还要私钥签名吗，用哪个私钥签名</p></div></blockquote><ol><li>客户端<code class="language-plaintext highlighter-rouge">向CA发送CSR</code>，该消息封装了调用 generate_certificate_request 方法得到的返回参数。CA(如果满足必要条件)<code class="language-plaintext highlighter-rouge">颁发</code>证书并将其发送给客户端;<li>客户端调用<code class="language-plaintext highlighter-rouge">import_certificate</code>方法。方法调用参数包含证书。服务器<code class="language-plaintext highlighter-rouge">验证</code>证书，如果成功，则将证书上的信息添加到 certificates 属性。如果验证失败，证书将被丢弃。</ol><p>导入新证书成功后，旧证书将被移除。</p><p>使用服务器证书的<code class="language-plaintext highlighter-rouge">各方</code>可以通过以下方式<code class="language-plaintext highlighter-rouge">获得证书</code>:</p><ul><li>带外<code class="language-plaintext highlighter-rouge">out of band</code>;<li>使用“<code class="language-plaintext highlighter-rouge">Security setup</code>”对象的<code class="language-plaintext highlighter-rouge">export_certificate</code>方法<li>作为<code class="language-plaintext highlighter-rouge">AARE</code>的一部分(在<code class="language-plaintext highlighter-rouge">HLS认证</code>期间)</ul></ul><h6 id="s92665-provisioning-servers-with-certificates-of-clients-and-third-parties">s9.2.6.6.5 Provisioning servers with certificates of clients and third parties</h6><p>向服务器提供客户端和第三方证书</p><p>服务器要<code class="language-plaintext highlighter-rouge">验证数字签名</code>，要使用使用静态密钥协商密钥的方案执行<code class="language-plaintext highlighter-rouge">密钥协商</code>，或要<code class="language-plaintext highlighter-rouge">建立TLS连接</code>，<code class="language-plaintext highlighter-rouge">服务器</code>需要<code class="language-plaintext highlighter-rouge">对方</code>的适当<code class="language-plaintext highlighter-rouge">公钥证书</code>。</p><p>如果在制造时<code class="language-plaintext highlighter-rouge">已经知道</code>客户端和/或第三方，则制造商可以将其<code class="language-plaintext highlighter-rouge">公钥证书注入服务器</code>。</p><p>否则，可以使用“<code class="language-plaintext highlighter-rouge">Security setup</code>”对象的<code class="language-plaintext highlighter-rouge">import_certificate</code>方法为服务器提供客户端和第三方的证书。</p><h6 id="s92666-provisioning-clients-and-third-parties-with-certificates-of-servers">s9.2.6.6.6 Provisioning clients and third parties with certificates of servers</h6><p>向客户端和第三方提供服务器的证书</p><p>要<code class="language-plaintext highlighter-rouge">验证数字签名</code>，要使用使用静态密钥协商密钥的方案执行<code class="language-plaintext highlighter-rouge">密钥协商</code>，或要<code class="language-plaintext highlighter-rouge">建立TLS连接</code>，<code class="language-plaintext highlighter-rouge">客户端或第三方</code>需要<code class="language-plaintext highlighter-rouge">对方</code>的适当<code class="language-plaintext highlighter-rouge">公钥证书</code>。</p><p>证书可以随服务器一起交付，并插入到客户端/第三方 OOB 中。</p><p>或者，客户端或第三方可以使用“<code class="language-plaintext highlighter-rouge">Security setup</code>”对象的<code class="language-plaintext highlighter-rouge">export_certificate</code>方法从服务器请求证书。方法调用参数标识所请求的证书。</p><h6 id="s92667-certificate-removal-from-the-server">s9.2.6.6.7 Certificate removal from the server</h6><p>从服务器上删除证书</p><p>当属于服务器的证书被删除时，与公钥相<code class="language-plaintext highlighter-rouge">关联的私钥</code>也应被<code class="language-plaintext highlighter-rouge">销毁</code>。</p><p>“<code class="language-plaintext highlighter-rouge">Security setup</code>“对象的<code class="language-plaintext highlighter-rouge">remove_certificate</code>方法用于删除证书</p><h4 id="s927-applying-cryptographic-protection"><span class="mr-2">s9.2.7 Applying cryptographic protection</span><a href="#s927-applying-cryptographic-protection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>保护<code class="language-plaintext highlighter-rouge">xDLMS APDUs</code>参见 9.2.7.2;<li>处理 HLS 认证期间的挑战信息<code class="language-plaintext highlighter-rouge">challenges</code>，见 9.2.7.4;<li>保护<code class="language-plaintext highlighter-rouge">COSEM data</code>，参见 9.2.7.5。</ul><h5 id="s9272-protecting-xdlms-apdus"><span class="mr-2">s9.2.7.2 Protecting xDLMS APDUs</span><a href="#s9272-protecting-xdlms-apdus" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>本小节 9.2.7.2 指定了 9.2.3.3 和 9.2.3.4 中指定的加密算法如何用于保护 xDLMS APDUs:</p><h6 id="s92722-security-policy-and-access-rights-values">s9.2.7.2.2 Security policy and access rights values</h6><p><img data-src="/assets/img/2022-03-17-dlms-green-1/securitypolicy.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">access rights访问权限</code>由“<code class="language-plaintext highlighter-rouge">Association LN</code>”的 <code class="language-plaintext highlighter-rouge">object_list</code> 属性或“<code class="language-plaintext highlighter-rouge">Association SN</code>”对象的 <code class="language-plaintext highlighter-rouge">access_rights_list</code> 持有。access_rights 的<code class="language-plaintext highlighter-rouge">access_mode</code>元素决定了访问类型并规定了密码保护。它是一个 enum 数据类型。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/accessright1.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/accessright2.jpg" alt="messages" data-proofer-ignore></p><p>对 <code class="language-plaintext highlighter-rouge">COSEM对象</code> 属性 和/或 方法 的<code class="language-plaintext highlighter-rouge">访问权Access rights</code>可能要求对 xDLMS APDUs 进行 认证、加密 和/或 签名 。为此，只允许保护程度<code class="language-plaintext highlighter-rouge">超过或等于安全策略security policy</code>要求的 APDUs。保护程度<code class="language-plaintext highlighter-rouge">低于安全策略和访问权限要求</code>的 APDU 应被<code class="language-plaintext highlighter-rouge">拒绝</code>。</p><p>在这种情况下，<code class="language-plaintext highlighter-rouge">更多的保护</code>是指在 xDLMS APDU 上应用比安全策略所要求的<code class="language-plaintext highlighter-rouge">更多种类</code>的保护：例如，安全策略 security policy 要求所有的 APDU 都经过<code class="language-plaintext highlighter-rouge">认证</code>，但访问权限 Access rights 要求 APDU 经过<code class="language-plaintext highlighter-rouge">加密和认证</code>，即更高的保护。</p><blockquote class="prompt-tip"><div><p>(access rights 是针对某个对象的特定属性或方法的，security policy 是全局的，所以 access rights 可以比 security policy 更严格，而不能更宽松)</p></div></blockquote><h6 id="s92723-ciphered-xdlms-apdus">s9.2.7.2.3 Ciphered xDLMS APDUs</h6><p><code class="language-plaintext highlighter-rouge">加密的xDLMS APDUs</code>只能在加密的<code class="language-plaintext highlighter-rouge">应用程序上下文</code>中使用。另一方面，在加密的应用程序上下文中，可以同时使用<code class="language-plaintext highlighter-rouge">加密</code>和<code class="language-plaintext highlighter-rouge">未加密</code>的 APDUs。</p><p>general-ded-ciphering <code class="language-plaintext highlighter-rouge">dedicated</code> 专用的，使用专用密钥，<code class="language-plaintext highlighter-rouge">AARQ时协商</code></p><p>general-glo-ciphering <code class="language-plaintext highlighter-rouge">global</code> 全局的，使用全局密钥，比如<code class="language-plaintext highlighter-rouge">GUEK</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/cipheredxdlmsapdus.jpg" alt="messages" data-proofer-ignore></p><h6 id="s92724-encryption-authentication-and-compression">s9.2.7.2.4 Encryption, authentication and compression</h6><p>在<code class="language-plaintext highlighter-rouge">消息保护</code>的情况下，要保护的信息是<code class="language-plaintext highlighter-rouge">xDLMS APDU</code>。在 COSEM<code class="language-plaintext highlighter-rouge">数据保护</code>的情况下，需要保护的信息是<code class="language-plaintext highlighter-rouge">COSEM data数据</code>，即<code class="language-plaintext highlighter-rouge">COSEM属性值</code>或<code class="language-plaintext highlighter-rouge">方法调用/返回参数</code>。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/aesgcmapdus.jpg" alt="messages" data-proofer-ignore></p><ul><li><p>The security header</p><p>$SH = SC || IC$</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/securitycontrolbyte.jpg" alt="messages" data-proofer-ignore></p><ul><li>Bit 3…0: Security_Suite_Id, see 9.2.3.7;<li>Bit 4: “A” subfield: 是否认证<li>Bit 5: “E” subfield: 是否加密<li>Bit 6: Key_Set subfield: 0 = Unicast, 1 = Broadcast;<li>Bit 7: 是否压缩</ul><li><p>Plaintext and Additional Authenticated Data</p><p>plaintext, P</p><p>Additional Authenticated Data, A</p><p>security control byte, SC</p><p>authentication key, AK</p><p>information, I</p><p><code class="language-plaintext highlighter-rouge">P</code>是一个关于加密的<code class="language-plaintext highlighter-rouge">形参</code>，可以为 I，如果不加密的话就是空的。</p><p>根据 SC 的不同，AAD 也会不同</p><li><p>Encryption key and authentication key</p><li><p>Initialization vector</p><li><p>三种加密方式</p><ul><li><p><code class="language-plaintext highlighter-rouge">Service-specific ciphering</code> xDLMS APDUs</p><p><code class="language-plaintext highlighter-rouge">Service-specific</code>区别于<code class="language-plaintext highlighter-rouge">general</code>，可以使用部分<code class="language-plaintext highlighter-rouge">变体</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/servicespecificapdus.jpg" alt="messages" data-proofer-ignore></p><li><p>The <code class="language-plaintext highlighter-rouge">general-glo-ciphering</code> and <code class="language-plaintext highlighter-rouge">geneal-ded-ciphering</code> xDLMS APDUs</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/generalglocipher.jpg" alt="messages" data-proofer-ignore></p><li><p>The <code class="language-plaintext highlighter-rouge">general-ciphering</code> APDU</p><p>可以用于<code class="language-plaintext highlighter-rouge">客户端和服务器</code>之间，也可以用于<code class="language-plaintext highlighter-rouge">第三方和服务器</code>之间。这些<code class="language-plaintext highlighter-rouge">APDU</code>还<code class="language-plaintext highlighter-rouge">携带</code>了所使用<code class="language-plaintext highlighter-rouge">密钥</code>的<code class="language-plaintext highlighter-rouge">必要信息</code>。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/generalcipher.jpg" alt="messages" data-proofer-ignore></p></ul><li><p>Use of the fields of the ciphering xDLMS APDUs</p><li><p>Encoding example: global-get-request xDLMS APDU</p></ul><h6 id="s92725-digital-signature">s9.2.7.2.5 Digital signature</h6><p><img data-src="/assets/img/2022-03-17-dlms-green-1/generalsign.jpg" alt="messages" data-proofer-ignore></p><h5 id="s9273-multi-layer-protection-by-multiple-parties"><span class="mr-2">s9.2.7.3 Multi-layer protection by multiple parties</span><a href="#s9273-multi-layer-protection-by-multiple-parties" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>多重保护一般用于 third party-&gt;client-&gt;server 模型，即 third party 应用一层，client 应用一层。</p><p>server 需要根据请求的保护状态以及 security policy and access rights 要求的保护来保护数据</p><blockquote class="prompt-danger"><div><p>TODO:很难理解，需要实例。对应9.2.2.5一起</p></div></blockquote><h5 id="s9274-hls-authentication-mechanisms"><span class="mr-2">s9.2.7.4 HLS authentication mechanisms</span><a href="#s9274-hls-authentication-mechanisms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/dlmshlsauth.jpg" alt="messages" data-proofer-ignore></p><p>需要提前知道对方的证书和 systemtitle,不知道的话需要传递</p><p>见原文示例</p><h5 id="s9275-protecting-cosem-data"><span class="mr-2">s9.2.7.5 Protecting COSEM data</span><a href="#s9275-protecting-cosem-data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>需要保护的数据列表、需要保护的对象和保护参数由“<code class="language-plaintext highlighter-rouge">Data protection</code>”对象决定。</p><h3 id="s93-dlmscosem-application-layer-service-specification"><span class="mr-2">s9.3 DLMS/COSEM application layer service specification</span><a href="#s93-dlmscosem-application-layer-service-specification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s931-service-primitives-and-parameters"><span class="mr-2">s9.3.1 Service primitives and parameters</span><a href="#s931-service-primitives-and-parameters" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><code class="language-plaintext highlighter-rouge">REQUEST</code>：请求原语从 N-用户传递到 N-层以请求启动服务；<li><code class="language-plaintext highlighter-rouge">INDICATION</code>：指示原语从 N-层传递给 N-用户，以指示对 N-用户重要的内部 N-层事件。 该事件可能逻辑上与远程服务请求有关，也可能是 N-层内部的事件引起的；<li><code class="language-plaintext highlighter-rouge">RESPONSE</code>：响应原语从 N-用户传递到 N-层，以完成先前由指示原语调用的过程。<li><code class="language-plaintext highlighter-rouge">CONFIRM</code>：确认原语从 N-层传递给 N-用户，以传达一个或多个相关的先前服务请求的结果。</ul><p><code class="language-plaintext highlighter-rouge">（重要）命名规则</code></p><h4 id="s932-the-cosem-open-service"><span class="mr-2">s9.3.2 The COSEM-OPEN service</span><a href="#s932-the-cosem-open-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>COSEM-OPEN 服务的作用是在对端 COSEM 应用实体(AEs)之间建立 AA。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/serviceparamopen.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-tip"><div><p>AA 相关协商后参数，AL 会保存，比如密钥、加密策略、是否使用 GBT、最大接收 PDU 大小等，</p></div></blockquote><p>使用 ACSE 的 A-ASSOCIATE 服务</p><ul><li><p>Protocol_Connection_Parameters</p><p>强制。 它包含使用通信配置文件层所必需的所有信息，包括通信配置文件（协议）标识符和所需的地址。 它确定了 AA 的参与者。 该参数的元素被传递给管理低层连接的实体，并酌情传递给低层。</p><li><p>ACSE_Protocol_Version</p><p>可选参数。如果存在，则应使用缺省值。</p><li><p>Application_Context_Name</p><p>强制。在请求原语中，它持有客户端<code class="language-plaintext highlighter-rouge">提议</code>的值。在响应原语中，它保存相同的值或服务器<code class="language-plaintext highlighter-rouge">支持</code>的值。(类似于 TLS 握手中的加密策略，是一个需要<code class="language-plaintext highlighter-rouge">协商</code>的值)</p><li><p>Called_AP_Title, Called_AE_Qualifier, Called_AP_Invocation _Identifier, Called_AE_Invocation_Identifier</p><p>可选</p><li><p>Calling_AP_Title</p><p>有条件的。当建议的<code class="language-plaintext highlighter-rouge">应用程序上下文</code>和/或建议的<code class="language-plaintext highlighter-rouge">HLS认证机制</code>要求使用<code class="language-plaintext highlighter-rouge">客户端system title</code>，并且在注册过程中尚未传输时，Calling_AP_Title 应携带客户端 system title。见 4.3.4。</p><li><p>Calling_AE_Qualifier</p><p>有条件的。当 Application_Context_Name 为加密的<code class="language-plaintext highlighter-rouge">应用上下文Application_Context_Name</code>时，可能携带客户端的公共数字签名密钥<code class="language-plaintext highlighter-rouge">证书</code>。</p><li><p>Calling_AP_Invocation_Identifier</p><p>可选。</p><li><p>Calling_AE_Invocation_Identifier</p><p>可选。携带 AA 的客户端用户的标识符。</p><li><p>Local_or_Remote</p><p>强制。接收到 AARE APDU 生成的确认就是 Remote,本地确认就是 Local</p><li><p>Result</p><p>强制。remote confirmation 下为 AA 是否被接受，local confirmation 下为本地低层协议栈是否接受请求</p><li><p>Failure_Type</p><p>强制。在远程确认的情况下，它携带服务器提供的信息。在局部和消极 negative 确认的情况下，表示失败的原因。</p><li><p>Responding_AP_Title</p><p>有条件的。当协商的应用程序上下文和/或协商的 HLS 认证机制要求使用服务器系统标题，并且在注册过程中尚未转移时，则 Responding_AP_Title 应携带服务器<code class="language-plaintext highlighter-rouge">系统标题system title</code>。</p><li><p>Responding_AE_Qualifier</p><p>有条件的。当 Application_Context_Name 为加密的应用上下文时，可能携带服务器的公共数字签名密钥<code class="language-plaintext highlighter-rouge">证书</code>。</p><li><p>Responding_AP_Invocation_Identifier and Responding_AE_Invocation_Identifier</p><p>可选</p><li><p>ACSE_Requirements</p><p>可选。用于选择认证功能单元。见 9.4.2.1 表格 81。DLMS 中的 ACSE 支持的 Authentication 功能模块（还有一个是 kernel 模块）为 AARQ 添加了一些参数</p><ul><li>Lowest Level Security:无此参数<li>LLS：.request 有，.response 可能有<li>HLS: .request 和.response 都有</ul><li><p>Security_Mechanism_Name</p><p>有条件的。</p><li><p>The Calling_Authentication_Value、the Responding_Authentication_Value</p><p>有条件的。</p><li><p>Implementation_Information</p><p>可选的</p><li><p>Proposed_xDLMS_Context</p><p>xDLMS_Context 建议值。包含在<code class="language-plaintext highlighter-rouge">AARQ</code> APDU 中的<code class="language-plaintext highlighter-rouge">user-information</code>中的 xDLMS InitiateRequest APDU 中</p><li><p>Negotiated_xDLMS_Context</p><p>服务端接受 Proposed_xDLMS_Context 建议后回复。包含在<code class="language-plaintext highlighter-rouge">AARE</code> APDU 中的<code class="language-plaintext highlighter-rouge">user-information</code>中的 xDLMS InitiateRequest APDU 中</p><li><p>xDLMS_Initiate_Error</p><p>服务端不接受 Proposed_xDLMS_Context 建议，回复。包含在<code class="language-plaintext highlighter-rouge">AARE</code> APDU 中的<code class="language-plaintext highlighter-rouge">user-information</code>中的 xDLMS InitiateRequest APDU 中</p><li><p><code class="language-plaintext highlighter-rouge">User_Information</code></p><blockquote class="prompt-tip"><div><p>请不要将 COSEM-OPEN 服务的<code class="language-plaintext highlighter-rouge">User_Information</code>参数与 AARQ / AARE apdu 的<code class="language-plaintext highlighter-rouge">user-information</code>字段<code class="language-plaintext highlighter-rouge">混淆</code>。</p></div></blockquote><li><p>Service_Class</p><p>强制的。指示服务是<code class="language-plaintext highlighter-rouge">confirmed</code>还是<code class="language-plaintext highlighter-rouge">unconfirmed</code></p></ul><h5 id="s9323-use"><span class="mr-2">s9.3.2.3 Use</span><a href="#s9323-use" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/timeseq.jpg" alt="messages" data-proofer-ignore></p><ul><li>confirmed AA – <code class="language-plaintext highlighter-rouge">a</code><li>unconfirmed AA – <code class="language-plaintext highlighter-rouge">b</code><li>pre-established AA – <code class="language-plaintext highlighter-rouge">c</code></ul><p>原语发生在 AP 和 AL 之间，</p><h4 id="s933-the-cosem-release-service"><span class="mr-2">s9.3.3 The COSEM-RELEASE service</span><a href="#s933-the-cosem-release-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">优雅释放</code>已经存在的 AA</p><p>调用它的方式（<code class="language-plaintext highlighter-rouge">Use_RLRQ_RLRE</code>参数）决定了它是否使用 ACSE 的<code class="language-plaintext highlighter-rouge">A-RELEASE</code>服务。</p><p>如果 Use_RLRQ_RLRE 为 FALSE，则 AL 层不能使用 A-RELEASE 服务中的<code class="language-plaintext highlighter-rouge">RLRQ和RLRE</code>（和 AARQ/AARE 相对，见 9.4.2.1），也就不能使用 RLRQ/RLRE 断链。可以通过断开支持层的方式断链</p><h4 id="s934-the-cosem-abort-service"><span class="mr-2">s9.3.4 The COSEM-ABORT service</span><a href="#s934-the-cosem-abort-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>指示支持协议层的主动断开,只有 COSEM-ABORT.indication 原语，，对应上图中的<code class="language-plaintext highlighter-rouge">e</code>情况</p><p>COSEM-ABORT.indication 原语在客户端和服务器端<code class="language-plaintext highlighter-rouge">本地生成</code>，以指示 COSEM AP 下层连接以<code class="language-plaintext highlighter-rouge">非请求</code>的方式<code class="language-plaintext highlighter-rouge">关闭</code>。</p><p>此类事件的起因可以是一个<code class="language-plaintext highlighter-rouge">外部事件</code>(例如物理线路断线)，或者在一些配置文件中出现的一个<code class="language-plaintext highlighter-rouge">支持协议层连接管理器AP</code>(<code class="language-plaintext highlighter-rouge">层管理AP</code>，非 COSEM AP)的动作，当支持的协议层连接不是由 DLMS/COSEM AL 管理时。这将导致 COSEM AP<code class="language-plaintext highlighter-rouge">中止</code>任何现有的 AA，除了在服务器端预连接 AA。</p><h4 id="s935-protection-and-general-block-transfer-parameters"><span class="mr-2">s9.3.5 Protection and general block transfer parameters</span><a href="#s935-protection-and-general-block-transfer-parameters" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/protectiongbtparams.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">Additional_Service_Parameters</code>仅在使用<code class="language-plaintext highlighter-rouge">加密</code>或<code class="language-plaintext highlighter-rouge">GBT</code>时存在。</p><ul><li>Invocation_Type:<code class="language-plaintext highlighter-rouge">COMPLETE</code>, <code class="language-plaintext highlighter-rouge">FIRST-PART</code>, <code class="language-plaintext highlighter-rouge">ONE-PART</code> and <code class="language-plaintext highlighter-rouge">LAST-PART</code></ul><blockquote class="prompt-warning"><div><p>TODO:<code class="language-plaintext highlighter-rouge">重要！</code>这里又提到了 Partial service invocations，就是用 FIRST-PART 之类的分包，属于可选的 Additional_Service_Parameters 参数，与 GET 之类的原语的 service-specific block transfer 不一样，和 general block transfer（GBT）又不一样，那这三种分包方式可以同时存在吗 更新：1.Invocation_Type 的分包是针对本地 AL 和本地 AP 之间的，可能是用于 AL 接受缓存或 AP 发送缓存不够的情况。2.service-specific block transfer 是针对本地 AP 和对端 AP 之间的，用于解决超过 AP 接受或发送缓存的情况，这时候还没有 APDU,数据仅仅是原语的参数 3.GBT 是本地 AL 和对端 AL 之间的，这时候分割的 APDU，用于 APDU 过大的情况</p></div></blockquote><p><code class="language-plaintext highlighter-rouge">Partial service invocations</code>在接收端时，AL 需要判断是否可以划分 PART，比如，因为 GBT 是流的形式传输，接收到的包都是按照字节分割的，所以接收端 APDU 需要判断是否可以完整解密、是否可以组成原语（如 ACTION-LIST，见 9.3.8 和 Figure 149，属性列表在前，参数列表在后，需要收全后才能组成原语），然后才能划分 PART。</p><p>Block_Transfer_Streaming 指示是否允许 AL 使用流（GBT），见 9.4.6.13</p><p>Block_Transfer_Window 指示最大接受窗口大小</p><h4 id="s936-the-get-service"><span class="mr-2">s9.3.6 The GET service</span><a href="#s936-the-get-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>其功能是<code class="language-plaintext highlighter-rouge">读取</code>一个或多个 COSEM 对象属性的值。结果可以在<code class="language-plaintext highlighter-rouge">单个响应</code>中交付，或者(如果它太长，不能在单个响应中交付)在<code class="language-plaintext highlighter-rouge">多个响应</code>中交付，使用<code class="language-plaintext highlighter-rouge">块传输</code>（没有指定是那种类型的块传输）。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/getparams.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/getreqtype.jpg" alt="messages" data-proofer-ignore></p><p>两个优先级 normal (FALSE) or high (TRUE).</p><p>如果是 Request_Type=NEXT 就不用带 COSEM_Attribute_Descriptor</p><p>REQUEST-WITH-LIST 会带多个 COSEM_Attribute_Descriptor，但不能超过 server-max-receive-pdu-size。<code class="language-plaintext highlighter-rouge">原则：GET.request服务原语必须包含在单个APDU中,所以不能用分BLOCK方式发请求</code></p><p>整个<code class="language-plaintext highlighter-rouge">响应</code>单个 APDU<code class="language-plaintext highlighter-rouge">放得下</code>就用 Response_Type == NORMAL or WITH-LIST，<code class="language-plaintext highlighter-rouge">放不下</code>就用 Response_Type == <code class="language-plaintext highlighter-rouge">ONE-BLOCK</code>，最后一包用 LAST-BLOCK</p><p>COSEM_Object_Attribute_Id == 0 (<code class="language-plaintext highlighter-rouge">Attribute_0</code>)的情况，表示读取<code class="language-plaintext highlighter-rouge">所有的属性</code>，返回一个包含所有数据的<code class="language-plaintext highlighter-rouge">结构体</code>，填充在<code class="language-plaintext highlighter-rouge">Data</code>区域，没权限的或访问出错的回 null-data</p><ul><li>successful confirmed GET – <code class="language-plaintext highlighter-rouge">a</code><li>unconfirmed GET – <code class="language-plaintext highlighter-rouge">d</code><li>unsuccessful attempt due to a local error – <code class="language-plaintext highlighter-rouge">c</code></ul><blockquote class="prompt-tip"><div><p>重要：关于<code class="language-plaintext highlighter-rouge">编解码</code>，AP 层并不负责对 APDU 的编解码（比如 A-XDR 编码），对于 AL 层原语的调用（如 COSEM-OPEN、GET 等），传递的只是参数（或者叫变量），关于参数的格式和定义就是设计的问题了（可以使用编程语言的基本变量类型或自定义变量类型）。</p><p><code class="language-plaintext highlighter-rouge">Table 60</code>中包含了原语的很多参数，但只有<code class="language-plaintext highlighter-rouge">部分</code>是需要被包含进<code class="language-plaintext highlighter-rouge">最终的APDU</code>中的，所以 AP 编解码本身就解释不通，否则 AL 需要再进行解码再封装，多此一举。其中 Result 中的<code class="language-plaintext highlighter-rouge">Data</code>是一个<code class="language-plaintext highlighter-rouge">octet-string格式</code>的参数，其内部的值已经是编完码的了，因为 Data 编解码是业务层蓝皮书的部分，需要 AP 来进行，但这里仅仅作为一个 octet-string 类型的变量，和 AP 不对整个 APDU 进行编码的观点不冲突。AL 属于绿皮书范畴，是通信的协议层，APDU 是作为通信载体，应该属于绿皮书范畴，所以需要 AL 层编解码</p></div></blockquote><h4 id="s937-the-set-service"><span class="mr-2">s9.3.7 The SET service</span><a href="#s937-the-set-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>写入一个或多个 COSEM 对象属性的值。要写入的数据可以在单个请求中发送，或者(如果数据太长，不能在单个请求中发送)在<code class="language-plaintext highlighter-rouge">多个请求</code>中使用<code class="language-plaintext highlighter-rouge">块传输</code>。(不同于 GET，SET 请求可以分包)</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/setparams.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/setreqtype.jpg" alt="messages" data-proofer-ignore></p><p>仅 Request_Type == NORMAL, FIRST-BLOCK, WITH-LIST and FIRST-BLOCK-WITH-LIST 携带 COSEM_Attribute_Descriptor</p><p>响应不能分包</p><p>COSEM_Object_Attribute_Id == 0 (<code class="language-plaintext highlighter-rouge">Attribute_0</code>)的情况，同 GET，需要 SET 请求包含有<code class="language-plaintext highlighter-rouge">全部公开属性</code>的 Data 值的<code class="language-plaintext highlighter-rouge">结构体</code>。Result 将携带一个结果，如果写入了<code class="language-plaintext highlighter-rouge">所有属性</code>则为<code class="language-plaintext highlighter-rouge">成功</code>，或者只有一个<code class="language-plaintext highlighter-rouge">失败原因</code>。</p><blockquote class="prompt-danger"><div><p>TODO:部分成功的情况呢</p></div></blockquote><ul><li>successful confirmed SET – <code class="language-plaintext highlighter-rouge">a</code><li>unconfirmed SET – <code class="language-plaintext highlighter-rouge">d</code><li>unsuccessful attempt due to a local error – <code class="language-plaintext highlighter-rouge">c</code></ul><h4 id="s938-the-action-service"><span class="mr-2">s9.3.8 The ACTION service</span><a href="#s938-the-action-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>调用一个或多个 COSEM 对象方法</p><p>请求响应都能分包,需要请求<code class="language-plaintext highlighter-rouge">完整发完</code>，响应才开始分包发送结果</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/actionparams.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/actionreqtypes.jpg" alt="messages" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">第一阶段</code>：client AP 向 AL 发送 ACTION.request，server 的 AL 收到后向 AP 发送 ACTION.indication，server AP 回 ACTION.response，ACTION.confirm 由 AL 发送给 client AP,都是可以是分包的。直到收到完整的请求（LAST-BLOCK 发送后）。</p><p><code class="language-plaintext highlighter-rouge">第二阶段</code>：开始执行方法，执行完后返回结果，可以分包</p><h4 id="s939-the-access-service"><span class="mr-2">s9.3.9 The ACCESS service</span><a href="#s939-the-access-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用一个.request / .response 访问（access）<code class="language-plaintext highlighter-rouge">多个</code>COSEM 对象属性和/或方法，包括 GET / SET / ACTION 的组合</p><p>ACCESS 好像就是 DSMR 里的 COSEM-ACCESS</p><p><code class="language-plaintext highlighter-rouge">Long_Invoke_Id</code>，区别于上面的 Invoke_Id</p><p><code class="language-plaintext highlighter-rouge">自描述响应</code>，不仅包含结果 data，也包含请求参数，可以不依赖于对应的请求直接解析响应。可选。</p><p>对于 GET，Access_Request_List_Of_Data 中也包括 data,对于 GET 就是 null-data，需要由响应填充</p><p>可以带<code class="language-plaintext highlighter-rouge">时间戳</code>，表示.request 和.response 调用时间，降低消耗</p><blockquote class="prompt-danger"><div><p>TODO:为什么可以降低消耗，原文是This further reduces overhead</p></div></blockquote><p>支持 list 访问，Access_Request_Specification 作为数组可以有多个元素</p><h5 id="s9392-service-specification"><span class="mr-2">s9.3.9.2 Service specification</span><a href="#s9392-service-specification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/accessparams.jpg" alt="messages" data-proofer-ignore></p><p>Access_Request_Specification:</p><ul><li>Access_Request_Get 不带选择性访问参数<li>Access_Request_Set 不带选择性访问参数<li>Access_Request_Action<li>Access_Request_Get_With_Selection 带选择性访问参数，不能用于 Attribute_0 情况<li>Access_Request_Set_With_Selection 带选择性访问参数，不能用于 Attribute_0 情况</ul><p>优先判断 result，如果 result 失败直接丢弃 data。</p><h4 id="s9310-the-datanotification-service"><span class="mr-2">s9.3.10 The DataNotification service</span><a href="#s9310-the-datanotification-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>数据推送</p><p>unsolicited 未经请求, unconfirmed 无需确认 或 confirmed 需确认</p><p>request 支持分块传输</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/datanotiparams.jpg" alt="m esages" data-proofer-ignore></p><p>Confirmed：收到 Data-Notification-Confirm APDU</p><p>Unconfirmed：收到支持层确认</p><p>服务原语通信模型：Figure 112 a), b) and d).</p><blockquote class="prompt-danger"><div><p>TODO:这里的 d 是什么情况，按照描述，Unconfirmed 也需要支持层响应</p></div></blockquote><h4 id="s9311-the-eventnotification-service"><span class="mr-2">s9.3.11 The EventNotification service</span><a href="#s9311-the-eventnotification-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>unconfirmed 无需确认</p><p>request 支持分块传输</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/eventnotiparams.jpg" alt="messages" data-proofer-ignore></p><p>Application_Addresses:可选，如果<code class="language-plaintext highlighter-rouge">没有</code>相应的<code class="language-plaintext highlighter-rouge">AA</code>，则包含全部识别信息(也就是允许没有 AA 的情况上报)</p><p>服务原语通信模型：Figure 112 f), g)</p><h4 id="s9312-the-triggereventnotificationsending-service"><span class="mr-2">s9.3.12 The TriggerEventNotificationSending service</span><a href="#s9312-the-triggereventnotificationsending-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>EventNotification 的触发服务，由客户端发起，用于 EventNotification 不能自动触发的情况。</p><p>不需要 AA</p><h4 id="s9313-variable-access-specification"><span class="mr-2">s9.3.13 Variable access specification</span><a href="#s9313-variable-access-specification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h4 id="s9314-the-read-service"><span class="mr-2">s9.3.14 The Read service</span><a href="#s9314-the-read-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h4 id="s9315-the-write-service"><span class="mr-2">s9.3.15 The Write service</span><a href="#s9315-the-write-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h4 id="s9316-the-unconfirmedwrite-service"><span class="mr-2">s9.3.16 The UnconfirmedWrite service</span><a href="#s9316-the-unconfirmedwrite-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h4 id="s9317-the-informationreport-service"><span class="mr-2">s9.3.17 The InformationReport service</span><a href="#s9317-the-informationreport-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h4 id="s9318-client-side-layer-management-services-the-setmappertablerequest"><span class="mr-2">s9.3.18 Client side layer management services: the SetMapperTable.request</span><a href="#s9318-client-side-layer-management-services-the-setmappertablerequest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>有关 SN 的跳过</p><h3 id="s94-dlmscosem-application-layer-protocol-specification"><span class="mr-2">s9.4 DLMS/COSEM application layer protocol specification</span><a href="#s94-dlmscosem-application-layer-protocol-specification" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s941-the-control-function-cf"><span class="mr-2">s9.4.1 The control function (CF)</span><a href="#s941-the-control-function-cf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s9411-state-definitions-of-the-client-side-control-function"><span class="mr-2">s9.4.1.1 State definitions of the client side control function</span><a href="#s9411-state-definitions-of-the-client-side-control-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/clientcfstatemachine.jpg" alt="messages" data-proofer-ignore></p><p>带<code class="language-plaintext highlighter-rouge">/</code>的表示<code class="language-plaintext highlighter-rouge">过程</code>，也就是在转换过程中发生的，不带<code class="language-plaintext highlighter-rouge">/</code>的表示状态转换触发的<code class="language-plaintext highlighter-rouge">起点</code>。(可以这么理解，左右两个 pending 就是<code class="language-plaintext highlighter-rouge">中间态</code>，而 IDLE 和 ASSOCIATED 是<code class="language-plaintext highlighter-rouge">起始态</code>，从起始触发的就是不带<code class="language-plaintext highlighter-rouge">/</code>的)</p><h5 id="s9412-state-definitions-of-the-server-side-control-function"><span class="mr-2">s9.4.1.2 State definitions of the server side control function</span><a href="#s9412-state-definitions-of-the-server-side-control-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/servercfstatemachine.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-warning"><div><p>TODO:图上的 EventNotification.reg 单词拼错了，应该是 req</p></div></blockquote><h4 id="s942-the-acse-services-and-apdus"><span class="mr-2">s9.4.2 The ACSE services and APDUs</span><a href="#s942-the-acse-services-and-apdus" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s9421-acse-functional-units-services-and-service-parameters"><span class="mr-2">s9.4.2.1 ACSE functional units, services and service parameters</span><a href="#s9421-acse-functional-units-services-and-service-parameters" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>DLMS/COSEM AL ACSE 基于 IEC 标准中的 connection-oriented ACSE</p><p>支持<code class="language-plaintext highlighter-rouge">Kernel</code>、<code class="language-plaintext highlighter-rouge">Authentication</code>两个功能模块</p><p>AARQ 和 AARE 中的<code class="language-plaintext highlighter-rouge">acse-requirements</code>(见 9.3.2)参数用于选择功能模块启用</p><p>见文中 Table 81</p><p>AARQ APDU 由 COSEM-OPEN.request 原语决定，AARE APDU 由 COSEM-OPEN.response 原语决定</p><p>各个参数：</p><blockquote class="prompt-warning"><div><p>TODO:用到的时候补充下</p></div></blockquote><ul><li><code class="language-plaintext highlighter-rouge">user-information</code>:AARQ APDU 中携带<code class="language-plaintext highlighter-rouge">xDLMS InitiateRequest APDU</code>包含 Proposed_xDLMS_Context 参数。AARE APDU 中携带 an xDLMS InitiateResponse APDU 包含 Negotiated_xDLMS_Context 参数</ul><h5 id="s9422-registered-cosem-names"><span class="mr-2">s9.4.2.2 Registered COSEM names</span><a href="#s9422-registered-cosem-names" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>OSI分层架构中的ISO标准网络对象名，由DLMS UA分配。</p><p>DLMS/COSEM中使用的对象名：</p><ul><li><p>COSEM_Application_Context_Name</p><p>{joint-iso-ccitt(2) country(16) country-name(756) identified-organization(5) DLMS-UA(8) application-context(1) context_id(x)}</p><p>application-context和context_id：</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/T82.jpg" alt="messages" data-proofer-ignore></p><li><p>COSEM_Authentication_Mechanism_Name</p><p>{joint-iso-ccitt(2) country(16) country-name(756) identified-organization(5) DLMS-UA(8) authentication_mechanism_name(2) mechanism_id(x)}</p><p>authentication_mechanism_name和mechanism_id：</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/T82.jpg" alt="messages" data-proofer-ignore></p><li><p>COSEM_Cryptographic_Algorithm_Id</p><p>{joint-iso-ccitt(2) country(16) country-name(756) identified-organization(5) DLMS-UA(8) cryptographic-algorithms (3) algorithm_id(x)}</p><p>cryptographic-algorithms和algorithm_id：</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/T84.jpg" alt="messages" data-proofer-ignore></p></ul><h4 id="s943-apdu-encoding-rules"><span class="mr-2">s9.4.3 APDU encoding rules</span><a href="#s943-apdu-encoding-rules" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s9431-encoding-of-the-acse-apdus"><span class="mr-2">s9.4.3.1 Encoding of the ACSE APDUs</span><a href="#s9431-encoding-of-the-acse-apdus" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><code class="language-plaintext highlighter-rouge">ACSE</code> APDUs 编码：<code class="language-plaintext highlighter-rouge">BER</code></p><p><code class="language-plaintext highlighter-rouge">user-information</code>(xDLMS InitiateRequest APDU)内的内容因为是<code class="language-plaintext highlighter-rouge">xDLMS</code>格式的，所以需要用<code class="language-plaintext highlighter-rouge">A-XDR</code>编码</p><h5 id="s9432-encoding-of-the-xdlms-apdus"><span class="mr-2">s9.4.3.2 Encoding of the xDLMS APDUs</span><a href="#s9432-encoding-of-the-xdlms-apdus" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><code class="language-plaintext highlighter-rouge">xDLMS</code> APDUs 编码：<code class="language-plaintext highlighter-rouge">A-XDR</code></p><h5 id="s9433-xml"><span class="mr-2">s9.4.3.3 XML</span><a href="#s9433-xml" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>DataNotification APDU 可以编码为 XML 格式。</p><h4 id="s944-protocol-for-application-association-establishment"><span class="mr-2">s9.4.4 Protocol for application association establishment</span><a href="#s944-protocol-for-application-association-establishment" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s9441-protocol-for-the-establishment-of-confirmed-application-associations"><span class="mr-2">s9.4.4.1 Protocol for the establishment of confirmed application associations</span><a href="#s9441-protocol-for-the-establishment-of-confirmed-application-associations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>client AP 发送<code class="language-plaintext highlighter-rouge">COSEM-OPEN.request</code>原语（Service_Class == Confirmed），client <code class="language-plaintext highlighter-rouge">CF</code>（control function）进入<code class="language-plaintext highlighter-rouge">ASSOCIATION PENDING</code>状态（见 9.4.1），</p><p>然后，<code class="language-plaintext highlighter-rouge">CF</code> 在 <code class="language-plaintext highlighter-rouge">xDLMS ASE</code> 和 <code class="language-plaintext highlighter-rouge">ACSE</code> 的帮助下<code class="language-plaintext highlighter-rouge">组装</code>包含从 AP 接收的 COSEM-OPEN.request 原语参数的 <code class="language-plaintext highlighter-rouge">AARQ APDU</code>，并将其<code class="language-plaintext highlighter-rouge">发送</code>到服务器。</p><blockquote class="prompt-tip"><div><p><code class="language-plaintext highlighter-rouge">xDLMS ASE</code>是 InitiateRequest APDU 打包器（只和 xDLMS 相关，就是 AARQ 中的<code class="language-plaintext highlighter-rouge">user-information</code>），<code class="language-plaintext highlighter-rouge">ACSE</code>是 AARQ APDU 打包器（ACSE 中的<code class="language-plaintext highlighter-rouge">Kernel</code>和<code class="language-plaintext highlighter-rouge">authentication</code> functional 相关的参数,见 9.4.2.1）</p></div></blockquote><p><code class="language-plaintext highlighter-rouge">服务器</code> AL 的 <code class="language-plaintext highlighter-rouge">CF</code> 将收到的 AARQ APDU 提供给 <code class="language-plaintext highlighter-rouge">ACSE</code>, ACSE 提取 <code class="language-plaintext highlighter-rouge">ACSE</code> 相关参数，然后将<code class="language-plaintext highlighter-rouge">控制权</code>交还给 CF。</p><p>然后，<code class="language-plaintext highlighter-rouge">CF</code> 将 AARQ APDU 的用户信息参数的内容（携带 xDLMS InitiateRequest APDU）传递给 <code class="language-plaintext highlighter-rouge">xDLMS ASE</code>,xDLMS ASE 检索此 APDU 的参数，然后将<code class="language-plaintext highlighter-rouge">控制权</code>交还给 CF。</p><p>CF 使用收到的 APDU 参数生成 COSEM-OPEN.indication 给服务器 AP ，并进入“<code class="language-plaintext highlighter-rouge">ASSOCIATION PENDING</code>”状态。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/mscaa.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-tip"><div><p>总结：先 xDLMS ASE 层打包，再 ACSE 层打包，得到 AARQ APDU。AARQ APDU 先 ACSE 层解包，再 xDLMS ASE 层解包</p></div></blockquote><h5 id="s9442-repeated-cosem-open-service-invocations"><span class="mr-2">s9.4.4.2 Repeated COSEM-OPEN service invocations</span><a href="#s9442-repeated-cosem-open-service-invocations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>AA 已经存在时，client AP 发的 COSEM-OPEN.request 直接由 client AL 回应确认</p><h5 id="s9443-establishment-of-unconfirmed-application-associations"><span class="mr-2">s9.4.4.3 Establishment of unconfirmed application associations</span><a href="#s9443-establishment-of-unconfirmed-application-associations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>Service_Class == Unconfirmed</p><p>本地 AL 不等待回应直接回.confirm</p><p>一般用于单向通信或广播</p><p>无需确认 AA 中只能使用无需确认 xDLMS 数据传输服务</p><h5 id="s9444-pre-established-application-associations"><span class="mr-2">s9.4.4.4 Pre-established application associations</span><a href="#s9444-pre-established-application-associations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>无需 AA 建立和释放</p><h4 id="s945-protocol-for-application-association-release"><span class="mr-2">s9.4.5 Protocol for application association release</span><a href="#s945-protocol-for-application-association-release" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><p>优雅 graceful 方式</p><ul><li><p>断开 AL 的支持协议层</p><p>前提是<code class="language-plaintext highlighter-rouge">面向连接</code>的协议层（HDLC,TCP）</p><p>the COSEM-RELEASE，<code class="language-plaintext highlighter-rouge">Use_RLRQ_RLRE</code>参数<code class="language-plaintext highlighter-rouge">不存在</code>或为<code class="language-plaintext highlighter-rouge">FALSE</code>(就是不使用 ACSE 的<code class="language-plaintext highlighter-rouge">A-RELEASE</code>服务，见 9.3.3)</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/releaseaaspl.jpg" alt="messages" data-proofer-ignore></p><li><p>使用 ACSE A-Release 服务</p><p><code class="language-plaintext highlighter-rouge">Use_RLRQ_RLRE</code>参数为<code class="language-plaintext highlighter-rouge">TRUE</code>（就是使用 ACSE 的<code class="language-plaintext highlighter-rouge">A-RELEASE</code>服务），COSEM-RELEASE 服务可以包含<code class="language-plaintext highlighter-rouge">加密的</code>xDLMS InitiateRequest / InitiateResponse 在 RLRQ / RLRE APDUs 的<code class="language-plaintext highlighter-rouge">user-information</code>参数中，从而防止潜在的<code class="language-plaintext highlighter-rouge">拒绝服务攻击</code>(没有保护的话谁都可以断开连接)。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/releaseaa.jpg" alt="messages" data-proofer-ignore></p></ul><li><p>非优雅 Non-graceful 方式</p><p>当 AP 发生意外事件(如检测到物理连接中断)时，检测本地错误，等等</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/phabort.jpg" alt="messages" data-proofer-ignore></p></ul><h4 id="s946-protocol-for-the-data-transfer-services"><span class="mr-2">s9.4.6 Protocol for the data transfer services</span><a href="#s946-protocol-for-the-data-transfer-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s9461-negotiation-of-services-and-options--the-conformance-block"><span class="mr-2">s9.4.6.1 Negotiation of services and options – the conformance block</span><a href="#s9461-negotiation-of-services-and-options--the-conformance-block" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>一致性块，用于协商双方支持的功能</p><p><code class="language-plaintext highlighter-rouge">COSEM-OPEN</code>服务中：xDLMS InitiateRequest APDU 中的<code class="language-plaintext highlighter-rouge">proposed-conformance</code>参数和 xDLMS InitiateResponse APDU 中的<code class="language-plaintext highlighter-rouge">negotiated-conformance</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/conformanceblock.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-tip"><div><p>图中提到了只有 get、set、action 可以配置为使用 block-transfer,应该就是 service-specific block transfer，和 9.4.6.6 ACCESS 服务不支持 service-specific block transfer 相符</p></div></blockquote><h5 id="s9462-confirmed-and-unconfirmed-xdlms-service-invocations"><span class="mr-2">s9.4.6.2 Confirmed and unconfirmed xDLMS service invocations</span><a href="#s9462-confirmed-and-unconfirmed-xdlms-service-invocations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><ul><li><p>client 发起：</p><ul><li><p>在<code class="language-plaintext highlighter-rouge">confirmed</code>的 AAs 中</p><p>可以以 confirmed or unconfirmed 的方式调用 xDLMS 服务。</p><li><p>在<code class="language-plaintext highlighter-rouge">unconfirmed</code>的 AAs 中</p><p>只能以 unconfirmed 的方式调用 xDLMS 服务。这样，在多播 和/或 广播的情况下，由于潜在的<code class="language-plaintext highlighter-rouge">多重响应</code>而产生的<code class="language-plaintext highlighter-rouge">冲突</code>可以避免。</p><p><code class="language-plaintext highlighter-rouge">unconfirmed</code> xDLMS services 三种<code class="language-plaintext highlighter-rouge">目的地址</code>：</p><ul><li>单个地址<li>组地址<li>广播地址</ul></ul><p>如果 AA 没建立，服务端会丢弃 unconfirmed 请求。</p><li><p>服务端发起：</p><p>unsolicited services：</p><ul><li><p>InformationReport;</p><p>只能以 unconfirmed 方式调用</p><li><p>EventNotification;</p><p>只能以 unconfirmed 方式调用</p><li><p>DataNotification.</p><p>1)unconfirmed，支持协议层失败重试; 2)unconfirmed，丢失支持协议层确认重试; 3)confirmed，丢失确认重试</p><p>详见 9.4.6.7</p></ul></ul><h5 id="s9463-protocol-for-the-get-service"><span class="mr-2">s9.4.6.3 Protocol for the GET service</span><a href="#s9463-protocol-for-the-get-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>有多个属性的情况下，每个属性都要回对应的 Data 或 Data_Access_Result</p><p>通过<code class="language-plaintext highlighter-rouge">conformance block</code>协商在<code class="language-plaintext highlighter-rouge">APDU过长</code>时是否使用<code class="language-plaintext highlighter-rouge">GBT</code>或<code class="language-plaintext highlighter-rouge">service-specific block transfer</code></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/getprotocol.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/getprotoblock.jpg" alt="messages" data-proofer-ignore></p><p>结合 9.3.6 对 GET 的说明，AP 负责 Data 的<code class="language-plaintext highlighter-rouge">编解码</code>，同时可以对<code class="language-plaintext highlighter-rouge">Data进行分块</code>，也就是 service-specific block transfer 的基础。其中分块可以是<code class="language-plaintext highlighter-rouge">按字节</code>不按逻辑分，也可以<code class="language-plaintext highlighter-rouge">按逻辑</code>分(每块都能自解析)。这样的话服务端就可以<code class="language-plaintext highlighter-rouge">分段生成回复</code>，对于已经发送的块可以释放内存，<code class="language-plaintext highlighter-rouge">减少内存占用</code></p><ul><li><p>发送接收流程：</p><p>第一个.response 的 DataBlock_G(见 9.3.7)：</p><ul><li>Last_Block == FALSE;<li>Block_Number == 1;<li>Result (Raw_Data) == the first K bytes of the encoded data: B1, B2, B3,…., BK.</ul><p>客户端 AP 继续发送 GET-REQUEST-NEXT,<code class="language-plaintext highlighter-rouge">Block_Number</code>和<code class="language-plaintext highlighter-rouge">上一次</code>接受到的回复<code class="language-plaintext highlighter-rouge">相同</code>，也就是 1（可以理解为客户端确认序号，表示 1 已确认）。服务端 AP 收到请求后继续发 Block_Number 为 2 的块</p><li><p>各种错误处理</p></ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/getprotolongerror.jpg" alt="messages" data-proofer-ignore></p><p>NEXT 请求序号与上一条回应序号不匹配</p><h5 id="s9464-protocol-for-the-set-service"><span class="mr-2">s9.4.6.4 Protocol for the SET service</span><a href="#s9464-protocol-for-the-set-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>类似 GET</p><p>即使分包，每一包的 Invoke_Id 和 Priority 必须是一样的，因为是同一个请求</p><p>多了 ACK-BLOCK，用于中间块的接收响应</p><p>各种错误处理</p><h5 id="s9465-protocol-for-the-action-service"><span class="mr-2">s9.4.6.5 Protocol for the ACTION service</span><a href="#s9465-protocol-for-the-action-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>请求响应都能分包，请求发完，再由响应分包。</p><h5 id="s9466-protocol-for-the-access-service"><span class="mr-2">s9.4.6.6 Protocol for the ACCESS service</span><a href="#s9466-protocol-for-the-access-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><blockquote class="prompt-warning"><div><p>TODO:ACCESS 是不支持 service-specific block transfer 吗，文中只给了 GBT 的例子，没有 更新：见 9.4.6.1，一致性块不包含，不支持</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/accessprotogbt.jpg" alt="messages" data-proofer-ignore></p><p>图中的 FIRST 和 LAST 应该是<code class="language-plaintext highlighter-rouge">partial service invocations</code>部分服务调用（FIRST-PART,LAST-PART），不是 service-specific block transfer</p><blockquote class="prompt-warning"><div><p>TODO:在这个例子中为什么客户端 AL 可以在不知道对方接收窗口的情况下发送 W=3 的 GBT，如果按照 AL 层的 GBT 参数必须由 AP 提供来看应该是错误的 更新：图片前有条件说明，Both parties know a priori that the other party supports streaming with window size = 3,已经知道是三个包</p></div></blockquote><blockquote class="prompt-tip"><div><p>有个要注意的是对于<code class="language-plaintext highlighter-rouge">GET\SET\ACTION\ACCESS</code>,<code class="language-plaintext highlighter-rouge">客户端</code>总是作为<code class="language-plaintext highlighter-rouge">主动方</code>，也就是管理重发的角色。服务端发出去的都不需要客户端回确认，超时也不重发</p></div></blockquote><h5 id="s9467-protocol-of-the-datanotification-service"><span class="mr-2">s9.4.6.7 Protocol of the DataNotification service</span><a href="#s9467-protocol-of-the-datanotification-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>可以使用<code class="language-plaintext highlighter-rouge">partial service invocations</code></p><p>可以使用 GBT</p><p>DataNotification.request 原语的<code class="language-plaintext highlighter-rouge">Service_Class</code>参数：</p><ul><li><p>unconfirmed，支持协议层回错误（及时）时重发</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/datanotimsc.jpg" alt="messages" data-proofer-ignore></p><li><p>unconfirmed，支持协议层超时未回应时重发</p><p>AP 超时未收到回应直接进重发模式，开始重发等待，此时支持协议层返回的信息都忽略，不管成功还是失败，</p><li><p>confirmed，未收到确认超时时重发</p><p>总是忽视本地确认，未收到远程 AP 确认前总是重发</p></ul><h5 id="s9468-protocol-for-the-eventnotification-service"><span class="mr-2">s9.4.6.8 Protocol for the EventNotification service</span><a href="#s9468-protocol-for-the-eventnotification-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>详见 10</p><h5 id="s9469-protocol-for-the-read-service"><span class="mr-2">s9.4.6.9 Protocol for the Read service</span><a href="#s9469-protocol-for-the-read-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h5 id="s94610-protocol-for-the-write-service"><span class="mr-2">s9.4.6.10 Protocol for the Write service</span><a href="#s94610-protocol-for-the-write-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h5 id="s94611-protocol-for-the-unconfirmedwrite-service"><span class="mr-2">s9.4.6.11 Protocol for the UnconfirmedWrite service</span><a href="#s94611-protocol-for-the-unconfirmedwrite-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><h5 id="s94612-protocol-for-the-informationreport-service"><span class="mr-2">s9.4.6.12 Protocol for the InformationReport service</span><a href="#s94612-protocol-for-the-informationreport-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>SN 相关的跳过</p><h5 id="s94613-protocol-of-general-block-transfer-mechanism"><span class="mr-2">s9.4.6.13 Protocol of general block transfer mechanism</span><a href="#s94613-protocol-of-general-block-transfer-mechanism" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><code class="language-plaintext highlighter-rouge">block transfer块传输总结</code>：</p><ol><li>Partial service invocations，9.3.5<li>service-specific block transfer，9.3.5，一般用于每包都独立，可以自解析的情况<li>general block transfer，由 AP 提供窗口和流参数，但如果没有参数会不会也触发 GBT 有待讨论.AA 握手时 AL 会保存相关参数，见 9.3.2.2 table 54</ol><p>由 AL 层实现，使用<code class="language-plaintext highlighter-rouge">General-Block-Transfer (GBT) xDLMS APDUs</code>传输<code class="language-plaintext highlighter-rouge">任意长度APDUs</code></p><p>AL 收到 AP 层.request / .response 服务原语：</p><ul><li>打包 APDU<li>根据 Security_Options 打包加密 APDU<li>如果大于协商的最大 APDU 大小，使用 GBT 分包</ul><blockquote class="prompt-tip"><div><p>区别于 AP 层的<code class="language-plaintext highlighter-rouge">partial service invocations部分服务调用</code>(9.3.5)，这个<code class="language-plaintext highlighter-rouge">GBT</code>是针对 APDU 的，两者没有直接关系</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/partialandgbt.jpg" alt="messages" data-proofer-ignore></p><p>原语参数：</p><ul><li><p>Block_Transfer_Streaming (<code class="language-plaintext highlighter-rouge">BTS</code>):用于 AP 指示 AL 是否可以用<code class="language-plaintext highlighter-rouge">流方式</code>(窗口)发送，（窗口的意思就是每发若干个包确认一次，结合 BTW 若为 0，表示无需确认，若为 1，表示 1 个包确认一次）</p><li><p>Block_Transfer_Window (<code class="language-plaintext highlighter-rouge">BTW</code>)：用于 AP 指示 AL<code class="language-plaintext highlighter-rouge">最大流窗口大小</code>，但最终由 AL 决定，AL 可以设置的很小用于传输丢失包。</p></ul><p><code class="language-plaintext highlighter-rouge">unconfirmed services</code>固定 Block_Transfer_Streaming 为<code class="language-plaintext highlighter-rouge">FALSE</code>，以及 Block_Transfer_Window 为<code class="language-plaintext highlighter-rouge">0</code>.类似 UDP，可以尽可能的发，无需对方 AL 层确认</p><p>GBT APDU 字段：</p><ul><li>the last-block (<code class="language-plaintext highlighter-rouge">LB</code>) ：是(LB = TRUE(1))否最后一包<li>streaming(<code class="language-plaintext highlighter-rouge">STR</code>) :对于一个窗口，在过程中(STR = TRUE(1))还是已结束(STR = FALSE(0)，一个窗口内的<code class="language-plaintext highlighter-rouge">最后一包</code>)。如果是已结束，需要<code class="language-plaintext highlighter-rouge">对方</code>回个<code class="language-plaintext highlighter-rouge">确认</code>，这个确认是对这个窗口的，如果是完整 APDU 的最后一包则<code class="language-plaintext highlighter-rouge">不回</code>(<code class="language-plaintext highlighter-rouge">最后一个窗口不确认</code>)<blockquote class="prompt-warning"><div><p>TODO:怎么判断收全了 更新：通过发送权思路，就是谁是主动方，谁负责报文的送达确认，这里接受方是主动方，如果没收全，会在超时时重发请求，发送端无需保证自己的报文送达</p></div></blockquote><li><code class="language-plaintext highlighter-rouge">window</code>：发送该 APDU 的一方的<code class="language-plaintext highlighter-rouge">接收窗口大小</code>，发送<code class="language-plaintext highlighter-rouge">unconfirmed services</code>时为 0<li><p>block-number (<code class="language-plaintext highlighter-rouge">BN</code>)：<code class="language-plaintext highlighter-rouge">block序号</code>，第一个为 1</p><blockquote class="prompt-warning"><div><p>TODO:具体什么时候开始重新计数 更新：应该是last-block的时候，也就是一个完整的APDU发送完成后</p></div></blockquote><li>block-number-acknowledged (<code class="language-plaintext highlighter-rouge">BNA</code>)：<code class="language-plaintext highlighter-rouge">被确认</code>块号，最后一个<code class="language-plaintext highlighter-rouge">连续的</code>被确认的块的<code class="language-plaintext highlighter-rouge">块号</code>（这个块之前的所有块也要已经被确认。这个是用于指示对方发送的块的确认，表明自己已确认）<li>block-data (<code class="language-plaintext highlighter-rouge">BD</code>):数据域，xDLMS APDU 的一部分</ul><h6 id="s946132-the-gbt-procedure">s9.4.6.13.2 The GBT procedure</h6><p><code class="language-plaintext highlighter-rouge">Send Queue SQ</code>： :发送队列，对于 block :每收到<code class="language-plaintext highlighter-rouge">AP调用原语</code>，(和 partial service invocations 无关，不管 Invocation_Type 参数为 COMPLETE, FIRST-PART, ONE-PART or LAST-PART 等)，就分成一个或多个 blocks 放进 SQ 中 :对于 SQ 内 blocks 的发送是个流过程（TODO:意思是不是已经和调用原语无关了 更新：与调用原语无关，也就是和 partial service invocations 无关）</p><p><code class="language-plaintext highlighter-rouge">Receive Queue RQ</code> :接收队列，对于 block</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/gbtprocedure.jpg" alt="messages" data-proofer-ignore></p><h6 id="s946133-gbt-procedure-state-variables">s9.4.6.13.3 GBT procedure state variables</h6><p><img data-src="/assets/img/2022-03-17-dlms-green-1/gbtprocedurestate.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/gbtprocedurestate2.jpg" alt="messages" data-proofer-ignore></p><ul><li><code class="language-plaintext highlighter-rouge">Gr</code>: 接收到的<code class="language-plaintext highlighter-rouge">对方参数</code><li><code class="language-plaintext highlighter-rouge">Gs</code>: 发送的<code class="language-plaintext highlighter-rouge">自己的参数</code><li><code class="language-plaintext highlighter-rouge">BNApeer</code>：自己的发送被对方确认的数量，（被 Gr.BNA 修改）<li><code class="language-plaintext highlighter-rouge">BNAself</code>：对方的发送被自己确认的数量，（发给对方）<li><code class="language-plaintext highlighter-rouge">NextBN</code>：自己 SQ 发送队列的下个插入序号，（插入 SQ 时递增）<li><code class="language-plaintext highlighter-rouge">STRpeer</code>：对方是否支持 GBT 流，（被 Gr.STR 修改）<li><code class="language-plaintext highlighter-rouge">STRself</code>：自己是否支持 GBT 流，（被本地 AP 修改）<li><code class="language-plaintext highlighter-rouge">Wpeer</code>：对方接收窗口大小，（被 Gr.W 修改）<li><code class="language-plaintext highlighter-rouge">Wself</code>：自己接收窗口的大小，（被本地 AP 修改）</ul><blockquote class="prompt-warning"><div><p>TODO:其中 Wself 有默认值，是不是不需要 AP 提供，也可以有默认值 更新：有默认值的参数不需要 AP 提供也能使用，初始值就是默认值</p></div></blockquote><p>子过程：</p><ul><li><p><strong>9.4.6.13.4 Send GBT APDU stream</strong></p><ul><li><p>Confirmed GBT stream send</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/sendgbtapdustream.jpg" alt="messages" data-proofer-ignore></p><p>AP 调用原语参数<code class="language-plaintext highlighter-rouge">BTW</code>要大于 0，SQ 为空时填充一个空的 block,NextBN 递增</p><ul><li><p>9.4.6.13.4.3.2 Last block management</p><p>最后一包管理。</p><ul><li><p>client-server services</p><p>客户端发送请求，LB=0，直到最后一包，LB=1。此时SQ应该空了，如果收到服务端响应，需要向SQ填充空的确认包，再发送，LB=1，如此重复。</p><p>服务端发送的LB=0，直到收到客户端LB=1的包（请求发完后以及确认包的LB都为1）且是服务端的最后一包，LB=1。也就是说在响应请求的确认包LB都为0。印证了Figure 141中空的确认包的LB可以为0或1。</p><li><p>unsolicited, confirmed service</p><p>需确认的上报</p><p>服务端发送上报LB=0直到最后一包LB=1（因为服务端不需要对客户端的响应做确认）</p><p>客户端发送确认和响应都是LB=0，直到收到服务端LB=1且是客户端的最后一包</p></ul></ul><blockquote class="prompt-warning"><div><p>TODO:9.4.6.13.4.3.1 If the SQ is empty, an empty block is added to the SQ and Nex tBN is incremented.为什么要加入空的 block,这个空的好像是确认包 更新：9.4.6.13.4.3.2 Last block management中提到了如果客户端把请求的APDU全发完了，那发送队列就空了，这时候还需要对服务端的响应回确认，所以还需要空的block。或者当服务端在接收请求回确认时SQ也是空的，需要填充确认包</p></div></blockquote><p>Gs.LB = B.LB, Gs.STR = STRself, Gs.W = Wself, Gs.BN = B.BN, Gs.BNA = BNAself and Gs.BD = B.BD</p><p>每个窗口最后一包以及LB=1时的包的Gs.STR都为0</p><p>被确认后才能从 SQ 删除，最后一包不需要对方确认，所以不能直接从 SQ 中删除。</p><blockquote class="prompt-warning"><div><p>TODO:应该什么时候删除，文中也没说，是否是超时</p></div></blockquote><li><p>Unconfirmed GBT send</p><p>AP 调用原语参数<code class="language-plaintext highlighter-rouge">BTW</code>要等于 0</p><p>全部发完就清空 SQ，不用确认</p></ul><li><p><strong>9.4.6.13.5 Process GBT APDU sub-procedure</strong></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/processgbt.jpg" alt="messages" data-proofer-ignore></p><p>这个过程是接收一个窗口的过程</p><ol><li>判断GBT APDU是否被对方拒绝（是不是表明参数不合理）<li>如果收到的是Gr.BN=1且Gr.BNA=0，表示是初始化包，是由对方发起的GBT过程，需要初始化（是不是就是向AP请求参数）<li>是否是confirmed service</ol><ul><li><p>9.4.6.13.5.2 Processing GBT APDUs in a confirmed GBT procedure</p><ol><li>判断合法性后将B放入RQ接收队列<li>配置窗口和对方确认序号，Wpeer = Gr.W, BNApeer = Gr.BNA<li>清空确认序号之前的SQ发送队列数据(已经确认)<li>RQ内数量是否等于BTW（BTW是AP给的接收窗口大小上限，相等说明一个窗口满了），是的话说明一个窗口接收结束，否的话说明还有后续block<li>判断STRpeer，如果为0表示即使没有到窗口上限，该（流）窗口也结束了，为1表示该窗口还有后续block<li>（一个窗口结束需要回确认）</ol><p>RQ中的报文回给AP，需要调用<code class="language-plaintext highlighter-rouge">Check RQ and fill gaps sub-procedure</code>.</p><li><p>9.4.6.13.5.3 Processing GBT APDUs in an unconfirmed GBT procedure</p><ol><li>判断合法性后将B放入RQ接收队列<li>如果达到RQ上限，则结束（虽然没有窗口的概念，但RQ也有上限，达到上限强制中断）<li>如果是最后一包LB=1则结束，如果不是则等待下一包</ol><blockquote><p>如果在结束后收到新的包，将视为overflow，直接丢弃，本次结果回给AP层后，清空RQ，本次GBT结束</p></blockquote></ul><li><p><strong>9.4.6.13.6 Check RQ and fill gaps</strong></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/checkrqandfile.jpg" alt="messages" data-proofer-ignore></p><ul><li><p>9.4.6.13.6.2 Confirmed GBT procedure</p><ol><li>RQ为空时全部重传，Wself（接收窗口大小）设置为BTW也就是最大窗口<li>RQ不为空时检查gaps，为空时表示无需重传，BNAself(己方确认)设置为B.BN(确认最后一包);不为空时表示还有需要重传的，此时Wself应设置为小于等于要重传的第一个gap大小（比如只丢了一个包或者说第一个gap只需要重传一个包，就重传一个包，接收窗口设为1就行，这样只要提供起始序号和窗口大小，对方就知道要补几个包了），开始请求重传。</ol><blockquote class="prompt-tip"><div><p><code class="language-plaintext highlighter-rouge">gap</code>可以理解为一个连续的丢包块</p><p>比如1x2x3√4x5√6√7√</p><p>第一个gap大小就是2，第二个gap大小就是1</p></div></blockquote><li><p>9.4.6.13.6.3 Unconfirmed GBT procedure</p><p>没有重传机制，没收全就是失败。</p></ul></ul><h6 id="s946137-gbt-protocol-examples">s9.4.6.13.7 GBT protocol examples</h6><p><img data-src="/assets/img/2022-03-17-dlms-green-1/getwithgbt.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-warning"><div><p>TODO:图里的 GET.cnf NORMAL(FIRST-PART)是否是一种 AL 向 AP 请求 GBT 参数的机制，前提是 AL 不知道相关的参数，所以 GET.req NORMAL(COMPLETE)其实是个空的报文？结合 9.3.5 Additional service parameters，这个参数是否应该在这个原语里携带。更新：the client AP invokes a GET.request NORMAL service primitive, without additional service parameters. The client AL sends the request in a Get-Request-Normal APDU 明确提到了 GET 相关原语可以携带 Additional service parameters</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/getservicewithpartial.jpg" alt="messages" data-proofer-ignore></p><p>可以只补单个包，此时请求的 W 置 1，BNA 置 3，表示窗口大小变为 1，就是单个确认。然后 BNA 为 3 表示让对方补第 4 个包。</p><blockquote class="prompt-warning"><div><p>TODO:如果 4、5 两包都丢了，是不是就是先补 4，再补 5，不会两包一起补。更新：如果 4、5 丢了，就 W 置 2，BNA 置 3，可以表示丢了连续的两个包</p></div></blockquote><p>如果是最后一包 LB=1 的丢了，由客户端请求这一包</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/setgbt.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/actionlistgbt.jpg" alt="messages" data-proofer-ignore></p><blockquote class="prompt-warning"><div><p>TODO:为什么 Action-Request-With-List 收到一半，服务端就可以回 Action-Response-With-List 更新：应该是一个错误，没有收全时是无法回复完整的，这里回个确认（空 BD）比较合理</p></div></blockquote><p><img data-src="/assets/img/2022-03-17-dlms-green-1/unconfirmeddatanoti.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/confirmeddatanoti.jpg" alt="messages" data-proofer-ignore></p><h6 id="s946138-aborting-the-gbt-procedure">s9.4.6.13.8 Aborting the GBT procedure</h6><p>终止条件：</p><ol><li>an ABORT GBT APDU with LB = 1, STR = FALSE, <code class="language-plaintext highlighter-rouge">BN = 0</code> and BNA = 0;<li>开始新的 GBT 过程。收到 BN = 1 and BNA = 0;<li>收到 APDU 而不是 GBT<li>confirmed 服务超时未收到确认</ol><h5 id="s94614-protocol-of-exception-mechanism"><span class="mr-2">s9.4.6.14 Protocol of exception mechanism</span><a href="#s94614-protocol-of-exception-mechanism" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>exception-response APDU 回应 GET, SET, ACTION and ACCESS services 表示无法处理的错误</p><blockquote class="prompt-warning"><div><p>TODO:错误是 AL 层直接打包还是 AP 层来通知的 更新：结合上下文，是 AL 层生成的</p></div></blockquote><h3 id="s95-abstract-syntax-of-cosem-pdus"><span class="mr-2">s9.5 Abstract syntax of COSEM PDUs</span><a href="#s95-abstract-syntax-of-cosem-pdus" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><a href="/assets/doc/2022-03-17-dlms-green-1/COSEMpdu_GB83.asn">asn.1 格式描述文档</a></p><p><a href="/assets/doc/2022-03-17-dlms-green-1/COSEMpdu_GB83asn.pdf">pdf 格式</a></p><h3 id="s96-cosem-pdu-xml-schema"><span class="mr-2">s9.6 COSEM PDU XML schema</span><a href="#s96-cosem-pdu-xml-schema" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><a href="/assets/doc/2022-03-17-dlms-green-1/COSEMpdu_GB83.xsd">xml 格式描述文档</a></p><h2 id="s10-using-the-dlmscosem-application-layer-in-various-communications-profiles"><span class="mr-2">s10 Using the DLMS/COSEM application layer in various communications profiles</span><a href="#s10-using-the-dlmscosem-application-layer-in-various-communications-profiles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s101-communication-profile-specific-elements"><span class="mr-2">s10.1 Communication profile specific elements</span><a href="#s101-communication-profile-specific-elements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>在 DLMS/COSEM 中，只有<code class="language-plaintext highlighter-rouge">COSEM-OPEN</code>服务具有特定的通信配置文件<code class="language-plaintext highlighter-rouge">参数</code>。它们的值和用途被定义为通信概要文件规范的一部分。</p><h3 id="s102-the-3-layer-connection-oriented-hdlc-based-ommunication-profile"><span class="mr-2">s10.2 The 3-layer, connection-oriented, HDLC based ommunication profile</span><a href="#s102-the-3-layer-connection-oriented-hdlc-based-ommunication-profile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s1022-the-structure-of-the-profile"><span class="mr-2">s10.2.2 The structure of the profile</span><a href="#s1022-the-structure-of-the-profile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>应用层：DLMS/COSEM AL，章节 9<li>链路层：基于 HDLC 标准的，章节 8<li>物理层： 章节 5，光口和本地回环物理接口见章节 6</ul><h4 id="s1023-identification-and-addressing-scheme"><span class="mr-2">s10.2.3 Identification and addressing scheme</span><a href="#s1023-identification-and-addressing-scheme" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>Data Link SAP-s 提供服务给 AL</p><p>客户端：只要定义客户端 AP，物理地址由 PhL 层填充</p><p>服务端：因为多点网络寻址的原因，所以目的地址需要物理设备地址加上逻辑设备地址。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/hdlcprofile.jpg" alt="messages" data-proofer-ignore></p><p>例子：Client_01 (HDLC address = 16) and Server 2 in Host Device 02 (HDLC address = 2392)，客户端地址为 16，服务端地址为 2392，23 为 upper 地址，92 为 lower 地址</p><h4 id="s1024-supporting-protocol-layer-services-and-service-mapping"><span class="mr-2">s10.2.4 Supporting protocol layer services and service mapping</span><a href="#s1024-supporting-protocol-layer-services-and-service-mapping" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>DL 层连接管理<li>面向连接数据传输<li>无连接数据传输</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/datalinksummary.jpg" alt="messages" data-proofer-ignore></p><p>DL-CONNECT 和 DL-DISCONNECT 也是由 AL 管理的，用于 AL 在收到 COSEM-OPEN.request 调用时开启 DL 连接，PhL 层的连接是 AP 管理的，不是 DL 层管理的</p><h4 id="s1025-communication-profile-specific-service-parameters-of-the-dlmscosem-al-services"><span class="mr-2">s10.2.5 Communication profile specific service parameters of the DLMS/COSEM AL services</span><a href="#s1025-communication-profile-specific-service-parameters-of-the-dlmscosem-al-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>COSEM-OPEN 携带 Communication profile 的参数</p><ul><li>Protocol (Profile) Identifier 3-Layer, connection-oriented, HDLC based;<li>Server_Lower_MAC_Address (COSEM Physical Device Address);<li>Server_Upper_MAC_Address (COSEM Logical Device Address);<li>Client_MAC_Address;<li>Server_LLC_Address;<li>Client_LLC_Address.</ul><blockquote class="prompt-tip"><div><p>也就是 HDLC 及 PhL 的地址也是 AP 管理的</p></div></blockquote><h4 id="s1026-specific-considerations--constraints"><span class="mr-2">s10.2.6 Specific considerations / constraints</span><a href="#s1026-specific-considerations--constraints" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="s10261-confirmed-and-unconfirmed-aas-and-data-transfer-service-invocations-frame-types-used"><span class="mr-2">s10.2.6.1 Confirmed and unconfirmed AAs and data transfer service invocations, frame types used</span><a href="#s10261-confirmed-and-unconfirmed-aas-and-data-transfer-service-invocations-frame-types-used" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/aahdlcprofile.jpg" alt="messages" data-proofer-ignore></p><p>Confirmed AARQ 用 I 帧携带</p><p>Unconfirmed AARQ 用 UI 帧携带</p><p>当通过网关访问服务端时，COSEM APDUs 总是使用<code class="language-plaintext highlighter-rouge">I帧</code>携带，包括 Unconfirmed 的 APDU 也是，此时服务端必须通过 xDLMS InitiateRequest APDU 的<code class="language-plaintext highlighter-rouge">response-allowed</code>（见 9.4.2.1）或 Invoke-Id-And-Priority / Long-Invoke-Id-And-Priority 的<code class="language-plaintext highlighter-rouge">service-class</code> bit（用于指示是否为 confirmed 见 381 页）判断请求是否是 Unconfirmed,</p><h5 id="s10262-correspondence-between-aas-and-data-link-layer-connections-releasing-aas"><span class="mr-2">s10.2.6.2 Correspondence between AAs and data link layer connections, releasing AAs</span><a href="#s10262-correspondence-between-aas-and-data-link-layer-connections-releasing-aas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><code class="language-plaintext highlighter-rouge">释放AA连接</code>的方式是<code class="language-plaintext highlighter-rouge">A-RELEASE服务</code>或<code class="language-plaintext highlighter-rouge">断开支持层连接</code>，因为本配置文件不需要任何下层连接，所以断开支持层连接方式不可用，如果 A-RELEASE 服务也不支持，就没有别的方式释放连接</p><h5 id="s10263-service-parameters-of-the-cosem-open---release---abort-services"><span class="mr-2">s10.2.6.3 Service parameters of the COSEM-OPEN / -RELEASE / -ABORT services</span><a href="#s10263-service-parameters-of-the-cosem-open---release---abort-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>由于<code class="language-plaintext highlighter-rouge">SNRM</code>和<code class="language-plaintext highlighter-rouge">DISC</code>可以透明传输高层参数，COSEM-OPEN 和 COSEM-RELEASE 中的<code class="language-plaintext highlighter-rouge">User_Information</code>将会可用</p><h5 id="s10264-eventnotification-service-and-protocol"><span class="mr-2">s10.2.6.4 EventNotification service and protocol</span><a href="#s10264-eventnotification-service-and-protocol" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>事件上报时，服务端角色为 Management Logical Device（upper HDLC 地址 0x01）,客户端角色为 Management AP（upper HDLC 地址 0x01）</p><p>使用 UI 帧发送，发送机会在 8.4.5.4.7 说明了</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/eventnotificationtrigger.jpg" alt="messages" data-proofer-ignore></p><p>当<code class="language-plaintext highlighter-rouge">客户端</code>检测到一个成功的<code class="language-plaintext highlighter-rouge">物理连接建立</code>——并且没有其他原因接收一个传入的调用——它就<code class="language-plaintext highlighter-rouge">假定</code>这个调用是由打算发送<code class="language-plaintext highlighter-rouge">事件通知</code>请求 APDU 的服务器发起的。</p><p>客户端必须首先使用第 5 章中描述的<code class="language-plaintext highlighter-rouge">可选协议识别服务</code>读取通信协议栈</p><p>客户端发起 TriggerEventNotificationSending .request 原语，发送 UI 帧交出发送权，此时服务端才能上报</p><h5 id="s10265-transporting-long-messages"><span class="mr-2">s10.2.6.5 Transporting long messages</span><a href="#s10265-transporting-long-messages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>使用 I_FRAGMENT，传输长消息，见 8.4.5.4.5</p><h5 id="s10266-supporting-multi-drop-configurations"><span class="mr-2">s10.2.6.6 Supporting multi-drop configurations</span><a href="#s10266-supporting-multi-drop-configurations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><img data-src="/assets/img/2022-03-17-dlms-green-1/multidropconfi.jpg" alt="messages" data-proofer-ignore></p><p>可以视为逻辑总线</p><p>冲突避免一般使用主从模型，由主站控制发送权限</p><p>上报时可能多个设备同时上报，需要解决两个问题：</p><ul><li>总线上的冲突，冲突在物理层体现，由厂家解决（可以用 CSMA 之类的）<li>客户端不知道需要上报服务端的物理地址时，目的地址可以使用 CALLING Physical Device Address（只有要上报的客户端才会接受这个地址）</ul><h3 id="s103-the-tcp-udpip-based-communication-profiles-cosem_on_ip"><span class="mr-2">s10.3 The TCP-UDP/IP based communication profiles (COSEM_on_IP)</span><a href="#s103-the-tcp-udpip-based-communication-profiles-cosem_on_ip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>COSEM 物理设备通过 IP 地址唯一标识，区别于 HDLC 地址。逻辑设备 AP 识别需要额外的地址，由 wrap 层提供，wPort。AL 只监听一个 TCP/UDP 端口。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpprofile.jpg" alt="messages" data-proofer-ignore></p><p>TCP TL 层提供的服务：</p><ul><li><p>TCP connection manager AP:</p><ul><li>TCP-CONNECT.request, .indication, .response, .confirm;<li>TCP-DISCONNECT.request, .indication, .response, .confirm;</ul><li><p>DLMS/COSEM AL:</p><ul><li>TCP-DATA .request, .indication, (. confirm).</ul></ul><p>UDP TL 层提供的服务：</p><ul><li><p>DLMS/COSEM AL:</p><ul><li>UDP-DATA .request, .indication, (.confirm)</ul></ul><p>TCP 连接的建立是独立于 DLMS/COSEM AP 的。</p><p>AP 能够在 COSEM-OPEN 前向 TCP 管理 AP 获取参数</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpudplayerservice.jpg" alt="messages" data-proofer-ignore></p><p>Protocol_Connection_Parameters：</p><ul><li>Protocol (Profile) Identifier – TCP/IP or UDP/IP;<li>Server_IP_Address – COSEM Physical Device Address;<li>Server_TCP_or_UDP_Port – The TCP or UDP port used for DLMS/COSEM, see 7.2;<li>Server_Wrapper_Port – COSEM Logical Device Address;<li>Client_IP_Address – COSEM Client’s Physical Device Address;<li>Client_TCP_or_UDP_Port – The TCP or UDP port used for DLMS/COSEM, see 7.2;<li>Client_Wrapper_Port – COSEM application process (type) identifier.</ul><h4 id="s1036-specific-considerations--constraints"><span class="mr-2">s10.3.6 Specific considerations / constraints</span><a href="#s1036-specific-considerations--constraints" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/tcpudpprofile.jpg" alt="messages" data-proofer-ignore></p><p>TCP 不支持使用 Unconfirmed AA,因为 TCP 不支持无连接访问，而 Unconfirmed AA 需要支持在不建立<code class="language-plaintext highlighter-rouge">支持层连接</code>情况下发送数据。两者矛盾</p><p><strong>释放 AA 只能使用 RLRQ/RLRE，不能使用通过断开支持层方式</strong>，因为一个 TCP/UDP 端口<code class="language-plaintext highlighter-rouge">承载所有AA</code>，一旦断开，<code class="language-plaintext highlighter-rouge">所有AA</code>都会断开，必须通过 RLRQ/RLRE 有选择的断开。还有 UDP 是<code class="language-plaintext highlighter-rouge">无连接</code>的，不能通过断开支持层连接<code class="language-plaintext highlighter-rouge">断开</code>AA</p><p>User_Information 不可用</p><h5 id="s10366-transporting-long-messages"><span class="mr-2">s10.3.6.6 Transporting long messages</span><a href="#s10366-transporting-long-messages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p><code class="language-plaintext highlighter-rouge">wrapper层</code>需要包含<code class="language-plaintext highlighter-rouge">完整APDU</code>。如需分块在 AL 层分块。</p><p>（就是 AL 调用 wrapper 服务时不支持分块）</p><h5 id="s10367-allowing-cosem-servers-to-establish-the-tcp-connection"><span class="mr-2">s10.3.6.7 Allowing COSEM servers to establish the TCP connection</span><a href="#s10367-allowing-cosem-servers-to-establish-the-tcp-connection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>服务端发起 TCP 连接，长连接模式，适用于服务端没有公开地址可以连接时。</p><h3 id="s104-the-coap-based-communication-profile-dlmscosem_on_coap"><span class="mr-2">s10.4 The CoAP based communication profile (DLMS/COSEM_on_CoAP)</span><a href="#s104-the-coap-based-communication-profile-dlmscosem_on_coap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapprofile.jpg" alt="messages" data-proofer-ignore></p><p>CoAP 可以提供可靠和不可靠服务</p><p>CoAP 支持<code class="language-plaintext highlighter-rouge">分段</code>，合理分段后就不用<code class="language-plaintext highlighter-rouge">IP层</code>再根据 MTU<code class="language-plaintext highlighter-rouge">分片</code>了，详见文章<a href="https://zhuanlan.zhihu.com/p/378153230">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a>。AL 也支持引用层的分块传输，根据对方 AL 层支持的接收大小 receiver_max_pdu_size</p><blockquote class="prompt-warning"><div><p>TODO:TCP/UDP IP 通信配置里好像没用到 UDP 支持广播的特性，可能是 UDP 广播只能在本地局域网中进行，不能跨路由器进行的原因</p></div></blockquote><h4 id="s1043-identification-and-addressing"><span class="mr-2">s10.4.3 Identification and addressing</span><a href="#s1043-identification-and-addressing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>CoAP URI：Uri-Host + Uri-Port + Uri-Path</p><p>发送端 AL 需要知道对方的<code class="language-plaintext highlighter-rouge">CoAP URI</code>和 SAP，由于 CoAP 封装了 UDP，所以<code class="language-plaintext highlighter-rouge">不需要</code>知道<code class="language-plaintext highlighter-rouge">ip地址和端口</code>，可能会动态变化</p><p>DLMS AE 通过唯一 systemtitle 标识，通过以下方式交换：(TODO:AE 是什么意思)</p><ul><li>在明确建立 AA 的情况下，在 AA 建立期间使用 COSEM-OPEN 服务;<li>通过在“Security setup”对象写入 client_system_title 属性和读取的 server_system_title 属性。适用于预连接 AA<li>加密 APDU 交换，general-ciphering (originator and recipient system title)或 general-glo-ciphering (originator system title).</ul><p>CoAP-DATA 原语需要包含对端的<code class="language-plaintext highlighter-rouge">ip地址</code>和端口，如果 IP 是<code class="language-plaintext highlighter-rouge">静态</code>的，那可以<code class="language-plaintext highlighter-rouge">静态绑定</code>到<code class="language-plaintext highlighter-rouge">system title</code>。如果是<code class="language-plaintext highlighter-rouge">动态</code>的，需要动态更新绑定，可以通过服务端 ip 变更自动推送实现</p><p>当客户端 AL 收到服务端上报 data 时，如果是动态 ip，客户端可以根据 system title 确认身份。</p><h4 id="s1044-supporting-layer-services-and-service-mapping"><span class="mr-2">s10.4.4 Supporting layer services and service mapping</span><a href="#s1044-supporting-layer-services-and-service-mapping" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h4 id="s1046-specific-considerations--constraints"><span class="mr-2">s10.4.6 Specific considerations / constraints</span><a href="#s1046-specific-considerations--constraints" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapaadata1.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/coapaadata2.jpg" alt="messages" data-proofer-ignore></p><p>unconfirmed AA 不能传 confirmed 消息,Reliable 可靠 CoAP 传输层配置不能传输广播消息</p><p>CoAP 传输层无连接，不能通过断开传输层连接断开 AA,只能通过 RLRQ/RLRE 断开</p><h3 id="s108-lpwan-profile"><span class="mr-2">s10.8 LPWAN profile</span><a href="#s108-lpwan-profile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><a href="https://zhuanlan.zhihu.com/p/151780634">什么是 LPWAN？ LPWAN 技术有哪些？</a></p><p><code class="language-plaintext highlighter-rouge">LPWAN</code>(低功耗广域网)，也称为 LPWA)或 LPN，是一种用于物联网(例如，以电池为电源的传感器)的类型，这是一种能够以低比特率进行远距离通信的无线网络。LPWAN 可以同时满足覆盖和续航的要求。以最小的功耗提供最长的距离覆盖是 LPWAN 最大的技术优势。</p><ul><li><code class="language-plaintext highlighter-rouge">NB-IoT</code>是物联网领域的一项新兴技术，支持广域网中低功耗设备的蜂窝数据连接。它也称为低功耗广域网(LPWAN)。NB-IoT 支持设备有效连接，待机时间长，对网络连接要求高。据称，NB-IoT 设备的电池续航时间可以提高到至少 10 年。<li><code class="language-plaintext highlighter-rouge">eMTC</code>作为物联网的一种应用场景。它具有超可靠和低延迟的特点。eMTC 主要应用在设备之间的通信需求上。<li><code class="language-plaintext highlighter-rouge">Lora</code>是一项专有技术， Semtech 为其提供芯片。Lora 技术改变了以往在传输距离和功耗之间的折衷，为用户提供了一个简单的系统，可以实现远距离、长续航、大容量，进而扩展传感器网络。</ul><p><img data-src="/assets/img/2022-03-17-dlms-green-1/lpwanarch.jpg" alt="messages" data-proofer-ignore></p><p>支持层固定使用了 UDP 和 IPV6</p><p>LPWAN 提供了<code class="language-plaintext highlighter-rouge">低层加密</code>和 SCHC<code class="language-plaintext highlighter-rouge">压缩/解压</code>和<code class="language-plaintext highlighter-rouge">分段/重组</code>功能</p><p>可以通过 DLMS/COSEM 对象配置 LPWAN 参数</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/lpwancommprofile.jpg" alt="messages" data-proofer-ignore></p><p>传输层还有 AA 和 UDP 通信配置差不多</p><p>绿皮书没有介绍多少东西，基本都源于 RFC 8376，RFC 8724</p><h3 id="s109-wi-sun-profile"><span class="mr-2">s10.9 Wi-SUN profile</span><a href="#s109-wi-sun-profile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">Wi-SUN Field Area Network</code> (FAN)是一种基于<code class="language-plaintext highlighter-rouge">IEEE 802.15.4</code>的 IPv6 无线网状网络，专为关键基础设施项目设计。每个个人区域网络(PAN)被设计成用一个边界路由器支持数千个路由器设备。一个 FAN 可以由多个 pan 组成，允许单个网络扩展到数百万个设备，见图 196。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/wisunarch.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/wisuncommprofile.jpg" alt="messages" data-proofer-ignore></p><p>支持层固定使用了 UDP 和 IPV6，对传输层来说和 UDP profile 类似，wrapper 和 TCP-UDP/IP profile 相同</p><h3 id="s1010-gateway-protocol"><span class="mr-2">s10.10 Gateway protocol</span><a href="#s1010-gateway-protocol" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-03-17-dlms-green-1/gatewayarch.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/gatewayapdu.jpg" alt="messages" data-proofer-ignore></p><ul><li><p>Header</p><ul><li>0xE6:请求（服务端发起 data notification 也算）<li>0xE7:响应</ul><li><p>Network ID</p><p>目的网络 ID，可以理解为<a href="https://zh.wikipedia.org/zh-cn/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">VLAN</a> ID</p><li><p>Address length L</p><p>目的物理地址长度</p><li><p>Physical device address</p><p>目的物理地址</p></ul><p>只有网关设备处理该报文</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/gatewaypullmessage.jpg" alt="messages" data-proofer-ignore></p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/gatewaypush.jpg" alt="messages" data-proofer-ignore></p><h2 id="s11-aarq-and-aare-encoding-examples"><span class="mr-2">s11 AARQ and AARE encoding examples</span><a href="#s11-aarq-and-aare-encoding-examples" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="s12-encoding-examples-aarq-and-aare-apdus-using-a-ciphered-application-context"><span class="mr-2">s12 Encoding examples: AARQ and AARE APDUs using a ciphered application context</span><a href="#s12-encoding-examples-aarq-and-aare-apdus-using-a-ciphered-application-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="s13-s-fsk-plc-encoding-examples"><span class="mr-2">s13 S-FSK PLC encoding examples</span><a href="#s13-s-fsk-plc-encoding-examples" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="s14-data-transfer-service-examples"><span class="mr-2">s14 Data transfer service examples</span><a href="#s14-data-transfer-service-examples" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s144-profile-generic-ic-buffer-attribute-encoding-examples"><span class="mr-2">s14.4 Profile generic IC buffer attribute encoding examples</span><a href="#s144-profile-generic-ic-buffer-attribute-encoding-examples" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>压缩见蓝皮书4.1.6.3</p><h4 id="s1443-get-response-with-profile-generic-null-data-compressed-encoding-example"><span class="mr-2">s14.4.3 Get-response with Profile generic null-data compressed encoding example</span><a href="#s1443-get-response-with-profile-generic-null-data-compressed-encoding-example" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>profile 支持使用空值 null-data 压缩，支持压缩基本类型数据（除数组结构体）</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/T150.jpg" alt="messages" data-proofer-ignore></p><h4 id="s1444-get-response-with-profile-generic-compact-array-encoding-example"><span class="mr-2">s14.4.4 Get-response with Profile generic compact-array encoding example</span><a href="#s1444-get-response-with-profile-generic-compact-array-encoding-example" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用 compact-array 减少类型描述，也能压缩。</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/T151.jpg" alt="messages" data-proofer-ignore></p><p>compact-array:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="go">compact-array                      [19]  IMPLICIT   SEQUENCE
{
    contents-description                [0]              TypeDescription,
    array-contents                      [1]   IMPLICIT   OCTET STRING
}
</span></pre></table></code></div></div><p>先声明类型，后面的数据就无需类型了，包括结构体和基本类型，后面的数据是 octet string 类型的</p><h4 id="s1445-get-response-with-profile-generic-null-data-and-delta-value-encoding-example"><span class="mr-2">s14.4.5 Get-response with Profile generic null-data and delta-value encoding example</span><a href="#s1445-get-response-with-profile-generic-null-data-and-delta-value-encoding-example" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用递增量压缩，如每次递增 0x29，就使用 1F 类型，值为 29，解压时为上条记录的值加上递增量</p><p><img data-src="/assets/img/2022-03-17-dlms-green-1/T152.jpg" alt="messages" data-proofer-ignore></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%8A%80%E6%9C%AF/'>技术</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/dao/" class="post-tag no-text-decoration" >DAO</a> <a href="/tags/database/" class="post-tag no-text-decoration" >database</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DLMS Green Book学习笔记 - 普通人&amp;url=https://hjk.life/posts/dlms-green-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DLMS Green Book学习笔记 - 普通人&amp;u=https://hjk.life/posts/dlms-green-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://hjk.life/posts/dlms-green-1/&amp;text=DLMS Green Book学习笔记 - 普通人" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=DLMS Green Book学习笔记 - 普通人&amp;url=https://hjk.life/posts/dlms-green-1/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/quantum-platform-1/">《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</a><li><a href="/posts/design-patterns-principles/">软件设计模式——七大设计原则</a><li><a href="/posts/const-c/">C语言中的const</a><li><a href="/posts/c-oop/">面向对象编程(OOP)的C语言实现</a><li><a href="/posts/operating-systems-28/">《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/cpp-dao/"><div class="card-body"> <em class="timeago small" data-ts="1646701200" > 2022-03-08 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++实现的DAO(数据访问对象模式)</h3><div class="text-muted small"><p> 本文将会介绍如何使用 C++实现设计模式中的 DAO(数据访问对象模式) DAO 介绍 什么是 DAO 在计算机软件中，数据访问对象（data access object，DAO）是为某种类型的数据库或其他持久性机制提供一个抽象接口的对象。通过映射应用程序对持久层的调用，DAO 提供一些特定的数据操作，而无需暴露数据库细节。这种隔离支持单一功能原则。 数据访问对象模式（Data Ac...</p></div></div></a></div><div class="card"> <a href="/posts/dlms-blue2/"><div class="card-body"> <em class="timeago small" data-ts="1646701200" > 2022-03-08 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DLMS/COSEM Blue Book学习笔记</h3><div class="text-muted small"><p> s4.1 基本概念 s4.1.2 Referencing methods logical names (LN referencing):The reference for an attribute is: class_id, value of the logical_name attribute, attribute_index.The reference for a method is...</p></div></div></a></div><div class="card"> <a href="/posts/plantuml-vscode/"><div class="card-body"> <em class="timeago small" data-ts="1628038800" > 2021-08-04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>使用PlantUML绘制类图</h3><div class="text-muted small"><p> 本文基于 vscode 的 PlantUML 插件绘制类图。 类的 UML 表示 使用 UML 表示一个类，主要由三部分组成。类名、属性、方法。其中属性和方法的访问修饰符用 - 、# 、+ 表示 private、protected、public。 如图所示，表示A类有一个private属性，protected 构造函数和public方法。 @startuml class A{ ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/operating-systems-7/" class="btn btn-outline-primary" prompt="上一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(七) 调度：比例份额</p></a> <a href="/posts/orangepi4-maintain/" class="btn btn-outline-primary" prompt="下一篇"><p>Orangepi4维护指南</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "ProphetHJK/prophethjk.github.io", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjk1MjU2NjI=", "data-category": "General", "data-category-id": "DIC_kwDOE6Qpns4CPYgF", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/prophethjk">Jinkai</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备20006745号-2</a> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VEN4M3BMXV"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VEN4M3BMXV'); }); </script>
