<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="DLMS/COSEM Blue Book学习笔记" /><meta name="author" content="Jinkai" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="s4.1 基本概念" /><meta property="og:description" content="s4.1 基本概念" /><link rel="canonical" href="https://hjk.life/posts/dlms-blue2/" /><meta property="og:url" content="https://hjk.life/posts/dlms-blue2/" /><meta property="og:site_name" content="普通人" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-08T09:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DLMS/COSEM Blue Book学习笔记" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jinkai" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jinkai"},"dateModified":"2022-09-22T14:40:45+08:00","datePublished":"2022-03-08T09:00:00+08:00","description":"s4.1 基本概念","headline":"DLMS/COSEM Blue Book学习笔记","mainEntityOfPage":{"@type":"WebPage","@id":"https://hjk.life/posts/dlms-blue2/"},"url":"https://hjk.life/posts/dlms-blue2/"}</script><title>DLMS/COSEM Blue Book学习笔记 | 普通人</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="普通人"><meta name="application-name" content="普通人"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/favicons/Humanity.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">普通人</a></div><div class="site-subtitle font-italic">潜龙勿用</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/prophethjk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['prophethjk','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>DLMS/COSEM Blue Book学习笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>DLMS/COSEM Blue Book学习笔记</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/prophethjk">Jinkai</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1646701200" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-03-08 </em> </span> <span> 更新于 <em class="timeago" data-ts="1663828845" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-09-22 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="21781 字"> <em>121 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="s41-基本概念"><span class="mr-2">s4.1 基本概念</span><a href="#s41-基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s412-referencing-methods"><span class="mr-2">s4.1.2 Referencing methods</span><a href="#s412-referencing-methods" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">logical names</code> (<code class="language-plaintext highlighter-rouge">LN</code> referencing):The reference for an <code class="language-plaintext highlighter-rouge">attribute</code> is: <code class="language-plaintext highlighter-rouge">class_id</code>, value of the <code class="language-plaintext highlighter-rouge">logical_name</code> attribute, <code class="language-plaintext highlighter-rouge">attribute_index</code>.The reference for a <code class="language-plaintext highlighter-rouge">method</code> is: <code class="language-plaintext highlighter-rouge">class_id</code>, value of the <code class="language-plaintext highlighter-rouge">logical_name</code> attribute, <code class="language-plaintext highlighter-rouge">method_index</code></p><blockquote class="prompt-tip"><div><p>关于index，<code class="language-plaintext highlighter-rouge">规范</code>内的属性或方法为<code class="language-plaintext highlighter-rouge">1开始</code>的<code class="language-plaintext highlighter-rouge">正数</code>，<code class="language-plaintext highlighter-rouge">专有</code>的属性或方法应该设置为<code class="language-plaintext highlighter-rouge">负数</code></p><p>logical names中的OBIS的每个字段，A,B,C,D,E,F都有各自含义，在blue book1中给出</p></div></blockquote><p><code class="language-plaintext highlighter-rouge">Short names</code>(<code class="language-plaintext highlighter-rouge">SN</code> referencing)：COSEM对象的每个属性和方法都用一个<code class="language-plaintext highlighter-rouge">13位整数</code>标识。短名称的语法与DLMS命名变量名称的语法相同。为了方便使用SN引用访问设备，一些<code class="language-plaintext highlighter-rouge">short_name</code>被保留为特殊COSEM对象的<code class="language-plaintext highlighter-rouge">base_name(objectName)</code>。保留base_names的范围是0xFA00到0xFFF8。这里的<code class="language-plaintext highlighter-rouge">base_name</code>就是cosem类的<code class="language-plaintext highlighter-rouge">不包含偏移</code>的短名，相当于每个类表格中的x，对应每个属性的短名叫short_name，是包含偏移的</p><h3 id="s4146-attributes"><span class="mr-2">s4.1.4.6 Attributes</span><a href="#s4146-attributes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>(dyn.) :对带有流程值的属性进行分类，流程值由<code class="language-plaintext highlighter-rouge">仪表本身更新</code>。</p><p>(static) :对一个属性进行分类，该属性<code class="language-plaintext highlighter-rouge">不会由仪表本身更新</code>(例如<code class="language-plaintext highlighter-rouge">配置数据</code>，<strong>但可通过外部通信方式修改</strong>)。</p><h3 id="s41414-mo"><span class="mr-2">s4.1.4.14 m/o</span><a href="#s41414-mo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>m (mandatory) :The method is mandatory<code class="language-plaintext highlighter-rouge">强制的</code>.</p><p>o (optional) :The method is optional<code class="language-plaintext highlighter-rouge">可选的</code>.</p><h4 id="s41417-selective-access"><span class="mr-2">s4.1.4.17 Selective access</span><a href="#s41417-selective-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>部分属性支持<code class="language-plaintext highlighter-rouge">选择性访问</code></p><ul><li>“<code class="language-plaintext highlighter-rouge">Profile generic</code>” objects, <code class="language-plaintext highlighter-rouge">buffer</code> attribute;<li>“<code class="language-plaintext highlighter-rouge">Association SN</code>” objects, <code class="language-plaintext highlighter-rouge">object_list</code> and <code class="language-plaintext highlighter-rouge">access_rights_list</code> attribute;<li>“<code class="language-plaintext highlighter-rouge">Association LN</code>” objects, <code class="language-plaintext highlighter-rouge">object_list</code> attribute;<li>“<code class="language-plaintext highlighter-rouge">Compact data</code>”, objects, <code class="language-plaintext highlighter-rouge">compact_buffer</code> attribute;<li>“<code class="language-plaintext highlighter-rouge">Push</code>” objects, <code class="language-plaintext highlighter-rouge">push_object_list</code> attribute;<li>“<code class="language-plaintext highlighter-rouge">Data protection</code>” objects, <code class="language-plaintext highlighter-rouge">protection_object_list</code> attribute <code class="language-plaintext highlighter-rouge">get_protected_attributes</code> method and <code class="language-plaintext highlighter-rouge">set_protected_attributes</code> method.</ul><h4 id="s4163-null-data-and-delta-value-encoding"><span class="mr-2">s4.1.6.3 Null-data and delta-value encoding</span><a href="#s4163-null-data-and-delta-value-encoding" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>用于array内<code class="language-plaintext highlighter-rouge">数据压缩</code></p><p><code class="language-plaintext highlighter-rouge">空值</code>表示该值可以从前一条记录中恢复，比如和上一条值相同</p><p><code class="language-plaintext highlighter-rouge">增量值</code>表示该值可以从前一条记录中通过递增方式恢复，第一条值必须是 integer 或 unsigned 类型，后面就可以一条条递增了</p><h3 id="s418-the-cosem-logical-device"><span class="mr-2">s4.1.8 The COSEM logical device</span><a href="#s418-the-cosem-logical-device" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="s4182-cosem-logical-device-name-ldn"><span class="mr-2">s4.1.8.2 COSEM logical device name (LDN)</span><a href="#s4182-cosem-logical-device-name-ldn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>每个COSEM逻辑设备都可以由其唯一的COSEM LDN来标识。LDN定义为最多16个字节的字符串。<code class="language-plaintext highlighter-rouge">前三个字节</code>应携带<code class="language-plaintext highlighter-rouge">制造商标识符</code>。制造商应确保<code class="language-plaintext highlighter-rouge">LDN</code>，从标识制造商的<code class="language-plaintext highlighter-rouge">3个字节开始</code>，<code class="language-plaintext highlighter-rouge">后面是最多13个字节</code>，对每个制造的逻辑设备是<code class="language-plaintext highlighter-rouge">唯一</code>的。</p><h4 id="s4183-the-association-view-of-the-logical-device"><span class="mr-2">s4.1.8.3 The “association view” of the logical device</span><a href="#s4183-the-association-view-of-the-logical-device" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>为了访问服务器中的COSEM对象，首先要与客户端建立应用关联(AA，application association)。AAs标识partners，并描述AA将在其中通信的<code class="language-plaintext highlighter-rouge">上下文</code>。上下文主要内容是:</p><ul><li>the application context;<li>the authentication mechanism;认证机制<li>the xDLMS context.</ul><p>根据客户端和服务器之间建立的AA关系，服务器可能会授予不同的<code class="language-plaintext highlighter-rouge">访问权限</code>。访问权限涉及一组COSEM对象(<code class="language-plaintext highlighter-rouge">可见对象</code>)，这些对象可以在<code class="language-plaintext highlighter-rouge">给定的AA</code>中被访问(“可见”)。此外，对这些COSEM对象的<code class="language-plaintext highlighter-rouge">属性和方法</code>的访问也可能在AA中受到限制(例如，某种类型的客户端<code class="language-plaintext highlighter-rouge">只能读取</code>COSEM对象的<code class="language-plaintext highlighter-rouge">特定属性</code>，但<code class="language-plaintext highlighter-rouge">不能写入</code>它)。访问权也可以规定所需的密码保护。</p><h4 id="s4184-mandatory-contents-of-a-cosem-logical-device"><span class="mr-2">s4.1.8.4 Mandatory contents of a COSEM logical device</span><a href="#s4184-mandatory-contents-of-a-cosem-logical-device" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>每个逻辑设备都应有：</p><ul><li>COSEM LDN对象<li>“Association” (LN or SN)对象</ul><blockquote><p>如果SAP Assignment对象存在，“Association” (LN or SN)对象非必选</p></blockquote><p>识别固件必选对象：</p><ul><li>active firmware identifier<li>active firmware signature</ul><p>每个固件对应以上两个对象各一个</p><h4 id="s4185-management-logical-device"><span class="mr-2">s4.1.8.5 Management logical device</span><a href="#s4185-management-logical-device" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>管理角色的逻辑设备</p><p>可以通过<code class="language-plaintext highlighter-rouge">public client</code>使用lowest level securty访问，作用是揭示物理设备<code class="language-plaintext highlighter-rouge">内部结构</code>以及<code class="language-plaintext highlighter-rouge">上报事件</code></p><p>需要包含一个“SAP assignment” object，可以被public client读取，包含物理设备内所有的<code class="language-plaintext highlighter-rouge">逻辑设备</code>对应的<code class="language-plaintext highlighter-rouge">SAP信息</code></p><h2 id="s43-参数和测量数据的接口类interface-classes-for-parameters-and-measurement-data"><span class="mr-2">s4.3 参数和测量数据的接口类Interface classes for parameters and measurement data</span><a href="#s43-参数和测量数据的接口类interface-classes-for-parameters-and-measurement-data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s432-register-class_id--3-version--0"><span class="mr-2">s4.3.2 Register (class_id = 3, version = 0)</span><a href="#s432-register-class_id--3-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>包含<code class="language-plaintext highlighter-rouge">值</code>（value）和<code class="language-plaintext highlighter-rouge">量纲</code>（scaler_unit,包括<code class="language-plaintext highlighter-rouge">精度</code>(scaler)、<code class="language-plaintext highlighter-rouge">单位</code>(unit)）</p><p>清除方法</p><h3 id="s433-extended-register-class_id--4-version--0"><span class="mr-2">s4.3.3 Extended register (class_id = 4, version = 0)</span><a href="#s433-extended-register-class_id--4-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>包含<code class="language-plaintext highlighter-rouge">值</code>、<code class="language-plaintext highlighter-rouge">量纲</code>、<code class="language-plaintext highlighter-rouge">状态</code>（厂家自定义）、<code class="language-plaintext highlighter-rouge">寄存器捕获时间</code></p><p>清除方法</p><h3 id="s434-demand-register-class_id--5-version--0"><span class="mr-2">s4.3.4 Demand register (class_id = 5, version = 0)</span><a href="#s434-demand-register-class_id--5-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">需量寄存器</code></p><p>周期性测量某个值得到当前平均值与上次平均值,<code class="language-plaintext highlighter-rouge">滑差式</code>统计，<code class="language-plaintext highlighter-rouge">统计窗口</code>可以是<code class="language-plaintext highlighter-rouge">1个或多个周期</code></p><p><img data-src="/assets/img/2022-03-17-dlms-blue2/demand.jpg" alt="demand" data-proofer-ignore></p><p>E3表示第三个周期内的电量增量,<code class="language-plaintext highlighter-rouge">假设</code>当前时间<code class="language-plaintext highlighter-rouge">大于</code>E3统计<code class="language-plaintext highlighter-rouge">结束时间</code>（第三周期结束时间），<code class="language-plaintext highlighter-rouge">小于</code>E4统计<code class="language-plaintext highlighter-rouge">结束时间</code>，电量记录值比E3统计结束时大<code class="language-plaintext highlighter-rouge">Δe</code></p><ul><li>current_average_value <code class="language-plaintext highlighter-rouge">当前平均值</code>，energy/3t,energy=E2+E3+Δe,t=period,3=周期个数<li>last_average_value <code class="language-plaintext highlighter-rouge">上一平均值</code>，energy/3t,energy=E1+E2+E3,t=period,3=周期个数<li>scaler_unit 量纲<li>status 状态<li>capture_time <code class="language-plaintext highlighter-rouge">last_average_value</code>计算时间<li>start_time_current <code class="language-plaintext highlighter-rouge">current_average_value</code>统计开始时间, TODO:这个start_time必须是周期开始时间吗？图里显示这个值会跳变，说明start_time在跳变,结合next_period好像说得通，每到新的周期开始点执行next_period，start_time加一个周期的时间，导致分子急剧变小<li>period <code class="language-plaintext highlighter-rouge">周期</code><li>number_of_periods <code class="language-plaintext highlighter-rouge">周期个数</code>，用于<code class="language-plaintext highlighter-rouge">last_average_value</code>计算，为<code class="language-plaintext highlighter-rouge">1表示区间式</code>(block)，<code class="language-plaintext highlighter-rouge">大于1表示滑差式</code>(sliding)</ul><p>方法：</p><ul><li>reset (data) 清除<li>next_period (data) 该方法用于触发一个时间段的正常终止(和重新启动)。关闭(终止)当前测量周期。<code class="language-plaintext highlighter-rouge">更新capture_time和start_time</code>，拷贝current_average_value到last_average_value，设置current_average_value为默认值。开始下一个测量周期。</ul><h3 id="s435-register-activation-class_id--6-version--0"><span class="mr-2">s4.3.5 Register activation (class_id = 6, version = 0)</span><a href="#s435-register-activation-class_id--6-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>该 IC 允许对不同收费结构的处理进行建模。 为每个“Register activation”对象分配“Register”, “Extended register”或“Demand register”对象组，对不同类型的量（例如<code class="language-plaintext highlighter-rouge">有功电量</code>、<code class="language-plaintext highlighter-rouge">有功需量</code>、<code class="language-plaintext highlighter-rouge">无功电量</code>等）进行建模。 由激活标记定义的这些寄存器的子组定义了不同的<code class="language-plaintext highlighter-rouge">收费结构</code>（例如，<code class="language-plaintext highlighter-rouge">白天</code>收费、<code class="language-plaintext highlighter-rouge">夜间</code>收费）。 这些激活标记之一，active_mask，定义了分配给“Register activation”对象实例的寄存器子集是活动的。 默认情况下，未包含在任何“Register activation”对象的 register_assignment 属性中的寄存器始终处于启用状态。</p><ul><li>register_assignment <code class="language-plaintext highlighter-rouge">寄存器列表</code>，包括Register”,“Extended register” or “Demand register”等的类id和OBIS<li>mask_list <code class="language-plaintext highlighter-rouge">标记列表</code>，有多个register_act_mask，每个register_act_mask包含唯一的mask_name，每个register_act_mask中的index_list中的值顺序与register_assignment中的对象顺序一一对应，TODO:示例<li>active_mask 激活的标记，<code class="language-plaintext highlighter-rouge">mask_list</code>中的<code class="language-plaintext highlighter-rouge">某个标记</code>，使用mask_name决定，用于表示当前<code class="language-plaintext highlighter-rouge">启用</code>的mask，进一步表示<code class="language-plaintext highlighter-rouge">启用</code>的register</ul><p>方法：</p><ul><li>add_register (data) 向register_assignment中添加一个项，添加在数组尾部<li>add_mask (data) 添加或更新mask_list<li>delete_mask (data) 从mask_list删除一个mask，使用mask_name</ul><h3 id="s436-profile-generic-class_id--7-version--1"><span class="mr-2">s4.3.6 Profile generic (class_id = 7, version = 1)</span><a href="#s436-profile-generic-class_id--7-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>允许<code class="language-plaintext highlighter-rouge">存储、排序和访问</code>称为<code class="language-plaintext highlighter-rouge">捕获对象</code>的数据组或数据系列。捕获对象是几个<code class="language-plaintext highlighter-rouge">COSEM对象</code>的几个适当<code class="language-plaintext highlighter-rouge">属性</code>或几个属性的几个<code class="language-plaintext highlighter-rouge">元素</code>的组合。捕获对象<code class="language-plaintext highlighter-rouge">定期或不定期收集</code>。</p><p>曲线包含<code class="language-plaintext highlighter-rouge">捕获对象</code>，可通过值的范围或输入范围<code class="language-plaintext highlighter-rouge">检索范围</code>内所有记录</p><p><code class="language-plaintext highlighter-rouge">捕获对象列表</code>定义了要保存在buffer中的值，列表是静态的，保证<code class="language-plaintext highlighter-rouge">每个记录</code>都拥有<code class="language-plaintext highlighter-rouge">相同的长度和结构</code></p><p>修改捕获列表必须清空buffer中所有记录，buffer被其他profile使用也必须清空buffer。以保证它们的缓冲区条目的同质性</p><p>记录可以按<code class="language-plaintext highlighter-rouge">某个字段</code>进行<code class="language-plaintext highlighter-rouge">排序</code>，如<code class="language-plaintext highlighter-rouge">时间</code>，或是按先进后出的栈的方式排序。例，按照Demand register中的last_average_value值来从小到大排序获得最大需量register</p><h4 id="s曲线数据大小限制参数"><span class="mr-2">s曲线数据大小限制参数</span><a href="#s曲线数据大小限制参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>记录数entries_in_use<li>最大保留条数。当记录数满时，新捕获数据会覆盖<code class="language-plaintext highlighter-rouge">最不重要</code>的一条数据，重要度根据<code class="language-plaintext highlighter-rouge">排序方式</code>获得，如根据时间排序，最不重要的数据就是时间最早的数据<li>缓冲区物理限制</ul><h4 id="s选择性访问"><span class="mr-2">s选择性访问</span><a href="#s选择性访问" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><p>按照值的范围：</p><p>值可以是时间，或是某个捕获对象的值</p><li><p>按照排序后记录存储的顺序范围：</p><p>如从第一条记录（<code class="language-plaintext highlighter-rouge">重要性</code>最高）到第三条</p><p>如从某个值最大的记录到第三大的记录，需要重新临时排序</p></ul><h4 id="s属性"><span class="mr-2">s属性</span><a href="#s属性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>buffer 包含记录序列，每个记录包含若干捕获对象<li>capture_objects 捕获对象列表，数组形式<li>capture_period 自动捕获周期，以秒为单位，大于1表示达到周期捕获，等于0表示不自动捕获，需要手动触发<li>sort_method <code class="language-plaintext highlighter-rouge">排序方式</code>，默认为<code class="language-plaintext highlighter-rouge">先进先出</code>排序。如果profile已经排序，插入新的记录时，将记录插入适当位置，移动该位置之后所有记录，最不重要记录可能在buffer满后丢失。如果新记录的重要度最低且buffer已满，则该记录不插入<li>sort_object 排序依据（对象）,此属性指定排序所基于的寄存器或时钟<li>entries_in_use 当前记录总数<li>profile_entries 记录上限</ul><h4 id="s方法"><span class="mr-2">s方法</span><a href="#s方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>reset (data) 清空buffer，entries_in_use清零，其他配置不变<li>capture (data) 手动触发捕获，<code class="language-plaintext highlighter-rouge">读取</code>每个捕获对象的<code class="language-plaintext highlighter-rouge">值</code>，<code class="language-plaintext highlighter-rouge">生成记录插入buffer</code>,同样不会改变捕获对象列表</ul><h4 id="s修改捕获对象列表后行为"><span class="mr-2">s修改捕获对象列表后行为</span><a href="#s修改捕获对象列表后行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">调用</code>使用了该捕获对象列表的profile的<code class="language-plaintext highlighter-rouge">reset操作</code>，需要清空buffer</p><h4 id="s限制"><span class="mr-2">s限制</span><a href="#s限制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>定义捕获对象列表时，避免<code class="language-plaintext highlighter-rouge">相互或循环引用</code>。</p><p>TODO:实例？</p><h3 id="s437-utility-tables-class_id--26-version--0"><span class="mr-2">s4.3.7 Utility tables (class_id = 26, version = 0)</span><a href="#s437-utility-tables-class_id--26-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>允许封装 ANSI C12.19:2012 table 数据</p><p>TODO:这是什么？</p><h3 id="s438-register-table-class_id--61-version--0"><span class="mr-2">s4.3.8 Register table (class_id = 61, version = 0)</span><a href="#s438-register-table-class_id--61-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>对<code class="language-plaintext highlighter-rouge">同构</code>条目、多个对象的<code class="language-plaintext highlighter-rouge">相同属性</code>进行<code class="language-plaintext highlighter-rouge">分组</code>，这些对象都是<code class="language-plaintext highlighter-rouge">相同IC</code>的实例,并且在它们的logical_name (OBIS代码)中，值组<code class="language-plaintext highlighter-rouge">A到D</code>和<code class="language-plaintext highlighter-rouge">F</code>中的值是<code class="language-plaintext highlighter-rouge">相同</code>的。</p><p>属性：</p><ul><li>logical_name 当逻辑名为A.B.C.D.255.F时，只捕获<code class="language-plaintext highlighter-rouge">一个属性</code>，如value。当逻辑名为A.B.98.10.X.255时，可以捕获有关对象的不同属性<li><p>table_cell_values 保存捕获属性的值（可选CHOICE种类就是register对象的value属性的类型，因为保存的是多个对象，所以是一个数组），可压缩</p><p>压缩条件：</p><p>如果捕获的属性是attribute_0（index 0,表示捕获所有属性），<code class="language-plaintext highlighter-rouge">冗余值</code>可以被“<code class="language-plaintext highlighter-rouge">null-data</code>”替换，如果它们的值可以明确地恢复(例如<code class="language-plaintext highlighter-rouge">scaler_unit</code>)。</p><li>table_cell_definition Class_id定义捕获属性的对象的公共Class_id;logical_name包含对象的通用逻辑名，E = 255(通配符);group_E_values包含单元标识符列表，类型为unsigned，在DLMS UA 1000-1 Ed 15 Part 1:2021的相应表中定义;Attribute_index是指向对象内属性的指针。Attribute_index 0表示所有公共属性。<li>scaler_unit 量纲，当“Register”或“Extended Register”对象的“value”属性被捕获时，scaler_unit应为所有对象的<code class="language-plaintext highlighter-rouge">公共属性</code>。如果是其他属性或是其他IC，则<code class="language-plaintext highlighter-rouge">该属性无用且禁止访问</code></ul><p>方法：</p><ul><li>reset (data) 清空table_cell_values<li>capture (data) 捕获，将原IC对象中的值拷贝到table_cell_values中，如果table_cell_definition中的attribute_index为0，则捕获所有属性</ul><p>table_cell_definition被写入时的动作：</p><p>自动调用reset方法清空原数据，如果需要捕获的属性的占用空间过大，table_cell_definition的写入会被拒绝</p><h3 id="s439-status-mapping-class_id--63-version--0"><span class="mr-2">s4.3.9 Status mapping (class_id = 63, version = 0)</span><a href="#s439-status-mapping-class_id--63-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>该IC允许将<code class="language-plaintext highlighter-rouge">状态字中的位</code>映射到<code class="language-plaintext highlighter-rouge">引用表</code>中的<code class="language-plaintext highlighter-rouge">项</code>。</p><ul><li>status_word 状态字，n*8比特，最大65536比特<li>mapping_table 包含status_word到引用表中位置的映射。<ul><li>ref_table_id 表示引用表的id<li><p>ref_table_mapping（choice：long-unsigned或long-unsigned数组）：该值对应<code class="language-plaintext highlighter-rouge">引用表</code>(reference table，见6.2.45)中的<code class="language-plaintext highlighter-rouge">一条记录</code>，该记录对应status_word中的第一位，该记录的下一条记录对应status_word中的第二位，直到status_word的最后一位</p><ul><li>如果该值选择<code class="language-plaintext highlighter-rouge">long-unsigned</code>，则表示对于引用表的引用起始指针</ul><p>假设status_word为10000001，ref_table_mapping的long-unsigned值为3，对于引用表的第3条记录</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">status_word位值<th style="text-align: center">引用表索引<tbody><tr><td style="text-align: center">1<td style="text-align: center">3<tr><td style="text-align: center">0<td style="text-align: center">4<tr><td style="text-align: center">0<td style="text-align: center">5<tr><td style="text-align: center">…<td style="text-align: center">…<tr><td style="text-align: center">1<td style="text-align: center">10</table></div><ul><li>ref_table_mapping选择<code class="language-plaintext highlighter-rouge">array</code>：array中的每个值对应引用表中的一条记录，每条记录对应status_word中的对应位，如array第一个值对应status中的第一位，最后一个值代表最后一位</ul></ul></ul><h3 id="s4310-compact-data-class_id-62-version--1"><span class="mr-2">s4.3.10 Compact data (class_id: 62, version = 1)</span><a href="#s4310-compact-data-class_id-62-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>紧凑数据</p><p>Compact数据IC的实例允许捕获由capture_objects属性确定的COSEM对象属性值。捕捉可以发生:</p><ul><li>在外部触发器上(显式捕捉);<li>在读取compact_buffer属性时(隐式捕获)。</ul><p>由capture_method属性确定</p><p>值保存在compact_buffer attribute中，以octet-string形式</p><p>这组数据类型由template_id属性标识。捕获的每个属性的数据类型由template_description属性保存。</p><p>客户端可以用未压缩的形式重新构造数据(解压)，即包括COSEM属性描述符、数据类型和使用capture_objects、template_id和template_description属性的数据值。</p><p>属性：</p><ul><li>compact_buffer 捕获的属性的值，octet-string形式，当类型为octet-string, bit-string, visible-string, utf8-string or array时，长度也包含在内。（不同于profile，这个类中的compact_buffer就是个octet-string，不是array，也就是只有一条）<li>capture_objects 指定分配给“Compact data”对象实例的<code class="language-plaintext highlighter-rouge">COSEM对象属性列表</code>，两种选择性访问方式：<ul><li><code class="language-plaintext highlighter-rouge">相对选择性访问</code>：相对当前的日期或当前的记录返回记录，由data_index元素控制<li><code class="language-plaintext highlighter-rouge">绝对选择性访问</code>：根据明确的时间范围或记录范围返回记录，由restriction_element控制，列（columns）是由data_index的MS byte(Most Significant byte,意为最高有效字节)的低半字节（右边4位）决定的</ul><div class="table-wrapper"><table><thead><tr><th style="text-align: center">data-index:<th style="text-align: center">MS-Byte<th style="text-align: center">MS-Byte<th style="text-align: center">LS-Byte<tbody><tr><td style="text-align: center"> <td style="text-align: center">Upper nibble<td style="text-align: center"><code class="language-plaintext highlighter-rouge">Lower nibble</code><td style="text-align: center"> <tr><td style="text-align: center"> <td style="text-align: center">0000<td style="text-align: center">0000<td style="text-align: center">00000000</table></div><ul><li>data_index:是一个指针，它<code class="language-plaintext highlighter-rouge">选择</code>具有复杂数据类型(结构或数组)的属性的一个或几个<code class="language-plaintext highlighter-rouge">特定元素</code>:<ul><li>如果属性的数据类型是简单类型，则该值无意义<li>如果属性的数据类型是结构体或数组（非profile generic对象的buffer），则该值指向该结构体或数组中的一个或多个特定元素<li>如果属性的数据类型是profile generic对象的buffer，该值包含相对选择性访问的参数，如当前日期或记录<li>0x0000 =标识整个属性;<li>0x0001到0x0FFF =标识复杂属性中的一个元素。复杂属性中的第一个元素由data_index 1标识;<li>0x1000到0xFFFF =对保存Profile generic对象的buffer的数组进行相对选择性访问。数据索引选择最近(最近)时间段内的条目，或最近(最近)条目内的条目，以及数组中的列。<ul><li>参考Table 9 – Encoding of selective access parameters with data_index。例，0x830C，MS-Byte中的高4位为0x8，表示包括当前小时在内的最后一个完整小时数，低4位为0x3，表示前3列，LS-Byte为0x0C,表示12小时，综上，该值表示选择最后12个小时内的前3列数据</ul></ul><li>restriction_element：当属性的数据类型是profile generic对象时，该值用于表示<code class="language-plaintext highlighter-rouge">绝对选择性访问</code>的参数，时间范围，记录序号范围，<ul><li>此时的data_index条件：<ul><li>MS Byte高4位为0（为1的话表示相对选择性访问）<li>MS Byte低4位为0x0到0xF<li>Lower byte为0</ul><li>restriction_type表示选择性访问的方式<li>restriction_value表示选择性访问范围</ul></ul><li>template_id 包含模板的<code class="language-plaintext highlighter-rouge">标识符</code>。它应唯一标识“Compact data”IC的实例和 template_description。<li>template_description 每个被捕获的属性的<code class="language-plaintext highlighter-rouge">数据类型</code>，由服务端自动生成，根据capture_objects，包含以下结构体：<ul><li>第一个字节是0x02结构体tag<li>后面是数量，变长，和capture_objects数量相同<li>后面是每个属性的数据类型，与capture_objects一一对应:<ul><li>对于具有简单数据类型的属性，该值一个字节，包含类型tag，如bit-string[4]<li>对于array[1]，该值为0x01，后面是元素的类型（数组内所有元素都相同，所以就一个）。不记录数目是因为compact_buffer已经记录了<li>对于structure[2]，该值为0x02,后面是元素数目，后面是每个元素的类型</ul></ul><li>capture_method 定义compact_buffer更新的方式：<ul><li>0：在调用Capture (data)方法时捕获。这可能发生在远程或本地(显式捕获)<li>1：读取compact_buffer属性时捕获(隐式捕获)</ul></ul><p>方法：</p><ul><li>reset(data) 仅清空compact_buffer<li>capture(data) 将捕获对象的值填充至compact_buffer中，<strong>不会触发捕获对象内的任何其他操作</strong>，如capture()或reset()</ul><p>对capture_objects的任何修改，必须<code class="language-plaintext highlighter-rouge">重置</code>compact_buffer以及<code class="language-plaintext highlighter-rouge">自动更新</code>template_description</p><h2 id="s44-用于访问控制和管理的接口类interface-classes-for-access-control-and-management"><span class="mr-2">s4.4 用于访问控制和管理的接口类Interface classes for access control and management</span><a href="#s44-用于访问控制和管理的接口类interface-classes-for-access-control-and-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s443-association-sn-class_id--12-version--4"><span class="mr-2">s4.4.3 Association SN (class_id = 12, version = 4)</span><a href="#s443-association-sn-class_id--12-version--4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>COSEM logical devices能够在COSEM context中<code class="language-plaintext highlighter-rouge">使用SN引用建立AAs</code>，使用“Association SN”IC的实例建模AAs。一个COSEM logical devices可以对<code class="language-plaintext highlighter-rouge">每个</code>设备能够支持的<code class="language-plaintext highlighter-rouge">AA</code>拥有<code class="language-plaintext highlighter-rouge">一个</code>该IC的<code class="language-plaintext highlighter-rouge">实例</code>。</p><p>属性：</p><ul><li>object_list 对象列表，数组形式，包含base_name,class_id,version,logical_name，base_name定义见<em>文章开头</em><blockquote><p>实际这里base_name和logical_name的含义重复了，不过base_name是是用来作为和access_rights_list关联的外键的</p></blockquote><p>TODO:logical_name和base_name重复了</p><li>access_rights_list 包含对属性和方法的<code class="language-plaintext highlighter-rouge">权限</code>，数组形式，和object_list间通过<code class="language-plaintext highlighter-rouge">base_name</code>管理，相当于外键，元素数量需要相同，元素顺序最好也相同。包含base_name，attribute_access(可选)，method_access(可选)<blockquote><p>object_list支持以class_id，logical_name或base_name为条件选择性访问，access_rights_list支持以base_name为条件选择性访问</p></blockquote><li>security_setup_reference 引用<code class="language-plaintext highlighter-rouge">Security setup</code>的logical_name，被引用的对象管理给定的”Association SN”对象实例的安全性<li>user_list <code class="language-plaintext highlighter-rouge">允许使用</code>本对象管理的<code class="language-plaintext highlighter-rouge">AA</code>的用户列表<ul><li>user_id表示user的id（<code class="language-plaintext highlighter-rouge">AARQ</code>中的<code class="language-plaintext highlighter-rouge">calling-AE-invocation-id</code>携带）<li>user_name是用户的名字</ul><blockquote><p>如果数组<code class="language-plaintext highlighter-rouge">为空</code>，则<code class="language-plaintext highlighter-rouge">任何用户</code>都能使用AA；如果数组不为空，则仅有列表内用户可以建立AA，也就是AARQ中的calling-AE-invocation-id字段必须匹配列表中的user_id。</p></blockquote><pre><code class="language-asn.1">  array user_list_entry
  user_list_entry ::= structure
  {
      user_id:    unsigned,
      user_name   CHOICE {
                  visible-string  [10],
                  UTF-8-string    [12]
                  }
  }
</code></pre><li>current_user 当前用户，若user_list为空，该值的user_id和user_name都为0（空）</ul><p>方法：</p><ul><li>read_by_logicalname (data) 读取指定对象的属性值，对象由class_id和logical_name指定，attribute_index表示索引，0表示全部属性，1表示第一个属性。回复的数据由属性类型决定<li>change_secret (data) 修改LLS密码或HLS密钥（不包括认证），可能包含校验信息或本身被加密，HLS with GMAC认证的密钥由Security setup管理。<li>reply_to_HLS_authentication (data) 此方法的<code class="language-plaintext highlighter-rouge">远程调用</code>将<code class="language-plaintext highlighter-rouge">服务端对客户端</code>的<code class="language-plaintext highlighter-rouge">质询</code>(change) f(<code class="language-plaintext highlighter-rouge">StoC</code>) 的客户端<code class="language-plaintext highlighter-rouge">秘密处理的结果</code>传递给服务端，作为通过参数化访问调用的 Read.request 原语的数据服务参数</ul><div class="table-wrapper"><table><thead><tr><th style="text-align: center">服务端S<th style="text-align: center">客户端C<tbody><tr><td style="text-align: center">StoC-&gt;<td style="text-align: center"> <tr><td style="text-align: center"> <td style="text-align: center">&lt;-f(StoC)加密处理后的结果</table></div><p>data数据是客户端对服务端的回复</p><p>TODO：请求和回复的数据是什么</p><p>回应数据：</p><p>如果认证被接受，则响应（Read.confirm 原语）包含 Result == OK 和服务器对客户端质询服务器的秘密处理结果，在 Read 的数据服务参数中 f(CtoS) 响应服务。</p><p>data数据是服务端对客户的回复</p><p>如果认证不被接受，则返回non-OK值，且不包括data</p><ul><li>add_user (data) 向user_list添加一个用户<li>remove_user (data) 从user_list移除一个用户</ul><h3 id="s444-association-ln-class_id--15-version--3"><span class="mr-2">s4.4.4 Association LN (class_id = 15, version = 3)</span><a href="#s444-association-ln-class_id--15-version--3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>COSEM logical devices能够使用 LN 引用在 COSEM context中建立 AA，通过“Association LN”IC 的实例对 AA 建模。 一个 COSEM logical devices件对于该器件能够支持的每个 AA 都有一个该 IC 的实例。</p><p>属性：</p><ul><li><p>object_list 同Association SN中object_list和access_rights_list的整合</p><p>选择性访问支持null(所有),class_list,object_id_list,object_id(class_id+logical_name)</p><li>associated_partners_id 包含COSEM客户端和服务端(逻辑设备，物理设备包含若干个逻辑设备)，属于由Association LN对象建模的AA。客户端范围为0x0-0x7F,服务端范围为0x0-0x3FFF<li>application_context_name 在COSEM环境中，希望预先存在一个<code class="language-plaintext highlighter-rouge">application context</code>，并在AA建立期间通过其名称引用它。此属性包含该AA的application context的名称。见<em>Green Book 4.5.2 application context</em>，<em>9.4.2.2.2 The COSEM application context</em>。TODO:查看文档<li>xDLMS_context_info 包含关于给定AA的<code class="language-plaintext highlighter-rouge">xDLMS context</code>的所有必要信息<ul><li>conformance element: 包含服务器支持的xDLMS一致性块,TODO:一致性块是什么 更新：见Gp322 Table 85，表示双方支持的功能列表，用于协商。位串的长度为24位;<li>max_receive_pdu_size：包含xDLMS APDU的<code class="language-plaintext highlighter-rouge">最大长度</code>，客户端可以发送的字节数在AA过程中协商，受xDLMS initiateResponse APDU的server-max-receive-pdu-size参数的限制;<li>max_send_pdu_size：在这个AA中服务器可以发送的xDLMS APDU的<code class="language-plaintext highlighter-rouge">最大长度</code>，以字节表示。它受到xDLMS initiateRequest APDU的client-max-receive-pdu-size参数的限制;<li>dlms_version_number：包含服务端支持的DLMS版本<li>quality_of_service：未使用<li>cyphering_info：在一个活动的AA中，包含xDLMS initiateRequest APDU的专用关键参数，见<em>GREEN BOOK 9.5</em></ul><li>authentication_mechanism_name AA认证机构名称<li>secret LLS或HLS密钥，同上SN<li>association_status AA当前状态<li>security_setup_reference 引用Security setup对象的logical name.该对象用于管理Association LN本对象实例<li>user_list 同上SN<li>current_user 同上SN</ul><p>方法：</p><ul><li>reply_to_HLS_authentication (data) 同上SN<li>change_HLS_secret (data) 同上SN<li>add_object (data) 同上SN<li>remove_object (data) 同上SN<li>add_user (data) 同上SN<li>remove_user (data) 同上SN</ul><h3 id="s445-sap-assignment-class_id--17-version--0"><span class="mr-2">s4.4.5 SAP assignment (class_id = 17, version = 0)</span><a href="#s445-sap-assignment-class_id--17-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>该 IC 允许通过提供有关将逻辑设备分配给其 SAP 的信息来对物理设备的逻辑结构进行建模。 参见 DLMS UA 1000-2 Ed.11:2021，第 10 条。</p><p>属性：</p><ul><li>SAP_assignment_list 包含物理设备上所有<code class="language-plaintext highlighter-rouge">逻辑设备</code>和他们的<code class="language-plaintext highlighter-rouge">sap</code><ul><li>逻辑设备名<li>sap</ul></ul><p>方法：</p><ul><li><p>connect_logical_device (data) 将<code class="language-plaintext highlighter-rouge">逻辑设备</code>连接到<code class="language-plaintext highlighter-rouge">SAP</code>。连接到<code class="language-plaintext highlighter-rouge">SAP 0</code>表示<code class="language-plaintext highlighter-rouge">断开</code>设备连接。一个SAP不能连接多个设备(SAP 0除外)。</p><p>逻辑设备：物理设备中的<code class="language-plaintext highlighter-rouge">抽象实体</code>，表示用COSEM对象建模的<code class="language-plaintext highlighter-rouge">功能子集</code></p></ul><h3 id="s446-image-transfer-class_id--18-version--0"><span class="mr-2">s4.4.6 Image transfer (class_id = 18, version = 0)</span><a href="#s446-image-transfer-class_id--18-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>图像传输IC模型的实例是将<code class="language-plaintext highlighter-rouge">二进制文件</code>(称为image)传输到<code class="language-plaintext highlighter-rouge">COSEM服务器</code>的过程。</p><ol><li>步骤1：(可选)获取ImageBlockSize<li>步骤2：客户端启动镜像传输<li>步骤3：客户端传输imageBlocks<li>步骤4：客户端检查确认传输完成<li>步骤5：服务端校验镜像完整性（客户端发起或服务端自行完成）<li>步骤6：（可选）客户端检查要激活的图像上的信息<li>步骤7：服务端激活镜像（客户端发起或服务端自行完成）</ol><p>属性：</p><ul><li>image_block_size 保存ImageBlockSize，一个镜像被分为若干块，这里是每个块大小，用八位字节表示，不能超过协商的ServerMaxReceivePduSize<li>image_transferred_blocks_status <code class="language-plaintext highlighter-rouge">位图</code>，提供关于每个ImageBlock的传输状态的信息。bit-string中的每一位提供了一个单独的ImageBlock的信息，0为未传输，1为已传输。<li>image_first_not_transferred_block_number 第一个<code class="language-plaintext highlighter-rouge">未传输</code>的块的编号，如果传输全部完成，该编号应该等于或大于image_block_size<li>image_transfer_enabled <code class="language-plaintext highlighter-rouge">控制</code>是否<code class="language-plaintext highlighter-rouge">启用</code>图像传输<code class="language-plaintext highlighter-rouge">过程</code>，只有置为true才能执行image transfer相关方法，为false是禁用所有方法的执行，返回错误<li>image_transfer_status <code class="language-plaintext highlighter-rouge">传输状态</code><li>image_to_activate_info 提供有关准备<code class="language-plaintext highlighter-rouge">激活的映像的信息</code>。这是一个<code class="language-plaintext highlighter-rouge">数组</code>，每个待激活的镜像都有<code class="language-plaintext highlighter-rouge">独立</code>信息，它是作为图像验证过程的结果生成的。客户端可以在激活映像之前检查这些信息（从服务端的这个属性中读出来后检查）。包括<code class="language-plaintext highlighter-rouge">大小、标识（identification）和签名</code></ul><p>方法：</p><ul><li>image_transfer_initiate (data) <code class="language-plaintext highlighter-rouge">初始化</code>传输过程，参数包括identifier和ImageSize（不是image block size）。在此之后，将image_transfer_status（传输状态）属性置为1，image_first_not_transferred_block_number置为0，对于该方法的调用会重置整个传输流程<li>image_block_transfer (data) 传<code class="language-plaintext highlighter-rouge">输一个块</code>到服务端，包括块序号和块内容，之后将image_transferred_blocks_status对应位置1，image_first_not_transferred_block_number更新<li><p>image_verify (data) 在激活之前验证映像的完整性(触发服务端自校验)。</p><p>调用这个方法的结果可能是<code class="language-plaintext highlighter-rouge">success、temporary_failure</code>或<code class="language-plaintext highlighter-rouge">other_reason</code>。如果<code class="language-plaintext highlighter-rouge">不成功</code>，则可以通过检索<code class="language-plaintext highlighter-rouge">image_transfer_status</code>属性的值来找到验证的结果。</p><p>如果<code class="language-plaintext highlighter-rouge">成功</code>，image_to_activate_info属性将保存要激活的图像的信息。</p><li><p>image_activate (data) <code class="language-plaintext highlighter-rouge">激活镜像</code>。</p><p>如果传输的Image之前没有经过<code class="language-plaintext highlighter-rouge">验证</code>（没执行image_verify），那么这将作为Image_activate的一部分完成。 调用此方法的结果可能是<code class="language-plaintext highlighter-rouge">成功</code>、<code class="language-plaintext highlighter-rouge">暂时失败</code>或<code class="language-plaintext highlighter-rouge">其他原因</code>。如果不是成功，那么可以通过检索<code class="language-plaintext highlighter-rouge">image_transfer_status</code>属性的值来了解激活的结果。</p></ul><p>如果客户端不知道图像传输目标服务器可以处理的图像块的大小，那么在开始处理之前，客户端需要读取图像传输到的每个服务器的相关“image transfer”对象的<code class="language-plaintext highlighter-rouge">image_block_size</code>属性。客户端可以传输<code class="language-plaintext highlighter-rouge">合适大小</code>的ImageBlocks。</p><p>如果图像块通过<code class="language-plaintext highlighter-rouge">广播</code>发送给一组COSEM服务端，图像块大小在组中的每个成员中应该是相同的。</p><p><code class="language-plaintext highlighter-rouge">校验临时失败</code>不是真正失败，可能是校验还未完成，客户端可以通过获取image_transfer_status属性的值来检查Image验证的结果。</p><p>服务端内可以保存多个待激活的镜像</p><h4 id="simage-transfer-for-m-bus-devices"><span class="mr-2">sImage transfer for M-Bus devices</span><a href="#simage-transfer-for-m-bus-devices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h3 id="s447-security-setup-class_id--64-version--1"><span class="mr-2">s4.4.7 Security setup (class_id = 64, version = 1)</span><a href="#s447-security-setup-class_id--64-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>“Security setup”IC的实例包含有关正在使用的<code class="language-plaintext highlighter-rouge">安全套件(security suite)</code>的必要信息，以及在客户机和服务器之间适用的<code class="language-plaintext highlighter-rouge">安全策略(security policy)</code>(由它们各自的系统标题标识)。它们还提供了提高安全性级别和管理<code class="language-plaintext highlighter-rouge">对称密钥</code>、<code class="language-plaintext highlighter-rouge">非对称密钥对</code>和<code class="language-plaintext highlighter-rouge">证书</code>的方法</p><p>属性：</p><ul><li>security_policy <code class="language-plaintext highlighter-rouge">安全策略</code>，使用安全套件中可用的安全算法强制身份验证和/或加密和/或数字签名。它独立地应用于请求和响应。<li><p>security_suite 安全套件，明确加密算法</p><ul><li>(0) AES-GCM-128 authenticated encryption and AES-128 key wrap<li>(1) AES-GCM-128 authenticated encryption, ECDSA P-256 digital signature, ECDH P-256 key agreement, SHA-256 hash, V.44 compression and AES-128 key wrap<li>(2) AES-GCM-256 authenticated encryption, ECDSA P-384 digital signature, ECDH P-384 key agreement, SHA-384 hash, V.44 compression and AES-256 key wrap<li>(3) … (15) reserved</ul><li>client_system_title 携带（当前）<code class="language-plaintext highlighter-rouge">客户端</code>system title，在已确认或未确认的AA建立过程中，由AARQ APDU的calling-AP-title字段承载;<li>server_system_title 携带<code class="language-plaintext highlighter-rouge">服务端</code>的system_title，在确认AA建立时，由AARE APDU的response-AP-title字段进行<li>certificates 携带可用的X.509 v3<code class="language-plaintext highlighter-rouge">证书信息</code>，并存储在服务器中。服务端可以保存服务端证书、每个客户端的证书、CA证书。</ul><p>方法：</p><ul><li>security_activate (data) 激活和<code class="language-plaintext highlighter-rouge">加强安全策略</code>security_policy，新的值安全性必须高于或等于原值，也就是只能加强，不能减弱<li>key_transfer (data) 用于<code class="language-plaintext highlighter-rouge">传输</code>一个或多个<code class="language-plaintext highlighter-rouge">密钥</code>(EK,AK,BK,MK),包括密钥标识和封装后的密钥（key wrapped）。可以是数组，一次多个密钥。<code class="language-plaintext highlighter-rouge">key wrap</code>算法由加密套件指定<li>key_agreement (data) 用于使用安全套件指定的<code class="language-plaintext highlighter-rouge">密钥协商算法</code>对一个或多个<code class="language-plaintext highlighter-rouge">对称密钥</code>达成一致。在套件1和套件2的情况下，ECDH密钥协商算法与临时统一模型(Ephemeral Unified Model) C(2e, 0s, ECC CDH)方案一起使用。<li>generate_key_pair (data) 根据<code class="language-plaintext highlighter-rouge">安全套件</code>的要求生成<code class="language-plaintext highlighter-rouge">非对称密钥对</code>。data<code class="language-plaintext highlighter-rouge">参数</code>标识要生成的密钥对的<code class="language-plaintext highlighter-rouge">用法</code>:<ul><li>digital signature key pair 数字签名<li>key agreement key pair 密钥协商<li>TLS key pair TLS通信</ul><p>以上每个用法的密钥对<code class="language-plaintext highlighter-rouge">最多同时</code>只能有<code class="language-plaintext highlighter-rouge">一个</code>，也就是最多有三个密钥对</p><li><p>generate_certificate_request (data) 当调用此方法时，服务器发送<code class="language-plaintext highlighter-rouge">证书签名请求</code>(<code class="language-plaintext highlighter-rouge">CSR</code>)数据，这是CA为服务器公钥生成证书所必需的。data参数为请求证书的密钥对类型</p><p>响应为CSR数据，PKCS #10格式DER编码的octet-string</p><li>import_certificate (data) <code class="language-plaintext highlighter-rouge">导入X.509 V3格式证书</code>，DER编码octet-string，无需指定类型，TODO：如何区分证书类型,自动识别？<li>export_certificate (data) <code class="language-plaintext highlighter-rouge">导出证书</code>，根据类型或序列号<li>remove_certificate (data) <code class="language-plaintext highlighter-rouge">移除证书</code>，参数同上导出证书</ul><h3 id="s448-push-interface-class"><span class="mr-2">s4.4.8 Push interface class</span><a href="#s448-push-interface-class" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>在很多情况下，DLMS消息可以在没有明确请求的情况下“<code class="language-plaintext highlighter-rouge">推送</code>”到目的地，例如:</p><ul><li>如果本地监控的值<code class="language-plaintext highlighter-rouge">超过阈值</code>;<li>由<code class="language-plaintext highlighter-rouge">本地事件</code>触发(如开机/关机，按下按钮，仪表盖打开)。</ul><p>DLMS/COSEM推送机制遵循<code class="language-plaintext highlighter-rouge">发布/订阅</code>模式。</p><p>在DLMS/COSEM中，发布是由“Association”对象的object_list属性建模的，该属性提供了给定AA中可访问的COSEM对象列表和它们的属性。订阅是通过编写“Push setup”对象的适当属性来建模的。使用xDLMS DataNotification服务(在指定的触发器上)发送所需的数据。</p><h3 id="s4482-push-setup-class_id--40-version--3"><span class="mr-2">s4.4.8.2 Push setup (class_id = 40, version = 3)</span><a href="#s4482-push-setup-class_id--40-version--3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>“Push setup”IC包含要推送的<code class="language-plaintext highlighter-rouge">COSEM对象属性</code>的<code class="language-plaintext highlighter-rouge">引用列表</code>。它还包含推送<code class="language-plaintext highlighter-rouge">目的地</code>和<code class="language-plaintext highlighter-rouge">方法</code>，以及<code class="language-plaintext highlighter-rouge">通信时间窗口</code>和<code class="language-plaintext highlighter-rouge">重试处理</code></p><p>Push在<em>push</em>方法被调用时启动，由<code class="language-plaintext highlighter-rouge">push *Single action schedule*对象</code>、<code class="language-plaintext highlighter-rouge">alarm *Register monitor*对象</code>、<code class="language-plaintext highlighter-rouge">专用的内部事件</code>或<code class="language-plaintext highlighter-rouge">外部事件</code>触发。push操作被<code class="language-plaintext highlighter-rouge">触发</code>后，根据给定的<code class="language-plaintext highlighter-rouge">push setup</code>对象中的设置执行。根据<code class="language-plaintext highlighter-rouge">通信窗口</code>的设置，push会在<code class="language-plaintext highlighter-rouge">随机延迟</code>后立即执行，或者在通信窗口激活后立即执行。如果push不成功，则会<code class="language-plaintext highlighter-rouge">重试</code>。重试可能在提示支持协议层失败或缺少确认时发生。</p><p>属性：</p><ul><li>push_object_list 定义要推送的<code class="language-plaintext highlighter-rouge">属性列表</code>，在调用<code class="language-plaintext highlighter-rouge">push (data)</code>方法时，内容被发送到<code class="language-plaintext highlighter-rouge">send_destination_and_method</code>属性中定义的目标。<ul><li>class_id 类<li>logical_name 对象<li>attribute_index 属性序号，0表示全部，如果attribute_index是0，则data_index为0且无意义，其他值也为空或null<li>data_index 当属性是数组或结构体时(除profile generic)，0表示所有元素，0x0001-0x0FFF表示元素序号，其他值为空或null<li>restriction,columns 当属性是profile generic对象的时，和data_index一起表示选择性访问参数</ul><p>携带推送数据的<code class="language-plaintext highlighter-rouge">DataNotification APDU</code>受到<em>安全套件suit</em>、<em>安全策略policy</em>和<em>安全材料material</em>的保护，这些安全配置包含在”Security setup”对象中，由AA应用上下文中的<code class="language-plaintext highlighter-rouge">Association SN/Association LN</code>对象的<code class="language-plaintext highlighter-rouge">security_setup_reference</code>属性引用，与<code class="language-plaintext highlighter-rouge">push_client_SAP</code>属性相关联；以及push_protection_parameters属性也是如此。对于在该AA中没有被授予读取访问权的属性，或者由于任何其他原因不能被访问的属性，应该返回空数据。</p><li>send_destination_and_method 包含<code class="language-plaintext highlighter-rouge">目标地址</code>和<code class="language-plaintext highlighter-rouge">传输服务</code>(例如电话号码，电子邮件地址，IP地址)，用于发送push_object_list指定的数据<ul><li>transport_service 传输服务类型，如TCP,HDLC,Gateway等<li>destination 目的地址，取决于transport_service，比如CoAP协议的目的地址时一个CoAP URI,<li>message APDU编码类型<ul><li>(0) A-XDR encoded xDLMS APDU<li>(1) XML encoded xDLMS APDU<li>(128…255) manufacturer specific</ul></ul><p>一个Push setup对象仅支持一个transport_service和destination，如果同一个内容需要上报给多个目的地，则需要多个不同对象</p><li>communication_window <code class="language-plaintext highlighter-rouge">通信窗口</code>，包含开始时间和结束时间的区间，是个数组，每个元素为一个区间。如果没有元素，则不限制窗口，随时可以推送<li>randomisation_start_interval 发送第一包前的<code class="language-plaintext highlighter-rouge">随机等待</code>时间的<code class="language-plaintext highlighter-rouge">最大值</code>，为了防止大量同网络设备同时推送。<ul><li>随机等待时间从0到最大值随机<li>仅在活动窗口内调用push生效，<code class="language-plaintext highlighter-rouge">不在重试时生效</code>（push失败后等待固定延迟时间重试，不应用随机等待时间）<li>在活动窗口外时push，到达窗口开始时间时计算随机值<li>随机延迟超出窗口结束时间，那要到下一个窗口才能push，见上一节的图片<li>未定义窗口时，所有push和重试都会应用随机等待</ul><li>number_of_retries 最大重试次数<li>repetition_delay 重发延迟<ul><li>最小时间<li>指数，用于计算下次延迟<li>最大时间</ul><blockquote><p>𝑟𝑒𝑝𝑒𝑡𝑖𝑡𝑖𝑜𝑛_𝑑𝑒𝑙𝑎𝑦 = 𝑟𝑒𝑝𝑒𝑡𝑖𝑡𝑖𝑜𝑛_𝑑𝑒𝑙𝑎𝑦_𝑚𝑖𝑛 × (𝑟𝑒𝑝𝑒𝑡𝑖𝑡𝑖𝑜𝑛_𝑑𝑒𝑙𝑎𝑦_𝑒𝑥𝑝𝑜𝑛𝑒𝑛𝑡 × 0.01)^(𝑛−1)</p></blockquote><p>n表示第几次，n=1表示第一次重试</p><blockquote><p><strong>push内容没有缓存，每次push重试，内容可能会变</strong></p></blockquote><li>port_reference 通信端口引用，引用通信端口setup对象的logical_name,TODO:查看对应章节<li>push_client_SAP 客户端SAP,推送目标，绑定对应的AA<li>push_protection_parameters 数据保护参数，见Data Protection IC<li><p>push_operation_method 定义是否使用 <code class="language-plaintext highlighter-rouge">Service_Class</code> == <code class="language-plaintext highlighter-rouge">Unconfirmed</code> 或 <code class="language-plaintext highlighter-rouge">Confirmed</code> 调用 DataNotification.request 服务原语以及推送<code class="language-plaintext highlighter-rouge">重试</code>的操作<code class="language-plaintext highlighter-rouge">方式</code>。</p><ul><li>(0) unconfirmed, retry on <code class="language-plaintext highlighter-rouge">supporting protocol layer failure</code>。AL层无需确认（发送结果不用给AL层），也不会超时重发，只在支持层回失败时重发，条件最宽松<li>(1) unconfirmed, retry on <code class="language-plaintext highlighter-rouge">missing supporting protocol layer confirmation</code>。AL层无需确认（发送结果不用给AL层），但会在支持层超时未回confirm原语时重发，包含0的情况，失败也重发<li>(2) confirmed, retry on <code class="language-plaintext highlighter-rouge">missing confirmation</code>。必须由AL层确认，否则都会超时重发（即使支持层回了成功也一样），包含0和1的情况</ul><li>confirmation_parameters 仅用于相对选择性访问时（见本节push_object_list中的data_index和restriction），该值定义选择的条件（已经被确认的条目，已经被确认的不再推送），防止推送较早的数据。如果没有条目被确认则所有条目都会被选择，全部推送<ul><li>选择条目开始时间<li>当前时间开始的向后偏移时间，秒</ul><li>last_confirmation_date_time 保存 <code class="language-plaintext highlighter-rouge">AL</code> 最近调用 <code class="language-plaintext highlighter-rouge">DataNotification.confirm 服务原语</code>并收到 <code class="language-plaintext highlighter-rouge">Result == CONFIRMED</code> 的日期和时间。</ul><p>方法：</p><p>push (data) 激活一次推送，发送携带推送数据的DataNot ification APDU reset (data) 重置为初始状态</p><h3 id="s449-cosem-data-protection-class_id--30-version--0"><span class="mr-2">s4.4.9 COSEM data protection (class_id = 30, version = 0)</span><a href="#s449-cosem-data-protection-class_id--30-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>该IC的实例允许对<code class="language-plaintext highlighter-rouge">COSEM数据</code>，即<code class="language-plaintext highlighter-rouge">属性值</code>、<code class="language-plaintext highlighter-rouge">方法</code>调用和<code class="language-plaintext highlighter-rouge">返回参数</code>应用<code class="language-plaintext highlighter-rouge">加密保护</code>。这是通过 “Data protection”接口类的实例间接访问其他COSEM对象的属性和/或方法来实现的，该接口类提供必要的机制和参数来应用/验证/移除对COSEM数据的保护。</p><p><code class="language-plaintext highlighter-rouge">保护参数</code>总是由<code class="language-plaintext highlighter-rouge">客户端</code>控制，一些元素由服务器适当地填充。<code class="language-plaintext highlighter-rouge">安全套件</code>由“<code class="language-plaintext highlighter-rouge">Security setup</code>”对象决定，该对象来自当前的“Association SN”/“Association LN”对象。</p><p>属性：</p><ul><li>protection_buffer 包含<code class="language-plaintext highlighter-rouge">受保护的数据</code>。读取时，捕获由protection_object_list指定的属性，然后根据protection_parameters_get应用保护。写入时，受保护的数据被放入protection_buffer中，然后根据protection_parameters_set验证/删除保护，并设置由protection_object_list指定的属性。<li><p>protection_object_list 定义在<code class="language-plaintext highlighter-rouge">读取</code>protection_buffer时要<code class="language-plaintext highlighter-rouge">捕获</code>的属性列表，或者在<code class="language-plaintext highlighter-rouge">写入</code>protection_buffer时要<code class="language-plaintext highlighter-rouge">设置</code>的属性列表。</p><p>关于选择性访问的描述见Compact data</p><li>protection_parameters_get 包含所有必要的<code class="language-plaintext highlighter-rouge">参数</code>，用于指定<code class="language-plaintext highlighter-rouge">读取</code>protection_buffer时应用的<code class="language-plaintext highlighter-rouge">保护</code>。这个属性首先由<code class="language-plaintext highlighter-rouge">客户端</code>写入。服务器可能需要填写一些额外的元素，在这种情况下，客户端必须读回这个属性——如果需要的话，转发给第三方——以便他们可以使用这些参数来验证/删除保护<li>protection_parameters_set 包含所有<code class="language-plaintext highlighter-rouge">必要的参数</code>，用于在<code class="language-plaintext highlighter-rouge">写入</code>protection_buffer时<code class="language-plaintext highlighter-rouge">验证/删除</code>应用的保护。参数与get相同。此属性由客户端编写，并由服务器使用它来验证和删除保护。<li><p>required_protection 规定了通过“Data protection”对象访问的<code class="language-plaintext highlighter-rouge">属性值/调用</code>和<code class="language-plaintext highlighter-rouge">方法的返回参数</code>所需的保护。</p><p>对于request和response的保护方式</p></ul><p>方法：</p><ul><li><p>get_protected_attributes (data) 获取object_list元素指定的属性的值，并应用get_protected_attributes_response中根据protection_parameters设置的保护</p><p>get_protected_attributes_response中的protection_parameters值是根据客户端参数get_protected_attributes_request中的得到的，服务端可能会有修改，所以可能会有不同</p><li>set_protected_attributes (data) 根据protection_parameters元素，在验证并移除protected_attributes元素上的保护之后，设置object_list元素指定的属性值。<li><p>invoke_protected_method (data) 以保护方式执行特定方法，方法的参数和返回值被保护。在根据invoke_protected_method_request中的protection_parameters验证并移除protected_method_invocation_parameters上的<code class="language-plaintext highlighter-rouge">保护后</code>，<code class="language-plaintext highlighter-rouge">调用</code>object_method元素<code class="language-plaintext highlighter-rouge">指定的方法</code>。</p><p>在调用由 object_method 元素指定的方法后，根据 invoke_protected_method_response 中的 protection_parameters 的保护（必须满足 required_protection）应用于返回参数，并且由 protection_parameters 和 protected_method_return_parameters 组成的 invoke_protected_method_response 返回。</p><pre><code class="language-asn.1">invoke_protected_method_request ::= structure {
  object_method 要执行的方法
  protection_parameters: 保护参数
  object_method_definition： 被保护的参数
  }

invoke_protected_method_response ::= structure {
  protection_parameters: 保护参数
  protected_method_return_parameters: 被保护的返回值（参数）
  }
</code></pre><p>protection_parameters必须满足required_protection</p></ul><h3 id="s4410-function-control-class_id-122-version-0"><span class="mr-2">s4.4.10 Function control (class_id: 122, version: 0)</span><a href="#s4410-function-control-class_id-122-version-0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>IC“Function control”的实例允许启用和禁用服务端中的<code class="language-plaintext highlighter-rouge">功能</code>（Function）。每个可以启用/禁用的功能都由一个名称标识，并由引用的一组特定对象标识符定义。</p><p>依赖“Single action schedule”和“Script table”对象实现按时间控制功能禁用启用</p><p>属性：</p><ul><li>activation_status 显示function_list属性中定义的每个功能块的<code class="language-plaintext highlighter-rouge">当前状态</code>(启用或禁用)<li><p>function_list 定义一个<code class="language-plaintext highlighter-rouge">功能列表</code>，可以通过调用set_function_status方法启用或禁用这些功能。通过class_id和logical_name指定，当功能不能对应特定的COSEM对象时，class_id为0，logical_name为特定描述文本。</p><p>这里的<code class="language-plaintext highlighter-rouge">功能</code>包含了若干个具体的<code class="language-plaintext highlighter-rouge">关联对象</code>，也就是是个抽象的概念，由不同的对象的合作实现的一个<code class="language-plaintext highlighter-rouge">功能</code></p></ul><p>方法：</p><ul><li>set_function_status (data) 启用或禁用一个或多个功能<li>add_function (data) 添加一个新功能，必须是服务端支持的<li>remove_function (data) 移除一个新功能</ul><h3 id="s4411-array-manager-class_id--123-version--0"><span class="mr-2">s4.4.11 Array manager (class_id = 123, version = 0)</span><a href="#s4411-array-manager-class_id--123-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>“Array manager”IC的实例允许管理<code class="language-plaintext highlighter-rouge">其他</code>接口对象<code class="language-plaintext highlighter-rouge">数组类型</code>的<code class="language-plaintext highlighter-rouge">属性</code></p><ul><li>检索条目的数量;<li>选择性地阅读一系列条目;<li>插入新条目或更新现有条目;<li>删除一个范围的条目</ul><p><code class="language-plaintext highlighter-rouge">每个</code>实例允许管理分配给它的数组类型的<code class="language-plaintext highlighter-rouge">几个</code>属性</p><p>TODO：该对象有权限访问修改其他对象的属性？</p><p>属性：</p><ul><li>array_object_list 定义可由该IC的实例管理的数组类型的属性列表</ul><p>方法：</p><ul><li><p>retrieve_number_of_entries(data) 返回一个数组中已标识的条目<code class="language-plaintext highlighter-rouge">总数</code></p><li><p>retrieve_entries (data) 检索array_object_list数组中的一个数组项的<code class="language-plaintext highlighter-rouge">范围</code>数据。</p><p>m表示记录总数，from_entry和to_entry表示数组序号，序号为1到m</p><ul><li>from_entry &lt; to_entry &lt; m，返回from_entry 到 to_entry记录<li>from_entry &lt; to_entry， to_entry &gt; m，返回from_entry到m的记录<li>from_entry &lt; to_entry， from_entry&gt;m，返回元素个数为0的空数组<li>from_entry &gt; to_entry,返回错误</ul><li>insert_entry (data) 向一个数组插入一条新记录,插入到参数id标识的序号之后，特殊情况：0表示变第一个，大于m表示变最后一个<li>update_entry (data) 更新一个数组中的一天记录<li>remove_entries (data) 按范围删除数组，同retrieve_entries</ul><h3 id="s4412-communication-port-protection-class_id--124-version--0"><span class="mr-2">s4.4.12 Communication port protection (class_id = 124, version = 0)</span><a href="#s4412-communication-port-protection-class_id--124-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">保护通信端口</code>，防止恶意通信，如暴力破解</p><p>属性：</p><ul><li><p>protection_mode <code class="language-plaintext highlighter-rouge">保护模式</code>，</p><ul><li>锁定<li>失败尝试后锁定<li>无锁定</ul><li>allowed_failed_attempts 触发锁定机制之前允许的失败通信<code class="language-plaintext highlighter-rouge">尝试次数</code>。<li>initial_lockout_time 第一次触发锁定的<code class="language-plaintext highlighter-rouge">锁定时间</code><li><p>steepness_factor 锁定时间<code class="language-plaintext highlighter-rouge">递增步长</code></p><p>NCA=failed_attempts-allowed_failed_attempts CLT=initial_lockout_time x (steepness_factor^(NCA-1))</p><li>max_lockout_time <code class="language-plaintext highlighter-rouge">最大锁定时间</code>,避免拒绝服务攻击(DDoS)<li>port_reference 被保护端口对象的逻辑名<li>protection_status 当前保护状态，未锁定、临时锁定、已锁定<li>failed_attempts 失败总数，与保护机制触发无关，会被reset重置<li>cumulative_failed_attempts <code class="language-plaintext highlighter-rouge">失败总数</code>，与保护机制触发无关，不会被重置</ul><p>方法：</p><ul><li>reset (data) 重置failed_attempts、current lockout time、protection_status</ul><h2 id="s45-时间和事件绑定控件的接口类interface-classes-for-time--and-event-bound-control"><span class="mr-2">s4.5 时间和事件绑定控件的接口类Interface classes for time- and event bound control</span><a href="#s45-时间和事件绑定控件的接口类interface-classes-for-time--and-event-bound-control" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s451-clock-class_id--8-version--0"><span class="mr-2">s4.5.1 Clock (class_id = 8, version = 0)</span><a href="#s451-clock-class_id--8-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>该IC为设备时钟建模，管理所有与<code class="language-plaintext highlighter-rouge">日期和时间</code>相关的信息，包括由于时区和<code class="language-plaintext highlighter-rouge">夏令时</code>方案而导致的本地时间与通用时间参考(UTC)的偏差。IC还提供了各种调整时钟的方法</p><p>日期信息包括<code class="language-plaintext highlighter-rouge">“年”、“月”、“日”、“周”</code>。时间信息包括<code class="language-plaintext highlighter-rouge">小时、分钟、秒、百分之一秒</code>以及本地时间与UTC的<code class="language-plaintext highlighter-rouge">偏差</code>。夏令时功能根据属性修改本地时间与UTC的偏差;参见图20所示。该函数的起始点和结束点通常设置一次。内部算法根据这些设置计算出真正的开关点</p><p>属性：</p><ul><li>time 包含仪表的本地日期和时间，其与UTC的偏差和状态。格式为date-time。可只修改部分字段，如只修改日期，此时参数中时间字段需为”not specified”<li>time_zone 时区<li>status 状态<li>daylight_savings_begin 夏令时开始日期时间<li>daylight_savings_end 夏令时结束日期时间<li>daylight_savings_deviation 夏令时偏移（分钟）<li>daylight_savings_enabled 夏令时启用<li>clock_base 时钟信息依据<ul><li>无<li>内部晶振<li>市电频率50Hz<li>市电频率60Hz<li>GPS<li>无线电控制</ul></ul><p>方法：</p><ul><li>adjust_to_quarter (data) 将时间调整为最近(+/-)的整刻钟(*:00,*:15,*:30,*:45)<li>adjust_to_measuring_period (data) 将时间调整为最近(+/-)<code class="language-plaintext highlighter-rouge">测量周期</code>的起点<li>adjust_to_minute (data) 将时间调整为最近(+/-)整分钟<li>adjust_to_preset_time (data) 和preset_adjusting_time配合，激活preset_time，执行时的时间必须是时间范围内的<li>preset_adjusting_time (data) 定义一个预设时间preset_time和一个允许执行生效时间范围<li>shift_time (data) 将时间移动n (-900 &lt;= n &lt;= 900) s。n为long类型</ul><h3 id="s452-script-table-class_id--9-version--0"><span class="mr-2">s4.5.2 Script table (class_id = 9, version = 0)</span><a href="#s452-script-table-class_id--9-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>通过脚本执行一系列动作</p><p>脚本可由同一个逻辑设备内其他COSEM对象或从外部激活</p><p>同时执行时索引小的优先执行</p><p>属性：</p><ul><li>scripts 脚本，操作列表<ul><li>action_specification指向引用对象的动作（限制为<code class="language-plaintext highlighter-rouge">不产生响应</code>的动作），为一个数组，可以有多个动作<ul><li>写属性<li>执行方法</ul><li>service_id为1表示属性，2表示方法</ul></ul><p>方法：</p><ul><li>execute (data) 执行对应的脚本</ul><h3 id="s453-schedule-class_id--10-version--0"><span class="mr-2">s4.5.3 Schedule (class_id = 10, version = 0)</span><a href="#s453-schedule-class_id--10-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>计划时间表</p><p>属性：</p><ul><li>entries 给定时间执行的脚本<ul><li>script_logical_name <code class="language-plaintext highlighter-rouge">Script table</code>对象的逻辑名<li>script_selector <code class="language-plaintext highlighter-rouge">Script table</code>对象中的script_identifier<li>switch_time 执行时间，支持通配符，time格式<li>Validity_window 有效窗口（执行宽容时间），一个以分钟为单位的<code class="language-plaintext highlighter-rouge">时间段</code>。(switch_time和实际的power_up之间的时间，如果在开机前这个时间范围内触发则执行，否则不执行。<strong>触发时间switch_time到后在这个时间范围内必须执行，如果未及时上电导致执行不了，则不执行</strong>)。0xFFFF:脚本在任何时候都被处理; TODO:理解有待明确<li>exec_weekdays 定义每周执行的天<li>exec_specdays 见节日表“Special days table”, day_id<li>Begin_date和end_date 定义了条目有效的日期范围(允许通配符)</ul></ul><p>方法：</p><ul><li>enable/disable (data) A范围内的禁用，B范围内的启用<li>insert (data) 插入一条新记录，已存在覆盖<li>delete (data) 按索引范围删除记录</ul><p>Time setting <code class="language-plaintext highlighter-rouge">forward</code>：向后调整时间，调整至更晚的时间，此时操作和掉电相同，根据Validity_window补执行</p><p>Time setting <code class="language-plaintext highlighter-rouge">backward</code>：向前调整时间，调整至更早时间，会出现重复执行的情况</p><p>夏令时向后则执行错过的脚本，向前则不执行重复的脚本</p><h3 id="s454-special-days-table-class_id--11-version--0"><span class="mr-2">s4.5.4 Special days table (class_id = 11, version = 0)</span><a href="#s454-special-days-table-class_id--11-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>定义特殊日期，特殊日期行为会覆盖通常的，与Schedule” 或 “Activity calendar” 同时执行</p><p>为给定日期指定特殊的日期标识符。日期可能具有重复特殊日子的通配符，如圣诞节。</p><p>属性：</p><p>entries 数组，每个条目表示一个特殊日期，如圣诞节</p><p>方法：</p><p>insert (data) 向entires插入一条记录，会覆盖 delete (data) 删除一条</p><h3 id="s455-activity-calendar-class_id--20-version--0"><span class="mr-2">s4.5.5 Activity calendar (class_id = 20, version = 0)</span><a href="#s455-activity-calendar-class_id--20-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>按计划执行脚本，遵循日历时间表方式，（和费率相关？）TODO：和Schedule的区别 更新：比Schedule更加具体，类似于cron表达式</p><p>可与<code class="language-plaintext highlighter-rouge">Schedule</code>对象<code class="language-plaintext highlighter-rouge">共存</code>，重叠时<code class="language-plaintext highlighter-rouge">Schedule</code>对象<code class="language-plaintext highlighter-rouge">优先执行</code></p><p>被Special days table覆盖</p><p>属性：</p><ul><li>calendar_name_active 标识符<li>season_profile_active 季节方案，包含季节开始时间和对应的week方案<li>week_profile_table_active 周方案，包括一周中每天的方案<li>day_profile_table_active 日方案，包含脚本执行时间、Script table对象内脚本的引用<li>calendar_name_passive 备用方案<li>season_profile_passive 备用方案<li>week_profile_table_passive 备用方案<li>day_profile_table_passive 备用方案<li>activate_passive_calendar_time 调用activate_passive_calendar的时间</ul><p>方法：</p><ul><li>activate_passive_calendar (data) <code class="language-plaintext highlighter-rouge">激活备用方案</code>，将passive属性复制到active中</ul><h3 id="s456-register-monitor-class_id--21-version--0"><span class="mr-2">s4.5.6 Register monitor (class_id = 21, version = 0)</span><a href="#s456-register-monitor-class_id--21-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>这个IC允许对 “Data” , “Register”, “Extended register” or “Demand register”对象的值进行建模<code class="language-plaintext highlighter-rouge">监控</code>。</p><p>监控用于在特定条件下触发脚本。</p><p>它允许指定阈值、监测的值和一组脚本，当监测的值超过阈值时，这些脚本将被执行。依赖于同一逻辑设备内的Script table对象</p><p>属性：</p><ul><li>thresholds 提供将引用寄存器的属性与之比较的<code class="language-plaintext highlighter-rouge">阈值</code>。<li>monitored_value 定义监视对象的哪个<code class="language-plaintext highlighter-rouge">属性</code>。只允许具有<code class="language-plaintext highlighter-rouge">简单数据类型</code>的值<li>actions 定义被引用对象的监视属性<code class="language-plaintext highlighter-rouge">超过</code>相应<code class="language-plaintext highlighter-rouge">阈值</code>时要执行的<code class="language-plaintext highlighter-rouge">脚本</code>。属性操作具有与属性阈值完全<code class="language-plaintext highlighter-rouge">相同</code>的<code class="language-plaintext highlighter-rouge">元素数量</code>。action_items的顺序与阈值的<code class="language-plaintext highlighter-rouge">顺序对应</code></ul><h3 id="s457-single-action-schedule-class_id--22-version--0"><span class="mr-2">s4.5.7 Single action schedule (class_id = 22, version = 0)</span><a href="#s457-single-action-schedule-class_id--22-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>执行定时任务 TODO:和Schedule的区别</p><ul><li>executed_script Script table对象的引用<li>type execution_time内时间是否相同，是否允许通配符<li>execution_time 脚本执行日期和时间</ul><h3 id="s458-disconnect-control-class_id--70-version--0"><span class="mr-2">s4.5.8 Disconnect control (class_id = 70, version = 0)</span><a href="#s458-disconnect-control-class_id--70-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>拉合闸控制，管理电表的内部或外部<code class="language-plaintext highlighter-rouge">断开装置</code>（例如电闸、燃气阀），以便部分或全部地连接或断开用户的电源。</p><p>三种方式：</p><ol><li><code class="language-plaintext highlighter-rouge">远程</code>Remotely，通过通信端口<li><code class="language-plaintext highlighter-rouge">手动</code>Manually，如按按钮<li><code class="language-plaintext highlighter-rouge">本地</code>Locally，电表内部功能触发，如limiter对象</ol><p>属性：</p><ul><li>output_state 设备supply实际的物理连接状态<li>control_state 内部控制连接状态<ul><li>(0) Disconnected<li>(1) Connected<li>(2) Ready_for_reconnection</ul><li>control_mode 控制模式，每一条对应3种控制方式的控制权限</ul><p>方法：</p><ul><li>remote_disconnect (data) <code class="language-plaintext highlighter-rouge">远程断开连接</code>，需要有权限<li>remote_reconnect (data) <code class="language-plaintext highlighter-rouge">远程恢复连接</code>，需要有权限</ul><h3 id="s459-limiter-class_id--71-version--0"><span class="mr-2">s4.5.9 Limiter (class_id = 71, version = 0)</span><a href="#s459-limiter-class_id--71-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>限制器，当“Data”, “Register”, “Extended Register”,“Demand Register”对象超过阈值一定时间时执行动作</p><p>TODO:和4.5.6 Register monitor的区别，应该是比后者更加详细，这个是超过一定时间加上更多种阈值。</p><p>阈值包括<code class="language-plaintext highlighter-rouge">正常阈值</code>和<code class="language-plaintext highlighter-rouge">紧急阈值</code>。<code class="language-plaintext highlighter-rouge">紧急阈值</code>通过emergency profile id, emergency activation time, and emergency duration定义的<code class="language-plaintext highlighter-rouge">emergency_profile</code>激活。emergency profile id元素与emergency profile group id匹配:这种机制只允许针对特定的emergency group激活紧急阈值。</p><ul><li>monitored_value 定义<code class="language-plaintext highlighter-rouge">要监控</code>的对象的<code class="language-plaintext highlighter-rouge">属性</code>。只允许具有<code class="language-plaintext highlighter-rouge">简单数据类型</code>的属性。<li>threshold_active 活动阈值<li>threshold_normal 正常阈值<li>threshold_emergency 紧急阈值<li>min_over_threshold_duration 超过阈值最小持续时间，秒<li>min_under_threshold_duration 低于阈值的最小持续时间<li>emergency_profile 紧急配置,用于紧急阈值激活，当emergency_profile_id和emergency_profile_id中的匹配，且当前时间在从emergency_activation_time开始emergency_duration范围内时激活<li>emergency_profile_group_id_list emergency_profile_id列表<li>emergency_profile_active emergency_profile激活状态<li>actions 超过或低于阈值超过最小持续时间时的<code class="language-plaintext highlighter-rouge">动作(script)</code></ul><h3 id="s4510-parameter-monitor-class_id--65-version--1"><span class="mr-2">s4.5.10 Parameter monitor (class_id = 65, version = 1)</span><a href="#s4510-parameter-monitor-class_id--65-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>监控参数修改（某些COSEM对象的属性用于表示配置参数）</p><p>可使用profile generic对象捕获，生成profile</p><p>每个可以访问服务器的客户端都必须知道当前的参数设置，以便能够正确地与服务器交换数据。参数可以分组，每个组可以有一个名称。</p><p>尽管最初的参数可能是已知的，但在电表的生命周期内可能会<code class="language-plaintext highlighter-rouge">发生变化</code>，例如它可能<code class="language-plaintext highlighter-rouge">被另一个客户</code>（如现场服务设备）改变。</p><p>当前的配置可能总是通过在交换开始时<code class="language-plaintext highlighter-rouge">读取配置参数</code>来检索。这并<code class="language-plaintext highlighter-rouge">不高效</code>，而且在推送操作的情况下，这并不实用。</p><p>需要一个解决方案，允许客户验证服务器的配置是否符合预期，或<code class="language-plaintext highlighter-rouge">检测是否发生了任何变化</code>。</p><p>属性：</p><ul><li>changed_parameter 保存最近更新的参数及其值（一个属性和一个值）TODO:choice类型的数据的profile捕获如何保证数据等长<li>capture_time 捕获时间，记录何时捕获<li>parameter_list 本对象管理的参数列表<li>parameter_list_name 参数列表名<li>hash_algorithm_id 摘要算法<li>parameter_value_digest 参数<code class="language-plaintext highlighter-rouge">值</code>摘要，整个parameter_list内属性的值需要先<code class="language-plaintext highlighter-rouge">转octet-string</code>（如果不是octet-string）<li>parameter_values parameter_list内属性的值,一个结构体，包含A-XDR编码的每个属性值</ul><p>方法：</p><ul><li>add_parameter (data) 向parameter_list添加一个<li>delete_parameter (data) 从parameter_list删除一个</ul><h3 id="s4511-sensor-manager-class_id--67-version--0"><span class="mr-2">s4.5.11 Sensor manager (class_id = 67, version = 0)</span><a href="#s4511-sensor-manager-class_id--67-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>传感器和测量值监控（除了电表之外的其他计量设备用得比较多）</p><ul><li>传感器装置的识别<li>传感器的连接和密封状态<li>传感器的配置<li>监测传感器的运行情况<li>对处理后的结果的监控</ul><p>属性：</p><ul><li>serial_number 序列号，标识传感器设备<li>metrological_identification 计量标识符，TODO:传感器的参数信息?<li>output_type 输出类型<li>adjustment_method 调整方法<li>sealing_method 密封（保护）方式<ul><li>物理方式（铅封、密封贴纸等）<li>电气方式（）<li>软件方式（密码）</ul><li>raw_value 原始记录值<li>scaler_unit 原始记录值的单位<li>status 状态（失败/启用/禁用）<li>capture_time raw_value捕获时间<li>raw_value_thresholds raw_value阈值<li>raw_value_actions 超过阈值执行的脚本，参考Register monitor类<li>processed_value raw_value处理后的值<li>processed_value_thresholds processed_value阈值<li>processed_value_actions 超过阈值执行的脚本(如告警位置位)</ul><p>方法：</p><ul><li>reset (data) 重置raw_value</ul><h3 id="s4512-arbitrator-class_id--68-version--0"><span class="mr-2">s4.5.12 Arbitrator (class_id = 68, version = 0)</span><a href="#s4512-arbitrator-class_id--68-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>仲裁者，允许根据由<code class="language-plaintext highlighter-rouge">权限</code>和<code class="language-plaintext highlighter-rouge">权重</code>组成的预先配置的规则，在<code class="language-plaintext highlighter-rouge">多个参与者</code>可能请求可能<code class="language-plaintext highlighter-rouge">相互冲突</code>的操作来控制<code class="language-plaintext highlighter-rouge">同一资源</code>时，执行哪些<code class="language-plaintext highlighter-rouge">操作</code>。</p><ul><li><code class="language-plaintext highlighter-rouge">配置</code>可能被请求的、潜在冲突的<code class="language-plaintext highlighter-rouge">动作</code>;<li><code class="language-plaintext highlighter-rouge">配置</code>每个参与者请求可能操作的<code class="language-plaintext highlighter-rouge">权限</code>;<li>为每个可能的请求<code class="language-plaintext highlighter-rouge">配置</code>每个参与者的<code class="language-plaintext highlighter-rouge">权重</code>。</ul><p><code class="language-plaintext highlighter-rouge">资源</code>的<code class="language-plaintext highlighter-rouge">例子</code>是<code class="language-plaintext highlighter-rouge">供应控制开关</code>或仪表的<code class="language-plaintext highlighter-rouge">气体阀门</code>。可能的<code class="language-plaintext highlighter-rouge">动作</code>包括<code class="language-plaintext highlighter-rouge">断开电源</code>、<code class="language-plaintext highlighter-rouge">使能重新连接</code>、重新连接电源、防止断开连接、防止重新连接。</p><p>属性：</p><ul><li>actions 动作，对<code class="language-plaintext highlighter-rouge">script table</code>对象的引用<li>permissions_table 每个参与者<code class="language-plaintext highlighter-rouge">权限</code>，数组每个元素对应每个用户的权限，是个位串，其中的位串中每一位对应每个动作权限（与actions对应）<li>weightings_table 每个参与者<code class="language-plaintext highlighter-rouge">权重</code>，和permissions_table结构顺序一样，不过把<code class="language-plaintext highlighter-rouge">位串换成了数组</code>，元素是long-unsigned（最好是2的幂）<li>most_recent_requests_table 记录每个用户的最近请求，与permissions_table结构相同，位串中已执行的置位，不一定只有一个。位的清除在下一次的request_action发生<li>last_outcome 最近一次请求结果，标识actions中的元素的序号，只针对actions，不针对用户</ul><p>方法：</p><ul><li><p>request_action (data) <code class="language-plaintext highlighter-rouge">封装动作执行请求</code>，request_actor表示请求用户，request_action_list表示请求动作列表，一次可执行多个</p><p>为什么可以一次请求多个操作：例子，可以做出一连串操作如<strong>disconecting supply同时关闭reconnect功能</strong>，同时做这两个操作可以防止其他用户修改该状态</p><li><p>reset (data) 重置位（权限位，权重元素，最近执行位，最近请求结果）</p><p>当权限位都是0时，request_action调用总是不会成功，因为都没权限</p></ul><p>TODO:两张示例分析</p><p>当<code class="language-plaintext highlighter-rouge">request_action</code>方法被<code class="language-plaintext highlighter-rouge">actor</code>调用时，<code class="language-plaintext highlighter-rouge">AP</code>执行以下活动:</p><ol><li>它检查给定actor的<code class="language-plaintext highlighter-rouge">permissions_table</code>属性条目，以确定请求的动作<code class="language-plaintext highlighter-rouge">是否允许</code>;<li>它<code class="language-plaintext highlighter-rouge">更新most_recent_requests_table</code>属性，通过<code class="language-plaintext highlighter-rouge">设置或清除</code>该actor的每个动作的位串中也被允许的<code class="language-plaintext highlighter-rouge">位</code>(位设置);或者没有请求/不允许(位被清除);<em>相当于request_action请求参数和permissions_table的交集，有请求且允许才置位</em><li>它为most_recent_requests_table应用<code class="language-plaintext highlighter-rouge">weightings_table</code>:对于most_recent_requests_table中设置的每个位，每个actor的相应权重被应用;<em>这里应该有个临时的表保持这个信息</em><li>每个动作的权重做统计，如果一个动作中有一个<code class="language-plaintext highlighter-rouge">唯一</code>的<code class="language-plaintext highlighter-rouge">最高权重值</code>，这个值会被写入<code class="language-plaintext highlighter-rouge">last_outcome</code>属性并执行相应的脚本。如果没有最高的<code class="language-plaintext highlighter-rouge">唯一</code>权重，那么<code class="language-plaintext highlighter-rouge">什么也不会发生</code>。 TODO:相同权重都不执行了吗？</ol><h2 id="s46-支付计量相关接口类payment-metering-related-interface-classes"><span class="mr-2">s4.6 支付计量相关接口类Payment metering related interface classes</span><a href="#s46-支付计量相关接口类payment-metering-related-interface-classes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s462-account-class_id--111-version--0"><span class="mr-2">s4.6.2 Account (class_id = 111, version = 0)</span><a href="#s462-account-class_id--111-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>用于计费，每个Account可以关联数个“Credit”, “Charge” and the “Token gateway”对象</p><p>比如入口消耗电网的电用一个账户Account，家里有发电出口给电网是第二个账户Account，单独计费</p><p><code class="language-plaintext highlighter-rouge">Credit</code>: <code class="language-plaintext highlighter-rouge">信用额度</code>，比如一个对象用来做token额度，一个用于紧急额度</p><p><code class="language-plaintext highlighter-rouge">Charge</code>：<code class="language-plaintext highlighter-rouge">费用统计</code>，比如一个用于能源使用，一个用于固定收费（月费），一个用于安装费用。</p><p>统计方式：</p><ol><li>基于能量消耗量和费率的<li>基于时间的，如月固定费用<li>手续费，每次充值时收取</ol><p>属性：</p><ul><li>account_mode_and_status <code class="language-plaintext highlighter-rouge">付费模式</code>（<code class="language-plaintext highlighter-rouge">后付费</code>credit和<code class="language-plaintext highlighter-rouge">预付费</code>prepayment）和账户<li>current_credit_in_use 正在使用（<code class="language-plaintext highlighter-rouge">In use</code>）的<code class="language-plaintext highlighter-rouge">credit对象</code>的<code class="language-plaintext highlighter-rouge">引用</code><li>current_credit_status 正在使用的<code class="language-plaintext highlighter-rouge">credit对象状态</code><li>available_credit <code class="language-plaintext highlighter-rouge">总可用额度</code>，只计算<code class="language-plaintext highlighter-rouge">正值</code>，本对象关联的可用的（status为Selected/Invoked或In use）Credit对象中<code class="language-plaintext highlighter-rouge">current_credit_amount总和</code><li><p>amount_to_clear 和available_credit类似，是负值的总和</p><ul><li>Credit对象中的所有<code class="language-plaintext highlighter-rouge">current_credit_amount负值</code>（credit_status = (4) Exhausted和credit_configuration bit 2未置位）<li>Credit对象中的credit_configuration bit 2置位的（需要偿还）的<code class="language-plaintext highlighter-rouge">额度的差值</code>(和preset_credit_amount)的负值（value * -1）<li><code class="language-plaintext highlighter-rouge">clearance_threshold</code>的负值（value * -1）</ul><li>clearance_threshold amount_to_clear的阈值<li>aggregated_debt <code class="language-plaintext highlighter-rouge">合计欠款</code>，Charge对象的<code class="language-plaintext highlighter-rouge">total_amount_remaining</code>的简单合计<li>credit_reference_list credit对象关联列表<li>charge_reference_list charge对象关联列表<li><p>credit_charge_configuration 这个属性映射出哪些<code class="language-plaintext highlighter-rouge">Charge</code>将<code class="language-plaintext highlighter-rouge">从哪些Credits</code>中收取。</p><p>无条目表示无限制</p><p>Credit必须搭配一个或多个Charge采集使用，否则不会被消耗</p><p>包含credit和charge对象的引用</p><p>collection_configuration：</p><ul><li>Bit 0 允许电源断开时采集<li>Bit 1 允许在负载限制期间采集<li>Bit 2 允许在友好信用期内采集</ul><li>token_gateway_configuration 此属性用于配置如何<code class="language-plaintext highlighter-rouge">分配</code>来自“<code class="language-plaintext highlighter-rouge">token_gateway</code>”的新的<code class="language-plaintext highlighter-rouge">充值token</code>，以便将token数量的<code class="language-plaintext highlighter-rouge">可配置百分比</code>分配给每个“Credit”对象。<li>account_activation_time 调用activate_account的时间<li>account_closure_time 调用close_account的时间<li>currency 本对象的所有方法使用的单位，可以为货币单位、时间、计量单位等<li>low_credit_threshold <code class="language-plaintext highlighter-rouge">低额度阈值</code>，引用credit的warning_threshold属性，可以用于低额度时告警<li>next_credit_available_threshold <code class="language-plaintext highlighter-rouge">下一个优先级</code>(如果是优先级顺序)credit对象的available_credit阈值 TODO：等Credit看完<li>max_provision 最大规定，当Charge为(2) payment_event_based_collection TODO：什么意思<li>max_provision_period 最大规定周期</ul><p>方法：</p><ul><li>activate_account (data) 激活账户，本对象的account_mode_and_status和account_activation_time修改<li>close_account (data) 本对象的account_mode_and_status和account_closure_time修改<li>reset_account (data) account_status为close状态下重置所有属性,为1或2时不操作</ul><h3 id="s463-credit-class_id--112-version--0"><span class="mr-2">s4.6.3 Credit (class_id = 112, version = 0)</span><a href="#s463-credit-class_id--112-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>可用额度，激活时用于抵扣Charge</p><p>属性：</p><ul><li>current_credit_amount 本对象当前可用额度<li>credit_type 类型<ul><li>(0) token_credit <code class="language-plaintext highlighter-rouge">预付费</code>方式<code class="language-plaintext highlighter-rouge">充值的余额</code>，一般是<code class="language-plaintext highlighter-rouge">token</code>方式<li>(1) reserved_credit <code class="language-plaintext highlighter-rouge">特定情况</code>可使用的信用额度<li>(2) emergency_credit <code class="language-plaintext highlighter-rouge">紧急额度</code>，紧急额度使用后在下次重置的时候抵扣补充<li>(3) time_based_credit <code class="language-plaintext highlighter-rouge">按照时间</code>产生的额度<li>(4) consumption_based_credit <code class="language-plaintext highlighter-rouge">预定义</code>信用额度</ul><li>priority <code class="language-plaintext highlighter-rouge">激活优先级</code>，1为最高，255最低，1-255不允许重复，0表示永不激活，可重复。优先级为0的不会出现在Account对象的credit_reference_list中<li>warning_threshold <code class="language-plaintext highlighter-rouge">警告阈值</code>，监控current_credit_amount，与Account对象中的low_credit_theshold关联<li>limit <code class="language-plaintext highlighter-rouge">耗尽阈值</code>，当<code class="language-plaintext highlighter-rouge">current_credit_amount</code>小于阈值时credit_status变为耗尽<code class="language-plaintext highlighter-rouge">Exhausted</code><li>credit_configuration 配置本对象行为<ul><li>Bit0 需要<code class="language-plaintext highlighter-rouge">视觉指示</code>(如液晶屏)<li>Bit1 在credit_status切换到Selected/Invoked之前<code class="language-plaintext highlighter-rouge">需要确认</code>（如按键）<li>Bit2 <code class="language-plaintext highlighter-rouge">需要偿还</code>的信用额度<li>Bit3 <code class="language-plaintext highlighter-rouge">可重置</code><li>Bit4 能够从<code class="language-plaintext highlighter-rouge">token</code>接收信用额度</ul><li>credit_status 预付费应用使用，指示状态<ul><li>Enable: <code class="language-plaintext highlighter-rouge">启用</code>，但还不能使用，会在credit_reference_list中<li>Selectable: <code class="language-plaintext highlighter-rouge">可选择的</code>，需要其他<code class="language-plaintext highlighter-rouge">命令</code>才能<code class="language-plaintext highlighter-rouge">激活</code>，还不能使用<li>Selected/Invoked：<code class="language-plaintext highlighter-rouge">已选择</code>，<code class="language-plaintext highlighter-rouge">已激活</code>，处于排队状态<li>In use：<code class="language-plaintext highlighter-rouge">正在使用中</code><li>Exhausted：额度已<code class="language-plaintext highlighter-rouge">耗尽</code></ul><li><p>preset_credit_amount <code class="language-plaintext highlighter-rouge">初始额度</code></p><p>会<code class="language-plaintext highlighter-rouge">累加</code>到<code class="language-plaintext highlighter-rouge">current_credit_amount</code>属性的情况：</p><ul><li>credit_status转换为(2)<code class="language-plaintext highlighter-rouge">Selected/Invoked</code>，且credit_configuration <code class="language-plaintext highlighter-rouge">bit 1</code>(切换需确认)置位，且被<code class="language-plaintext highlighter-rouge">确认</code><li>credit_status从不为(4)<code class="language-plaintext highlighter-rouge">Exhausted</code>状态转换为(3)<code class="language-plaintext highlighter-rouge">In use</code>，且credit_configuration <code class="language-plaintext highlighter-rouge">bit 1</code>置位未置位<li>当调用<code class="language-plaintext highlighter-rouge">invoke_credit</code>方法时，且credit_configuration <code class="language-plaintext highlighter-rouge">bit 2</code>置位<li><code class="language-plaintext highlighter-rouge">period</code> 里date_time发生时，这是隐式的</ul><p>如果<code class="language-plaintext highlighter-rouge">不需要</code>初始额度就设置为0，这种情况下可以通过<code class="language-plaintext highlighter-rouge">token充值</code>或<code class="language-plaintext highlighter-rouge">调用方法</code>方式增加<code class="language-plaintext highlighter-rouge">current_credit_amount</code></p><p>如果credit_type是<code class="language-plaintext highlighter-rouge">emergency_credit</code>：</p><ul><li>该值preset_credit_amount需要被使用<li><p>只在以下情况可用token充值</p><ul><li>status为(3) <code class="language-plaintext highlighter-rouge">In use</code> or (4) <code class="language-plaintext highlighter-rouge">Exhausted</code><li>且部分或全部额度<code class="language-plaintext highlighter-rouge">被使用</code><li>且credit_configuration <code class="language-plaintext highlighter-rouge">bit 2</code>(需要偿还)置位</ul></ul><blockquote><p>当<code class="language-plaintext highlighter-rouge">current_credit_amount</code>达到<code class="language-plaintext highlighter-rouge">limit</code>时，<code class="language-plaintext highlighter-rouge">credit_status</code>属性将变成<code class="language-plaintext highlighter-rouge">（4）Exhausted</code>。如果<code class="language-plaintext highlighter-rouge">credit_configuration bit 2</code>（要求偿还的信用额度）被<code class="language-plaintext highlighter-rouge">设置</code>，那么使用的信用额度是<code class="language-plaintext highlighter-rouge">preset_credit_amount</code>和<code class="language-plaintext highlighter-rouge">current_credit_amount</code>之间的<code class="language-plaintext highlighter-rouge">差值</code>（正值），通常是通过增加一个<code class="language-plaintext highlighter-rouge">token充值</code>或通过<code class="language-plaintext highlighter-rouge">调用一个方法</code>来偿还。在偿还信贷后，<code class="language-plaintext highlighter-rouge">current_credit_amount</code>将变<code class="language-plaintext highlighter-rouge">0</code>（等待下次激活把preset_credit_amount加上），当amount_to_clear=0时<code class="language-plaintext highlighter-rouge">credit_status</code>将变<code class="language-plaintext highlighter-rouge">（0）Enabled</code>（还清了）;当amount_to_clear小于0时，<code class="language-plaintext highlighter-rouge">credit_status</code>将变<code class="language-plaintext highlighter-rouge">（4）Exhausted</code>(没还清)</p></blockquote><li><p>credit_available_threshold 与“Account”对象<code class="language-plaintext highlighter-rouge">available_credit</code>相关联的<code class="language-plaintext highlighter-rouge">阈值</code>。</p><p>当“Account”对象的<code class="language-plaintext highlighter-rouge">available_credit</code>缩减到下一个优先级的Credit对象的credit_available_threshold时（此时该对象还是enable状态，不在credit_reference_list属性里，不计入available_credit），credit_status设置为：</p><ul><li>Selectable (1) if the credit_configuration bit 1 (Requires confirmation) is set<li>Selected/Invoked (2) if the credit_configuration bit 1 (Requires confirmation) is cleared</ul><li>period 在<code class="language-plaintext highlighter-rouge">credit_type = 3</code> (time_based_credit)或<code class="language-plaintext highlighter-rouge">credit_type = 4</code> (consumption_based_credit)时，该属性<code class="language-plaintext highlighter-rouge">保存</code>将<code class="language-plaintext highlighter-rouge">current_credit_amount</code>自动设置为<code class="language-plaintext highlighter-rouge">preset_credit_amount</code>的<code class="language-plaintext highlighter-rouge">时间</code>。</ul><p>方法：</p><ul><li>update_amount (data) 调整<code class="language-plaintext highlighter-rouge">current_credit_amount</code>属性的值,<code class="language-plaintext highlighter-rouge">主要是正值</code>，负值也允许<li>set_amount_to_value (data) 设置<code class="language-plaintext highlighter-rouge">current_credit_amount</code>属性的值，返回值为配置前的值<li>invoke_credit (data) 将“Credit”对象的credit_status改为(2)Selected/Invoked或(1) Selectable（取决于credit_configuration bit 1）</ul><h3 id="s464-charge-class_id--113-version--0"><span class="mr-2">s4.6.4 Charge (class_id = 113, version = 0)</span><a href="#s464-charge-class_id--113-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>total_amount_paid 本对象<code class="language-plaintext highlighter-rouge">总金额</code>，一般不重置<li><p>charge_type 收费类型</p><ul><li>(0) consumption_based_collection <code class="language-plaintext highlighter-rouge">按量计费</code><li>(1) time_based_collection <code class="language-plaintext highlighter-rouge">时间计费</code><li>(2) payment_event_based_collection <code class="language-plaintext highlighter-rouge">支付事件计费</code>（<code class="language-plaintext highlighter-rouge">手续费</code>，比如用新的token充值需要手续费）</ul><li>priority 优先级和Credit类相同,大于0的必须出现在“Account”对象charge_reference_list中<li><p>unit_charge_active 根据相关的“<code class="language-plaintext highlighter-rouge">Account</code>”实例的<code class="language-plaintext highlighter-rouge">货币</code>属性，以及相关的由<code class="language-plaintext highlighter-rouge">commodities _reference</code>结构标识的对象的<code class="language-plaintext highlighter-rouge">scaler_unit</code>属性，定义<code class="language-plaintext highlighter-rouge">有效价格</code>，即每<code class="language-plaintext highlighter-rouge">消耗量</code>、每<code class="language-plaintext highlighter-rouge">时间</code>或每<code class="language-plaintext highlighter-rouge">收到的付款</code>所收取的金额。</p><ul><li>charge_per_unit_scaling_type <code class="language-plaintext highlighter-rouge">每单位收费缩放</code>，包含消耗量单位缩放（<code class="language-plaintext highlighter-rouge">10的指数</code>，如10^3kWh为一单位），<code class="language-plaintext highlighter-rouge">单位价格缩放</code>（关联Account中的currency_scale属性中currency元素，10的指数）<li>commodity_reference_type <code class="language-plaintext highlighter-rouge">消耗量依据</code>，只在charge_type = (0) consumption_based_collection时生效，标识一个寄存器对象的scaler_unit（量纲）属性的引用，如电量<li>charge_table charge_per_unit是基于charge_per_unit_scaling_type的缩放生成的<code class="language-plaintext highlighter-rouge">每单位价格值</code>，index表示在按量计费模式下不同的费率模式，其他模式为0</ul><li>unit_charge_passive unit_charge的<code class="language-plaintext highlighter-rouge">备用方案</code>，和unit_charge_active结构相同，激活时拷贝到unit_charge_active中<li>unit_charge_activation_time 调用<code class="language-plaintext highlighter-rouge">激活方法</code>的<code class="language-plaintext highlighter-rouge">时间</code><li>period 表示Charge<code class="language-plaintext highlighter-rouge">采集周期</code>，仅当charge_type = (0) consumption_based_collection 或 (1) time_based_collection<li><p>charge_configuration 采集方式</p><ul><li>bit 0: <code class="language-plaintext highlighter-rouge">比例方式</code>，用于charge_type = (2) payment_event_based_collection<li>bit 1: <code class="language-plaintext highlighter-rouge">不间断采集方式</code>，置位后total_amount_remaining为0时依旧采集，否则不采集</ul><li>last_collection_time <code class="language-plaintext highlighter-rouge">上次采集时间</code><li>last_collection_amount <code class="language-plaintext highlighter-rouge">上次收集金额</code><li>total_amount_remaining 总剩余金额 TODO:什么意思<li>proportion 手续费<code class="language-plaintext highlighter-rouge">比例</code>，仅当charge_type = (2) payment_event_based_collection有效</ul><p>方法：</p><ul><li>update_unit_charge (data) 更新unit_charge_passive<li>activate_passive_unit_charge (data) 启用备用方案unit_charge_passive<li>collect (data) charge_type 不为 (0) consumption_based_collection时生效，采集在unit_charge_active定义的数据<li>update_total_amount_remaining (data) 更新total_amount_remaining<li>set_total_amount_remaining (data) 设置total_amount_remaining</ul><h3 id="s465-token-gateway-class_id--115-version--0"><span class="mr-2">s4.6.5 Token gateway (class_id = 115, version = 0)</span><a href="#s465-token-gateway-class_id--115-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>属性：</p><ul><li>token 包含最近接收到的未处理的octet string或用于在history profile中捕获的token。<li>token_time 最近接收和处理token的时间<li>token_description 最近接收和处理的token的描述<li><p>token_delivery_method 最近接收的token的接收方式</p><ul><li>远程通信<li>本地通信<li>手动输入</ul><li>token_status token状态（接收，处理，校验，认证）</ul><p>方法：</p><ul><li>enter (data) 以octet-string格式传入token</ul><p>Max credit limit: 达到可用额度上限，不能充值token</p><p>Max vend limit: 达到单次充值上限，不能充值token</p><h3 id="s466-iec-62055-41-attributes-class_id--116-version-0"><span class="mr-2">s4.6.6 IEC 62055-41 Attributes (class_id = 116, version =0)</span><a href="#s466-iec-62055-41-attributes-class_id--116-version-0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">IEC 62055-41</code>数据元素的选择，这些元素是管理在DLMS服务器中实现的<code class="language-plaintext highlighter-rouge">STS</code>功能所必需的。</p><ul><li>meter_pan MeterPrimaryAccountNumber<li>commodity 计量用途名称，“ELECTRICITY”, “WATER”, “GAS”, or “TIME”<li>token_carrier_types<li>encryption_algorithm<li>supply_group_code<li>tariff_index<li>key_revision_number<li>key_type<li>key_expiry_number<li>no_of_kct_supported<li>sts_certificate_no</ul><h2 id="s47-通过本地端口和调制解调器建立数据交换的接口类interface-classes-for-setting-up-data-exchange-via-local-ports-and-modems"><span class="mr-2">s4.7 通过本地端口和调制解调器建立数据交换的接口类Interface classes for setting up data exchange via local ports and modems</span><a href="#s47-通过本地端口和调制解调器建立数据交换的接口类interface-classes-for-setting-up-data-exchange-via-local-ports-and-modems" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s471-iec-local-port-setup-class_id--19-version--1"><span class="mr-2">s4.7.1 IEC local port setup (class_id = 19, version = 1)</span><a href="#s471-iec-local-port-setup-class_id--19-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>default_mode 定义端口上仪表使用的协议</p><ul><li>IEC 62056-21:2002 (modes A…E)<li>IEC 62056-46:2002/AMD1:2006<li>协议未指定</ul><li>default_baud 起始波特率<li>prop_baud 建议波特率<li>response_time 接收到请求到发送回复的最小时间<li>device_addr IEC 62056-21:2002定义<li>pass_p1 IEC 62056-21:2002定义<li>pass_p2 IEC 62056-21:2002定义<li>pass_w5 IEC 62056-21:2002定义</ul><h3 id="s472-iec-hdlc-setup-class_id--23-version--1"><span class="mr-2">s4.7.2 IEC HDLC setup (class_id = 23, version = 1)</span><a href="#s472-iec-hdlc-setup-class_id--23-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>comm_speed 对应端口支持的通信速度</p><p>(0) 300 baud, (1) 600 baud, (2) 1 200 baud, (3) 2 400 baud, (4) 4 800 baud, (5) 9 600 baud, (6) 19 200 baud, (7) 38 400 baud, (8) 57 600 baud, (9) 115 200 baud</p><li>window_size_transmit 发送窗口大小<li>window_size_receive 接收窗口大小<li>max_info_field_length_transmit 最大发送长度<li>max_info_field_length_receive 最大接受长度<li>inter_octet_time_out 接收超时，超时未接收到新字符时视为完整报文<li>inactivity_time_out 超时断开<li>device_address 物理设备地址</ul><h3 id="s473-iec-twisted-pair-1-setup-class_id--24-version--1"><span class="mr-2">s4.7.3 IEC twisted pair (1) setup (class_id = 24, version = 1)</span><a href="#s473-iec-twisted-pair-1-setup-class_id--24-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>允许通过IEC 62056-3-1:2021中规定的带有载波信号的中<code class="language-plaintext highlighter-rouge">绞线对</code>建立数据交换。可配置多个通信通道</p><h3 id="s474-modem-configuration-class_id--27-version--1"><span class="mr-2">s4.7.4 Modem configuration (class_id = 27, version = 1)</span><a href="#s474-modem-configuration-class_id--27-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>和模块间的数据传输配置</p><ul><li>comm_speed 通信速度，波特率<li>initialization_string 初始化命令<li>modem_profile 海斯命令集（Hayes standard commands，AT命令）映射</ul><h3 id="s475-auto-answer-class_id--28-version--2"><span class="mr-2">s4.7.5 Auto answer (class_id = 28, version = 2)</span><a href="#s475-auto-answer-class_id--28-version--2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>自动接听</p><ul><li><p>mode 自动接听工作模式</p><ul><li>(0) 设备专用线路<li>(1) 共享线路管理，允许有限数量的呼叫。一旦达到了<code class="language-plaintext highlighter-rouge">调用的数量</code>，窗口状态就变成不活动，直到下一个开始日期，无论调用的结果是什么<li>(2) 共享线路管理，允许有限数量的成功呼叫。一旦达到了<code class="language-plaintext highlighter-rouge">成功通信的数量</code>，窗口状态就会变得不活动，直到下一个开始日期<li>(3) 目前没有连接调制解调器<li>(200…255) 制造商特定的模式</ul><li><p>listening_window 定义<code class="language-plaintext highlighter-rouge">通信窗口</code><code class="language-plaintext highlighter-rouge">活跃</code>(start_time)和<code class="language-plaintext highlighter-rouge">不活跃</code>(end_time)的时间点。start_time隐式地定义周期。</p><p>允许not specified（0xFF）表示每月每日重复</p><li><p>status 通信窗口状态</p><ul><li>(0)未激活:设备将不会管理新的来电。当下一次监听窗口启动时，该状态将自动重置为Active<li>(1)主动:设备可以接听下一个来电<li>(2)锁定:该值可以由设备或特定的客户端自动设置，当该客户端完成其读取会话，并希望在窗口持续时间结束前将行返回给客户。当下一次监听窗口启动时，该状态将自动重置为Active</ul><li>number_of_calls mode为1或2时，最大呼叫数量<li>number_of_rings TODO:ring是什么意思？环数？响声？<li><p>list_of_allowed_callers 一个可选的主叫号码列表，包括呼叫和SMS短信</p><ul><li>caller_id <code class="language-plaintext highlighter-rouge">号码</code>，允许通配符<li><p>call_type 定义了调用的<code class="language-plaintext highlighter-rouge">目的</code>，例如，它是一个标准的<code class="language-plaintext highlighter-rouge">CSD调用</code>还是一个<code class="language-plaintext highlighter-rouge">唤醒呼叫/唤醒消息</code>。</p><ul><li><p>(0) = normal CSD call:modem只有在主叫号码与列表中的条目<code class="language-plaintext highlighter-rouge">匹配时</code>才<code class="language-plaintext highlighter-rouge">连接</code>。这是在测试所有其他属性的同时进行的，例如number_of_rings, listening_windows等</p><p><code class="language-plaintext highlighter-rouge">电路交换数据（CSD）</code>:属于2G技术,用于传输数据，类似GPRS，但更加老旧</p><li><p>(1) = wake-up request:来自<code class="language-plaintext highlighter-rouge">该主叫号码</code>的呼叫或消息将作为<code class="language-plaintext highlighter-rouge">唤醒请求</code>处理。唤醒请求将立即处理，而不考虑number_of_rings和listening_window等所有其他属性(除非主叫号码也出现在普通CSD调用列表中，请参见下面)。</p><p>需要<code class="language-plaintext highlighter-rouge">为空</code>，否则不被是为<code class="language-plaintext highlighter-rouge">唤醒请求</code></p><p>如果<code class="language-plaintext highlighter-rouge">不为空</code>，且包含预连接AA客户端的可用xDLMS APDU消息,则视为<code class="language-plaintext highlighter-rouge">xDLMS服务消息</code>而非唤醒请求，否则不做任何反应</p><p>TODO：需要补充</p></ul></ul></ul><h3 id="s476-auto-connect-class_id--29-version--2"><span class="mr-2">s4.7.6 Auto connect (class_id = 29, version = 2)</span><a href="#s476-auto-connect-class_id--29-version--2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>自动连接，自动拨号、发送消息等</p><p>属性：</p><ul><li>mode 自动连接模式，根据时间、消息类型和要使用的基础设施来控制自动连接功能。<li>repetitions 连接失败最大尝试次数<li>repetition_delay 重试间隔，秒<li>calling_window 活动窗口，在窗口时间内允许自动连接，看mode的配置<li>destination_list 包含在特定条件下必须发送消息的目的地列表(例如电话号码、电子邮件地址或它们的组合)。这里没有定义数组元素的条件及其链接</ul><p>方法：</p><ul><li>connect (data) 根据mode属性定义的规则向通信网络发起连接进程。</ul><h3 id="s477-gprs-modem-setup-class_id--45-version--0"><span class="mr-2">s4.7.7 GPRS modem setup (class_id = 45, version = 0)</span><a href="#s477-gprs-modem-setup-class_id--45-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>GPRS参数</p><ul><li>APN APN名称<li>PIN_code 个人识别码（personal identification number）<li><p>quality_of_service 指定服务质量参数（QoS）。它是一个由两个元素组成的结构:</p><ul><li>默认值<li>请求值</ul></ul><h3 id="s478-gsm-diagnostic-class_id-47-version-2"><span class="mr-2">s4.7.8 GSM diagnostic (class_id: 47, version: 2)</span><a href="#s478-gsm-diagnostic-class_id-47-version-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>“GSM diagnostic”类的一个实例存储了分析网络运行所必需的GSM/GPRS、UMTS、CDMA或LTE<code class="language-plaintext highlighter-rouge">网络参数</code>。</p><p>蜂窝网络在<code class="language-plaintext highlighter-rouge">注册状态</code>、<code class="language-plaintext highlighter-rouge">信号质量</code>等方面都在不断变化。监控和记录相关参数是必要的，以便获得诊断信息，以便识别网络中的通信问题。</p><p>可用“Profile generic”捕获</p><ul><li>operator 运营商名称<li>status modem注册状态<li>cs_attachment 当前电路切换（CS,Circuit Switch）状态，见<a href="https://baike.baidu.com/item/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">电路交换</a><li>ps_status 报文分组交换技术(PS,packet switch)状态，见<a href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/1227042">报文分组交换</a><li>cell_info 蜂窝网络状态<li>adjacent_cells 临近节点状态<li>capture_time 捕获时间</ul><p>TODO：这个类没有捕获方法？</p><h3 id="s479-lte-monitoring-class_id-151-version--1"><span class="mr-2">s4.7.9 LTE monitoring (class_id: 151, version = 1)</span><a href="#s479-lte-monitoring-class_id-151-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>允许通过处理所有必要的数据来<code class="language-plaintext highlighter-rouge">监控</code>LTE调制解调器</p><ul><li>LTE_network_parameters 网络参数<li>LTE_quality_of_service 服务质量</ul><h2 id="s48-通过m-bus建立数据交换的接口类interface-classes-for-setting-up-data-exchange-via-m-bus"><span class="mr-2">s4.8 通过M-Bus建立数据交换的接口类Interface classes for setting up data exchange via M-Bus</span><a href="#s48-通过m-bus建立数据交换的接口类interface-classes-for-setting-up-data-exchange-via-m-bus" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s482-m-bus-slave-port-setup-class_id--25-version--0"><span class="mr-2">s4.8.2 M-Bus slave port setup (class_id = 25, version = 0)</span><a href="#s482-m-bus-slave-port-setup-class_id--25-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>M-Bus<code class="language-plaintext highlighter-rouge">从设备</code>端口设置</p><ul><li>default_baud 起始波特率<li>avail_baud 协商波特率<li>addr_state 设备是否分配了地址<li>bus_address 总线上当前为设备分配的地址</ul><h3 id="s483-m-bus-client-class_id--72-version--2"><span class="mr-2">s4.8.3 M-Bus client (class_id = 72, version = 2)</span><a href="#s483-m-bus-client-class_id--72-version--2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>每个“M-Bus client”对象<code class="language-plaintext highlighter-rouge">控制</code>一个M-Bus<code class="language-plaintext highlighter-rouge">从设备</code>。</p><p>方法可以实现M-Bus从设备的<code class="language-plaintext highlighter-rouge">安装和卸载</code></p><p>本对象可以向<strong>从设备</strong>采集数据，也可以发送数据（配置，动作，传密钥等）</p><p>属性：</p><ul><li>mbus_port_reference “<code class="language-plaintext highlighter-rouge">M-Bus master port setup</code>”对象<code class="language-plaintext highlighter-rouge">引用</code>，每个接口允许与一个或多个M-Bus从设备交换数据。<li>capture_definition 捕获定义，TODO:需要看引用文档<li><p>capture_period <code class="language-plaintext highlighter-rouge">捕获周期</code></p><ul><li>&gt;=1: 自动捕获，秒<li>0：不自动捕获，需手动触发</ul><li><p>primary_address M-Bus从设备的主地址（primary address），范围是0-250</p><p>有该值，表示可以立即通信，不允许还未准备就绪（安装）时写该值</p><li>identification_number 标识号，第一次通信时写入<li>manufacturer_id EN 137577:2018<li>version EN 137577:2018<li>device_type EN 137577:2018<li>access_number EN 137577:2018<li>status EN 137577:2018<li>alarm EN 137577:2018<li>configuration EN 137577:2018<li>encryption_key_status <code class="language-plaintext highlighter-rouge">加密密钥状态</code>，设置、传输、使用<li>configuration_extension EN 137577:2018<li>invocation_status 携带未决（pending）M-Bus方法调用的<code class="language-plaintext highlighter-rouge">调用状态</code>。当invocation_status表示<code class="language-plaintext highlighter-rouge">(1)成功</code>时，结果携带在invocation_status的<code class="language-plaintext highlighter-rouge">return-data</code>中。如果没有返回数据可用，则return_data octet-string为空，即长度为0。当没有挂起的调用时，数组为空。</ul><p>方法：</p><ul><li><p>slave_install (data) <code class="language-plaintext highlighter-rouge">安装</code>一个未配置的从设备（primary address 是 0）</p><ul><li>检查<code class="language-plaintext highlighter-rouge">M-Bus地址</code>0上是否有新设备<li>没找到调用失败<li>方法参数表示<code class="language-plaintext highlighter-rouge">primary address</code>，如果不带参数调用，则自动取未使用的<code class="language-plaintext highlighter-rouge">primary address</code>，分配并传输给从设备</ul><li><p>slave_deinstall (data) <code class="language-plaintext highlighter-rouge">卸载</code>从设备。此服务的主要目的是卸载M-Bus从设备，并让主设备为安装新设备做好准备。执行以下操作:</p><ul><li>从设备<code class="language-plaintext highlighter-rouge">M-Bus地址</code>设置为0<li><code class="language-plaintext highlighter-rouge">销毁</code>之前传输的<code class="language-plaintext highlighter-rouge">密钥</code>，不影响默认密钥<li>encryption_key_status设为<code class="language-plaintext highlighter-rouge">(0): no encryption_key</code><li><code class="language-plaintext highlighter-rouge">primary address</code>设为0<li>全部<code class="language-plaintext highlighter-rouge">属性</code>设置为<code class="language-plaintext highlighter-rouge">默认值</code></ul><li>capture (data) 捕获，和capture_definition属性关联<li>reset_alarm (data) 复位M-Bus从设备<code class="language-plaintext highlighter-rouge">告警状态</code><li>synchronize_clock (data) 同步从设备时钟<li>data_send (data) 向从设备<code class="language-plaintext highlighter-rouge">发送数据</code><li>set_encryption_key (data) <code class="language-plaintext highlighter-rouge">设置</code>M-Bus<code class="language-plaintext highlighter-rouge">客户端</code>设备的加密<code class="language-plaintext highlighter-rouge">密钥</code>，<strong>从设备</strong>刚安装时客户端设备有个空密钥，且加密传输禁用，可以通过配置空密钥禁用加密传输<li><p>transfer_key (data) <code class="language-plaintext highlighter-rouge">传输加密密钥</code>给从设备</p><p>在加密传输启用前，<code class="language-plaintext highlighter-rouge">加密密钥</code>通过从设备<code class="language-plaintext highlighter-rouge">默认密钥</code>（密钥加密密钥，MK）<code class="language-plaintext highlighter-rouge">加密</code>，传输给从设备，本次传输通道<code class="language-plaintext highlighter-rouge">不加密</code>，之后才开始加密传输。之后可以重复调用该方法<code class="language-plaintext highlighter-rouge">更新</code>密钥，同样使用默认密钥加密密钥，但这次传输通道为<code class="language-plaintext highlighter-rouge">加密的</code></p><p>被卸载后，从设备内密钥销毁，但默认密钥不受影响，禁用加密传输</p><li>transfer_security_information (data) 向M-Bus从设备传输<code class="language-plaintext highlighter-rouge">安全信息</code>(security_information)<li>invocations_reset(data) 将M-Bus从设备的方法调用重置为初始状态</ul><h3 id="s484-wireless-mode-q-channel-class_id--73-version--1"><span class="mr-2">s4.8.4 Wireless Mode Q channel (class_id = 73, version = 1)</span><a href="#s484-wireless-mode-q-channel-class_id--73-version--1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>使用模式Q接口进行通信的操作参数。参见<em>EN 13757-5:2015</em>。</p><h3 id="s485-m-bus-master-port-setup-class_id--74-version--0"><span class="mr-2">s4.8.5 M-Bus master port setup (class_id = 74, version = 0)</span><a href="#s485-m-bus-master-port-setup-class_id--74-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>如果设备作为M-bus master，该IC的实例定义了使用<em>EN 13757-2</em>接口进行通信的操作参数。</p><h3 id="s486-dlms-server-m-bus-port-setup-class_id--76-version--0"><span class="mr-2">s4.8.6 DLMS server M-Bus port setup (class_id = 76, version = 0)</span><a href="#s486-dlms-server-m-bus-port-setup-class_id--76-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>在M-Bus从设备托管的DLMS服务器中使用，使用DLMS/COSEM有线或无线M-Bus (wM-Bus)通信配置文件</p><ul><li>M-Bus_profile_selection 引用M-Bus通信端口设置对象,“M-Bus slave port setup” object (class_id = 25)或 “Wireless Mode Q channel” object (class_id = 73).<li><p>M-Bus_port_communication_state M-Bus node通信状态</p><ul><li>(0)无接入:仪表无接入窗口(单向仪表)，<li>(1)暂无接入:仪表一般支持双向接入，但本次传输后没有接入窗口(如为了保持占空比限制或<code class="language-plaintext highlighter-rouge">限制能耗</code>，暂无接入)，<li>(2)有限的访问:仪表仅在传输后提供一个短的访问窗口(如电池供电仪表)，<li>(3)无限接入:至少在下次传输(如市电供电设备)之前，仪表提供无限接入。<li>(4)此属性仅在wM-Bus中相关。</ul><p>TODO:node是什么意思？</p><li>M-Bus_Data_Header_Type 报文头类型，派生自当前通信的CITL值。<li>primary_address EN 137577:2018<li>identification_number EN 137577:2018<li>manufacturer_id EN 137577:2018<li>version EN 137577:2018<li>device_type EN 137577:2018<li>max_pdu_size M-Bus低层pdu长度上限，对于长消息，可以使用<code class="language-plaintext highlighter-rouge">DLMS/COSEM应用层</code>提供的<code class="language-plaintext highlighter-rouge">块传输</code>或<code class="language-plaintext highlighter-rouge">传输层</code>提供的<code class="language-plaintext highlighter-rouge">分段传输</code>，也可以同时使用这两种机制。<li>listening_window 此属性仅在wM-Bus中相关，定义点对点通信窗口活动(start_time)和不活动(end_time)的时间点。start_time隐式地定义周期</ul><h3 id="s487-m-bus-diagnostic-class_id--77-version--0"><span class="mr-2">s4.8.7 M-Bus diagnostic (class_id = 77, version = 0)</span><a href="#s487-m-bus-diagnostic-class_id--77-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>包含与M-Bus网络运行相关的信息，如当前<code class="language-plaintext highlighter-rouge">信号强度</code>、<code class="language-plaintext highlighter-rouge">通道标识符</code>、到M-Bus网络的<code class="language-plaintext highlighter-rouge">链路状态</code>以及与<code class="language-plaintext highlighter-rouge">帧交换</code>、<code class="language-plaintext highlighter-rouge">传输</code>和<code class="language-plaintext highlighter-rouge">帧接收</code><code class="language-plaintext highlighter-rouge">质量</code>相关的<code class="language-plaintext highlighter-rouge">计数器</code>。</p><ul><li><p>received-signal-strength 此属性仅与无线双向M-Bus（<code class="language-plaintext highlighter-rouge">wM-Bus,wireless M-Bus</code>）通信相关。</p><p>当使用wM-Bus配置文件时，这个属性保存了接收到的最后一个wM-Bus帧的<code class="language-plaintext highlighter-rouge">信号强度值</code>，用<code class="language-plaintext highlighter-rouge">dBm</code>表示。</p><li>channel_Id 此属性仅与wM-Bus通信相关。当使用wM-Bus配置文件时，此属性保存当前使用的<code class="language-plaintext highlighter-rouge">通道的标识</code>。缺省值为0。<li><p>link_status 此属性仅与wM-Bus通信相关。当使用wM-Bus配置文件时，此属性保存到M-Bus网络的<code class="language-plaintext highlighter-rouge">链接</code>的<code class="language-plaintext highlighter-rouge">当前状态</code></p><ul><li>(0)缺省值(未接收到数据)<li>(1)链路正常运行<li>(2)链路暂时中断</ul><li>broadcast_frames_counter 持有<code class="language-plaintext highlighter-rouge">广播帧计数</code>器的值，时间戳为接收到的最后一帧，并由客户端标识符区分<li>transmissions_counter 统计相关M-Bus端口<code class="language-plaintext highlighter-rouge">传输</code>的<code class="language-plaintext highlighter-rouge">帧数</code>。到达最大值归0。<li>FCS_OK_frames_counter 以<code class="language-plaintext highlighter-rouge">正确的</code>校验和计算接收到的<code class="language-plaintext highlighter-rouge">帧数</code>。到达最大值归0。<li>FCS_NOK_frames_counter 统计接收到的<code class="language-plaintext highlighter-rouge">校验和(checksum)错误</code>的<code class="language-plaintext highlighter-rouge">帧数</code><li>capture_time 保存属性received-signal-strength、link_status、transmissions_counter、FCS_OK_frames_counter或FCS_NOK_frames_counter的值<code class="language-plaintext highlighter-rouge">最近变化</code>的<code class="language-plaintext highlighter-rouge">时间戳</code>。</ul><p>方法：</p><ul><li>reset (data) 清除所有计数器(counters)，received_signal_strength, link_status和capture_time</ul><h2 id="s49-用于在internet上建立数据交换的接口类interface-classes-for-setting-up-data-exchange-over-the-internet"><span class="mr-2">s4.9 用于在Internet上建立数据交换的接口类Interface classes for setting up data exchange over the Internet</span><a href="#s49-用于在internet上建立数据交换的接口类interface-classes-for-setting-up-data-exchange-over-the-internet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="s491-tcp-udp-setup-class_id--41-version--0"><span class="mr-2">s4.9.1 TCP-UDP setup (class_id = 41, version = 0)</span><a href="#s491-tcp-udp-setup-class_id--41-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>允许对基于<code class="language-plaintext highlighter-rouge">TCP-UDP/IP</code>的通信配置文件的<code class="language-plaintext highlighter-rouge">TCP或UDP传输层</code>的设置建模</p><p>或基于<code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP</code>的<code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP传输层</code>的<code class="language-plaintext highlighter-rouge">UDP子层</code>的设置建模</p><p>在基于<code class="language-plaintext highlighter-rouge">TCP-UDP/IP</code>的通信配置文件中，承载<code class="language-plaintext highlighter-rouge">一个或多个</code>COSEM<code class="language-plaintext highlighter-rouge">客户端</code>应用程序进程的<code class="language-plaintext highlighter-rouge">物理设备</code>和承载<code class="language-plaintext highlighter-rouge">一个或多个</code>COSEM<code class="language-plaintext highlighter-rouge">服务器</code>ap的<code class="language-plaintext highlighter-rouge">物理设备</code>之间的<code class="language-plaintext highlighter-rouge">所有AAs</code>都依赖于<code class="language-plaintext highlighter-rouge">单个</code>TCP或UDP连接。TCP或UDP实体封装在基于COSEM TCP-UDP的传输层中。在物理设备中，每个<code class="language-plaintext highlighter-rouge">AP</code>(客户端AP或服务器逻辑设备)都绑定到一个<code class="language-plaintext highlighter-rouge">包装器端口(WPort)</code></p><p>一个基于<code class="language-plaintext highlighter-rouge">COSEM TCP或UDP的传输层</code>可能能够支持一个<code class="language-plaintext highlighter-rouge">物理设备</code>和多个承载COSEM ap的<code class="language-plaintext highlighter-rouge">对等物理设备</code>之间的<code class="language-plaintext highlighter-rouge">多个</code>TCP或UDP连接。</p><p>一个<code class="language-plaintext highlighter-rouge">DLMS/COSEM CoAP传输层</code>可以支持<code class="language-plaintext highlighter-rouge">多个UDP连接</code>，用于一个<code class="language-plaintext highlighter-rouge">物理设备</code>和一个或多个承载COSEM ap的<code class="language-plaintext highlighter-rouge">对等物理设备</code>之间的通信。</p><p>当一个<code class="language-plaintext highlighter-rouge">COSEM物理设备</code>支持<code class="language-plaintext highlighter-rouge">各种数据链路层</code>时——例如以太网和PPP——<code class="language-plaintext highlighter-rouge">每一个</code>都需要<code class="language-plaintext highlighter-rouge">一个</code>TCP-UDP setup对象的<code class="language-plaintext highlighter-rouge">实例</code>。</p><ul><li>TCP-UDP_port 监听端口号，4059 TCP/UDP<li>IP_reference 引用“IP setup”对象<li><p>MSS 在最大段大小(MSS，Maximum Segment Size)选项的帮助下，TCP实体可以向它的对端指示最大的接收段大小。注意:</p><ul><li>这个选项只能在<code class="language-plaintext highlighter-rouge">初始连接请求</code>中发送(即发送<code class="language-plaintext highlighter-rouge">SYN控制位</code>的分段);<li>如果这个选项不存在，通常MSS被认为是它的默认值，<code class="language-plaintext highlighter-rouge">576</code>;<li>MSS是<code class="language-plaintext highlighter-rouge">不可协商</code>的;它的值由这个属性指示。</ul><li>nb_of_sim_conn 基于COSEM TCP-UDP的传输层能够支持的<code class="language-plaintext highlighter-rouge">最大同时连接数</code>(maximum number of simultaneous connections)<li>inactivity_time_out <code class="language-plaintext highlighter-rouge">接收超时释放</code>，定义时间，以秒表示，如果没有从COSEM客户端收到帧，<code class="language-plaintext highlighter-rouge">不活动</code>的TCP连接将被<code class="language-plaintext highlighter-rouge">中止</code>。</ul><p>0表示永不中止</p><p>注意，所有与管理<code class="language-plaintext highlighter-rouge">非活动超时函数</code>相关的<code class="language-plaintext highlighter-rouge">操作</code>，如<code class="language-plaintext highlighter-rouge">测量</code>非活动时间、在超时结束时<code class="language-plaintext highlighter-rouge">终止</code>TCP连接等，都在<code class="language-plaintext highlighter-rouge">TCP-UDP层</code>实现中进行管理。</p><h3 id="s492-ipv4-setup-class_id--42-version--0"><span class="mr-2">s4.9.2 IPv4 setup (class_id = 42, version = 0)</span><a href="#s492-ipv4-setup-class_id--42-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>IPv4信息，每个网口对应一个</p><p>属性：</p><ul><li>DL_reference 引用数据链路层(如以太网或PPP)设置对象<li><p>IP_address 静态或动态的<code class="language-plaintext highlighter-rouge">ip地址</code></p><p>IPv4地址192.168.0.1(点分十进制)对应C0A80001 (hexa)，得到3232235521 (double-long-unsigned)。</p><li>multicast_IP_address <code class="language-plaintext highlighter-rouge">组播地址</code>，该<code class="language-plaintext highlighter-rouge">数组</code>中的IP地址应属于<code class="language-plaintext highlighter-rouge">组播组地址范围</code>(“D类”地址，包括224.0.0.0 - 239.255.255.255范围内的IP地址)。当设备接收到IP数据报时，如果<code class="language-plaintext highlighter-rouge">目的IP地址</code>字段属于数组中IP地址之一，它应该认为该数据报是给它自己的。<li><p>IP_options 包含支持所选IP选项的<code class="language-plaintext highlighter-rouge">必要参数</code>——例如<code class="language-plaintext highlighter-rouge">数据报时间戳</code>或<code class="language-plaintext highlighter-rouge">安全服务</code>(IPSec)。</p><p>标准的<a href="https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml">IP option RFC 791</a>中的部分</p><ul><li>Security: IP_Option_Type = 0x82, IP_Option_Length = 11<li>Loose Source and Record Route: IP_Option_Type = 0x83 宽松的源站选路（为数据报指定一系列必须经过的IP地址）<li>Strict Source and Record Route: IP_Option_Type = 0x89 严格的源站选路选项。与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址。<li>Record Route: IP_Option_Type = 0x07 记录路径（让每个路由器都记下它的IP地址）<li>Internet Timestamp: IP_Option_Type = 0x44 时间戳选项</ul><li>subnet_mask 子网掩码<li>gateway_IP_address 网关IP<li>use_DHCP_flag 是否启用dhcp，启用后IP_address, subnet_mask and gateway_IP_address变为动态<li>primary_DNS_address 主DNS<li>secondary_DNS_address 备用DNS</ul><p>方法：</p><ul><li>add_mc_IP_address (data) 向multicast_IP_address数组添加一个新的ip<li>delete_mc_IP_address (data) 从multicast_IP_address数组删除一个ip<li>get_nbof_mc_IP_addresses (data) 获取multicast_IP_address数组元素数量</ul><h3 id="s493-ipv6-setup-class_id--48-version--0"><span class="mr-2">s4.9.3 IPv6 setup (class_id = 48, version = 0)</span><a href="#s493-ipv6-setup-class_id--48-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>属性：</p><ul><li>DL_reference 同IPv4<li><p>address_config_mode IPv6地址配置模式</p><ul><li>(0) Auto-configuration (default)<li>(1) DHCPv6<li>(2) Manual<li>(3) ND (Neighbour Discovery)</ul><li>unicast_IPv6_addresses <code class="language-plaintext highlighter-rouge">单播地址</code>(唯一本地单播，链接本地单播 和/或 全球单播地址)，是<code class="language-plaintext highlighter-rouge">数组</code><li>multicast_IPv6_addresses <code class="language-plaintext highlighter-rouge">组播地址</code>, <code class="language-plaintext highlighter-rouge">数组</code><li>gateway_IPv6_addresses <code class="language-plaintext highlighter-rouge">网关IP</code>，<code class="language-plaintext highlighter-rouge">数组</code><li>primary_DNS_address 同IPv4<li>secondary_DNS_address 同IPv4<li>traffic_class 包含IPv6头的traffic class元素。RFC 2474:1998第3条规定，使用<code class="language-plaintext highlighter-rouge">DSCP</code> (Differentiated Services Codepoint)对报文进行分类，根据类型的不同QoS可以指定不同动作，如有些需要低延迟，有些需要大流量。<li><p>neighbor_discovery_setup 包含用于支持IPv6<code class="language-plaintext highlighter-rouge">邻居发现协议NDP</code>(rfc4861)的路由器和主机的配置。</p><ul><li>RS_max_retry 给出一个节点在<code class="language-plaintext highlighter-rouge">没有</code>收到<code class="language-plaintext highlighter-rouge">预期</code>的路由器<code class="language-plaintext highlighter-rouge">通告</code>时执行的最大路由器请求<code class="language-plaintext highlighter-rouge">重试次数</code>。<li>RS_retry_wait_time 给出两个连续路由器请求重试之间的<code class="language-plaintext highlighter-rouge">等待时间</code>(以<code class="language-plaintext highlighter-rouge">毫秒</code>为单位)。<li>RA_send_period 给出路由器通告传输的<code class="language-plaintext highlighter-rouge">周期</code>，单位为秒</ul></ul><p>方法：</p><ul><li>add_IPv6_address (data) 添加IPv6地址，参数包括类型：单播、组播、网关<li>remove_IPv6_address (data) 移除IPv6地址，参数包括类型：单播、组播、网关</ul><h3 id="s494-mac-address-setup-class_id--43-version--0"><span class="mr-2">s4.9.4 MAC address setup (class_id = 43, version = 0)</span><a href="#s494-mac-address-setup-class_id--43-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>从原来的“Ethernet setup”更名而来，说明这个类原来仅用于以太网。现在可以用于更广泛的用途，如PLC网络的MAC</p><p>保存MAC地址</p><p>属性：</p><ul><li>MAC_address MAC地址</ul><h3 id="s495-ppp-setup-class_id--44-version--0"><span class="mr-2">s4.9.5 PPP setup (class_id = 44, version = 0)</span><a href="#s495-ppp-setup-class_id--44-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>通过处理与给定<code class="language-plaintext highlighter-rouge">物理设备</code>相关的<code class="language-plaintext highlighter-rouge">PPP设置</code>的<code class="language-plaintext highlighter-rouge">所有信息</code>，以及与使用这些设置的<code class="language-plaintext highlighter-rouge">低层连接</code>，该IC允许使用<code class="language-plaintext highlighter-rouge">PPP协议模拟接口</code>的设置。一个物理设备的<code class="language-plaintext highlighter-rouge">每个</code>网络接口都应该有一个该IC的实例。</p><ul><li>PHY_reference 通过它的logical_name引用<code class="language-plaintext highlighter-rouge">另一个对象</code>。引用的对象包含具体<code class="language-plaintext highlighter-rouge">物理层接口的信息</code>，支持PPP层。 TODO:引用什么对象？<li><p>LCP_options <code class="language-plaintext highlighter-rouge">LCP</code>配置<a href="http://www.iana.org/assignments/ppp-numbers/ppp-numbers.xml">参数</a>。</p><ul><li>Maximum-Receive-Unit (MRU), LCP_Option_Type = 1. See RFC 1661. <code class="language-plaintext highlighter-rouge">最大接收单元</code>。用于通知peer可以接收更大的包（如对方发的包比较小，可以告诉他自己最大能接收多少），也能通知peer发更小的包，太大处理不了<li>Async-Control-Character-Map (ACCM), LCP_Option_Type = 2. See RFC 1662. 异步控制字符映像<li>Authentication-Protocol, LCP_Option_Type = 3. See RFC 1661. <code class="language-plaintext highlighter-rouge">认证协议</code>，PAP、CHAP、EAP。<li>Magic-Number, LCP_Option_Type = 5. See RFC 1661. 该配置选项提供了一种<code class="language-plaintext highlighter-rouge">检测回环链路</code>和其他数据链路层<code class="language-plaintext highlighter-rouge">异常</code>的方法;<li>Protocol-Field-Compression (PFC), LCP_Option_Type = 7. See RFC 1661. <code class="language-plaintext highlighter-rouge">协议域压缩</code>，这个配置选项提供了一种协商PPP协议字段压缩的方法<li>Address-and-Control-Field-Compression (ACFC), LCP_Option_Type = 8. See RFC 1661. <code class="language-plaintext highlighter-rouge">地址和控制字段压缩</code>，这个配置选项提供了一种方法来协商数据链路层地址和控制字段的压缩;<li>FCS-Alternatives, LCP_Option_Type = 9. See RFC 1570. FCS替换，可以指定对等端发送的<code class="language-plaintext highlighter-rouge">另一种</code>FCS格式，或者协商<code class="language-plaintext highlighter-rouge">完全放弃</code>FCS<li>Callback, LCP_Option_Type = 13. See RFC 1570. 回拨，是指当通信一方拨号到另一方后，由另一方断开拨号连接并进行<code class="language-plaintext highlighter-rouge">反向的拨号</code>。更加安全，另一方可以在回叫前验证对方是否合法，如查数据库或查对方号码</ul><li>IPCP_options 包含<code class="language-plaintext highlighter-rouge">网际协议控制协议</code>（IPCP）(PPP的网络控制协议模块)的必要参数，允许协商理想的互联网协议参数。有关IPCP的详情，请参阅<code class="language-plaintext highlighter-rouge">RFC 1332</code>。<li><p>PPP_authentication PPP认证参数，PAP、CHAP、EAP，<a href="https://workos.com/blog/authentication-protocols-your-guide-to-the-basics">见本文</a></p><ul><li>PAP: 明文密码传输，客户端发送明文用户名密码<li>CHAP：服务端发个OTP(相当于盐)，客户端用OTP和密码计算哈希值，把明文的用户名和哈希值发送服务端，服务端用相同的OTP和密码计算哈希值，并比对。过程中密码没有明文传输<li>EAP: 服务器向客户端发送<code class="language-plaintext highlighter-rouge">身份验证请求</code>，包括它应使用的 <code class="language-plaintext highlighter-rouge">40 种</code>身份验证方法中的哪一种。客户端根据该方法加密用户名密码，发送给服务端</ul></ul><h3 id="s496-smtp-setup-class_id--46-version--0"><span class="mr-2">s4.9.6 SMTP setup (class_id = 46, version = 0)</span><a href="#s496-smtp-setup-class_id--46-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>允许使用简单邮件传输协议(Simple Mail Transfer Protocol，SMTP)协议与远程服务器建立数据交换</p><ul><li>server_port 服务器端口，25/TCP,UDP<li>user_name 用户名，登录用<li>login_password 密码，登陆用<li>server_address 服务器ip<li>sender_address 发送者ip地址</ul><h3 id="s497-ntp-setup-class_id--100-version--0"><span class="mr-2">s4.9.7 NTP setup (class_id = 100, version = 0)</span><a href="#s497-ntp-setup-class_id--100-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>NTP协议时间同步</p><p>属性：</p><ul><li>activated NTP时间同步是否激活<li>server_address NTP服务器地址<li>server_port 端口<li>authentication_method 认证方式<li>authentication_keys 认证密钥数组<li>client_key 客户端密钥，NTP服务端公钥，IFF方式</ul><p>方法：</p><ul><li>synchronize (data) 同步时间<li>add_authentication_key (data) 添加authentication_key<li>delete_authentication_key (data) 删除authentication_key</ul><h3 id="s498-coap-setup-class_id--152-version--0"><span class="mr-2">s4.9.8 CoAP setup (class_id = 152 version = 0)</span><a href="#s498-coap-setup-class_id--152-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>属性：</p><ul><li>UDP_reference 指向<code class="language-plaintext highlighter-rouge">TCP-UDP setup</code>对象,和UDP层相关<li>ack_timeout confirmable消息的最小<code class="language-plaintext highlighter-rouge">初始ACK超时时间</code><li>ack_random_factor 初始ACK超时时间生成<code class="language-plaintext highlighter-rouge">随机因子</code>，初始ACK超时时间在ack_timeout - ack_timeout x ack_random_factor x 0.01之间<li>max_retransmit confirmable消息的<code class="language-plaintext highlighter-rouge">最大重传次数</code><li>nstart 同时未完成的下列形式的CoAP请求消息的数量:未收到CoAP确认的CON CoAP消息或未收到CoAP响应消息的NON CoAP消息。<li>delay_ack_timeout CoAP消息传递层<code class="language-plaintext highlighter-rouge">等待应用层</code>返回响应的时间(单位为ms)，然后它将返回确认以防止来自对等体的虚假重传。<li><p>exponential_back_off</p><p>重发延迟因子</p><blockquote><p>n表示第几次重发</p></blockquote><p>retransmission_delay = initial_ack_timeout x (exponential_back_off x 0.01) ^ (n -1)</p><li>probing_rate 定义一个端点在发送到另一个没有响应的端点时<code class="language-plaintext highlighter-rouge">不应超过</code>的平均数据速率(字节/秒)。<li>CoAP_uri_path uri-path<li><p>transport_mode 传输方式</p><ul><li>仅可靠<li>仅不可靠<li>同时支持</ul><li>version DLMS/COSEM CoAP wrapper的版本<li>token_length token长度（CoAP协议中的token）</ul><h3 id="s499-coap-diagnostic-class_id--153-version--0"><span class="mr-2">s4.9.9 CoAP diagnostic (class_id = 153, version = 0)</span><a href="#s499-coap-diagnostic-class_id--153-version--0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>CoAP诊断</p><p>属性：</p><ul><li>messages_counter 报文计数<li>request_response_counter CoAP请求响应的报文计数<li>coap_bt_counter CoAP Block-Wise transfer layer(块传输)，发起总数，完成总数，超时总数<li>capture_time 捕获时间（最近更新本对象相关属性的时间）</ul><p>方法：</p><ul><li>reset (data) 全部清空</ul><h3 id="s625-clock-objects-class_id--8"><span class="mr-2">s6.2.5 Clock objects (class_id = 8)</span><a href="#s625-clock-objects-class_id--8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>TODO:对图的疑问。表内时间实际上只有一份，通过D的不同区分不同的表现形式。而且可以用不同的类表示。说明obis和class间没有太大的联系</p><h3 id="s6217-payment-metering-related-objects"><span class="mr-2">s6.2.17 Payment metering related objects</span><a href="#s6217-payment-metering-related-objects" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>C决定了大的功能模块，D区分这个功能模块需要用到的数据，可以是隶属于不同class的。</p><p>如图，C=19表示payment相关功能，需要用到来自111、112、113、115、01、116类的数据</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%8A%80%E6%9C%AF/'>技术</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/dao/" class="post-tag no-text-decoration" >DAO</a> <a href="/tags/database/" class="post-tag no-text-decoration" >database</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DLMS/COSEM Blue Book学习笔记 - 普通人&amp;url=https://hjk.life/posts/dlms-blue2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DLMS/COSEM Blue Book学习笔记 - 普通人&amp;u=https://hjk.life/posts/dlms-blue2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://hjk.life/posts/dlms-blue2/&amp;text=DLMS/COSEM Blue Book学习笔记 - 普通人" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=DLMS/COSEM Blue Book学习笔记 - 普通人&amp;url=https://hjk.life/posts/dlms-blue2/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/quantum-platform-1/">《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</a><li><a href="/posts/design-patterns-principles/">软件设计模式——七大设计原则</a><li><a href="/posts/const-c/">C语言中的const</a><li><a href="/posts/c-oop/">面向对象编程(OOP)的C语言实现</a><li><a href="/posts/operating-systems-28/">《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/cpp-dao/"><div class="card-body"> <em class="timeago small" data-ts="1646701200" > 2022-03-08 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++实现的DAO(数据访问对象模式)</h3><div class="text-muted small"><p> 本文将会介绍如何使用 C++实现设计模式中的 DAO(数据访问对象模式) DAO 介绍 什么是 DAO 在计算机软件中，数据访问对象（data access object，DAO）是为某种类型的数据库或其他持久性机制提供一个抽象接口的对象。通过映射应用程序对持久层的调用，DAO 提供一些特定的数据操作，而无需暴露数据库细节。这种隔离支持单一功能原则。 数据访问对象模式（Data Ac...</p></div></div></a></div><div class="card"> <a href="/posts/dlms-green-1/"><div class="card-body"> <em class="timeago small" data-ts="1650330000" > 2022-04-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DLMS Green Book学习笔记</h3><div class="text-muted small"><p> s1 Scope s3 Terms, definitions and abbreviations and symbols s3.1 General DLMS/COSEM definitions s4 Information exchange in DLMS/COSEM s4.1 General s4.2 C...</p></div></div></a></div><div class="card"> <a href="/posts/plantuml-vscode/"><div class="card-body"> <em class="timeago small" data-ts="1628038800" > 2021-08-04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>使用PlantUML绘制类图</h3><div class="text-muted small"><p> 本文基于 vscode 的 PlantUML 插件绘制类图。 类的 UML 表示 使用 UML 表示一个类，主要由三部分组成。类名、属性、方法。其中属性和方法的访问修饰符用 - 、# 、+ 表示 private、protected、public。 如图所示，表示A类有一个private属性，protected 构造函数和public方法。 @startuml class A{ ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/cpp-dao/" class="btn btn-outline-primary" prompt="上一篇"><p>C++实现的DAO(数据访问对象模式)</p></a> <a href="/posts/operating-systems-7/" class="btn btn-outline-primary" prompt="下一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(七) 调度：比例份额</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "ProphetHJK/prophethjk.github.io", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjk1MjU2NjI=", "data-category": "General", "data-category-id": "DIC_kwDOE6Qpns4CPYgF", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/prophethjk">Jinkai</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备20006745号-2</a> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VEN4M3BMXV"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VEN4M3BMXV'); }); </script>
