<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API" /><meta name="author" content="Jinkai" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="fork()系统调用" /><meta property="og:description" content="fork()系统调用" /><link rel="canonical" href="https://hjk.life/posts/operating-systems-3/" /><meta property="og:url" content="https://hjk.life/posts/operating-systems-3/" /><meta property="og:site_name" content="普通人" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-12T17:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jinkai" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Jinkai"},"description":"fork()系统调用","url":"https://hjk.life/posts/operating-systems-3/","@type":"BlogPosting","headline":"《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API","dateModified":"2021-04-20T13:55:01+08:00","datePublished":"2021-03-12T17:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://hjk.life/posts/operating-systems-3/"},"@context":"https://schema.org"}</script><title>《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API | 普通人</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="普通人"><meta name="application-name" content="普通人"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/Humanity.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">普通人</a></div><div class="site-subtitle font-italic">潜龙勿用</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/prophethjk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['prophethjk','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Jinkai </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2021-03-12, 17:00 +0800" >03-12<i class="unloaded">2021-03-12T17:00:00+08:00</i> </span></div><div> <span> 更新于 <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2021-04-20, 13:55 +0800" >04-20<i class="unloaded">2021-04-20T13:55:01+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4124 字">22 分钟 阅读</span></div></div><div class="post-content"><h2 id="fork系统调用">fork()系统调用</h2><p>在执行函数 fork()时，创建了一个子进程，此时是两个进程同时运行</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello world (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child (new process)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am child (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am parent of %d (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
               <span class="n">rc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>输出如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>prompt&gt; ./p1
hello world <span class="o">(</span>pid:29146<span class="o">)</span>
hello, I am parent of 29147 <span class="o">(</span>pid:29146<span class="o">)</span>
hello, I am child <span class="o">(</span>pid:29147<span class="o">)</span>
prompt&gt;
</pre></table></code></div></div><p>上面这段程序执行了一次 fork 操作，<code class="language-plaintext highlighter-rouge">fork()</code>函数是一个神奇的操作，它只被调用了一次，却产生了两个返回值。对于<code class="language-plaintext highlighter-rouge">父进程</code>来说，其返回值是子进程的 pid；对于<code class="language-plaintext highlighter-rouge">子进程</code>来说，其返回值为 0。</p><p>子进程并<code class="language-plaintext highlighter-rouge">不是完全拷贝</code>了父进程，所以子进程不会从 main 开始执行，该程序的首行打印并未被子进程执行。<strong>它拥有自己的<code class="language-plaintext highlighter-rouge">地址空间</code>（即拥有自己的私有内存）、<code class="language-plaintext highlighter-rouge">寄存器</code>、<code class="language-plaintext highlighter-rouge">程序计数器</code>等</strong>。</p><p>此处父进程与子进程的执行顺序并不是绝对的，取决于 cpu 的调度算法，子进程也可能比父进程先执行完</p><blockquote><p>TODO: fork()函数的具体原理还有待进一步学习</p></blockquote><h2 id="wait系统调用">wait()系统调用</h2><p><code class="language-plaintext highlighter-rouge">wait()</code>函数用于使父进程（也就是调用 wait()的进程）<code class="language-plaintext highlighter-rouge">阻塞</code>，直到<code class="language-plaintext highlighter-rouge">一个子进程结束</code>或者该进程接收到了一个<code class="language-plaintext highlighter-rouge">指定的信号</code>为止。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello world (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child (new process)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am child (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am parent of %d (wc:%d) (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
               <span class="n">rc</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>prompt&gt; ./p2
hello world <span class="o">(</span>pid:29266<span class="o">)</span>
hello, I am child <span class="o">(</span>pid:29267<span class="o">)</span>
hello, I am parent of 29267 <span class="o">(</span><span class="nb">wc</span>:29267<span class="o">)</span> <span class="o">(</span>pid:29266<span class="o">)</span>
prompt&gt;
</pre></table></code></div></div><p>本例中，子进程却优先于父进程执行完毕，这是因为父进程调用了<code class="language-plaintext highlighter-rouge">wait()</code>操作</p><p>当父进程先执行时，会等待子进程结束，才会继续执行</p><h2 id="exec系统调用">exec()系统调用</h2><p>exec()这个系统调用可以让子进程执行与父进程不同的程序</p><blockquote><p>关于<code class="language-plaintext highlighter-rouge">exec函数族</code>的更多相关内容，可以查看<a href="https://blog.csdn.net/mybelief321/article/details/9055589">Linux 多任务编程（三）—exec 函数族及其基础实验</a></p></blockquote><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/wait.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello world (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child (new process)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am child (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">myargs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">"wc"</span><span class="p">);</span>   <span class="c1">// program: "wc" (word count)</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">"p3.c"</span><span class="p">);</span> <span class="c1">// argument: file to count</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>           <span class="c1">// marks end of array</span>
        <span class="n">execvp</span><span class="p">(</span><span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">myargs</span><span class="p">);</span>  <span class="c1">// runs word count</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"this shouldn't print out"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am parent of %d (wc:%d) (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
               <span class="n">rc</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>prompt&gt; ./p3
hello world <span class="o">(</span>pid:29383<span class="o">)</span>
hello, I am child <span class="o">(</span>pid:29384<span class="o">)</span>
 29 107 1030 p3.c
hello, I am parent of 29384 <span class="o">(</span><span class="nb">wc</span>:29384<span class="o">)</span> <span class="o">(</span>pid:29383<span class="o">)</span>
prompt&gt;
</pre></table></code></div></div><p>在这个例子中，子进程调用 <code class="language-plaintext highlighter-rouge">execvp()</code>来运行字符计数程序 wc。实际上，它针对源代码文件 p3.c 运行 wc，从而告诉我们该文件有多少行、多少单词，以及多少字节。</p><p>给定<code class="language-plaintext highlighter-rouge">可执行程序的名称</code>（如 wc）及<code class="language-plaintext highlighter-rouge">需要的参数</code>（如 p3.c）后，exec()会从可执行程序中加载代码和静态数据，<strong>并用它<code class="language-plaintext highlighter-rouge">覆写</code>自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化</strong>。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 p3）<code class="language-plaintext highlighter-rouge">替换</code>为不同的运行程序（wc）。子进程执行 exec()之后，几乎就像 p3.c 从未运行过一样。对 exec()的成功调用<code class="language-plaintext highlighter-rouge">永远不会返回</code>。如果 exec 函数执行失败, 它会返回失败的信息, 而且进程<code class="language-plaintext highlighter-rouge">继续执行后面的代码</code>。</p><blockquote><p>注意：此时子进程的 pid 号并没有变，且还是该父进程的子进程，所以并不会影响 wait()操作，等待该进程的操作（统计字节）完成后，wait()才会返回，父进程同时退出阻塞状态</p></blockquote><h2 id="为什么这样设计-api">为什么这样设计 API</h2><p>事实证明，这种分离 fork()及 exec()的做法在构建 <code class="language-plaintext highlighter-rouge">UNIX shell</code> 的时候非常有用，因为这给了 shell 在 fork 之后 exec 之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现。</p><p>shell 也是一个用户程序，它首先显示一个提示符（prompt），然后等待用户输入。你可以向它输入一个命令（一个可执行程序的名称及需要的参数），大多数情况下，<strong>shell 可以在文件系统中找到这个可执行程序，调用 <code class="language-plaintext highlighter-rouge">fork()</code>创建新进程，并调用 <code class="language-plaintext highlighter-rouge">exec()</code>的某个变体来执行这个可执行程序，调用 <code class="language-plaintext highlighter-rouge">wait()</code>等待该命令完成</strong>。子进程执行结束后，shell 从 wait()返回并再次输出一个提示符，等待用户输入下一条命令。</p><p>fork()和 exec()的分离，让 shell 可以方便地实现很多有用的功能。比如：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>prompt&gt; <span class="nb">wc </span>p3.c <span class="o">&gt;</span> newfile.txt
</pre></table></code></div></div><p>在上面的例子中，wc 的输出结果被重定向（redirect）到文件 newfile.txt 中（通过 newfile.txt 之前的大于号来指明重定向）。shell 实现结果重定向的方式也很简单，当完成子进程的创建后，shell 在调用 exec()之前先关闭了标准输出（standard output），打开了文件 newfile.txt。这样，即将运行的程序 wc 的输出结果就被发送到该文件，而不是打印在屏幕上。</p><h3 id="扩展阅读重定向">扩展阅读：重定向</h3><p>重定向的工作原理，是基于对操作系统管理文件描述符方式的假设，首先看实例：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child: redirect standard output to a file</span>
        <span class="n">close</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">);</span>
        <span class="n">open</span><span class="p">(</span><span class="s">"./p4.output"</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRWXU</span><span class="p">);</span>

        <span class="c1">// now exec "wc"...</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">myargs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">"wc"</span><span class="p">);</span>   <span class="c1">// program: "wc" (word count)</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">"p4.c"</span><span class="p">);</span> <span class="c1">// argument: file to count</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>           <span class="c1">// marks end of array</span>
        <span class="n">execvp</span><span class="p">(</span><span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">myargs</span><span class="p">);</span>  <span class="c1">// runs word count</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>prompt&gt; ./p4
prompt&gt; <span class="nb">cat </span>p4.output
 32 109 846 p4.c
prompt&gt;
</pre></table></code></div></div><p>要看懂上面的例子，首先要补充点<code class="language-plaintext highlighter-rouge">Unix文件描述符</code>的知识</p><ul><li><p>每个 Unix 进程（除了可能的守护进程）应均有三个标准的 POSIX 文件描述符，对应于三个标准流：</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">整数值<th style="text-align: center">名称<th style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;unistd.h&gt;</code>符号常量<th style="text-align: center"><code class="language-plaintext highlighter-rouge">&lt;stdio.h&gt;</code>文件流<tbody><tr><td style="text-align: center">0<td style="text-align: center">Standard input<td style="text-align: center">STDIN_FILENO<td style="text-align: center">stdin<tr><td style="text-align: center">1<td style="text-align: center">Standard output<td style="text-align: center">STDOUT_FILENO<td style="text-align: center">stdout<tr><td style="text-align: center">2<td style="text-align: center">Standard error<td style="text-align: center">STDERR_FILENO<td style="text-align: center">stderr</table></div></ul><ol><li><p>UNIX 系统从 0 开始寻找可以使用的文件描述符，进程启动后默认打开了标准输出<code class="language-plaintext highlighter-rouge">STDOUT_FILENO</code>输出到屏幕，此时所有的对<code class="language-plaintext highlighter-rouge">标准输出文件描述符</code>的输出，如 <code class="language-plaintext highlighter-rouge">printf()</code>，都会打印的屏幕上：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root@hjk:~/repo/os_test# ./a.out
33 113 864 p4.c
</pre></table></code></div></div><li><p>如果使用<em>close(STDOUT_FILENO)</em>关闭了这个描述符，再去调用<code class="language-plaintext highlighter-rouge">printf()</code>，系统会提示找不到文件描述符</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root@hjk:~/repo/os_test# ./a.out
<span class="nb">wc</span>: write error: Bad file descriptor
</pre></table></code></div></div><li><p>此时再打开<code class="language-plaintext highlighter-rouge">新的文件描述符</code>，会将所有的对<code class="language-plaintext highlighter-rouge">标准输出文件描述符</code>的输出定向到该文件描述符上</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> open<span class="o">(</span><span class="s2">"./p4.output"</span>, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU<span class="o">)</span>
</pre></table></code></div></div><blockquote><p>因为 Unix 系统会从 0 开始寻找可用的文件描述符，当找不到<code class="language-plaintext highlighter-rouge">STDOUT_FILENO</code>自然会去找新打开的文件描述符</p></blockquote></ol><h3 id="扩展阅读管道">扩展阅读：管道</h3><p><code class="language-plaintext highlighter-rouge">UNIX管道</code>也是用类似的方式实现的，但用的是 <code class="language-plaintext highlighter-rouge">pipe()</code>系统调用。在这种情况下，一个进程的<code class="language-plaintext highlighter-rouge">输出</code>被链接到了一个<code class="language-plaintext highlighter-rouge">内核管道</code>（pipe）上（队列），另一个进程的<code class="language-plaintext highlighter-rouge">输入</code>也被连接到了同一个管道上。因此，<code class="language-plaintext highlighter-rouge">前一个进程的输出无缝地作为后一个进程的输入</code>，许多命令可以用这种方式串联在一起，共同完成某项任务。比如通过将 <code class="language-plaintext highlighter-rouge">grep</code>、<code class="language-plaintext highlighter-rouge">wc</code> 命令用管道连接可以完成从一个文件中查找某个词，并统计其出现次数的功能：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">grep</span> <span class="nt">-o</span> foo file | <span class="nb">wc</span> <span class="nt">-l</span>
</pre></table></code></div></div><h2 id="作业">作业</h2><ol><li><p>编写一个调用 fork()的程序。在调用 fork()之前，让主进程访问一个变量（例如 x）并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x 的值时，变量会发生什么？</p><p>答：父进程在 fork 之前修改的值会同步到子进程中（fork 前子进程并不存在），当 fork 完成后，两个进程相互独立，修改 fork 前定义的变量时也是独立的。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello world (pid:%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child (new process)</span>
        <span class="n">x</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am child (pid:%d),x:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">(),</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am parent of %d (pid:%d),x:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">rc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">(),</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>结果如下，两个进程的 x 独立，即便是子进程修改了 x，父进程中的 x 还是 fork 前的值</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>root@hjk:~/repo/os_test# ./a.out
hello world <span class="o">(</span>pid:17699<span class="o">)</span>
hello, I am child <span class="o">(</span>pid:17700<span class="o">)</span>,x:4
hello, I am parent of 17700 <span class="o">(</span>pid:17699<span class="o">)</span>,x:3
</pre></table></code></div></div><li><p>编写一个打开文件的程序（使用 open()系统调用），然后调用 fork()创建一个新进程。子进程和父进程都可以访问 open()返回的文件描述符吗？当它们并发（即同时）写入文件时，会发生什么？</p><p>答：都可以访问。并发时无影响。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">close</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"./p4.output"</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRWXU</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child: redirect standard output to a file</span>
        <span class="c1">// now exec "wc"...</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"child</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="c1">// int wc = wait(NULL);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"father</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// if(fd&gt;=0)</span>
    <span class="c1">// {</span>
    <span class="c1">//     close(fd);</span>
    <span class="c1">// }</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>p4.output 文件输出如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>father
child
</pre></table></code></div></div><li><p>使用 fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait()而做到这一点呢？</p><p>答：使用 sleep 函数时父进程休眠一段时间</p><li><p>现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用 wait()会发生什么？</p><p>答：wait()返回子进程的 pid，子进程中调用无影响，返回值为-1。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">close</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"./p4.output"</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRWXU</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child: redirect standard output to a file</span>
        <span class="c1">// now exec "wc"...</span>
        <span class="kt">int</span> <span class="n">wc</span><span class="o">=</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"child,pid:%d,wc:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">(),</span><span class="n">wc</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="c1">// sleep(1);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"father,pid:%d,wc:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">(),</span><span class="n">wc</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// if(fd&gt;=0)</span>
    <span class="c1">// {</span>
    <span class="c1">//     close(fd);</span>
    <span class="c1">// }</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>p4.output 输出结果为：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>child,pid:4577,wc:-1
father,pid:4576,wc:4577
</pre></table></code></div></div><li><p>对前一个程序稍作修改，这次使用 waitpid()而不是 wait()。什么时候 waitpid()会有用？</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code class="language-plaintext highlighter-rouge">waitpid()</code>参数值<th style="text-align: left">说明<tbody><tr><td style="text-align: center">pid&lt;-1<td style="text-align: left">等待<code class="language-plaintext highlighter-rouge">进程组</code>号为 <code class="language-plaintext highlighter-rouge">pid 绝对值</code>的任何子进程。<tr><td style="text-align: center">pid=-1<td style="text-align: left">等待<code class="language-plaintext highlighter-rouge">任何子进程</code>，此时的 waitpid()函数就退化成了普通的 <code class="language-plaintext highlighter-rouge">wait()</code>函数。<tr><td style="text-align: center">pid=0<td style="text-align: left">等待<code class="language-plaintext highlighter-rouge">进程组</code>号与目前进程<code class="language-plaintext highlighter-rouge">相同</code>的任何子进程，也就是说任何和调用 waitpid()函数的进程在同一个进程组的进程。<tr><td style="text-align: center">pid&gt;0<td style="text-align: left">等待<code class="language-plaintext highlighter-rouge">进程号</code>为 pid 的子进程。</table></div><blockquote><p>使用<code class="language-plaintext highlighter-rouge">getpgrp()</code>获取当前进程组号</p></blockquote><p>答：当 pid 为<code class="language-plaintext highlighter-rouge">0</code>(pid=0),<code class="language-plaintext highlighter-rouge">-1</code>(pid=-1),<code class="language-plaintext highlighter-rouge">child_pid</code>(pid&gt;0),<code class="language-plaintext highlighter-rouge">getpgrp()*-1</code>(pid&lt;-1)时，waitpid()有用</p><li><p>编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO）。如果子进程在关闭描述符后调用 printf()打印输出，会发生什么？</p><p>答：子进程无法打印，父进程无影响</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// close(STDOUT_FILENO);</span>
    <span class="c1">// int fd = open("./p4.output", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// fork failed; exit</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// child: redirect standard output to a file</span>
        <span class="c1">// now exec "wc"...</span>
        <span class="c1">// int wc=wait(NULL);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"child,pid:%d,wc:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
        <span class="c1">// int wc = waitpid(getpgrp(),NULL,0);</span>
        <span class="c1">// sleep(1);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"father,pid:%d,wc:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">// if(fd&gt;=0)</span>
    <span class="c1">// {</span>
    <span class="c1">//     close(fd);</span>
    <span class="c1">// }</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>输出为：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root@hjk:~/repo/os_test# ./a.out
father,pid:11189,wc:0
</pre></table></code></div></div><li><p>编写一个程序，创建两个子进程，并使用 pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。</p><p>答：该程序将子进程2中的输出通过管道连接到子进程1的输入中</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre><td class="rouge-code"><pre> <span class="cp">#include &lt;stdio.h&gt;
</span> <span class="cp">#include &lt;stdlib.h&gt;
</span> <span class="cp">#include &lt;unistd.h&gt;
</span> <span class="cp">#include &lt;string.h&gt;
</span> <span class="cp">#include &lt;fcntl.h&gt;
</span> <span class="cp">#include &lt;sys/wait.h&gt;
</span>
 <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
 <span class="p">{</span>
     <span class="c1">// close(STDOUT_FILENO);</span>
     <span class="c1">// int fd = open("./p4.output", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);</span>
     <span class="kt">int</span> <span class="n">fds</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
     <span class="k">if</span><span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"open pipe failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
         <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
        
     <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
     <span class="p">{</span> <span class="c1">// fork failed; exit</span>
         <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
         <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
     <span class="p">{</span> <span class="c1">// child: redirect standard output to a file</span>
         <span class="c1">// int wc=wait(NULL);</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">"child1,pid:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">());</span>
         <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
         <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
         <span class="c1">// 从pipe中读取</span>
         <span class="k">if</span><span class="p">((</span><span class="n">len</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
         <span class="p">{</span>
             <span class="n">perror</span><span class="p">(</span><span class="s">"read from pipe"</span><span class="p">);</span>
             <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">"buf:%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
         <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">else</span>
     <span class="p">{</span> <span class="c1">// parent goes down this path (main)</span>
         <span class="c1">// wait(NULL);</span>
         <span class="c1">//创建第二个子进程</span>
         <span class="kt">int</span> <span class="n">rc2</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">rc2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
         <span class="p">{</span> <span class="c1">// fork failed; exit</span>
             <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"fork failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
             <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
         <span class="p">{</span> <span class="c1">// child: redirect standard output to a file</span>
             <span class="c1">// int wc=wait(NULL);</span>
             <span class="n">printf</span><span class="p">(</span><span class="s">"child2,pid:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">());</span>
             <span class="kt">char</span> <span class="n">buf</span><span class="p">[]</span><span class="o">=</span> <span class="s">"12345"</span><span class="p">;</span>
             <span class="c1">// 写入pipe</span>
             <span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="o">!=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
             <span class="p">{</span>
                 <span class="n">perror</span><span class="p">(</span><span class="s">"write to pipe"</span><span class="p">);</span>
                 <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
             <span class="p">}</span>
             <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
         <span class="p">}</span>
     <span class="p">}</span>

     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre></table></code></div></div></ol><h2 id="补充有趣的小知识">补充：有趣的小知识</h2><p>在做作业时发现，有时子进程打印的结果会在shell显示<code class="language-plaintext highlighter-rouge">提示符</code>后才打印出来，如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>root@hjk:~/repo/os_test# ./a.out 
father,pid:92505
root@hjk:~/repo/os_test# child,pid:92506
</pre></table></code></div></div><p>在本文的<code class="language-plaintext highlighter-rouge">[为什么这样设计 API]</code>一节中有提到shell执行程序的逻辑，下面解释下：</p><ul><li>shell 也是一个用户程序，它首先显示一个提示符（prompt）<li>运行程序时shell进程会fork一个子进程<li>子进程使用exec替换程序为要执行的程序，如a.out<li>此时shell进入wait状态，直到子进程退出<li>由于作业中编写的程序又创建了一个子进程，如果父进程先执行完，那么对于shell进程来说，它的子进程就已经结束了，shell结束wait状态，打印一行提示符。此时用户进程的子进程还未结束，又继续在标准输出上打印了信息，那就会有这种现象</ul><h2 id="参考">参考</h2><ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/05.pdf">Operating Systems: Three Easy Pieces 中文版</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-systems/" class="post-tag no-text-decoration" >Operating Systems</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" class="post-tag no-text-decoration" >操作系统导论</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API - 普通人&url=https://hjk.life/posts/operating-systems-3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API - 普通人&u=https://hjk.life/posts/operating-systems-3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API - 普通人&url=https://hjk.life/posts/operating-systems-3/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/docker-cross-compile/">移植Docker到ARM嵌入式设备</a><li><a href="/posts/design-patterns-principles/">软件设计模式——七大设计原则</a><li><a href="/posts/operating-systems-5/">《Operating Systems: Three Easy Pieces》学习笔记(五) 进程调度：介绍</a><li><a href="/posts/operating-systems-6/">《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列</a><li><a href="/posts/memory-fork-error/">Linux系统中内存不足导致system()执行失败的问题</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/cisco/">Cisco</a> <a class="post-tag" href="/tags/container/">container</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/operating-systems-1/"><div class="card-body"> <span class="timeago small" >03-11<i class="unloaded">2021-03-11T09:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(一) 操作系统介绍</h3><div class="text-muted small"><p> 本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出 虚拟化 CPU 首先看个例子 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/time.h&gt; #include &...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-2/"><div class="card-body"> <span class="timeago small" >03-12<i class="unloaded">2021-03-12T09:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二) 抽象：进程</h3><div class="text-muted small"><p> 本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出 进程 API 创建（create） 操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。 销毁（destroy） 由于存在创建...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-4/"><div class="card-body"> <span class="timeago small" >03-16<i class="unloaded">2021-03-16T09:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行</h3><div class="text-muted small"><p> 本文中文版翻译质量堪忧，有不少名词翻译不知所云，建议对照英文版阅读 前言 在构建这样的虚拟化机制时存在一些挑战。 第一个是性能：如何在不增加系统开销的情况下实现虚拟化？ 第二个是控制权：如何有效地运行进程，同时保留对 CPU 的控制？ 控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/operating-systems-2/" class="btn btn-outline-primary" prompt="上一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(二) 抽象：进程</p></a> <a href="/posts/operating-systems-4/" class="btn btn-outline-primary" prompt="下一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://hjk.life/posts/operating-systems-3/'; this.page.identifier = '/posts/operating-systems-3/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://jksky.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (modeToggle !== null) { modeToggle.addEventListener('click', reloadDisqus); window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/prophethjk">Jinkai</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/cisco/">Cisco</a> <a class="post-tag" href="/tags/container/">container</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://hjk.life{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VEN4M3BMXV"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VEN4M3BMXV'); }); </script>
