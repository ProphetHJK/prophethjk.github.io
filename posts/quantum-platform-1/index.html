<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记" /><meta name="author" content="Jinkai" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="架构 控制的倒置 (Inversion of Control) UML 状态机速成 基本的状态机概念 状态 状态图 事件 (Event) 动作和转换 (Action and Transition) 运行-到-完成执行模型 (Run-to-Completion Execution Model, RTC) UML 对传统 FSM 方法的扩展 状态机分类 行为继承 (Behavioral Inheritance) 状态的 LISKOV 替换原则 (LSP) 正交区域 进入和退出动作 (Entry and Exit Actions) 内部转换 (Internal Transistions) 转换的执行次序 本地转换和外部转换的对比 UML 里的事件类型 事件的延迟 (Event Deferral) 伪状态 (Pseudostates) UML 实例 设计一个 UML 状态机 高层设计 寻找重用 (Reuse) operandX 状态设计 处理负号的两种情况 最终状态图 标准状态机的实现方法 嵌套的 switch 语句 状态表 (State Table) 面向对象的状态设计模式 增加进入退出状态操作 封装事件处理 QEP FSM 实现方法 状态机实现技术的一般性讨论 层次式事件处理器的实现 层次式状态处理函数 层次式状态机的类 顶状态和初始伪状态 进入 / 退出动作和嵌套的初始转换 最顶层初始转换 (QHsm_init()) 分派事件（ QHsm_dispatch(), 通用结构） 在状态机里实施一个转换（ QHsm_dispatch(), 转换） 使用 QEP 实现 HSM 步骤的概要 常见问题 状态模式 终极钩子 提示器 延迟的事件 正交构件 转换到历史状态 实时框架的概念 CPU 管理 活动对象计算模式 系统结构 异步通讯 运行 - 到 - 完成 RTC 封装 事件派发机制 直接事件发送 订阅派发机制 事件内存管理 零复制的事件派发 静态和动态的事件 多路传输事件和引用计数器算法 事件的所有权 内存池 时间管理 系统时钟节拍 错误和例外的处理 C 和 C++ 里可定制的断言 基于框架的软件追踪 实时框架的实现 QF 实时框架的关键特征 QF 的结构 QF 源代码的组织 QF 里的临界区 保存和恢复中断状态 无条件上锁和解锁中断 中断上锁/解锁的内部 QF 宏 主动对象 活动对象的内部状态机 活动对象的事件队列 执行线程和活动对象优先级 QF 的事件管理 事件的结构 动态事件分配 自动垃圾收集 延迟和恢复事件 QF 的事件派发机制 直接事件发送 发行-订阅事件发送 时间管理 时间事件结构和接口 系统时钟节拍和 QF_tick() 函数 arming 和 disarm 一个时间事件 原生 QF 事件队列 QEQueue 结构 QEQueue 的初始化 原生 QF 活动对象队列 “ 原始的”线程安全的队列 原生 QF 内存池 原生 QF 内存池的初始化 从池里获得一个内存块 把一个内存块回收到池内 原生 QF 优先级集合 原生合作式 vanilla 内核 qvanilla.c 源文件 qvanilla.h 头文件 可抢占式“运行-到-完成”内核 选择一个可抢占式内核的理由 RTC 内核简介 使用单堆栈的可抢占式多任务处理 非阻塞型内核 同步抢占和异步抢占 堆栈的利用 和传统可抢占式内核的比较 QK 的实现 QK 源代码的组织 头文件 qk.h 中断的处理 源文件 qk_sched.c （ QK 调度器） 源文件 qk.c （ QK 的启动和空闲循环） 高级的 QK 特征 优先级天花板互斥体 本地线程存储 扩展的上下文切换（对协处理器的支持） 移植 QK 移植和配置 QF QP 平台抽象层 生成 QP 应用程序 创建 QP 库 目录和文件 头文件 qep_port.h 头文件 qf_port.h 源代码 qf_port.c 和平台相关的 QF 回调函数 系统时钟节拍（调用 QF_tick() ） 创建 QF 库 移植合作式 Vanilla 内核 头文件 qep_port.h 头文件 qf_port.h 系统时钟节拍（QF_tick()） 空闲处理（QF_onIdel()） QF 移植到 uc/os-II (常规 RTOS) QF 移植到 Linux （常规 POSIX 兼容的操作系统） 头文件 qep_port.h 头文件 qf_port.h qf_port.c 源代码 开发 QP 应用程序 开发 QP 应用程序的准则 准则 启发式 哲学家就餐问题 第一步：需求 第二步：顺序图 第三步：信号，事件和活动对象 第四步：状态机 第五步：初始化并启动应用程序 第六步：优雅的结束应用程序 在不同的平台运行 DPP 在 DOS 上的 Vanilla 内核 在 Cortex-M3 上的 Vanilla 内核 uC/OS-II Linux 调整事件队列和事件池的大小 调整事件队列的大小 调整事件池的大小 系统集成 事件驱动型系统的软件追踪 QS 目标系统驻留构件 QS 源代码的组织 QS 的平台无关头文件 qs.h 和 qs_dummy.h QS 的临界区 QS 记录的一般结构 QS 的过滤器 全局开/关过滤器 本地过滤器 QS 数据协议 透明 大小端 QS 追踪缓存区 初始化 QS 追踪缓存区 QS_initBuf() 面向字节的接口： QS_getByte() 面向块的接口： QS_getBlock() 字典追踪记录 应用程序相关的 QS 追踪记录 移植和配置 QS QSPY 主机应用程序 向 MATLAB 输出追踪数据 向 QP 应用程序添加 QS 软件追踪 定义平台相关的 QS 回调函数 使用回调函数 QS_onGetTime() 产生 QS 时间戳 从主动对象产生 QS 字典 添加应用程序相关的追踪记录 问题 参考" /><meta property="og:description" content="架构 控制的倒置 (Inversion of Control) UML 状态机速成 基本的状态机概念 状态 状态图 事件 (Event) 动作和转换 (Action and Transition) 运行-到-完成执行模型 (Run-to-Completion Execution Model, RTC) UML 对传统 FSM 方法的扩展 状态机分类 行为继承 (Behavioral Inheritance) 状态的 LISKOV 替换原则 (LSP) 正交区域 进入和退出动作 (Entry and Exit Actions) 内部转换 (Internal Transistions) 转换的执行次序 本地转换和外部转换的对比 UML 里的事件类型 事件的延迟 (Event Deferral) 伪状态 (Pseudostates) UML 实例 设计一个 UML 状态机 高层设计 寻找重用 (Reuse) operandX 状态设计 处理负号的两种情况 最终状态图 标准状态机的实现方法 嵌套的 switch 语句 状态表 (State Table) 面向对象的状态设计模式 增加进入退出状态操作 封装事件处理 QEP FSM 实现方法 状态机实现技术的一般性讨论 层次式事件处理器的实现 层次式状态处理函数 层次式状态机的类 顶状态和初始伪状态 进入 / 退出动作和嵌套的初始转换 最顶层初始转换 (QHsm_init()) 分派事件（ QHsm_dispatch(), 通用结构） 在状态机里实施一个转换（ QHsm_dispatch(), 转换） 使用 QEP 实现 HSM 步骤的概要 常见问题 状态模式 终极钩子 提示器 延迟的事件 正交构件 转换到历史状态 实时框架的概念 CPU 管理 活动对象计算模式 系统结构 异步通讯 运行 - 到 - 完成 RTC 封装 事件派发机制 直接事件发送 订阅派发机制 事件内存管理 零复制的事件派发 静态和动态的事件 多路传输事件和引用计数器算法 事件的所有权 内存池 时间管理 系统时钟节拍 错误和例外的处理 C 和 C++ 里可定制的断言 基于框架的软件追踪 实时框架的实现 QF 实时框架的关键特征 QF 的结构 QF 源代码的组织 QF 里的临界区 保存和恢复中断状态 无条件上锁和解锁中断 中断上锁/解锁的内部 QF 宏 主动对象 活动对象的内部状态机 活动对象的事件队列 执行线程和活动对象优先级 QF 的事件管理 事件的结构 动态事件分配 自动垃圾收集 延迟和恢复事件 QF 的事件派发机制 直接事件发送 发行-订阅事件发送 时间管理 时间事件结构和接口 系统时钟节拍和 QF_tick() 函数 arming 和 disarm 一个时间事件 原生 QF 事件队列 QEQueue 结构 QEQueue 的初始化 原生 QF 活动对象队列 “ 原始的”线程安全的队列 原生 QF 内存池 原生 QF 内存池的初始化 从池里获得一个内存块 把一个内存块回收到池内 原生 QF 优先级集合 原生合作式 vanilla 内核 qvanilla.c 源文件 qvanilla.h 头文件 可抢占式“运行-到-完成”内核 选择一个可抢占式内核的理由 RTC 内核简介 使用单堆栈的可抢占式多任务处理 非阻塞型内核 同步抢占和异步抢占 堆栈的利用 和传统可抢占式内核的比较 QK 的实现 QK 源代码的组织 头文件 qk.h 中断的处理 源文件 qk_sched.c （ QK 调度器） 源文件 qk.c （ QK 的启动和空闲循环） 高级的 QK 特征 优先级天花板互斥体 本地线程存储 扩展的上下文切换（对协处理器的支持） 移植 QK 移植和配置 QF QP 平台抽象层 生成 QP 应用程序 创建 QP 库 目录和文件 头文件 qep_port.h 头文件 qf_port.h 源代码 qf_port.c 和平台相关的 QF 回调函数 系统时钟节拍（调用 QF_tick() ） 创建 QF 库 移植合作式 Vanilla 内核 头文件 qep_port.h 头文件 qf_port.h 系统时钟节拍（QF_tick()） 空闲处理（QF_onIdel()） QF 移植到 uc/os-II (常规 RTOS) QF 移植到 Linux （常规 POSIX 兼容的操作系统） 头文件 qep_port.h 头文件 qf_port.h qf_port.c 源代码 开发 QP 应用程序 开发 QP 应用程序的准则 准则 启发式 哲学家就餐问题 第一步：需求 第二步：顺序图 第三步：信号，事件和活动对象 第四步：状态机 第五步：初始化并启动应用程序 第六步：优雅的结束应用程序 在不同的平台运行 DPP 在 DOS 上的 Vanilla 内核 在 Cortex-M3 上的 Vanilla 内核 uC/OS-II Linux 调整事件队列和事件池的大小 调整事件队列的大小 调整事件池的大小 系统集成 事件驱动型系统的软件追踪 QS 目标系统驻留构件 QS 源代码的组织 QS 的平台无关头文件 qs.h 和 qs_dummy.h QS 的临界区 QS 记录的一般结构 QS 的过滤器 全局开/关过滤器 本地过滤器 QS 数据协议 透明 大小端 QS 追踪缓存区 初始化 QS 追踪缓存区 QS_initBuf() 面向字节的接口： QS_getByte() 面向块的接口： QS_getBlock() 字典追踪记录 应用程序相关的 QS 追踪记录 移植和配置 QS QSPY 主机应用程序 向 MATLAB 输出追踪数据 向 QP 应用程序添加 QS 软件追踪 定义平台相关的 QS 回调函数 使用回调函数 QS_onGetTime() 产生 QS 时间戳 从主动对象产生 QS 字典 添加应用程序相关的追踪记录 问题 参考" /><link rel="canonical" href="https://hjk.life/posts/quantum-platform-1/" /><meta property="og:url" content="https://hjk.life/posts/quantum-platform-1/" /><meta property="og:site_name" content="普通人" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-27T09:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jinkai" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jinkai"},"dateModified":"2022-10-24T16:56:10+08:00","datePublished":"2022-07-27T09:00:00+08:00","description":"架构 控制的倒置 (Inversion of Control) UML 状态机速成 基本的状态机概念 状态 状态图 事件 (Event) 动作和转换 (Action and Transition) 运行-到-完成执行模型 (Run-to-Completion Execution Model, RTC) UML 对传统 FSM 方法的扩展 状态机分类 行为继承 (Behavioral Inheritance) 状态的 LISKOV 替换原则 (LSP) 正交区域 进入和退出动作 (Entry and Exit Actions) 内部转换 (Internal Transistions) 转换的执行次序 本地转换和外部转换的对比 UML 里的事件类型 事件的延迟 (Event Deferral) 伪状态 (Pseudostates) UML 实例 设计一个 UML 状态机 高层设计 寻找重用 (Reuse) operandX 状态设计 处理负号的两种情况 最终状态图 标准状态机的实现方法 嵌套的 switch 语句 状态表 (State Table) 面向对象的状态设计模式 增加进入退出状态操作 封装事件处理 QEP FSM 实现方法 状态机实现技术的一般性讨论 层次式事件处理器的实现 层次式状态处理函数 层次式状态机的类 顶状态和初始伪状态 进入 / 退出动作和嵌套的初始转换 最顶层初始转换 (QHsm_init()) 分派事件（ QHsm_dispatch(), 通用结构） 在状态机里实施一个转换（ QHsm_dispatch(), 转换） 使用 QEP 实现 HSM 步骤的概要 常见问题 状态模式 终极钩子 提示器 延迟的事件 正交构件 转换到历史状态 实时框架的概念 CPU 管理 活动对象计算模式 系统结构 异步通讯 运行 - 到 - 完成 RTC 封装 事件派发机制 直接事件发送 订阅派发机制 事件内存管理 零复制的事件派发 静态和动态的事件 多路传输事件和引用计数器算法 事件的所有权 内存池 时间管理 系统时钟节拍 错误和例外的处理 C 和 C++ 里可定制的断言 基于框架的软件追踪 实时框架的实现 QF 实时框架的关键特征 QF 的结构 QF 源代码的组织 QF 里的临界区 保存和恢复中断状态 无条件上锁和解锁中断 中断上锁/解锁的内部 QF 宏 主动对象 活动对象的内部状态机 活动对象的事件队列 执行线程和活动对象优先级 QF 的事件管理 事件的结构 动态事件分配 自动垃圾收集 延迟和恢复事件 QF 的事件派发机制 直接事件发送 发行-订阅事件发送 时间管理 时间事件结构和接口 系统时钟节拍和 QF_tick() 函数 arming 和 disarm 一个时间事件 原生 QF 事件队列 QEQueue 结构 QEQueue 的初始化 原生 QF 活动对象队列 “ 原始的”线程安全的队列 原生 QF 内存池 原生 QF 内存池的初始化 从池里获得一个内存块 把一个内存块回收到池内 原生 QF 优先级集合 原生合作式 vanilla 内核 qvanilla.c 源文件 qvanilla.h 头文件 可抢占式“运行-到-完成”内核 选择一个可抢占式内核的理由 RTC 内核简介 使用单堆栈的可抢占式多任务处理 非阻塞型内核 同步抢占和异步抢占 堆栈的利用 和传统可抢占式内核的比较 QK 的实现 QK 源代码的组织 头文件 qk.h 中断的处理 源文件 qk_sched.c （ QK 调度器） 源文件 qk.c （ QK 的启动和空闲循环） 高级的 QK 特征 优先级天花板互斥体 本地线程存储 扩展的上下文切换（对协处理器的支持） 移植 QK 移植和配置 QF QP 平台抽象层 生成 QP 应用程序 创建 QP 库 目录和文件 头文件 qep_port.h 头文件 qf_port.h 源代码 qf_port.c 和平台相关的 QF 回调函数 系统时钟节拍（调用 QF_tick() ） 创建 QF 库 移植合作式 Vanilla 内核 头文件 qep_port.h 头文件 qf_port.h 系统时钟节拍（QF_tick()） 空闲处理（QF_onIdel()） QF 移植到 uc/os-II (常规 RTOS) QF 移植到 Linux （常规 POSIX 兼容的操作系统） 头文件 qep_port.h 头文件 qf_port.h qf_port.c 源代码 开发 QP 应用程序 开发 QP 应用程序的准则 准则 启发式 哲学家就餐问题 第一步：需求 第二步：顺序图 第三步：信号，事件和活动对象 第四步：状态机 第五步：初始化并启动应用程序 第六步：优雅的结束应用程序 在不同的平台运行 DPP 在 DOS 上的 Vanilla 内核 在 Cortex-M3 上的 Vanilla 内核 uC/OS-II Linux 调整事件队列和事件池的大小 调整事件队列的大小 调整事件池的大小 系统集成 事件驱动型系统的软件追踪 QS 目标系统驻留构件 QS 源代码的组织 QS 的平台无关头文件 qs.h 和 qs_dummy.h QS 的临界区 QS 记录的一般结构 QS 的过滤器 全局开/关过滤器 本地过滤器 QS 数据协议 透明 大小端 QS 追踪缓存区 初始化 QS 追踪缓存区 QS_initBuf() 面向字节的接口： QS_getByte() 面向块的接口： QS_getBlock() 字典追踪记录 应用程序相关的 QS 追踪记录 移植和配置 QS QSPY 主机应用程序 向 MATLAB 输出追踪数据 向 QP 应用程序添加 QS 软件追踪 定义平台相关的 QS 回调函数 使用回调函数 QS_onGetTime() 产生 QS 时间戳 从主动对象产生 QS 字典 添加应用程序相关的追踪记录 问题 参考","headline":"《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记","mainEntityOfPage":{"@type":"WebPage","@id":"https://hjk.life/posts/quantum-platform-1/"},"url":"https://hjk.life/posts/quantum-platform-1/"}</script><title>《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记 | 普通人</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="普通人"><meta name="application-name" content="普通人"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/favicons/Humanity.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">普通人</a></div><div class="site-subtitle font-italic">潜龙勿用</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/prophethjk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['prophethjk','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/prophethjk">Jinkai</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1658883600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-07-27 </em> </span> <span> 更新于 <em class="timeago" data-ts="1666601770" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-10-24 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="64290 字"> <em>357 分钟</em>阅读</span></div></div></div><div class="post-content"><ul><li><a href="#架构">架构</a><ul><li><a href="#控制的倒置-inversion-of-control">控制的倒置 (Inversion of Control)</a></ul><li><a href="#uml-状态机速成">UML 状态机速成</a><ul><li><a href="#基本的状态机概念">基本的状态机概念</a><ul><li><a href="#状态">状态</a><li><a href="#状态图">状态图</a><li><a href="#事件-event">事件 (Event)</a><li><a href="#动作和转换-action-and-transition">动作和转换 (Action and Transition)</a><li><a href="#运行-到-完成执行模型-run-to-completion-execution-model-rtc">运行-到-完成执行模型 (Run-to-Completion Execution Model, RTC)</a></ul><li><a href="#uml-对传统-fsm-方法的扩展">UML 对传统 FSM 方法的扩展</a><ul><li><a href="#状态机分类">状态机分类</a><li><a href="#行为继承-behavioral-inheritance">行为继承 (Behavioral Inheritance)</a><li><a href="#状态的-liskov-替换原则-lsp">状态的 LISKOV 替换原则 (LSP)</a><li><a href="#正交区域">正交区域</a><li><a href="#进入和退出动作-entry-and-exit-actions">进入和退出动作 (Entry and Exit Actions)</a><li><a href="#内部转换-internal-transistions">内部转换 (Internal Transistions)</a><li><a href="#转换的执行次序">转换的执行次序</a></ul><li><a href="#本地转换和外部转换的对比">本地转换和外部转换的对比</a><ul><li><a href="#uml-里的事件类型">UML 里的事件类型</a><li><a href="#事件的延迟-event-deferral">事件的延迟 (Event Deferral)</a><li><a href="#伪状态-pseudostates">伪状态 (Pseudostates)</a><li><a href="#uml-实例">UML 实例</a></ul><li><a href="#设计一个-uml-状态机">设计一个 UML 状态机</a><ul><li><a href="#高层设计">高层设计</a><li><a href="#寻找重用-reuse">寻找重用 (Reuse)</a><li><a href="#operandx-状态设计">operandX 状态设计</a><li><a href="#处理负号的两种情况">处理负号的两种情况</a><li><a href="#最终状态图">最终状态图</a></ul></ul><li><a href="#标准状态机的实现方法">标准状态机的实现方法</a><ul><li><a href="#嵌套的-switch-语句">嵌套的 switch 语句</a><li><a href="#状态表-state-table">状态表 (State Table)</a><li><a href="#面向对象的状态设计模式">面向对象的状态设计模式</a><ul><li><a href="#增加进入退出状态操作">增加进入退出状态操作</a><li><a href="#封装事件处理">封装事件处理</a></ul><li><a href="#qep-fsm-实现方法">QEP FSM 实现方法</a><li><a href="#状态机实现技术的一般性讨论">状态机实现技术的一般性讨论</a></ul><li><a href="#层次式事件处理器的实现">层次式事件处理器的实现</a><ul><li><a href="#层次式状态处理函数">层次式状态处理函数</a><li><a href="#层次式状态机的类">层次式状态机的类</a><ul><li><a href="#顶状态和初始伪状态">顶状态和初始伪状态</a><li><a href="#进入--退出动作和嵌套的初始转换">进入 / 退出动作和嵌套的初始转换</a><li><a href="#最顶层初始转换-qhsm_init">最顶层初始转换 (QHsm_init())</a><li><a href="#分派事件-qhsm_dispatch-通用结构">分派事件（ QHsm_dispatch(), 通用结构）</a><li><a href="#在状态机里实施一个转换-qhsm_dispatch-转换">在状态机里实施一个转换（ QHsm_dispatch(), 转换）</a></ul><li><a href="#使用-qep-实现-hsm-步骤的概要">使用 QEP 实现 HSM 步骤的概要</a><li><a href="#常见问题">常见问题</a></ul><li><a href="#状态模式">状态模式</a><ul><li><a href="#终极钩子">终极钩子</a><li><a href="#提示器">提示器</a><li><a href="#延迟的事件">延迟的事件</a><li><a href="#正交构件">正交构件</a><li><a href="#转换到历史状态">转换到历史状态</a></ul><li><a href="#实时框架的概念">实时框架的概念</a><ul><li><a href="#cpu-管理">CPU 管理</a><li><a href="#活动对象计算模式">活动对象计算模式</a><ul><li><a href="#系统结构">系统结构</a><li><a href="#异步通讯">异步通讯</a><li><a href="#运行---到---完成-rtc">运行 - 到 - 完成 RTC</a><li><a href="#封装">封装</a></ul><li><a href="#事件派发机制">事件派发机制</a><ul><li><a href="#直接事件发送">直接事件发送</a><li><a href="#订阅派发机制">订阅派发机制</a></ul><li><a href="#事件内存管理">事件内存管理</a><ul><li><a href="#零复制的事件派发">零复制的事件派发</a><li><a href="#静态和动态的事件">静态和动态的事件</a><li><a href="#多路传输事件和引用计数器算法">多路传输事件和引用计数器算法</a><li><a href="#事件的所有权">事件的所有权</a><li><a href="#内存池">内存池</a><li><a href="#时间管理">时间管理</a><li><a href="#系统时钟节拍">系统时钟节拍</a></ul><li><a href="#错误和例外的处理">错误和例外的处理</a><ul><li><a href="#c-和-c-里可定制的断言">C 和 C++ 里可定制的断言</a></ul><li><a href="#基于框架的软件追踪">基于框架的软件追踪</a></ul><li><a href="#实时框架的实现">实时框架的实现</a><ul><li><a href="#qf-实时框架的关键特征">QF 实时框架的关键特征</a><li><a href="#qf-的结构">QF 的结构</a><ul><li><a href="#qf-源代码的组织">QF 源代码的组织</a></ul><li><a href="#qf-里的临界区">QF 里的临界区</a><ul><li><a href="#保存和恢复中断状态">保存和恢复中断状态</a><li><a href="#无条件上锁和解锁中断">无条件上锁和解锁中断</a><li><a href="#中断上锁解锁的内部-qf-宏">中断上锁/解锁的内部 QF 宏</a></ul><li><a href="#主动对象">主动对象</a><ul><li><a href="#活动对象的内部状态机">活动对象的内部状态机</a><li><a href="#活动对象的事件队列">活动对象的事件队列</a><li><a href="#执行线程和活动对象优先级">执行线程和活动对象优先级</a></ul><li><a href="#qf-的事件管理">QF 的事件管理</a><ul><li><a href="#事件的结构">事件的结构</a><li><a href="#动态事件分配">动态事件分配</a><li><a href="#自动垃圾收集">自动垃圾收集</a><li><a href="#延迟和恢复事件">延迟和恢复事件</a></ul><li><a href="#qf-的事件派发机制">QF 的事件派发机制</a><ul><li><a href="#直接事件发送-1">直接事件发送</a><li><a href="#发行-订阅事件发送">发行-订阅事件发送</a></ul><li><a href="#时间管理-1">时间管理</a><ul><li><a href="#时间事件结构和接口">时间事件结构和接口</a><li><a href="#系统时钟节拍和-qf_tick-函数">系统时钟节拍和 QF_tick() 函数</a><li><a href="#arming-和-disarm-一个时间事件">arming 和 disarm 一个时间事件</a></ul><li><a href="#原生-qf-事件队列">原生 QF 事件队列</a><ul><li><a href="#qequeue-结构">QEQueue 结构</a><li><a href="#qequeue-的初始化">QEQueue 的初始化</a><li><a href="#原生-qf-活动对象队列">原生 QF 活动对象队列</a><li><a href="#-原始的线程安全的队列">“ 原始的”线程安全的队列</a></ul><li><a href="#原生-qf-内存池">原生 QF 内存池</a><ul><li><a href="#原生-qf-内存池的初始化">原生 QF 内存池的初始化</a><li><a href="#从池里获得一个内存块">从池里获得一个内存块</a><li><a href="#把一个内存块回收到池内">把一个内存块回收到池内</a></ul><li><a href="#原生-qf-优先级集合">原生 QF 优先级集合</a><li><a href="#原生合作式-vanilla-内核">原生合作式 vanilla 内核</a><ul><li><a href="#qvanillac-源文件">qvanilla.c 源文件</a><li><a href="#qvanillah-头文件">qvanilla.h 头文件</a></ul></ul><li><a href="#可抢占式运行-到-完成内核">可抢占式“运行-到-完成”内核</a><ul><li><a href="#选择一个可抢占式内核的理由">选择一个可抢占式内核的理由</a><li><a href="#rtc-内核简介">RTC 内核简介</a><ul><li><a href="#使用单堆栈的可抢占式多任务处理">使用单堆栈的可抢占式多任务处理</a><li><a href="#非阻塞型内核">非阻塞型内核</a><li><a href="#同步抢占和异步抢占">同步抢占和异步抢占</a><li><a href="#堆栈的利用">堆栈的利用</a><li><a href="#和传统可抢占式内核的比较">和传统可抢占式内核的比较</a></ul><li><a href="#qk-的实现">QK 的实现</a><ul><li><a href="#qk-源代码的组织">QK 源代码的组织</a><li><a href="#头文件-qkh">头文件 qk.h</a><li><a href="#中断的处理">中断的处理</a><li><a href="#源文件-qk_schedc--qk-调度器">源文件 qk_sched.c （ QK 调度器）</a><li><a href="#源文件-qkc--qk-的启动和空闲循环">源文件 qk.c （ QK 的启动和空闲循环）</a></ul><li><a href="#高级的-qk-特征">高级的 QK 特征</a><ul><li><a href="#优先级天花板互斥体">优先级天花板互斥体</a><li><a href="#本地线程存储">本地线程存储</a><li><a href="#扩展的上下文切换对协处理器的支持">扩展的上下文切换（对协处理器的支持）</a></ul><li><a href="#移植-qk">移植 QK</a></ul><li><a href="#移植和配置-qf">移植和配置 QF</a><ul><li><a href="#qp-平台抽象层">QP 平台抽象层</a><ul><li><a href="#生成-qp-应用程序">生成 QP 应用程序</a><li><a href="#创建-qp-库">创建 QP 库</a><li><a href="#目录和文件">目录和文件</a><li><a href="#头文件-qep_porth">头文件 qep_port.h</a><li><a href="#头文件-qf_porth">头文件 qf_port.h</a><li><a href="#源代码-qf_portc">源代码 qf_port.c</a><li><a href="#和平台相关的-qf-回调函数">和平台相关的 QF 回调函数</a><li><a href="#系统时钟节拍调用-qf_tick-">系统时钟节拍（调用 QF_tick() ）</a><li><a href="#创建-qf-库">创建 QF 库</a></ul><li><a href="#移植合作式-vanilla-内核">移植合作式 Vanilla 内核</a><ul><li><a href="#头文件-qep_porth-1">头文件 qep_port.h</a><li><a href="#头文件-qf_porth-1">头文件 qf_port.h</a><li><a href="#系统时钟节拍qf_tick">系统时钟节拍（QF_tick()）</a><li><a href="#空闲处理qf_onidel">空闲处理（QF_onIdel()）</a></ul><li><a href="#qf-移植到-ucos-ii-常规-rtos">QF 移植到 uc/os-II (常规 RTOS)</a><li><a href="#qf-移植到-linux-常规-posix-兼容的操作系统">QF 移植到 Linux （常规 POSIX 兼容的操作系统）</a><ul><li><a href="#头文件-qep_porth-2">头文件 qep_port.h</a><li><a href="#头文件-qf_porth-2">头文件 qf_port.h</a><li><a href="#qf_portc-源代码">qf_port.c 源代码</a></ul></ul><li><a href="#开发-qp-应用程序">开发 QP 应用程序</a><ul><li><a href="#开发-qp-应用程序的准则">开发 QP 应用程序的准则</a><ul><li><a href="#准则">准则</a><li><a href="#启发式">启发式</a></ul><li><a href="#哲学家就餐问题">哲学家就餐问题</a><ul><li><a href="#第一步需求">第一步：需求</a><li><a href="#第二步顺序图">第二步：顺序图</a><li><a href="#第三步信号事件和活动对象">第三步：信号，事件和活动对象</a><li><a href="#第四步状态机">第四步：状态机</a><li><a href="#第五步初始化并启动应用程序">第五步：初始化并启动应用程序</a><li><a href="#第六步优雅的结束应用程序">第六步：优雅的结束应用程序</a></ul><li><a href="#在不同的平台运行-dpp">在不同的平台运行 DPP</a><ul><li><a href="#在-dos-上的-vanilla-内核">在 DOS 上的 Vanilla 内核</a><li><a href="#在-cortex-m3-上的-vanilla-内核">在 Cortex-M3 上的 Vanilla 内核</a><li><a href="#ucos-ii">uC/OS-II</a><li><a href="#linux">Linux</a></ul><li><a href="#调整事件队列和事件池的大小">调整事件队列和事件池的大小</a><ul><li><a href="#调整事件队列的大小">调整事件队列的大小</a><li><a href="#调整事件池的大小">调整事件池的大小</a><li><a href="#系统集成">系统集成</a></ul></ul><li><a href="#事件驱动型系统的软件追踪">事件驱动型系统的软件追踪</a><ul><li><a href="#qs-目标系统驻留构件">QS 目标系统驻留构件</a><ul><li><a href="#qs-源代码的组织">QS 源代码的组织</a><li><a href="#qs-的平台无关头文件-qsh-和-qs_dummyh">QS 的平台无关头文件 qs.h 和 qs_dummy.h</a><li><a href="#qs-的临界区">QS 的临界区</a><li><a href="#qs-记录的一般结构">QS 记录的一般结构</a><li><a href="#qs-的过滤器">QS 的过滤器</a><ul><li><a href="#全局开关过滤器">全局开/关过滤器</a><li><a href="#本地过滤器">本地过滤器</a></ul><li><a href="#qs-数据协议">QS 数据协议</a><ul><li><a href="#透明">透明</a><li><a href="#大小端">大小端</a></ul><li><a href="#qs-追踪缓存区">QS 追踪缓存区</a><ul><li><a href="#初始化-qs-追踪缓存区-qs_initbuf">初始化 QS 追踪缓存区 QS_initBuf()</a></ul><li><a href="#面向字节的接口-qs_getbyte">面向字节的接口： QS_getByte()</a><li><a href="#面向块的接口-qs_getblock">面向块的接口： QS_getBlock()</a><li><a href="#字典追踪记录">字典追踪记录</a><li><a href="#应用程序相关的-qs-追踪记录">应用程序相关的 QS 追踪记录</a><li><a href="#移植和配置-qs">移植和配置 QS</a></ul><li><a href="#qspy-主机应用程序">QSPY 主机应用程序</a><li><a href="#向-matlab-输出追踪数据">向 MATLAB 输出追踪数据</a><li><a href="#向-qp-应用程序添加-qs-软件追踪">向 QP 应用程序添加 QS 软件追踪</a><ul><li><a href="#定义平台相关的-qs-回调函数">定义平台相关的 QS 回调函数</a><li><a href="#使用回调函数-qs_ongettime-产生-qs-时间戳">使用回调函数 QS_onGetTime() 产生 QS 时间戳</a><li><a href="#从主动对象产生-qs-字典">从主动对象产生 QS 字典</a><li><a href="#添加应用程序相关的追踪记录">添加应用程序相关的追踪记录</a></ul></ul><li><a href="#问题">问题</a><li><a href="#参考">参考</a></ul><h2 id="架构"><span class="mr-2">架构</span><a href="#架构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qp1.jpg" alt="qp1" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">QF</code> 是一个轻量级<code class="language-plaintext highlighter-rouge">实时框架</code>，是 <code class="language-plaintext highlighter-rouge">QP事件驱动平台</code>的核心构件， QP 也包括了 <code class="language-plaintext highlighter-rouge">QEP层次式事件处理器</code>（在本书第一部分描叙），可抢占的<code class="language-plaintext highlighter-rouge">RTC内核(QK)</code>，和<code class="language-plaintext highlighter-rouge">软件追踪装置(QS)</code>。</p><h3 id="控制的倒置-inversion-of-control"><span class="mr-2">控制的倒置 (Inversion of Control)</span><a href="#控制的倒置-inversion-of-control" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>它和传统的顺序式编程方法例如“超级循环”，或传统的 RTOS 的任务不同。绝大多数的现代事件驱动型系统根据好莱坞原则被构造，“不要呼叫（调用）我们，我们会呼叫（调用）您”(Don’t call us, we will call you.)。因此，当它等待一个事件时，这个事件驱动型系统<code class="language-plaintext highlighter-rouge">没有控制权</code>。仅当一个事件<code class="language-plaintext highlighter-rouge">到达</code>了，程序才被调用去处理这个事件，然后它又很快的<code class="language-plaintext highlighter-rouge">放弃</code>控制权。这种安排允许这个事件驱动型系统同时等待许多事件，结果系统对所有需要处理的事件都能保持反应。</p><ul><li>第一，它意味着一个事件驱动型系统被自然的分解到应用程序里面，由应用程序处理事件，而监督者是事件驱动的平台，由它等待事件并把它们分发给应用程序。<li>第二，控制存在于<code class="language-plaintext highlighter-rouge">事件驱动平台的</code>基础设施 (infrastructure) 中，因此从应用程序的角度看，和传统的顺序式程序相比，<code class="language-plaintext highlighter-rouge">控制被倒置</code>了。<li>第三，事件驱动型应用程序必须在处理完每个事件后交出控制权，因此和顺序式程序不同的是，运行时上下文和程序计数器不能被保留在基于<code class="language-plaintext highlighter-rouge">堆栈</code>的变量中。相反，事件驱动应用程序变成了一个状态机，或者实际上一组合作的状态机，并在<code class="language-plaintext highlighter-rouge">静态变量</code>里保留从一个事件到另一个事件的上下文。</ul><h2 id="uml-状态机速成"><span class="mr-2">UML 状态机速成</span><a href="#uml-状态机速成" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="基本的状态机概念"><span class="mr-2">基本的状态机概念</span><a href="#基本的状态机概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="状态"><span class="mr-2">状态</span><a href="#状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>你不用许多变量、标志和复杂逻辑来记录事件历史，而主要依靠一个<code class="language-plaintext highlighter-rouge">状态变量</code>，它能被假定为<code class="language-plaintext highlighter-rouge">一些</code>有限的已经被确定的值，比如手机的勿扰模式包括了不播放声音、不震动、不自动亮屏等一些设置项，此时对于通知或者来电的处理和正常模式不一样，原来要判断很多设置项，现在只要判断是否是勿扰模式这一个状态就行。</p><h4 id="状态图"><span class="mr-2">状态图</span><a href="#状态图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/uml.jpg" alt="uml" data-proofer-ignore></p><ul><li>状态：圆角矩形<li>状态名：圆角矩形里的标签<li>状态转换：箭头<li>事件：箭头上的标签的<code class="language-plaintext highlighter-rouge">/</code>的前半部分，一般大写<li>动作：箭头上的标签的<code class="language-plaintext highlighter-rouge">/</code>的后半部分<li>初始转换：实心圆点加箭头</ul><h4 id="事件-event"><span class="mr-2">事件 (Event)</span><a href="#事件-event" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>一个事件是对系统有<code class="language-plaintext highlighter-rouge">重大意义</code>的一个在时间和空间上所发生的事情。</p><p>UML图中事件表示<code class="language-plaintext highlighter-rouge">事件类型</code>而不是实例，实际程序中判断的是事件类型实例化后的<code class="language-plaintext highlighter-rouge">事件实例</code>。</p><h4 id="动作和转换-action-and-transition"><span class="mr-2">动作和转换 (Action and Transition)</span><a href="#动作和转换-action-and-transition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>从一个状态切换到另一个状态被称为状态转换，引发它的事件被称为触发事件 (triggering event) ，或简单的被称为触发 (trigger) 。</p><h4 id="运行-到-完成执行模型-run-to-completion-execution-model-rtc"><span class="mr-2">运行-到-完成执行模型 (Run-to-Completion Execution Model, RTC)</span><a href="#运行-到-完成执行模型-run-to-completion-execution-model-rtc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>在 RTC 模型里，系统在分散的不可分割的 <code class="language-plaintext highlighter-rouge">RTC 步骤</code>里处理事件。新到的事件不能中断当前事件的处理，而且必须被存储（通常是存储在一个事件队列里），直到状态机又变成空闲。这些语义完全避免了在一个单一的状态机里的任何内部<code class="language-plaintext highlighter-rouge">并发问题</code>。</p><p>实际上 RTC 步骤可以被抢占，只要抢占它的进程不会共享和该状态机相关的资源，抢占结束能恢复原始上下文就行。</p><h3 id="uml-对传统-fsm-方法的扩展"><span class="mr-2">UML 对传统 FSM 方法的扩展</span><a href="#uml-对传统-fsm-方法的扩展" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="状态机分类"><span class="mr-2">状态机分类</span><a href="#状态机分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><dl><dt>有限状态机 (FSM)<dd>行为的改变（例如，响应<code class="language-plaintext highlighter-rouge">任何事件</code>的改变）对应着<code class="language-plaintext highlighter-rouge">状态改变</code>，被称为状态转换。<dt>扩展状态机(ESM)<dd>事件的发生并不意味着状态改变，通过<code class="language-plaintext highlighter-rouge">定量</code>的方式，让事件发生达到<code class="language-plaintext highlighter-rouge">监护条件</code>（如次数）才<code class="language-plaintext highlighter-rouge">改变状态</code>。</dl><blockquote><p>监护条件 (Guard Condition)：为状态转换添加定量条件，如事件发送达到 1000 次条件才为真，才发生状态转换</p></blockquote><dl><dt>层次式状态机(HSM)<dd>子状态没有对应事件处理方法时，寻找父状态处理方法。不同的子状态<code class="language-plaintext highlighter-rouge">复用</code>了父状态的处理方法，类似于继承(抽象)</dl><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/hsmstate.jpg" alt="hsmstate" data-proofer-ignore></p><p>包含其他状态的状态被称为<code class="language-plaintext highlighter-rouge">复合状态</code> (composite state) ，相对的，没有内部结构的状态被称为<code class="language-plaintext highlighter-rouge">简单状态</code> (simple state)。一个嵌套的状态当它没有被其他状态包含时被称为直接子状态 (direct substate)，否则，它被归类于过渡性嵌套子状态 (transitively nested substate) 。</p><h4 id="行为继承-behavioral-inheritance"><span class="mr-2">行为继承 (Behavioral Inheritance)</span><a href="#行为继承-behavioral-inheritance" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>复用父类处理方法，相当于 OOP 中继承父类函数</p><h4 id="状态的-liskov-替换原则-lsp"><span class="mr-2">状态的 LISKOV 替换原则 (LSP)</span><a href="#状态的-liskov-替换原则-lsp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>一个子状态的行为应该和超状态一致。</p><p>如果在状态 heating 意味着<code class="language-plaintext highlighter-rouge">开启加热器</code>，没有一个子状态（在不从状态 heating 转换出去的情况下）将会<code class="language-plaintext highlighter-rouge">关闭加热器</code>。关闭加热器并停留在 toasting 或 baking 状态就和在 heating 状态<code class="language-plaintext highlighter-rouge">不一致</code>，这说明它是一个（违反了 LSP ）的不良设计。</p><h4 id="正交区域"><span class="mr-2">正交区域</span><a href="#正交区域" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>计算机键盘的两个正交区域（主键区和数字键区）。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/zhenjiao.jpg" alt="zhenjiao" data-proofer-ignore></p><p>当一个系统的行为被分解为<code class="language-plaintext highlighter-rouge">独立</code>的<code class="language-plaintext highlighter-rouge">并发性</code>的主动部分时，状态数目组合性增加，正交区域解决了这个常常碰到的问题。例如，除<code class="language-plaintext highlighter-rouge">主键区</code>外，一个计算机键盘有一个独立的<code class="language-plaintext highlighter-rouge">数字键区</code>。</p><p>尽管正交区域意味着执行时的<code class="language-plaintext highlighter-rouge">独立性</code>（也就是说有一些并发性）， UML 规范没有要求为每一个正交区域分配一个独立的执行线程（尽管可以这样做）。事实上最普通的情况是，这些正交区域在<code class="language-plaintext highlighter-rouge">同一个线程</code>里执行。 UML 规范仅要求设计者在一个事件被派发到一些相关的正交区域时，不要依赖于任何特定的次序。</p><h4 id="进入和退出动作-entry-and-exit-actions"><span class="mr-2">进入和退出动作 (Entry and Exit Actions)</span><a href="#进入和退出动作-entry-and-exit-actions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>UML 的状态图里的每个状态机都可以有<code class="language-plaintext highlighter-rouge">可选</code>的<code class="language-plaintext highlighter-rouge">进入动作</code>，它在进入一个状态时被执行；同时也可以有<code class="language-plaintext highlighter-rouge">可选</code>的<code class="language-plaintext highlighter-rouge">退出动作</code>，在退出一个状态时被执行。</p><p>无论一个状态被以什么方法进入或退出，所有它的进入和退出动作将被执行。(自动强制执行)</p><p>进入和退出动作的价值是它们提供了可担保的初始化和清理方法，非常像 OOP 里类的构造函数和析构函数</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/entryexit.jpg" alt="entryexit" data-proofer-ignore></p><p>如图，当炉门在打开时总是关闭加热器(heating状态退出动作)。另外当炉门被打开，应该点亮内部照明灯(door_open状态进入动作)。</p><p>进入动作的执行必须总是按从最外层状态到最里层状态的次序被处理，如 DOOR_CLOSE 事件让状态变为 heating ，此时先执行 heater_on() ，再因初始转换自动进入子状态 toasting ，并执行 arm_time_event(me-&gt;toast_color) 。类比于构造函数的调用顺序</p><h4 id="内部转换-internal-transistions"><span class="mr-2">内部转换 (Internal Transistions)</span><a href="#内部转换-internal-transistions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>一个<code class="language-plaintext highlighter-rouge">事件</code>造成一些内部动作被执行但是又<code class="language-plaintext highlighter-rouge">不导致</code>一个<code class="language-plaintext highlighter-rouge">状态的改变</code>（状态转换），也不执行任何进入退出动作</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/internaltrans.jpg" alt="internaltrans" data-proofer-ignore></p><p>当你在键盘上打字时，它通过产生不同的字符码来响应。然而，<code class="language-plaintext highlighter-rouge">除非</code>你敲击<code class="language-plaintext highlighter-rouge">CapsLock键</code>，键盘的状态<code class="language-plaintext highlighter-rouge">不会改变</code>（没有状态转换发生）。 ANY_KEY 事件触发内部转换</p><p>和<code class="language-plaintext highlighter-rouge">自转换</code>相反，在执行内部转换时<code class="language-plaintext highlighter-rouge">不会执行</code>进入和退出动作，即使内部转换是从一个超过当前活动状态较高层的层次<code class="language-plaintext highlighter-rouge">继承</code>的。从<code class="language-plaintext highlighter-rouge">超状态</code>继承的<code class="language-plaintext highlighter-rouge">内部转换</code>在任何的<code class="language-plaintext highlighter-rouge">嵌套层</code>都如同它们被直接在<code class="language-plaintext highlighter-rouge">当前活动状态</code>被定义一样执行。</p><h4 id="转换的执行次序"><span class="mr-2">转换的执行次序</span><a href="#转换的执行次序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>如果状态机在一个<code class="language-plaintext highlighter-rouge">复合状态</code>（它也可以被包含在一个更高层的复合状态， 并递归嵌套）里面的<code class="language-plaintext highlighter-rouge">叶状态</code>，所有的直接或间接<code class="language-plaintext highlighter-rouge">包含</code>这个叶状态 (leaf state)的复合状态都是<code class="language-plaintext highlighter-rouge">活动</code>的。而且， 因为在这个层次里的一些复合状态也许有<code class="language-plaintext highlighter-rouge">正交区域</code>，当前活动状态事件代表了一个<code class="language-plaintext highlighter-rouge">树</code>，从在根部的单一顶状态开始往下直到在这个叶的单一<code class="language-plaintext highlighter-rouge">简单状态</code>。 UML 规范把这样一个<code class="language-plaintext highlighter-rouge">状态树</code>叫做<code class="language-plaintext highlighter-rouge">状态配置</code> (state configuration)</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/zhuanhuanlliuchen.jpg" alt="zhuanhuanlliuchen" data-proofer-ignore></p><p>在 UML ，一个<code class="language-plaintext highlighter-rouge">状态转换</code>能直接连接任何两个状态。这两个状态也许是复合的状态，它们被定名一个转换的<code class="language-plaintext highlighter-rouge">主源</code> (main source) 和<code class="language-plaintext highlighter-rouge">主目标</code> (main target)。图 2.9 展示了一个简单的转换实例，并解释了在这个转换里的状态的角色。 UML 规范描叙了执行一个状态转换需要牵涉到以下的动作:</p><ol><li>评估和转换联合的监护条件，如果监护条件为真则执行以下的步骤。<li>退出源状态配置。<li>执行和转换联合的动作。<li>进入到目的状态配置。</ol><p>在这个简单的实例里，主源和主目标在相同的层嵌套，因此这个转换序列很容易解释。例如，图 2.9 所示的转换 T1 引起监护条件 g() 的评估，假设监护条件 g() 被评估为真，后面是动作的<code class="language-plaintext highlighter-rouge">执行序列</code>： a() ； b() ； t() ； c() ； d() ； e() 。</p><p><strong>本书改动</strong>：</p><p>本书描叙的 <code class="language-plaintext highlighter-rouge">HSM实现</code>（见第四章）通过进入到目标状态配置来维持必要的退出源结构的次序，但是完全在<code class="language-plaintext highlighter-rouge">源状态的上下文</code>里去执行和转换联合的动作。也就是说，在<code class="language-plaintext highlighter-rouge">退出</code>源状态配置<code class="language-plaintext highlighter-rouge">之前</code>执行。所实现的具体的转换序列如下：</p><ol><li>评估和转换联合的监护条件，仅当监护条件为真，执行以下的步骤。<li>执行和转换联合的动作。<li>退出源状态配置并进入到目标状态配置。</ol><p>例如，图 2.9 所示的转换 T1 会引发对监护条件 g() 的评估；然后当对监护条件 g() 为真时是<code class="language-plaintext highlighter-rouge">动作序列</code>： t() ；a() ； b() ； c() ； d() ； e() 。</p><p>就是先进行转换和对应动作，再退出源状态，因为退出源状态意味着清空了上下文，不退出就可以利用<code class="language-plaintext highlighter-rouge">源状态的上下文</code>信息做些事情</p><h3 id="本地转换和外部转换的对比"><span class="mr-2">本地转换和外部转换的对比</span><a href="#本地转换和外部转换的对比" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/transitions.jpg" alt="transitions" data-proofer-ignore></p><ul><li>图中(a)上半：本地转换在主目标状态是<code class="language-plaintext highlighter-rouge">主源状态</code>的一个<code class="language-plaintext highlighter-rouge">子状态</code>时，并不会导致从主源状态的退出。<li>图中(a)下半：本地转换在主目标状态是<code class="language-plaintext highlighter-rouge">主源状态</code>的一个<code class="language-plaintext highlighter-rouge">超状态</code>时，不会导致退出和重新进入目标状态。<li>图中(b)上半：外部转换在主目标状态是<code class="language-plaintext highlighter-rouge">主源状态</code>的一个<code class="language-plaintext highlighter-rouge">子状态</code>时，导致退出和重新进入主源状态。<li>图中(b)下半：本地转换在主目标状态是<code class="language-plaintext highlighter-rouge">主源状态</code>的一个<code class="language-plaintext highlighter-rouge">超状态</code>时，导致退出和重新进入目标状态。</ul><blockquote><p>在本书第四章描叙的 HSM实现（以及本书第一版描叙的HSM实现）仅支持<code class="language-plaintext highlighter-rouge">本地转换</code>语义。</p></blockquote><h4 id="uml-里的事件类型"><span class="mr-2">UML 里的事件类型</span><a href="#uml-里的事件类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>UML 规范定义了四种事件，通过具体的符号区分它们：</p><ul><li><code class="language-plaintext highlighter-rouge">signalEvent</code> 代表一个特定的（异步）信号。它的格式是：<em><code class="language-plaintext highlighter-rouge">信号名 ’(’ 逗号分开的变量表 ’)’</code></em> 。<li><code class="language-plaintext highlighter-rouge">TimeEvnt</code> 对一个特定的最后期限建模。它用关键词 <code class="language-plaintext highlighter-rouge">after</code> 标识，后面是一个具体指明时间量的表达式。时间从进入到以 TimeEvnt为一个触发的状态开始计时。<li><code class="language-plaintext highlighter-rouge">callEvent</code> 代表了同步地调用一个特定操作的请求。它的格式是：<em><code class="language-plaintext highlighter-rouge">操作名 ’(’ 逗号分开的变量表 ’)’</code></em> 。<li><code class="language-plaintext highlighter-rouge">changeEvent</code> 对一个明确的布尔表达式为真时出现的一个事件建模。它用关键词 <code class="language-plaintext highlighter-rouge">when</code> 标识，后面是一个布尔表达式。</ul><blockquote><p>本书描叙的 HSM 实现（见第四章）仅支持 <code class="language-plaintext highlighter-rouge">SignalEvent</code> 类型。第 2 部分描叙的实时框架增加了对 TimeEvent 类型的支持，但是 QF 里的 TimeEvent 需要明确的启动和解除，这和 UML 的 after 符号不兼容。因为 SignalEvent <code class="language-plaintext highlighter-rouge">多态性事件</code>触发的固有的复杂性和非常高的<code class="language-plaintext highlighter-rouge">性能开销</code>，它也不被支持。</p></blockquote><h4 id="事件的延迟-event-deferral"><span class="mr-2">事件的延迟 (Event Deferral)</span><a href="#事件的延迟-event-deferral" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>有时候，一个事件，在一个状态机正在某个状态中从而不能处理这个事件这种特别<code class="language-plaintext highlighter-rouge">不方便</code>的时刻到达。在很多情况下，事件的本性是它可以被（有限度的）<code class="language-plaintext highlighter-rouge">推迟</code>，直到系统进入到<code class="language-plaintext highlighter-rouge">另一个状态</code>，在那里它被更好的准备去处理这个原来的事件。</p><p>UML 状态机提供了一个特定的机制，用来在状态里延迟事件。在每一个状态，你能包含一个 <code class="language-plaintext highlighter-rouge">deferred / [event list]</code>。如果在当前状态的延迟事件列表中的一个事件出现，这个事件会被保留（延迟）给将来处理，直到进入到一个没有把它放在自己的延迟事件列表中的状态。在进入这种状态时， UML 状态机将自动的<code class="language-plaintext highlighter-rouge">恢复</code>任何被保留的事件，不再延迟它们，而像它们<code class="language-plaintext highlighter-rouge">刚刚到达</code>一样处理它们。</p><p>关联章节<a href="#延迟的事件">延迟的事件</a></p><h4 id="伪状态-pseudostates"><span class="mr-2">伪状态 (Pseudostates)</span><a href="#伪状态-pseudostates" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><code class="language-plaintext highlighter-rouge">初始伪状态</code> (initial pseudostate)(显示为一个黑点)表示了一个初始转换的源。在一个复合状态里，可以有最多一个初始伪装态。从初始伪装态出发的转换可能有动作，但是没有触发或者监护条件。<li><code class="language-plaintext highlighter-rouge">选择伪状态</code> (choice pseudostate)(显示为一个菱形或空心圈)被用来进行动态条件分支。它允许转换的分裂到多个外向路径，因此决定使用哪一个路径取决于在相同的 RTC 步骤先前被执行的动作。<li>浅历史伪状态 (shallow-history pseudostate)<li>深历史伪状态 (deep-history pseudostate)<li>连接点伪状态 (junction pseudostate)<li>结合伪状态 (join pseudostate)<li>分支伪状态 (fork pseudostate)</ul><blockquote><p>只介绍两个常用的，其他的不做介绍</p></blockquote><h4 id="uml-实例"><span class="mr-2">UML 实例</span><a href="#uml-实例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>假想的 <code class="language-plaintext highlighter-rouge">4 层嵌套状态机</code>，包含了所有可能的状态转换拓扑，初始 me-&gt;foo 为 0：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/SM_of_QHsmTst.png" alt="SM_of_QHsmTst" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">状态切换</code>，QHSMTST.EXE 实例程序运行在命令窗口。 在括号里的是供参照的行序号：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qhsmtst.jpg" alt="qhsmtst" data-proofer-ignore></p><p>(5) 当前状态为 s11，首先使用 s11 自带的 D 事件处理方法处理 D 事件，发现 D 的监护条件不满足，则转而执行 s11 父状态 s1 的 D 事件处理函数，发现监护条件满足。然后先退出 s11 到 s1，因为本次转换的源状态需要为 s1，然后切换到目标状态 s。因为 s 状态包含初始伪状态，需要执行初始伪状态对应的转换（见 <a href="#伪状态-pseudostates">伪状态 (Pseudostates)</a>），所以会进入 s1 再进入 s11（虽然箭头直接指向 s11，但不能越过 s11 的进入动作）。</p><ul><li><p>事件的表示</p><ul><li>事件名称(类型)<li>(可选)菱形分割<li>监护条件(判断条件，<code class="language-plaintext highlighter-rouge">[]</code>包裹)<li>分割号<code class="language-plaintext highlighter-rouge">/</code><li>动作<li>源状态(超状态有个黑点表示本状态，表示进入此状态时无条件自动进入目标状态，状态机不能处于超状态下)<li>目标状态</ul><p>示例 1：<code class="language-plaintext highlighter-rouge">I[me-&gt;foo]/me-&gt;foo=0</code>，<code class="language-plaintext highlighter-rouge">I</code>为事件名称，<code class="language-plaintext highlighter-rouge">[me-&gt;foo]</code>为监护条件，分割号<code class="language-plaintext highlighter-rouge">/</code>分割了事件信息和动作，<code class="language-plaintext highlighter-rouge">me-&gt;foo=0</code>为动作。</p><p>示例 2：<code class="language-plaintext highlighter-rouge">entry/</code>，<code class="language-plaintext highlighter-rouge">entry</code>表示 entry 事件，没有对应的动作和监护条件；<code class="language-plaintext highlighter-rouge">exit/</code>，<code class="language-plaintext highlighter-rouge">exit</code>表示 exit 事件，没有对应的动作和监护条件</p></ul><p><code class="language-plaintext highlighter-rouge">满足监护条件</code>才会执行对应的<code class="language-plaintext highlighter-rouge">状态转换</code>和<code class="language-plaintext highlighter-rouge">动作</code>。</p><p>子状态之间的状态转换需要源状态依次退出到双方的<code class="language-plaintext highlighter-rouge">最小共同父状态</code>(如 s11 和 s211 的最小共同父状态为 s，书中叫最少共同祖先 least common ancestor(LCA)，我觉得不太好理解)，再依次进入到目的标态</p><h3 id="设计一个-uml-状态机"><span class="mr-2">设计一个 UML 状态机</span><a href="#设计一个-uml-状态机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>计算器（见图 2.13）总的来说操作如下：用户输入一个<code class="language-plaintext highlighter-rouge">操作数</code> (operand) ，然后一个<code class="language-plaintext highlighter-rouge">操作符</code> (operator)，然后另一个<code class="language-plaintext highlighter-rouge">操作数</code>，最后点击<code class="language-plaintext highlighter-rouge">等号</code>按钮得到一个结果。从编程的角度看，意味着这个计算器需要对由下面 BNF 语法定义的数字表达式进行语法分析</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>expression ::= operand1 operator operand2 '='
operand1   ::= expression | ['+' | '-'] number
operand2   ::= ['+' | '-'] number
number     ::= {'0' | '1' | ... '9'}* ['.' {'0' | '1' | ... '9'}*]
operator   ::= '+' | '-' | '*' | '/'
</pre></table></code></div></div><h4 id="高层设计"><span class="mr-2">高层设计</span><a href="#高层设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/calculater1.jpg" alt="calculater1" data-proofer-ignore></p><p>(A)的问题是没有结果显示状态(result)，完善后得到(B)，可以在开始下一次输入 operand1 前清空屏幕，还可以将结果作为下一次的 operand1</p><blockquote><p>把信号 PLUS ，MINUS， MULTIPLY 和 DIVIDE <code class="language-plaintext highlighter-rouge">合并</code>成一个高级的信号 <code class="language-plaintext highlighter-rouge">OPER</code> （操作数）。这个变换避免了在两个转换（从 operand1 到 opEntered，和从 result 到 opEntered）上重复相同的触发（这里的意思应该就是简化设计，不然要画4条箭头）。</p></blockquote><h4 id="寻找重用-reuse"><span class="mr-2">寻找重用 (Reuse)</span><a href="#寻找重用-reuse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/calculater2.jpg" alt="calculater2" data-proofer-ignore></p><p>为了保证能在任意状态执行 <code class="language-plaintext highlighter-rouge">Clear 初始化</code>和<code class="language-plaintext highlighter-rouge">关机</code>，需要很多状态转换。</p><p>此时可以提取一个<code class="language-plaintext highlighter-rouge">超状态</code>，初始化操作和关机操作放到超状态（图中(B)），让子状态重用该操作，这里就利用了层次式状态机</p><h4 id="operandx-状态设计"><span class="mr-2">operandX 状态设计</span><a href="#operandx-状态设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/calculater3.jpg" alt="calculater3" data-proofer-ignore></p><p>三个入口：</p><ul><li>输入 0 事件 – zeroX 状态<li>输入 1-9 事件 – intX 状态<li>输入小数点事件 – fracX 状态</ul><p>三个状态：</p><ul><li><p>zeroX</p><ul><li>忽略输入 0 事件<li>其他事件产生状态切换</ul><li><p>intX</p><ul><li>处理输入 0-9 事件<li>输入小数点事件产生状态切换</ul><li><p>fracX</p><ul><li>处理输入 0-9 事件<li>忽略输入小数点事件</ul></ul><h4 id="处理负号的两种情况"><span class="mr-2">处理负号的两种情况</span><a href="#处理负号的两种情况" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>如表达式 -2 * -2 =</p><p>添加两个和 operandX 同级的状态 negated1 和 negated2 用于处理数字前的负号，和 zeroX 状态类似</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/calculater4.jpg" alt="calculater4" data-proofer-ignore></p><p>(A) 为第二个操作数添加负号，<code class="language-plaintext highlighter-rouge">opEntered</code>状态下收到 <code class="language-plaintext highlighter-rouge">OPER</code> 事件，判断监护条件按键是否是’-‘，是的话进入<code class="language-plaintext highlighter-rouge">negated2</code>状态，该状态仅处理数字和小数点。</p><p>(B) 为第一个操作数添加负号，<code class="language-plaintext highlighter-rouge">opEntered</code>状态下收到 <code class="language-plaintext highlighter-rouge">OPER</code> 事件，判断监护条件按键是否是’-‘，是的话进入<code class="language-plaintext highlighter-rouge">negated1</code>状态，该状态仅处理数字和小数点。</p><h4 id="最终状态图"><span class="mr-2">最终状态图</span><a href="#最终状态图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/calculater5.jpg" alt="calculater5" data-proofer-ignore></p><h2 id="标准状态机的实现方法"><span class="mr-2">标准状态机的实现方法</span><a href="#标准状态机的实现方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>定时炸弹有一个带有LCD的控制面板显示当前的超时值，还有三个按钮： UP ，DOWN 和 ARM 。用户开始时要设定时炸弹，使用 UP 和 DOWN 按钮以一秒的步长调节超时值。一旦所需要的超时值被选中，用户能通过按 ARM 按钮来启动这个炸弹。当启动后，炸弹开始每秒递减这个超时值， 并在超时值到达零时爆炸。附加的安全特征是通过输入一个密码来拆除一个已启动的定时炸弹雷管的选项。拆雷管的密码是 UP 和 DOWN 按钮的某个组合，并以 ARM 按钮被按下结束。当然，拆雷管的密码必须在炸弹超时前被正确的输入。</p><p>定时炸弹状态机的 UML 状态图:</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/bomb.jpg" alt="bomb" data-proofer-ignore></p><h3 id="嵌套的-switch-语句"><span class="mr-2">嵌套的 switch 语句</span><a href="#嵌套的-switch-语句" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Bomb1_dispatch</span><span class="p">(</span><span class="n">Bomb1</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">Event</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* dispatching */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SETTING_STATE</span><span class="p">:</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">UP_SIG</span><span class="p">:</span> <span class="p">{</span> <span class="cm">/* internal transition with a guard */</span>
        <span class="p">...}</span>
      <span class="p">}</span>
      <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">TIMING_STATE</span><span class="p">:</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">UP_SIG</span><span class="p">:</span> <span class="p">{</span>
          <span class="n">me</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">me</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
      <span class="p">}</span>
      <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="状态表-state-table"><span class="mr-2">状态表 (State Table)</span><a href="#状态表-state-table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/bomb_statetable.jpg" alt="bomb_statetable" data-proofer-ignore></p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">当前状态<th style="text-align: left">事件 ( 参数 )<th style="text-align: left">[ 监护条件 ]<th style="text-align: left">下一状态<th style="text-align: left">动作<tbody><tr><td style="text-align: left">setting<td style="text-align: left">UP<td style="text-align: left">[me-&gt;timeout &lt; 60]<td style="text-align: left">setting<td style="text-align: left">++me-&gt;timeout;BSP_display(me-&gt;timeout);<tr><td style="text-align: left"> <td style="text-align: left">DOWN<td style="text-align: left">[me-&gt;timeout &gt; 1]<td style="text-align: left">setting<td style="text-align: left">–me-&gt;timeout;BSP_display(me-&gt;timeout);<tr><td style="text-align: left"> <td style="text-align: left">ARM<td style="text-align: left"> <td style="text-align: left">timing<td style="text-align: left">me-&gt;code = 0;<tr><td style="text-align: left"> <td style="text-align: left">TICK<td style="text-align: left"> <td style="text-align: left">setting<td style="text-align: left"> <tr><td style="text-align: left">timing<td style="text-align: left">UP<td style="text-align: left"> <td style="text-align: left">timing<td style="text-align: left">me-&gt;code «=1;me-&gt;code = 1;<tr><td style="text-align: left"> <td style="text-align: left">DOWN<td style="text-align: left"> <td style="text-align: left">timing<td style="text-align: left">me-&gt;code «= 1;<tr><td style="text-align: left"> <td style="text-align: left">ARM<td style="text-align: left">[me-&gt;code == me-&gt;defuse]<td style="text-align: left">setting<td style="text-align: left"> <tr><td style="text-align: left"> <td style="text-align: left">TICK(fine_time)<td style="text-align: left">[e-&gt;fine_time == 0]<td style="text-align: left">choice<td style="text-align: left">–me-&gt;timeout;BSP_display(me-&gt;timeout);<tr><td style="text-align: left"> <td style="text-align: left"> <td style="text-align: left">[me-&gt;timeout == 0]<td style="text-align: left">final<td style="text-align: left">BSP_boom();<tr><td style="text-align: left"> <td style="text-align: left"> <td style="text-align: left">[else]<td style="text-align: left">timing<td style="text-align: left"> </table></div><h3 id="面向对象的状态设计模式"><span class="mr-2">面向对象的状态设计模式</span><a href="#面向对象的状态设计模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/bomb_oob.jpg" alt="bomb_oob" data-proofer-ignore></p><p>用到了多态，使用 C++实现更为简单</p><p>正常来说 BombState 被定义为<code class="language-plaintext highlighter-rouge">抽象类</code>，应该包含至少一个<code class="language-plaintext highlighter-rouge">纯虚函数</code>，不过此处没有，应该是为了让子类继承父类中虚函数的空实现。</p><h4 id="增加进入退出状态操作"><span class="mr-2">增加进入退出状态操作</span><a href="#增加进入退出状态操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/bomb_oob2.jpg" alt="bomb_oob2" data-proofer-ignore></p><p>Bomb 类的 onTick()操作不仅调用了 BombState 状态或是子状态的 onTick 事件处理，还检测了状态是否切换，并执行对应的退出和进入动作</p><h4 id="封装事件处理"><span class="mr-2">封装事件处理</span><a href="#封装事件处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/bomb_oob3.jpg" alt="bomb_oob3" data-proofer-ignore></p><p>封装了状态中的事件处理函数，这就导致需要在封装函数内使用<code class="language-plaintext highlighter-rouge">switch</code>区分事件并执行操作。</p><p>坏处是失去了 C++提供的多态性</p><p>好处是在添加新事件时只需修改函数内内容，无需增加函数定义</p><h3 id="qep-fsm-实现方法"><span class="mr-2">QEP FSM 实现方法</span><a href="#qep-fsm-实现方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>在前面的几节里，提供了实现 FSM 的三种最流行的技术。可是从我的经验来说，单独使用它们时没有一个是最优的</p><p>本章只介绍 FSM 的实现，HSM 层次式状态机的在下一章</p><p>通用的 QEP 事件处理器：</p><p>QEP（事件处理器）设计的创新性来自于把<code class="language-plaintext highlighter-rouge">状态</code>直接映射成<code class="language-plaintext highlighter-rouge">状态处理函数</code>，处理在状态里它们表示的全部事件</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qep.jpg" alt="qep" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="cm">/* qevent.h ----------------------------------------------------------------*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">QEventTag</span>
<span class="p">{</span>                     <span class="cm">/* the event structure */</span>
    <span class="c1">// 一个整数，相当于事件唯一标识，方便switch...case...区分事件</span>
    <span class="n">QSignal</span> <span class="n">sig</span><span class="p">;</span>      <span class="cm">/* signal of the event */</span>
    <span class="kt">uint8_t</span> <span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* dynamic attribute of the event (0 for static) */</span>
<span class="p">}</span> <span class="n">QEvent</span><span class="p">;</span> <span class="c1">// 事件，可派生添加参数</span>

<span class="cm">/* qep.h -------------------------------------------------------------------*/</span>
<span class="c1">// 事件处理对事件处理的状态</span>
<span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="n">QState</span><span class="p">;</span>          <span class="cm">/* status returned from a state-handler function */</span>
<span class="c1">// 状态处理函数指针，本设计中状态处理函数就表示状态，有typedef表示指定它的类型为QState，</span>
<span class="c1">// 相当于一种声明，而非定义产生实例</span>
<span class="k">typedef</span>                          <span class="cm">/* pointer to function type definition */</span>
    <span class="n">QState</span>                       <span class="cm">/* return type */</span>
    <span class="p">(</span><span class="o">*</span><span class="n">QStateHandler</span><span class="p">)</span>             <span class="cm">/* name of the pointer-to-function type */</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span> <span class="cm">/* argument list */</span> <span class="c1">// 一个通用状态机的指针和一个 QEvent指针</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">QFsmTag</span>
<span class="p">{</span>                        <span class="cm">/* Finite State Machine */</span>
    <span class="c1">// 当前处于的状态，指向状态处理函数</span>
    <span class="n">QStateHandler</span> <span class="n">state</span><span class="p">;</span> <span class="cm">/* current active state */</span>
<span class="p">}</span> <span class="n">QFsm</span><span class="p">;</span> <span class="c1">// 派生各个状态机结构的基本类</span>

<span class="cp">#define QFsm_ctor(me_, initial_) ((me_)-&gt;state = (initial_))
</span><span class="c1">// 触发状态机的初始转换</span>
<span class="kt">void</span> <span class="nf">QFsm_init</span><span class="p">(</span><span class="n">QFsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="c1">// 派发一个事件给状态机</span>
<span class="kt">void</span> <span class="nf">QFsm_dispatch</span><span class="p">(</span><span class="n">QFsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>

<span class="c1">// 从状态处理函数到事件处理器的返回状态</span>
<span class="cp">#define Q_RET_HANDLED ((QState)0)
#define Q_RET_IGNORED ((QState)1)
#define Q_RET_TRAN ((QState)2)
</span>
<span class="c1">// 一个状态处理函数，每当它处理了当前的事件时，返回宏 Q_HANDLED( ) 。</span>
<span class="cp">#define Q_HANDLED() (Q_RET_HANDLED)
</span><span class="c1">// 一个状态处理函数，每当它忽略（不处理）当前的事件时，返回宏 Q_IGNORED( )</span>
<span class="cp">#define Q_IGNORED() (Q_RET_IGNORED)
</span><span class="c1">// 逗号表达式表示执行逗号前语句，但整个表达式的值为逗号后变量，优先级比'='更低，</span>
<span class="c1">// 先执行((QFsm *)me)-&gt;state = (QStateHandler)(target_)，但Q_TRAN(target_)值为Q_RET_TRAN</span>
<span class="c1">// 这里可以用(QFsm *)强制转换me是因为派生类me的第一个成员变量就是它的父类QFsm实例，内存起始位置和me一样</span>
<span class="cp">#define Q_TRAN(target_) \
    (((QFsm *)me)-&gt;state = (QStateHandler)(target_), Q_RET_TRAN)
</span>
<span class="c1">// 内部使用的信号</span>
<span class="c1">// QEP内部维护一个不变的保留事件数组 QEP_reservedEvt_[ ]。用于保存信号对应的事件</span>
<span class="k">enum</span> <span class="n">QReservedSignals</span>
<span class="p">{</span>
    <span class="n">Q_ENTRY_SIG</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* signal for coding entry actions */</span>
    <span class="n">Q_EXIT_SIG</span><span class="p">,</span>      <span class="cm">/* signal for coding exit actions */</span>
    <span class="n">Q_INIT_SIG</span><span class="p">,</span>      <span class="cm">/* signal for coding initial transitions */</span>
    <span class="n">Q_USER_SIG</span>       <span class="cm">/* first signal that can be used in user applications */</span>
<span class="p">};</span>
</pre></table></code></div></div><p>QEP FSM 事件处理器的实现:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cm">/* file qfsm_ini.c ---------------------------------------------------------*/</span>
<span class="cp">#include</span> <span class="cpf">"qep_port.h"</span><span class="c1"> /* the port of the QEP event processor */</span><span class="cp">
#include</span> <span class="cpf">"qassert.h"</span><span class="c1">  /* embedded systems-friendly assertions */</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">QFsm_init</span><span class="p">(</span><span class="n">QFsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 执行QFsm超状态的状态处理函数，就是init</span>
    <span class="p">(</span><span class="o">*</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)(</span><span class="n">me</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* execute the top-most initial transition */</span>
    <span class="c1">// 进入目的状态，手动指定状态切换事件(用信号Q_ENTRY_SIG指定)，并处理状态切换事件</span>
    <span class="c1">// QEP内部维护一个不变的保留事件数组 QEP_reservedEvt_[ ]。用于保存信号对应的事件</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="o">*</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)(</span><span class="n">me</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QEP_reservedEvt_</span><span class="p">[</span><span class="n">Q_ENTRY_SIG</span><span class="p">]);</span><span class="cm">/* enter the target */</span>
<span class="p">}</span>
<span class="cm">/* file qfsm_dis.c ---------------------------------------------------------*/</span>
<span class="c1">// 事件生成函数</span>
<span class="kt">void</span> <span class="nf">QFsm_dispatch</span><span class="p">(</span><span class="n">QFsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 在栈空间中临时保存，防止执行事件处理函数切换状态后丢失源状态</span>
    <span class="n">QStateHandler</span> <span class="n">s</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span> <span class="cm">/* save the current state */</span>
    <span class="c1">// 调用当前状态中对应的事件处理函数</span>
    <span class="n">QState</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)(</span><span class="n">me</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>      <span class="cm">/* call the event handler */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">Q_RET_TRAN</span><span class="p">)</span> <span class="c1">// 执行事件处理函数后发生了状态转换</span>
    <span class="p">{</span>                                                           <span class="cm">/* transition taken? */</span>
        <span class="c1">// 退出源状态，调用源状态的事件处理函数（发送信号Q_EXIT_SIG）</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="o">*</span><span class="n">s</span><span class="p">)(</span><span class="n">me</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QEP_reservedEvt_</span><span class="p">[</span><span class="n">Q_EXIT_SIG</span><span class="p">]);</span>          <span class="cm">/* exit the source */</span>
        <span class="c1">// 进入目的状态，调用目的状态的事件处理函数（发送信号Q_ENTRY_SIG）</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="o">*</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)(</span><span class="n">me</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QEP_reservedEvt_</span><span class="p">[</span><span class="n">Q_ENTRY_SIG</span><span class="p">]);</span> <span class="cm">/*enter target*/</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>应用程序相关的代码(定时炸弹实例):</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qep_port.h"</span><span class="c1"> /* the port of the QEP event processor */</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="c1">      /* board support package */</span><span class="cp">
</span><span class="c1">// 内部使用的信号</span>
<span class="k">enum</span> <span class="n">BombSignals</span>
<span class="p">{</span> <span class="cm">/* all signals for the Bomb FSM */</span>
  <span class="n">UP_SIG</span> <span class="o">=</span> <span class="n">Q_USER_SIG</span><span class="p">,</span>
  <span class="n">DOWN_SIG</span><span class="p">,</span>
  <span class="n">ARM_SIG</span><span class="p">,</span>
  <span class="n">TICK_SIG</span>
<span class="p">};</span>
<span class="c1">// 继承自QEvent的Tick事件</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TickEvtTag</span>
<span class="p">{</span>
    <span class="n">QEvent</span> <span class="n">super</span><span class="p">;</span>      <span class="cm">/* derive from the QEvent structure */</span>
    <span class="kt">uint8_t</span> <span class="n">fine_time</span><span class="p">;</span> <span class="cm">/* the fine 1/10 s counter */</span>
<span class="p">}</span> <span class="n">TickEvt</span><span class="p">;</span>
<span class="c1">// 继承自QFsm的状态机，增加了自定义的一些参数</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Bomb4Tag</span>
<span class="p">{</span>
    <span class="n">QFsm</span> <span class="n">super</span><span class="p">;</span>      <span class="cm">/* derive from QFsm */</span>
    <span class="kt">uint8_t</span> <span class="n">timeout</span><span class="p">;</span> <span class="cm">/* number of seconds till explosion */</span> <span class="c1">//倒计时</span>
    <span class="kt">uint8_t</span> <span class="n">code</span><span class="p">;</span>    <span class="cm">/* currently entered code to disarm the bomb */</span> <span class="c1">//密码输入值</span>
    <span class="kt">uint8_t</span> <span class="n">defuse</span><span class="p">;</span>  <span class="cm">/* secret defuse code to disarm the bomb */</span> <span class="c1">//密码</span>
<span class="p">}</span> <span class="n">Bomb4</span><span class="p">;</span>
<span class="c1">// 后面是不是就是检测到事件时调用me-&gt;state(me,e)就行</span>
<span class="kt">void</span> <span class="nf">Bomb4_ctor</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">defuse</span><span class="p">);</span> <span class="c1">// 初始化（类似C++的构造函数）</span>
<span class="n">QState</span> <span class="nf">Bomb4_initial</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span> <span class="c1">// 入口</span>
<span class="n">QState</span> <span class="nf">Bomb4_setting</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span> <span class="c1">// setting状态事件处理函数</span>
<span class="n">QState</span> <span class="nf">Bomb4_timing</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span> <span class="c1">// timing状态事件处理函数</span>
<span class="cm">/*--------------------------------------------------------------------------*/</span>
<span class="cm">/* the initial value of the timeout */</span>
<span class="cp">#define INIT_TIMEOUT 10
</span><span class="cm">/*..........................................................................*/</span>
<span class="kt">void</span> <span class="nf">Bomb4_ctor</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">defuse</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QFsm_ctor_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Bomb4_initial</span><span class="p">);</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">defuse</span> <span class="o">=</span> <span class="n">defuse</span><span class="p">;</span> <span class="cm">/* the defuse code is assigned at instantiation */</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="n">QState</span> <span class="nf">Bomb4_initial</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">INIT_TIMEOUT</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Bomb4_setting</span><span class="p">);</span> <span class="c1">//切换到setting</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="n">QState</span> <span class="nf">Bomb4_setting</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 使用switch区分事件，这里是用了QEvent中的一个整数变量sig，相当于事件唯一标识，</span>
    <span class="c1">// 因为switch只支持int整数，不支持结构体</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">UP_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
            <span class="n">BSP_display</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span><span class="c1">// 不切换状态就返回Q_HANDLED()</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">DOWN_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">--</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
            <span class="n">BSP_display</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">ARM_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="c1">// 需要切换状态就使用Q_TRAN</span>
        <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Bomb4_timing</span><span class="p">);</span> <span class="cm">/* transition to "timing" */</span>
    <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Q_IGNORED</span><span class="p">();</span><span class="c1">// 没有对应事件就返回Q_IGNORED()</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="kt">void</span> <span class="nf">Bomb4_timing</span><span class="p">(</span><span class="n">Bomb4</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">me</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* clear the defuse code */</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">UP_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">me</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">me</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">DOWN_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">me</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">ARM_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">==</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">defuse</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Bomb4_setting</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">TICK_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="c1">// 拿派生事件的自定义参数也没问题</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">TickEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fine_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">--</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
            <span class="n">BSP_display</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">BSP_boom</span><span class="p">();</span> <span class="cm">/* destroy the bomb */</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Q_IGNORED</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="状态机实现技术的一般性讨论"><span class="mr-2">状态机实现技术的一般性讨论</span><a href="#状态机实现技术的一般性讨论" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><code class="language-plaintext highlighter-rouge">函数指针</code>是使用 C/C++ 实现状态机时最快的途径。状态函数可以放在 ROM 里，RAM 里只需存指针。<li>C++语言里，<code class="language-plaintext highlighter-rouge">异常抛出和捕捉</code>例外和状态机的<code class="language-plaintext highlighter-rouge">运行到完成</code> (RTC) 语义基本上<code class="language-plaintext highlighter-rouge">不相容</code>。因为破坏了事件处理的原子性<li><code class="language-plaintext highlighter-rouge">监护条件</code>和<code class="language-plaintext highlighter-rouge">选择伪状态</code>的实现就是把<code class="language-plaintext highlighter-rouge">return Q_TRAN()</code>改为条件判断函数，将切换状态的任务交给该函数<li><code class="language-plaintext highlighter-rouge">QFsm_dispatch</code>实现状态切换的方式是发送<code class="language-plaintext highlighter-rouge">EXIT</code>和<code class="language-plaintext highlighter-rouge">ENTER</code>事件(信号)给对应状态，这样状态可以在进入和退出时做一些事情，如初始化某些值，相关状态只需要在事件处理函数中实现对这类事件的处理。</ul><h2 id="层次式事件处理器的实现"><span class="mr-2">层次式事件处理器的实现</span><a href="#层次式事件处理器的实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qep_hsm.jpg" alt="qep_hsm" data-proofer-ignore></p><p>下面只介绍和 FSM 实现不同的地方</p><h3 id="层次式状态处理函数"><span class="mr-2">层次式状态处理函数</span><a href="#层次式状态处理函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>一个层次式状态处理函数<code class="language-plaintext highlighter-rouge">QStateHandler</code>必须特别通知事件处理器有关状态<code class="language-plaintext highlighter-rouge">嵌套层次</code>的信息。</p><p>当一个层次式状态处理函数不处理当前的事件，它返回一个宏 <code class="language-plaintext highlighter-rouge">Q_SUPER()</code>给事件处理器，定义如下:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define Q_RET_SUPER ((QState)3)
#define Q_SUPER(super_) \
  (((QHsm *)me)-&gt;state = (QStateHandler)(super_), Q_RET_SUPER)
</span></pre></table></code></div></div><p>FSM 里不处理是返回<code class="language-plaintext highlighter-rouge">Q_RET_IGNORED</code>，因为没有超状态去处理它，HSM 里就需要返回<code class="language-plaintext highlighter-rouge">Q_RET_SUPER</code></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">QState</span> <span class="nf">Calc_int1</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">DIGIT_0_SIG</span><span class="p">:</span> <span class="cm">/* intentionally fall through */</span>
    <span class="k">case</span> <span class="n">DIGIT_1_9_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">BSP_insert</span><span class="p">(((</span><span class="n">CalcEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">key_code</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">POINT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">BSP_insert</span><span class="p">(((</span><span class="n">CalcEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">key_code</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc_frac1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc_operand1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="层次式状态机的类"><span class="mr-2">层次式状态机的类</span><a href="#层次式状态机的类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>QHsm 类</p><p><strong>C 语言版本</strong>：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QHsmTag</span>
<span class="p">{</span>
    <span class="n">QStateHandler</span> <span class="n">state</span><span class="p">;</span> <span class="cm">/* current active state (state-variable) */</span>
<span class="p">}</span> <span class="n">QHsm</span><span class="p">;</span> <span class="c1">// 这里和FSM一样，事件处理函数的指针</span>
<span class="cp">#define QHsm_ctor(me_, initial_) ((me_)-&gt;state = (initial_))
</span><span class="kt">void</span> <span class="nf">QHsm_init</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="c1">// 分派事件</span>
<span class="kt">void</span> <span class="nf">QHsm_dispatch</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="c1">// 测试HSM是否“在”一个给定的状态内，超状态包括子状态</span>
<span class="kt">uint8_t</span> <span class="nf">QHsm_isIn</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QHsmState</span> <span class="n">state</span><span class="p">);</span>
<span class="cm">/**
 * 函数QHsm_top( )是顶状态的层次式状态处理函数。
 * 顶状态是 UML 的概念，表示状态层次的最终根。
 * 顶状态处理函数对每一个事件的处理方法是静静的忽略它，
 * 这是 UML 的默认方法
 */</span>
<span class="n">QState</span> <span class="nf">QHsm_top</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
</pre></table></code></div></div><p>c 语言版本的不太直观，没有反应出继承关系，建议看 C++版本的</p><p><strong>C++版本</strong>：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">QHsm</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="n">QStateHandler</span> <span class="n">m_state</span><span class="p">;</span> <span class="c1">// current active state (state-variable)</span>

<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
    <span class="kt">uint8_t</span> <span class="n">isIn</span><span class="p">(</span><span class="n">QHsmState</span> <span class="n">state</span><span class="p">);</span>

<span class="nl">protected:</span>
    <span class="n">QHsm</span><span class="p">(</span><span class="n">QStateHandler</span> <span class="n">initial</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_state</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// protected ctor</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">top</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">top</code>函数就是 C 版本中的<code class="language-plaintext highlighter-rouge">QHsm_top</code>，这里用了<code class="language-plaintext highlighter-rouge">静态类型</code>，这样子类继承后所有对象共享相同的 top 函数，也可以<code class="language-plaintext highlighter-rouge">防止被重载</code>。且 static 成员变量或函数在基类和派生类中是<code class="language-plaintext highlighter-rouge">共用空间</code>的，可以节省空间</p><p>除此之外的其他成员函数都是需要<code class="language-plaintext highlighter-rouge">重载</code>的</p><h4 id="顶状态和初始伪状态"><span class="mr-2">顶状态和初始伪状态</span><a href="#顶状态和初始伪状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>每一个 HSM 都有（典型的是隐含）<code class="language-plaintext highlighter-rouge">顶状态</code> top，它围绕着整个状态机的全部其他元素</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qep_hsm2.jpg" alt="qep_hsm2" data-proofer-ignore></p><p>QHsm 类通过提供 <code class="language-plaintext highlighter-rouge">QHsm_top()</code> 层次式状态处理函数，然后由<code class="language-plaintext highlighter-rouge">子类</code>来继承它，从而确保顶状态对每一个<code class="language-plaintext highlighter-rouge">派生</code>的状态机都是可用的。 <code class="language-plaintext highlighter-rouge">QHsm_top()</code> 层次式状态处理函数定义如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// protected型的静态成员函数，子类都可调用，一般在子类处理事件时如果没有找到对应处理方式时调用</span>
<span class="n">QState</span> <span class="nf">QHsm_top</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 避免编译器报未使用参数的警告，空引用一下</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span>           <span class="cm">/* avoid the compiler warning about unused parameter */</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span>            <span class="cm">/* avoid the compiler warning about unused parameter */</span>
    <span class="c1">// 顶状态可以理解为一个虚状态，不做任何事，所以忽略掉事件</span>
    <span class="k">return</span> <span class="n">Q_IGNORED</span><span class="p">();</span> <span class="cm">/* the top state ignores all events */</span>
<span class="p">}</span>
</pre></table></code></div></div><p>状态机的初始化被特意分为 2 步。 QHsm <code class="language-plaintext highlighter-rouge">构造函数</code>仅仅把状态变量初始化成<code class="language-plaintext highlighter-rouge">初始伪状态</code>。然后，应用程序代码必须通过调用<code class="language-plaintext highlighter-rouge">QHsm_init()</code>明确的触发初始转换。这个设计分割了状态机的实例化和初始化，让用户程序对系统的初始化顺序有完全的控制。</p><p>下一节有详细描述</p><p>以下代码展示了计算器状态机的一个初始伪状态处理函数的例子：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">QState</span> <span class="nf">Calc_initial</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span>                 <span class="cm">/* avoid the compiler warning about unused parameter */</span>
    <span class="n">BSP_clear</span><span class="p">();</span>             <span class="cm">/* clear the calculator display */</span>
    <span class="c1">// 初始化后必须转换到默认子状态的操作</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc_on</span><span class="p">);</span> <span class="cm">/* designate the default state */</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">非叶子</code>状态才有<code class="language-plaintext highlighter-rouge">初始伪状态</code>，离开状态再次进入会触发初始化</p><h4 id="进入--退出动作和嵌套的初始转换"><span class="mr-2">进入 / 退出动作和嵌套的初始转换</span><a href="#进入--退出动作和嵌套的初始转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">QReservedSignals</span> <span class="p">{</span>
    <span class="n">Q_ENTRY_SIG</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* signal for coding entry actions */</span>
    <span class="n">Q_EXIT_SIG</span><span class="p">,</span> <span class="cm">/* signal for coding exit actions */</span>
    <span class="n">Q_INIT_SIG</span><span class="p">,</span> <span class="cm">/* signal for coding initial transitions */</span>
    <span class="n">Q_USER_SIG</span> <span class="cm">/* first signal that can be used in user code */</span>
<span class="p">};</span>
</pre></table></code></div></div><p>状态处理函数能够通过把它们放在在 switch 语句的 case 后作为标签来处理它们。</p><p>状态处理函数可以任意执行任何动作去响应这些信号</p><p>限制条件：</p><ul><li><code class="language-plaintext highlighter-rouge">进入动作Q_ENTRY_SIG</code>和<code class="language-plaintext highlighter-rouge">退出动作Q_EXIT_SIG</code>中不能做任何<code class="language-plaintext highlighter-rouge">状态转换</code><li><code class="language-plaintext highlighter-rouge">初始化动作Q_INIT_SIG</code>必须包括 <code class="language-plaintext highlighter-rouge">Q_TRAN()</code> 宏来转换到当前状态的<code class="language-plaintext highlighter-rouge">默认子状态</code>。</ul><p>嵌套的初始转换必须“钻进”状态层次(直接或间接的子状态)，但是不能“上升” 到目标超状态，或“绕道”到同级状态。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="n">QState</span> <span class="nf">Calc_on</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
        <span class="p">{</span> <span class="cm">/* entry action */</span>
            <span class="n">BSP_message</span><span class="p">(</span><span class="s">"on-ENTRY;"</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
        <span class="p">{</span> <span class="cm">/* exit action */</span>
            <span class="n">BSP_message</span><span class="p">(</span><span class="s">"on-EXIT;"</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">Q_INIT_SIG</span><span class="p">:</span>
        <span class="p">{</span> <span class="cm">/* nested initial transition */</span>
            <span class="n">BSP_message</span><span class="p">(</span><span class="s">"on-INIT;"</span><span class="p">);</span>
            <span class="c1">// 初始化后必须转换到子状态</span>
            <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc_ready</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">C_SIG</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">BSP_clear</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc_on</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">OFF_SIG</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc_final</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 无法处理时使用超状态处理</span>
    <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">保留</code>的信号占用最低的信号值（ 0…3,进入退出和初始化），它们不能被<code class="language-plaintext highlighter-rouge">应用程序</code>使用。为了方便，公开的 HSM 接口包含了信号 <code class="language-plaintext highlighter-rouge">Q_USER_SIG</code> ，这是用户可以使用的<code class="language-plaintext highlighter-rouge">第一个信号值</code>。一个典型的定义应用程序级信号的方法是使用一个新的<code class="language-plaintext highlighter-rouge">枚举值</code>。这样 Q_USER_SIG 能被用于<code class="language-plaintext highlighter-rouge">偏移</code>全部新的枚举量</p><h4 id="最顶层初始转换-qhsm_init"><span class="mr-2">最顶层初始转换 (QHsm_init())</span><a href="#最顶层初始转换-qhsm_init" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qep_hsm3.jpg" alt="qep_hsm3" data-proofer-ignore></p><ol><li>执行和最顶层转换关联的动作<li>执行进入动作到达默认子状态 <code class="language-plaintext highlighter-rouge">on</code><li>执行由状态 <code class="language-plaintext highlighter-rouge">on</code> 定义的和<code class="language-plaintext highlighter-rouge">初始</code>转换关联的动作<li>执行进入动作到达默认子状态 <code class="language-plaintext highlighter-rouge">ready</code><li>执行由状态 <code class="language-plaintext highlighter-rouge">ready</code> 定义的和<code class="language-plaintext highlighter-rouge">初始</code>转换关联的动作，进入 <code class="language-plaintext highlighter-rouge">begin</code><li>执行和状态 <code class="language-plaintext highlighter-rouge">begin</code> 关联的进入动作。在这一刻，转换已经完成，因为 <code class="language-plaintext highlighter-rouge">begin</code> 是没有嵌套的初始转换的<code class="language-plaintext highlighter-rouge">叶状态</code>。</ol><p>树状继承结构的优势是从叶节点<code class="language-plaintext highlighter-rouge">返回</code>到上层节点(如 top)很容易，但从上层节点<code class="language-plaintext highlighter-rouge">进入</code>到指定的目的节点却很复杂，因为要<code class="language-plaintext highlighter-rouge">遍历</code>寻找叶节点的父节点</p><p>QEP 里的解决方法是使用一个临时的数组 <code class="language-plaintext highlighter-rouge">path[]</code> 记录从初始状态的目标状态开始的<code class="language-plaintext highlighter-rouge">退出路径</code>而不执行任何动作（见图 4.4 ）。通过使用保留的 <code class="language-plaintext highlighter-rouge">QEP_EMPTY_SIG_</code> 信号来调用状态处理函数，令每一个状态处理函数不执行任何动作就立刻返回超状态。返回的路径被保存在 path[] 数组。在到达当前的状态后， path[] 数组被回访，精确的沿着它被退出的<code class="language-plaintext highlighter-rouge">相反次序</code>进入目标状态</p><p>使用 path[] 数组沿着正确的次序进入目标状态配置:</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qep_hsm4.jpg" alt="qep_hsm4" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="cp">#define QEP_TRIG_(state_, sig_) \
    ((*(state_))(me, &amp;QEP_reservedEvt_[sig_]))
</span>
<span class="cp">#define QEP_EXIT_(state_) \
    if (QEP_TRIG_(state_, Q_EXIT_SIG) == Q_RET_HANDLED) { \
        </span><span class="cm">/* QS software tracing instrumentation for state entry */</span><span class="cp">\
    }
</span>
<span class="cp">#define QEP_ENTER_(state_) \
    if (QEP_TRIG_(state_, Q_ENTRY_SIG) == Q_RET_HANDLED) { \
        </span><span class="cm">/* QS software tracing instrumentation for state exit */</span><span class="cp">\
    }
</span><span class="kt">void</span> <span class="nf">QHsm_init</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QStateHandler</span> <span class="n">t</span><span class="p">;</span>
    <span class="cm">/* the top-most initial transition must be taken */</span>
    <span class="c1">// 初始伪状态产生的初始转换（只改了state没有执行对应进入动作）</span>
    <span class="n">Q_ALLEGE</span><span class="p">((</span><span class="o">*</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)(</span><span class="n">me</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q_RET_TRAN</span><span class="p">);</span>
    <span class="c1">// 临时保存源状态t（第一次为top）</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">;</span> <span class="cm">/* HSM starts in the top state */</span>
    <span class="k">do</span>
    <span class="p">{</span> <span class="cm">/* drill into the target... */</span>
        <span class="n">QStateHandler</span> <span class="n">path</span><span class="p">[</span><span class="n">QEP_MAX_NEST_DEPTH_</span><span class="p">];</span>
        <span class="kt">int8_t</span> <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* transition entry path index */</span>
        <span class="c1">// 临时存下目的状态，同时作为路径起点，前面做过状态转换，me-&gt;state已经是目的状态了</span>
        <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>   <span class="cm">/* save the target of the initial transition */</span>
        <span class="c1">// 返回到超状态，利用QEP_EMPTY_SIG_信号</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span>
        <span class="c1">// 直到回退到源状态t，这里都只是修改state没有触发进入退出动作</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">t</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 保存路径</span>
            <span class="n">path</span><span class="p">[</span><span class="o">++</span><span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
            <span class="c1">// 不断返回超状态，直到到达源状态</span>
            <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 路径记录完把状态恢复为目的状态(只改了state没有执行对应进入动作)</span>
        <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* restore the target of the initial tran. */</span>
                             <span class="cm">/* entry path must not overflow */</span>
        <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">QEP_MAX_NEST_DEPTH_</span><span class="p">);</span>
        <span class="k">do</span>
        <span class="p">{</span><span class="cm">/* retrace the entry path in reverse (desired) order... */</span>
            <span class="c1">// 反向遍历路径，从源状态一层层进入目的状态（处理ENTER信号）</span>
            <span class="n">QEP_ENTER_</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">ip</span><span class="p">]);</span> <span class="cm">/* enter path[ip] */</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">--</span><span class="n">ip</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
        <span class="c1">// 临时保存源状态t（就是本循环一开始的目的状态，在下个循环里就是源状态了）</span>
        <span class="c1">// 现在来看是等于me-&gt;state的，因为上面也给me-&gt;state赋值了</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* current state becomes the new source */</span>
    <span class="c1">// 如果本次循环抵达的目的状态不是叶状态，还要继续深入</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Q_INIT_SIG</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q_RET_TRAN</span><span class="p">);</span>
    <span class="c1">// 直到当前状态为叶状态</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>QEP 内定义的断言宏：</p><ul><li>Q_REQUIRE()，断言一个前置条件<li>Q_ENSURE() ，断言一个后置条件<li>Q_INVARIANT() ，断言一个不变量<li>Q_ASSERT() ，断言一个其他类型的一般性契约<li>Q_ALLEGE，断言一个一般性的契约，而且即使在编译时间断言被禁止了也评估当前的情况。</ul></blockquote><h4 id="分派事件-qhsm_dispatch-通用结构"><span class="mr-2">分派事件（ QHsm_dispatch(), 通用结构）</span><a href="#分派事件-qhsm_dispatch-通用结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QHsm_dispatch</span><span class="p">(</span><span class="n">QHsm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QStateHandler</span> <span class="n">path</span><span class="p">[</span><span class="n">QEP_MAX_NEST_DEPTH_</span><span class="p">];</span>
    <span class="n">QStateHandler</span> <span class="n">s</span><span class="p">;</span><span class="c1">// source源状态</span>
    <span class="n">QStateHandler</span> <span class="n">t</span><span class="p">;</span><span class="c1">// target目的状态</span>
    <span class="n">QState</span> <span class="n">r</span><span class="p">;</span>
    <span class="c1">// 临时保存当前状态，后面作为源状态</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span> <span class="cm">/* save the current state */</span>
    <span class="c1">// 执行对应状态事件处理函数，如果返回Q_RET_SUPER说明交给了超状态处理，</span>
    <span class="c1">// 此时继续执行，直到某个超状态处理了该事件</span>
    <span class="k">do</span>
    <span class="p">{</span> <span class="cm">/* process the event hierarchically... */</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)(</span><span class="n">me</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* invoke state handler s */</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">Q_RET_SUPER</span><span class="p">);</span>
    <span class="c1">// 当需要转换状态时，源状态必须为处理该事件的状态，</span>
    <span class="c1">// 所以如果处理事件的状态为超状态而非当前状态，</span>
    <span class="c1">// 当前状态必须切换为该超状态，也就是返回到该超状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">Q_RET_TRAN</span><span class="p">)</span>
    <span class="p">{</span>                             <span class="cm">/* transition taken? */</span>
        <span class="kt">int8_t</span> <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* transition entry path index */</span>
        <span class="kt">int8_t</span> <span class="n">iq</span><span class="p">;</span>                <span class="cm">/* helper transition entry path index */</span>
        <span class="c1">// 路径0赋值为目的状态</span>
        <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>      <span class="cm">/* save the target of the transition */</span>
        <span class="c1">// 路径1赋值为源状态</span>
        <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="c1">// s状态就是实际处理了该事件的状态</span>
        <span class="c1">// s状态可能是源状态，也可能是源状态的某个超状态</span>
        <span class="c1">// 如果当前状态不为s状态时，当前状态退出直到s状态</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">{</span> <span class="cm">/* exit current state to transition source s... */</span>
            <span class="c1">// 退出源状态</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Q_EXIT_SIG</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q_RET_HANDLED</span><span class="p">)</span>
            <span class="p">{</span>                                       <span class="cm">/*exit handled? */</span>
                <span class="c1">// 退出成功时返回到超状态</span>
                <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span> <span class="cm">/* find superstate of t */</span>
            <span class="p">}</span>
            <span class="c1">// t赋值为该超状态</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span> <span class="cm">/* me-&gt;state holds the superstate */</span>
        <span class="p">}</span>
        <span class="c1">// 最后t==s，执行状态切换动作（下一节讲）</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="cm">/* set new state or restore the current state */</span>
<span class="p">}</span>
</pre></table></code></div></div><p>对<code class="language-plaintext highlighter-rouge">if (r == Q_RET_TRAN)</code>的解释：当需要转换状态时，源状态必须为处理该事件的状态，所以如果处理事件的状态为超状态而非当前状态，当前状态必须切换为该超状态，也就是返回到该超状态</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qep_hsm5.jpg" alt="qep_hsm5" data-proofer-ignore></p><p>本图中 result 收到的 OPER 事件被交给 ready 处理，ready 对事件的处理需要转换状态到 opEntered，所以必须将当前状态转变为 ready，也就是退出 result(此时不触发 ready 的 init，可以不把这个操作理解成标准的状态切换，因为本身 ready 也是临时状态，马上要切换成其他状态了)，然后触发状态切换从 ready 到 opEntered</p><h4 id="在状态机里实施一个转换-qhsm_dispatch-转换"><span class="mr-2">在状态机里实施一个转换（ QHsm_dispatch(), 转换）</span><a href="#在状态机里实施一个转换-qhsm_dispatch-转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>上一节是找路径，这一节是沿着路径做转换</p><p>在 HSM 里执行一个通用的<code class="language-plaintext highlighter-rouge">状态转换</code>，到目前为止是 QEP 实现的<code class="language-plaintext highlighter-rouge">最复杂</code>的部分。挑战是最快的找到源状态和目标状态的<code class="language-plaintext highlighter-rouge">最少共同祖先</code> (<code class="language-plaintext highlighter-rouge">LCA</code>) 状态。 (LCA 是同时源状态和目标状态的超状态里的最低层次的状态 ) 。</p><p>然后转换序列牵涉到所有状态的<code class="language-plaintext highlighter-rouge">退出</code>动作，向上到达<code class="language-plaintext highlighter-rouge">LCA</code>（但是<code class="language-plaintext highlighter-rouge">不退出 LCA</code>本身），然后是递归的进入到目标状态，然后使用初始转换“<code class="language-plaintext highlighter-rouge">钻入</code>”到目标状态配置，直到到达一个<code class="language-plaintext highlighter-rouge">叶状态</code>为止。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qep_hsm6.jpg" alt="qep_hsm6" data-proofer-ignore></p><blockquote><p>h: 子状态到超状态的超状态</p></blockquote><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
</pre><td class="rouge-code"><pre><span class="cm">/* NOTE: 上一节代码省略部分 */</span>
<span class="c1">// 路径0保存了目的状态，给t赋值，t等于me-&gt;state</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* target of the transition */</span>
<span class="c1">// 如果源状态等于目的状态，相当于自转换，情况(a)适用</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>                   <span class="cm">/* (a) check source==target (transition to self) */</span>
    <span class="n">QEP_EXIT_</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>    <span class="cm">/* exit the source */</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* enter the target */</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// t(等于当前状态me-&gt;state)退出到超状态</span>
    <span class="c1">// 使用t作为参数，会忽略me-&gt;state原有值，执行后强制赋值，</span>
    <span class="c1">// 如此处给空信号返回超状态，me-&gt;state强制赋值为t的超状态</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span> <span class="cm">/* superstate of target */</span>
    <span class="c1">// 为t赋值当前状态（目的状态的超状态）</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
    <span class="c1">// 情况(b)，目的状态的超状态为源状态，超状态进入子状态（源状态不用退出）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>                   <span class="cm">/* (b) check source==target-&gt;super */</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* enter the target */</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// 退出到s的超状态，为me-&gt;state强制赋值</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span> <span class="cm">/* superstate of src */</span>
                                            <span class="cm">/* (c) check source-&gt;super==target-&gt;super */</span>
        <span class="c1">// 情况(c)，源状态的超状态等于目的状态的超状态</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">QEP_EXIT_</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>    <span class="cm">/* exit the source */</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* enter the target */</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="cm">/* (d) check source-&gt;super==target */</span>
            <span class="c1">// 情况(d)，源超状态等于目的状态</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">QEP_EXIT_</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="cm">/* exit the source */</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>                   <span class="cm">/* (e) check rest of source==target-&gt;super-&gt;super..
                                 * and store the entry path along the way
                                 */</span>
                <span class="n">iq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* indicate that LCA not found */</span>
                <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* enter target and its superstate */</span>
                <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>    <span class="cm">/* save the superstate of target */</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>  <span class="cm">/* save source-&gt;super */</span>
                <span class="cm">/* find target-&gt;super-&gt;super */</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">Q_RET_SUPER</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">path</span><span class="p">[</span><span class="o">++</span><span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span> <span class="cm">/* store the entry path */</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">s</span><span class="p">)</span>
                    <span class="p">{</span>                   <span class="cm">/* is it the source? */</span>
                        <span class="n">iq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* indicate that LCA found */</span>
                        <span class="cm">/* entry path must not overflow */</span>
                        <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">QEP_MAX_NEST_DEPTH_</span><span class="p">);</span>
                        <span class="o">--</span><span class="n">ip</span><span class="p">;</span>              <span class="cm">/* do not enter the source */</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">Q_RET_HANDLED</span><span class="p">;</span> <span class="cm">/* terminate the loop */</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span> <span class="cm">/* it is not the source, keep going up */</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iq</span> <span class="o">==</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">{</span> <span class="cm">/* the LCA not found yet? */</span>
                    <span class="cm">/* entry path must not overflow */</span>
                    <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">QEP_MAX_NEST_DEPTH_</span><span class="p">);</span>
                    <span class="n">QEP_EXIT_</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="cm">/* exit the source */</span>
                    <span class="cm">/* (f) check the rest of source-&gt;super
                     * == target-&gt;super-&gt;super...
                     */</span>
                    <span class="n">iq</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Q_RET_IGNORED</span><span class="p">;</span> <span class="cm">/* indicate LCA NOT found */</span>
                    <span class="k">do</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">path</span><span class="p">[</span><span class="n">iq</span><span class="p">])</span>
                        <span class="p">{</span>                          <span class="cm">/* is this the LCA? */</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="n">Q_RET_HANDLED</span><span class="p">;</span>     <span class="cm">/* indicate LCA found */</span>
                            <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)(</span><span class="n">iq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/*do not enter LCA*/</span>
                            <span class="n">iq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>     <span class="cm">/* terminate the loop */</span>
                        <span class="p">}</span>
                        <span class="k">else</span>
                        <span class="p">{</span>
                            <span class="o">--</span><span class="n">iq</span><span class="p">;</span> <span class="cm">/* try lower superstate of target */</span>
                        <span class="p">}</span>
                    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iq</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">Q_RET_HANDLED</span><span class="p">)</span>
                    <span class="p">{</span> <span class="cm">/* LCA not found yet? */</span>
                        <span class="cm">/* (g) check each source-&gt;super-&gt;...
                         * for each target-&gt;super...
                         */</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">Q_RET_IGNORED</span><span class="p">;</span> <span class="cm">/* keep looping */</span>
                        <span class="k">do</span>
                        <span class="p">{</span>
                            <span class="cm">/* exit t unhandled? */</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Q_EXIT_SIG</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q_RET_HANDLED</span><span class="p">)</span>
                            <span class="p">{</span>
                                <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span>
                            <span class="p">}</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span> <span class="cm">/* set to super of t */</span>
                            <span class="n">iq</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
                            <span class="k">do</span>
                            <span class="p">{</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">path</span><span class="p">[</span><span class="n">iq</span><span class="p">])</span>
                                <span class="p">{</span> <span class="cm">/* is this LCA? */</span>
                                    <span class="cm">/* do not enter LCA */</span>
                                    <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)(</span><span class="n">iq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                                    <span class="n">iq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/*break inner */</span>
                                    <span class="n">r</span> <span class="o">=</span> <span class="n">Q_RET_HANDLED</span><span class="p">;</span> <span class="cm">/*break outer */</span>
                                <span class="p">}</span>
                                <span class="k">else</span>
                                <span class="p">{</span>
                                    <span class="o">--</span><span class="n">iq</span><span class="p">;</span>
                                <span class="p">}</span>
                            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iq</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
                        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">Q_RET_HANDLED</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/* retrace the entry path in reverse (desired) order... */</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">ip</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QEP_ENTER_</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">ip</span><span class="p">])</span> <span class="cm">/* enter path[ip] */</span>
<span class="p">}</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>   <span class="cm">/* stick the target into register */</span>
<span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="cm">/* update the current state */</span>
               <span class="cm">/* drill into the target hierarchy... */</span>
<span class="k">while</span> <span class="p">(</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Q_INIT_SIG</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q_RET_TRAN</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span> <span class="cm">/* find superstate */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">path</span><span class="p">[</span><span class="o">++</span><span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">QEP_TRIG_</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">QEP_EMPTY_SIG_</span><span class="p">);</span> <span class="cm">/*find superstate*/</span>
    <span class="p">}</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="cm">/* entry path must not overflow */</span>
    <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">QEP_MAX_NEST_DEPTH_</span><span class="p">);</span>
    <span class="k">do</span>
    <span class="p">{</span>                        <span class="cm">/* retrace the entry path in reverse (correct) order... */</span>
        <span class="n">QEP_ENTER_</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">ip</span><span class="p">])</span> <span class="cm">/* enter path[ip] */</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">--</span><span class="n">ip</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="使用-qep-实现-hsm-步骤的概要"><span class="mr-2">使用 QEP 实现 HSM 步骤的概要</span><a href="#使用-qep-实现-hsm-步骤的概要" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>计算器认识的按键是： 0 ， 1-9 ， . ， + ， - ， * ， / ， = ， C 和 E(cancel entry CE) 。ESC 按键终止程序。其他别的按键会被忽略。</p><ul><li>枚举信号，如 C， CE ， DIGIT_0 ， DIGIT_1_9 等待<li><p>定义事件，如<code class="language-plaintext highlighter-rouge">OPER_SIG</code>信号对应按下+ ， - ， * ， / 的四个事件，事件参数在 key_code 变量中</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">CalcEvt</span> <span class="o">:</span> <span class="n">public</span> <span class="n">QEvent</span> <span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">key_code</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><li><p>派生特定的状态机</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="n">class</span> <span class="n">Calc</span> <span class="o">:</span> <span class="n">public</span> <span class="n">QHsm</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">m_operand1</span><span class="p">;</span>  <span class="c1">// the value of operand 1 (extended state variable)</span>
    <span class="kt">uint8_t</span> <span class="n">m_operator</span><span class="p">;</span> <span class="c1">// operator key entered (extended state variable)</span>
<span class="nl">public:</span>
    <span class="n">Calc</span><span class="p">()</span> <span class="o">:</span> <span class="n">QHsm</span><span class="p">((</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Calc</span><span class="o">::</span><span class="n">initial</span><span class="p">)</span>
    <span class="p">{</span> <span class="c1">// ctor</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="c1">// 声明为静态,如果有扩展派生类也能共享</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">initial</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>   <span class="c1">// initial pseudostate</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">on</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>        <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">error</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">ready</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">result</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>    <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">begin</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">negated1</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>  <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">operand1</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>  <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">zero1</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">int1</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>      <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">frac1</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">opEntered</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span> <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">negated2</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>  <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">operand2</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>  <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">zero2</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">int2</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>      <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">frac2</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
    <span class="k">static</span> <span class="n">QState</span> <span class="n">final</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>     <span class="c1">// state handler</span>
<span class="p">};</span>
</pre></table></code></div></div><li><p>定义初始伪状态，作用是执行一些初始化操作，还有转换到默认状态 on</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">QState</span> <span class="n">Calc</span><span class="o">::</span><span class="n">initial</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span> <span class="cm">/* e */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BSP_clear</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc</span><span class="o">::</span><span class="n">on</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>定义状态处理函数</p><p>用 switch 处理信号，避免<code class="language-plaintext highlighter-rouge">switch外</code>的处理代码</p><ul><li>Q_ENTRY_SIG 和 Q_EXIT_SIG：进入动作和退出动作，总是返回 Q_HANDLED()，<code class="language-plaintext highlighter-rouge">不允许</code>状态切换<li>Q_INIT_SIG：每个<code class="language-plaintext highlighter-rouge">组合状态</code>（带有子状态的状态）能有它自己的<code class="language-plaintext highlighter-rouge">初始转换</code>，初始转换不能有监护条件，初始转换只能以自己的子状态作为目的状态<li>内部转换：内部转换是对事件的简单反应，并从<code class="language-plaintext highlighter-rouge">不导致</code>状态的转换，因此也从不导致进入动作，退出动作或初始转换的执行，总是返回 Q_HANDLED()<li>常规转换：执行动作，返回 Q_TRAN()<li>监护条件：根据事件参数的值和 / 或和状态机联合的变量（扩展状态变量）来<code class="language-plaintext highlighter-rouge">动态的评估</code>。条件为 false 相当于没处理，需要抛给超状态处理</ul></ul><h3 id="常见问题"><span class="mr-2">常见问题</span><a href="#常见问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>不完整的状态处理函数</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">QState</span> <span class="nf">Calc_on</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span><span class="k">case</span> <span class="n">C_SIG</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">// case里应该return一个预定义的QState值，如Q_HANDLED()，</span>
            <span class="c1">// 这里却是一个自定义函数，虽然结果相同，但代码不直观，违反了设计规范</span>
            <span class="k">return</span> <span class="n">Calc_onClear</span><span class="p">(</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* handle the Clear event */</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span><span class="n">QState</span> <span class="nf">Calc_onClear</span><span class="p">(</span><span class="n">Calc</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BSP_clear</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Calc_on</span><span class="p">);</span> <span class="cm">/* transition to "on" */</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>在进入 / 退出动作或初始转换内访问事件参数</p><p>处理 Q_ENTRY_SIG 信号时不应该访问 QEvent 参数，需要在切换时传递的参数可以定义为该状态机的全局变量（如上面的<code class="language-plaintext highlighter-rouge">m_operand1</code>），这样状态机里所有状态都能共享</p><li><p>不够优化的信号粒度</p><p>计算器状态图把数字 1 到 9 的群表示为一个 信号 <code class="language-plaintext highlighter-rouge">IDC_1_9_SIG</code>，而不是每个数字一个信号，这样增加了一步读取事件参数获得实际值的操作，但减少了信号数量，总体上增大了信号粒度，避免过细的信号粒度带来的复杂性</p><p>过大的信号粒度会导致一个 case 里写的条件判断过多（switch 套 switch），让代码变成意大利面条</p></ul><h2 id="状态模式"><span class="mr-2">状态模式</span><a href="#状态模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>状态机面向对象的设计模式，设计模式就是用于解决实际问题的最佳实践</p><h3 id="终极钩子"><span class="mr-2">终极钩子</span><a href="#终极钩子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>目的</ul><p>提供共同的设施和方式来处理事件但是让客户<code class="language-plaintext highlighter-rouge">重载</code> (override)并<code class="language-plaintext highlighter-rouge">定制</code>系统行为的每一个方面。</p><ul><li>问题</ul><p>许多事件驱动型系统需要一致性方式来处理事件。在一个 GUI 设计里，<code class="language-plaintext highlighter-rouge">一致性</code>是用户接口的典型性观感的一部分。挑战是在系统层软件要提供这样一种共同的观感，客户程序可以容易的默认方式使用它们。 同时，客户必须能够容易的<code class="language-plaintext highlighter-rouge">重载</code>默认行为的每一个方面，如果他们想这么做的话</p><ul><li>解决方案</ul><p>使用一个子状态，能够继承父状态的默认方法（忽略事件并让父状态处理），也能重载产生自定义的方法（编写事件的处理方法）</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/ultimatehook.jpg" alt="ultimatehook" data-proofer-ignore></p><p>specific 重载了 <code class="language-plaintext highlighter-rouge">A 事件</code>和<code class="language-plaintext highlighter-rouge">进入退出动作</code>的处理，B、C、D 则继承父状态的处理</p><p>其中 C 事件表示复位，D 事件表示终止</p><ul><li>代码样本</ul><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/hookoutput.jpg" alt="hookoutput" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
</pre><td class="rouge-code"><pre><span class="c1">// QEP应用需要qep_port.h</span>
<span class="cp">#include</span> <span class="cpf">"qep_port.h"</span><span class="cp">
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">UltimateHookTag</span>
<span class="p">{</span>             <span class="cm">/* UltimateHook state machine */</span>
  <span class="n">QHsm</span> <span class="n">super</span><span class="p">;</span> <span class="cm">/* derive from QHsm */</span>
<span class="p">}</span> <span class="n">UltimateHook</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">UltimateHook_ctor</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* ctor */</span>
<span class="n">QState</span> <span class="nf">UltimateHook_initial</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">UltimateHook_generic</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">UltimateHook_specific</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">UltimateHook_final</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="k">enum</span> <span class="n">UltimateHookSignals</span>
<span class="p">{</span> <span class="cm">/* enumeration of signals */</span>
  <span class="n">A_SIG</span> <span class="o">=</span> <span class="n">Q_USER_SIG</span><span class="p">,</span>
  <span class="n">B_SIG</span><span class="p">,</span>
  <span class="n">C_SIG</span><span class="p">,</span>
  <span class="n">D_SIG</span>
<span class="p">};</span>
<span class="cm">/*.............................................................*/</span>
<span class="kt">void</span> <span class="nf">UltimateHook_ctor</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QHsm_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">UltimateHook_initial</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.............................................................*/</span>
<span class="n">QState</span> <span class="nf">UltimateHook_initial</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"top-INIT;"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UltimateHook_generic</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.............................................................*/</span>
<span class="n">QState</span> <span class="nf">UltimateHook_final</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"final-ENTRY(terminate);</span><span class="se">\n</span><span class="s">Bye!Bye!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*............................................................*/</span>
<span class="n">QState</span> <span class="nf">UltimateHook_generic</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">case</span> <span class="n">Q_INIT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"generic-INIT;"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UltimateHook_specific</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">A_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"generic-A;"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">B_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"generic-B;"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">C_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"generic-C(reset);"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UltimateHook_generic</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">D_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UltimateHook_final</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*............................................................*/</span>
<span class="n">QState</span> <span class="nf">UltimateHook_specific</span><span class="p">(</span><span class="n">UltimateHook</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"specific-ENTRY;"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"specific-EXIT;"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">A_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"specific-A;"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 默认使用超状态处理，类似于继承</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UltimateHook_generic</span><span class="p">);</span> <span class="cm">/* the superstate */</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>结论</p><ul><li>specific 子状态只需要知道它将重载的事件。<li>可以容易的加入新事件到高层 generic 超状态而不会影响 specific 子状态。<li>难以去掉或者改变客户已经在使用的事件的语义。（见设计模式中的<a href="/posts/design-patterns-principles/#开闭原则">开闭原则</a>，对扩展开放，对修改关闭，本来就应该这么做，其实这个不算问题）<li>在许多嵌套层次间（如果 specific 子状态有<code class="language-plaintext highlighter-rouge">嵌套</code>的子状态）传递每一个事件的<code class="language-plaintext highlighter-rouge">成本</code>很高。</ul></ul><h3 id="提示器"><span class="mr-2">提示器</span><a href="#提示器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>目的</ul><p>通过创造并<code class="language-plaintext highlighter-rouge">发送给本身</code>一个事件而使状态图拓扑更加灵活。</p><ul><li>问题</ul><p>在状态建模时，一个<code class="language-plaintext highlighter-rouge">公共事件</code>常常把系统的一些松散的功能很强的<code class="language-plaintext highlighter-rouge">耦合</code>起来。考虑这个例子，在<code class="language-plaintext highlighter-rouge">周期性数据采集</code>时需要在一个预定的速率查询一个传感器产生的数据。假设一个<code class="language-plaintext highlighter-rouge">周期性 TIMEOUT 事件</code>以一个需要的速率被派发给系统用来提供查询传感器的触发。因为系统<code class="language-plaintext highlighter-rouge">仅有一个</code>外部事件 (TIMEOUT 事件) ， 看来好像这个事件需要<code class="language-plaintext highlighter-rouge">同时</code>触发<code class="language-plaintext highlighter-rouge">查询</code>传感器功能和<code class="language-plaintext highlighter-rouge">处理</code>数据功能。一个直接的但是不够优化的解决方法是把状态机组织成 2 个不同的<code class="language-plaintext highlighter-rouge">正交区域</code>（用来查询和处理）。然而，正交区域增加了派发事件的成本（参考“<code class="language-plaintext highlighter-rouge">正交组件</code>”模式）并且需要在区域间复杂的同步，因为查询和处理并不是完全独立的。</p><ul><li>解决方法</ul><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/reminderstate.jpg" alt="reminderstate" data-proofer-ignore></p><p>使用一个 <code class="language-plaintext highlighter-rouge">DATA_READY</code> 事件用于传给自己，表示数据就绪。</p><p>将“<code class="language-plaintext highlighter-rouge">处理</code>数据功能”（<code class="language-plaintext highlighter-rouge">processing</code>）作为“<code class="language-plaintext highlighter-rouge">查询</code>传感器功能”（<code class="language-plaintext highlighter-rouge">polling</code>）的子状态，继承 <code class="language-plaintext highlighter-rouge">TIMEOUT 事件</code>的处理方法 pollSensor()，<code class="language-plaintext highlighter-rouge">busy</code>作为 polling 子状态可以<code class="language-plaintext highlighter-rouge">重载</code> TIMEOUT，以便实现自定义功能。例如，为了提供性能， <code class="language-plaintext highlighter-rouge">polling</code> 状态可以<code class="language-plaintext highlighter-rouge">缓存</code>原始传感器数据并仅在缓存区填满后在生成 <code class="language-plaintext highlighter-rouge">DATA_READY</code> 事件，图中展示了使用 <code class="language-plaintext highlighter-rouge">if(…)</code> 条件的这个选项，它在 polling 状态的 postFIFO(me, DATA_REDY) 的前面。</p><p>本例有个特征，就是<code class="language-plaintext highlighter-rouge">周期性查询</code>和<code class="language-plaintext highlighter-rouge">周期性处理</code>虽然都需要共用定时事件，但实时性不同，<code class="language-plaintext highlighter-rouge">周期性查询</code>比较频繁需要实时，<code class="language-plaintext highlighter-rouge">周期性处理</code>甚至不需要实时处理，所以可以仅让<code class="language-plaintext highlighter-rouge">周期性查询</code>处理定时事件，使用另一个 <code class="language-plaintext highlighter-rouge">DATA_READY</code> 事件让<code class="language-plaintext highlighter-rouge">周期性查询</code>通知<code class="language-plaintext highlighter-rouge">周期性处理</code>何时能进行处理</p><p>也就是仅让 polling 处理 TIMEOUT 事件，因为 processing 状态不需要频繁处理数据，可以在 idle 状态等待，直到 DATA_READY 事件发生变为 busy 开始处理数据</p><ul><li>代码样本</ul><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/reminderstate.jpg" alt="reminderstate" data-proofer-ignore></p><p>原生 QEP 事件处理器并不支持事件排队，这里用到了 QP 实时框架 QF，还利用了 QF 的定时组件</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="c1"> /* QP interface */</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="c1">     /* board support package */</span><span class="cp">
</span><span class="k">enum</span> <span class="n">SensorSignals</span>
<span class="p">{</span>
  <span class="n">TIMEOUT_SIG</span> <span class="o">=</span> <span class="n">Q_USER_SIG</span><span class="p">,</span> <span class="cm">/* the periodic timeout signal */</span>
  <span class="n">DATA_READY_SIG</span><span class="p">,</span>           <span class="cm">/* the invented reminder signal */</span>
  <span class="n">TERMINATE_SIG</span>             <span class="cm">/* terminate the application */</span>
<span class="p">};</span>
<span class="cm">/*............................................................*/</span>
<span class="c1">// 使用了QF中的QActive活动对象和QTimeEvt定时组件</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">SensorTag</span>
<span class="p">{</span>                   <span class="cm">/* the Sensor active object */</span>
  <span class="n">QActive</span> <span class="n">super</span><span class="p">;</span>    <span class="cm">/* derive from QActive */</span>
  <span class="n">QTimeEvt</span> <span class="n">timeEvt</span><span class="p">;</span> <span class="cm">/* private time event generator */</span>
  <span class="kt">uint16_t</span> <span class="n">pollCtr</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">procCtr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Sensor</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Sensor_ctor</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span>
<span class="cm">/* hierarchical state machine ... */</span>
<span class="n">QState</span> <span class="nf">Sensor_initial</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">Sensor_polling</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">Sensor_processing</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">Sensor_idle</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">Sensor_busy</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">Sensor_final</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="cm">/*............................................................*/</span>
<span class="kt">void</span> <span class="nf">Sensor_ctor</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QActive_ctor_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Sensor_initial</span><span class="p">);</span>
  <span class="n">QTimeEvt_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeEvt</span><span class="p">,</span> <span class="n">TIMEOUT_SIG</span><span class="p">);</span> <span class="cm">/* time event ctor */</span>
<span class="p">}</span>
<span class="cm">/* HSM definition----------------------------------------------*/</span>
<span class="n">QState</span> <span class="nf">Sensor_initial</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">pollCtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">procCtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_polling</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*............................................................*/</span>
<span class="n">QState</span> <span class="nf">Sensor_final</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"final-ENTRY;</span><span class="se">\n</span><span class="s">Bye!Bye!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">BSP_exit</span><span class="p">();</span> <span class="cm">/* terminate the application */</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*............................................................*/</span>
<span class="n">QState</span> <span class="nf">Sensor_polling</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="c1">// 注册定时事件，每半秒一次</span>
      <span class="cm">/* periodic timeout every 1/2 second */</span>
      <span class="n">QTimeEvt_postEvery</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeEvt</span><span class="p">,</span> <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span>
                        <span class="n">BSP_TICKS_PER_SEC</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">QTimeEvt_disarm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeEvt</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">Q_INIT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="c1">// 初始进入processing状态</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_processing</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// processing和idle都交给本状态处理，busy重载了这个处理</span>
    <span class="k">case</span> <span class="n">TIMEOUT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">static</span> <span class="k">const</span> <span class="n">QEvent</span> <span class="n">reminderEvt</span> <span class="o">=</span> <span class="p">{</span><span class="n">DATA_READY_SIG</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
      <span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">pollCtr</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"polling %3d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">pollCtr</span><span class="p">);</span>
      <span class="c1">// 每4次发送一个DATA_READY事件</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">pollCtr</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* modulo 4 */</span>
        <span class="n">QActive_postFIFO</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reminderEvt</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">TERMINATE_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_final</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*............................................................*/</span>
<span class="n">QState</span> <span class="nf">Sensor_processing</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_INIT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="c1">// 初始进入idle状态</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_idle</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_polling</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*..............................................................*/</span>
<span class="n">QState</span> <span class="nf">Sensor_idle</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"idle-ENTRY;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">DATA_READY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_busy</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_processing</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*..............................................................*/</span>
<span class="n">QState</span> <span class="nf">Sensor_busy</span><span class="p">(</span><span class="n">Sensor</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"busy-ENTRY;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// busy重载了定时处理</span>
    <span class="k">case</span> <span class="n">TIMEOUT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">procCtr</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"processing %3d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">procCtr</span><span class="p">);</span>
      <span class="c1">// 处理完返回idle,TODO：这里不处理采集的话不就丢了一次采集吗</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">procCtr</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* modulo 2 */</span>
        <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_idle</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sensor_processing</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>结论</ul><p>很像<a href="#状态机分类">监护条件</a>，但是监护条件是<code class="language-plaintext highlighter-rouge">明确</code>的，对应的事件就是用于转换状态的，但这里转换状态是<code class="language-plaintext highlighter-rouge">隐含</code>的，称为<code class="language-plaintext highlighter-rouge">补充性转换</code>。通过创造一个自定义的内部事件，在满足某种条件并产生隐式转换时发送该事件给自己，即可实现明确的转换。</p><p>提醒器模式的另一个重要的应用是把较长的 RTC 步骤分解为较短的几个步骤。通过在内部事件中<code class="language-plaintext highlighter-rouge">携带上下文</code>可以让下一个短步骤获取上个短步骤留下的上下文，从而让这些短步骤能衔接起来，看上去像是一个连续执行的长步骤。通过分解和 FIFO 事件排队，能让其他任务也能及时运行而不受长步骤影响。</p><h3 id="延迟的事件"><span class="mr-2">延迟的事件</span><a href="#延迟的事件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>目的</ul><p>通过改变事件的顺序来简化状态机。</p><ul><li>问题</ul><p>有时候一个事件在某个<code class="language-plaintext highlighter-rouge">不方便</code>的时刻到达，这时刻系统正在某个<code class="language-plaintext highlighter-rouge">复杂的事件队列</code>的中间。</p><blockquote><p><code class="language-plaintext highlighter-rouge">复杂的事件队列</code>指一系列不应该被打断的事件，如发送请求、等待收到回复事件后处理回复，两个事件不是同时发生，但中间也不希望被插入新事件打断</p></blockquote><p>实例：服务器程序处理业务（如从 ATM 终端）的案例。一旦业务开始了，它典型地要走完一个<code class="language-plaintext highlighter-rouge">处理序列</code>，从一个远距离终端接受数据开始，然后是业务的授权。这几个事件被视为<code class="language-plaintext highlighter-rouge">连续事件</code>，虽然事件产生有一定时间间隔，但希望它们能<code class="language-plaintext highlighter-rouge">连续执行</code>而不应该被新到达的业务<code class="language-plaintext highlighter-rouge">打断</code>。（可以理解为中断，中断的话需要保存上下文，退出中断后恢复，同理状态机处理“中断”也要保存当前状态和上下文，等新事件处理完恢复，太麻烦了。这个正好和上面一节的拆分长步骤的例子<code class="language-plaintext highlighter-rouge">相反</code>，一个是希望拆分长步骤为短步骤，让其他任务也能及时运行，这里是希望各个短步骤看上去像长步骤一样中间<code class="language-plaintext highlighter-rouge">不要被打断</code>。）</p><ul><li>解决</ul><p>添加一个<code class="language-plaintext highlighter-rouge">等待队列</code>，当新业务事件到达时加入这个队列而不是事件队列，在 idle 时再去读取等待队列，把等待队列里的事件加入事件队列</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/deferevent.jpg" alt="deferevent" data-proofer-ignore></p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/deferevent2.jpg" alt="deferevent2" data-proofer-ignore></p><p>处于 busy 状态的子状态(receiving 和 authorizing)时，收到新的请求事件，处理方法为不执行并加入等待队列，然后该事件会被移除出事件队列，原业务得以继续正常执行。idle 状态通过进入动作执行 recall() 从等待队列召回被等待的第一个事件，并发送给自己。</p><ul><li>实例代码</ul><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/defer.jpg" alt="defer" data-proofer-ignore></p><p>延迟事件状态模式严重依赖事件队列，所以用了QF框架</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="cm">/*.......................................................................*/</span>
<span class="k">enum</span> <span class="n">TServerSignals</span>
<span class="p">{</span>
  <span class="n">NEW_REQUEST_SIG</span> <span class="o">=</span> <span class="n">Q_USER_SIG</span><span class="p">,</span> <span class="cm">/* the new request signal */</span>
  <span class="n">RECEIVED_SIG</span><span class="p">,</span>                 <span class="cm">/* the request has been received */</span>
  <span class="n">AUTHORIZED_SIG</span><span class="p">,</span>               <span class="cm">/* the request has been authorized */</span>
  <span class="n">TERMINATE_SIG</span>                 <span class="cm">/* terminate the application */</span>
<span class="p">};</span>
<span class="cm">/*......................................................................*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">RequestEvtTag</span>
<span class="p">{</span>
  <span class="n">QEvent</span> <span class="n">super</span><span class="p">;</span>    <span class="cm">/* derive from QEvent */</span>
  <span class="kt">uint8_t</span> <span class="n">ref_num</span><span class="p">;</span> <span class="cm">/* reference number of the request */</span>
<span class="p">}</span> <span class="n">RequestEvt</span><span class="p">;</span>
<span class="cm">/*......................................................................*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TServerTag</span>
<span class="p">{</span>                               <span class="cm">/* Transaction Server active object */</span>
  <span class="n">QActive</span> <span class="n">super</span><span class="p">;</span>                <span class="cm">/* derive from QActive */</span>
  <span class="c1">// 私用事件队列，用于等待队列</span>
  <span class="n">QEQueue</span> <span class="n">requestQueue</span><span class="p">;</span>         <span class="cm">/* native QF queue for deferred request events */</span>
  <span class="c1">// 指针数组，存放了3个指针，用于QEQueue事件队列，只要指针就行，指针指向的空间由QF管理是运行时绑定的</span>
  <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">requestQSto</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/* storage for the deferred queue buffer */</span>
  <span class="c1">// 使用定时任务模拟延迟</span>
  <span class="n">QTimeEvt</span> <span class="n">receivedEvt</span><span class="p">;</span>         <span class="cm">/* private time event generator */</span>
  <span class="n">QTimeEvt</span> <span class="n">authorizedEvt</span><span class="p">;</span>       <span class="cm">/* private time event generator */</span>
<span class="p">}</span> <span class="n">TServer</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">TServer_ctor</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* the default ctor */</span>
<span class="cm">/* hierarchical state machine ... */</span>
<span class="n">QState</span> <span class="nf">TServer_initial</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">TServer_idle</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">TServer_busy</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">TServer_receiving</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">TServer_authorizing</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">TServer_final</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">TServer_ctor</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* the default ctor */</span>
  <span class="n">QActive_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">TServer_initial</span><span class="p">);</span>
  <span class="c1">// 私有等待队列初始化</span>
  <span class="n">QEQueue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">requestQueue</span><span class="p">,</span>
               <span class="n">me</span><span class="o">-&gt;</span><span class="n">requestQSto</span><span class="p">,</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">requestQSto</span><span class="p">));</span>
  <span class="n">QTimeEvt_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">receivedEvt</span><span class="p">,</span> <span class="n">RECEIVED_SIG</span><span class="p">);</span>
  <span class="n">QTimeEvt_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">authorizedEvt</span><span class="p">,</span> <span class="n">AUTHORIZED_SIG</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* HSM definition -------------------------------------------------------*/</span>
<span class="n">QState</span> <span class="nf">TServer_initial</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span> <span class="cm">/* avoid the compiler warning about unused parameter */</span>
  <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_idle</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="n">QState</span> <span class="nf">TServer_final</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span> <span class="cm">/* avoid the compiler warning about unused parameter */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"final-ENTRY;</span><span class="se">\n</span><span class="s">Bye!Bye!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">BSP_exit</span><span class="p">();</span> <span class="cm">/* terminate the application */</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*............................................................................*/</span>
<span class="n">QState</span> <span class="nf">TServer_idle</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="c1">// 在idle的进入动作中尝试召回事件</span>
      <span class="n">RequestEvt</span> <span class="k">const</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"idle-ENTRY;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="cm">/* recall the request from the private requestQueue */</span>
      <span class="c1">// 使用QF框架提供的recall()功能召回，recall()内部通过LIFO将等待队列里的事件发给</span>
      <span class="c1">// 自己的事件队列，用LIFO是为了保证优先处理</span>
      <span class="n">rq</span> <span class="o">=</span> <span class="p">(</span><span class="n">RequestEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">QActive_recall</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span>
                                              <span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">requestQueue</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">!=</span> <span class="p">(</span><span class="n">RequestEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* recall posted an event? */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Request #%d recalled</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">refNum</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"No deferred requests</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">NEW_REQUEST_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Processing request #%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">RequestEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">refNum</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_receiving</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">TERMINATE_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_final</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="n">QState</span> <span class="nf">TServer_busy</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">NEW_REQUEST_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="c1">// busy状态下收到新的REQUEST事件，先检查等待队列是否空闲，</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">QEQueue_getNFree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">requestQueue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* can defer? */</span>
        <span class="cm">/* defer the request */</span>
        <span class="c1">// 为空就加入等待队列，用QF框架自带的QActive_defer</span>
        <span class="n">QActive_defer</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">requestQueue</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Request #%d deferred;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
              <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">RequestEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ref_num</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
        <span class="cm">/* notify the request sender that the request was ignored.. */</span>
        <span class="c1">// 满了就提醒用户，对QF框架来说等待队列和事件队列都是不允许满了丢弃的，会断言退出</span>
        <span class="c1">// 这里修改了QF框架，允许满了后丢弃</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Request #%d IGNORED;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
              <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">RequestEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ref_num</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">TERMINATE_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_final</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">TServer_receiving</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"receiving-ENTRY;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="cm">/* one-shot timeout in 1 second */</span>
      <span class="n">QTimeEvt_fireIn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">receivedEvt</span><span class="p">,</span> <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span>
                      <span class="n">BSP_TICKS_PER_SEC</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">QTimeEvt_disarm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">receivedEvt</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">RECEIVED_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_authorizing</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_busy</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">TServer_authorizing</span><span class="p">(</span><span class="n">TServer</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"authorizing-ENTRY;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="cm">/* one-shot timeout in 2 seconds */</span>
      <span class="n">QTimeEvt_fireIn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">authorizedEvt</span><span class="p">,</span> <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span>
                      <span class="mi">2</span> <span class="o">*</span> <span class="n">BSP_TICKS_PER_SEC</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">QTimeEvt_disarm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">authorizedEvt</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">AUTHORIZED_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_idle</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TServer_busy</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>等待队列和事件队列的管理都由 QF 实现，使用了“零复制”方式。</p><blockquote><p>一种变体：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/defer2.jpg" alt="defer2" data-proofer-ignore></p><p>busy 状态变成了其他状态包括 idle 的超状态。 idle 子状态重载了 NEW_REQUEST 事件。 其他全部 busy 的子状态依赖在 busy 超状态的默认事件处理方法，这个方法会延迟 NEW_REQUEST 事件。相当于就是把 idle 放进了 busy，其他都一样，TODO:这样有什么好处，busy 和 idle 从意义上讲应该是互斥的，这样做是否违反了逻辑</p></blockquote><p>按键触发新事件的代码：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">BSP_onConsoleInput</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">'n'</span><span class="p">:</span>
    <span class="p">{</span>                            <span class="cm">/* new request */</span>
      <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">reqCtr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* count the requests */</span>
      <span class="n">RequestEvt</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">Q_NEW</span><span class="p">(</span><span class="n">RequestEvt</span><span class="p">,</span> <span class="n">NEW_REQUEST_SIG</span><span class="p">);</span>
      <span class="n">e</span><span class="o">-&gt;</span><span class="n">ref_num</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">reqCtr</span><span class="p">);</span> <span class="cm">/* set the reference number */</span>
                              <span class="cm">/* post directly to TServer active object */</span>
      <span class="n">QActive_postFIFO</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">l_tserver</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="mh">0x1B</span><span class="p">:</span>
    <span class="p">{</span> <span class="cm">/* ESC key */</span>
      <span class="k">static</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="n">terminateEvt</span> <span class="o">=</span> <span class="p">{</span><span class="n">TERMINATE_SIG</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
      <span class="n">QActive_postFIFO</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">l_tserver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">terminateEvt</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>结论</p><p>事件延迟是个<code class="language-plaintext highlighter-rouge">简化</code>状态模型的有价值的技术。你不用建立一个过份复杂的状态机去处理在任何时候的每个事件，而是可以延迟一个在不合适或者棘手的时刻到达的事件。当状态机可以处理它时这个事件被<code class="language-plaintext highlighter-rouge">召回</code>。</p><ul><li>它需要<code class="language-plaintext highlighter-rouge">明确</code>的延迟和召回被延迟的事件。<li><code class="language-plaintext highlighter-rouge">QF</code> 实时框架提供了类属 <code class="language-plaintext highlighter-rouge">defer()</code> 和 <code class="language-plaintext highlighter-rouge">recall()</code> 操作。<li>如果一个状态机延迟了一个以上的事件，它可以使用同样的事件队列 (QEQueue) 或为不同的事件使用不同的事件队列。类属 QF 操作 defer() 和 recall() 支持这 2 个选项。<li>如果事件在一个高层状态被延迟，这通常发生在这个状态的某个<a href="#内部转换-internal-transistions">内部转换</a>中。<li>在这个状态的<code class="language-plaintext highlighter-rouge">进入动作</code>是这个事件被召回，可以方便的处理这个被延迟事件类型。<li>事件不应该在它被明确的召回时处理（要先加入事件队列，QF 会处理）。因为， recall() 操作使用 LIFO 策略发送这个事件， 这样状态机在处理这事件前不能够改变状态。<li>召回一个事件牵涉到把它发送给自己，然而，和提醒器模式不一样，延迟的事件是外部的而不是被创造出来的。</ul></ul><h3 id="正交构件"><span class="mr-2">正交构件</span><a href="#正交构件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>目的</ul><p>作为组件使用状态机。</p><ul><li>问题</ul><p>许多对象包含<code class="language-plaintext highlighter-rouge">相对独立</code>的具有状态行为的部分。例如，考虑一个简单的数字闹钟。这个设备执行 2 个大的<code class="language-plaintext highlighter-rouge">独立</code>的功能：<code class="language-plaintext highlighter-rouge">基本的计时功能</code>和<code class="language-plaintext highlighter-rouge">闹钟功能</code>。每个功能都有自己的操作模式。例如，计时可以使用 2 个模式： 12小时制或 24小时制。类似的，闹钟功能也可以启动或停止。</p><p>在 UML 状态图里建模这样行为的标准方法是吧每个这种松散关联的功能放到一个独立的<code class="language-plaintext highlighter-rouge">正交区域</code>。相当于两个线程，重用少，资源消耗大，且 QEP 不支持</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/alarmclock.jpg" alt="alarmclock" data-proofer-ignore></p><ul><li>解决方法</ul><p>并发性实际上总是在<code class="language-plaintext highlighter-rouge">聚合</code>对象的内部出现，也就是说，组件的多个状态对这个合成对象的单一状态有贡献</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/alarmclock2.jpg" alt="alarmclock2" data-proofer-ignore></p><blockquote><p>图中菱形加箭头就是 UML 中的聚合的表示</p></blockquote><p>将两个功能拆成<code class="language-plaintext highlighter-rouge">两个状态机</code>，通过聚合方式进行关联，将闹钟功能状态机（<code class="language-plaintext highlighter-rouge">组件</code>）放在计时功能状态机（<code class="language-plaintext highlighter-rouge">容器</code>）内作为组件</p><ul><li>代码样本</ul><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/alarmclock3.jpg" alt="alarmclock3" data-proofer-ignore></p><p><em>共有信号和事件 clock.h:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#ifndef clock_h
#define clock_h
</span><span class="k">enum</span> <span class="n">AlarmClockSignals</span>
<span class="p">{</span>
  <span class="n">TICK_SIG</span> <span class="o">=</span> <span class="n">Q_USER_SIG</span><span class="p">,</span> <span class="cm">/* time tick event */</span>
  <span class="n">ALARM_SET_SIG</span><span class="p">,</span>         <span class="cm">/* set the alarm */</span>
  <span class="n">ALARM_ON_SIG</span><span class="p">,</span>          <span class="cm">/* turn the alarm on */</span>
  <span class="n">ALARM_OFF_SIG</span><span class="p">,</span>         <span class="cm">/* turn the alarm off */</span>
  <span class="n">ALARM_SIG</span><span class="p">,</span>             <span class="cm">/* alarm event from Alarm component to AlarmClock container */</span>
  <span class="n">CLOCK_12H_SIG</span><span class="p">,</span>         <span class="cm">/* set the clock in 12H mode */</span>
  <span class="n">CLOCK_24H_SIG</span><span class="p">,</span>         <span class="cm">/* set the clock in 24H mode */</span>
  <span class="n">TERMINATE_SIG</span>          <span class="cm">/* terminate the application */</span>
<span class="p">};</span>
<span class="cm">/*.................................................................*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">SetEvtTag</span>
<span class="p">{</span>
  <span class="n">QEvent</span> <span class="n">super</span><span class="p">;</span> <span class="cm">/* derive from QEvent */</span>
  <span class="kt">uint8_t</span> <span class="n">digit</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SetEvt</span><span class="p">;</span>
<span class="c1">// 用于通知当前时间的事件</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TimeEvtTag</span>
<span class="p">{</span>
  <span class="n">QEvent</span> <span class="n">super</span><span class="p">;</span> <span class="cm">/* derive from QEvent */</span>
  <span class="kt">uint32_t</span> <span class="n">current_time</span><span class="p">;</span>
<span class="p">}</span> <span class="n">TimeEvt</span><span class="p">;</span>
<span class="c1">// 只使用基类QActive指针，组件类不需要知道容器类的具体结构，该技术叫不透明指针(opaque pointer)</span>
<span class="k">extern</span> <span class="n">QActive</span> <span class="o">*</span><span class="n">APP_alarmClock</span><span class="p">;</span> <span class="cm">/* AlarmClock container active object */</span>
<span class="cp">#endif </span><span class="cm">/* clock_h */</span><span class="cp">
</span></pre></table></code></div></div><p><em>Alarm 组件(闹钟功能)声明 alarm.h:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#ifndef alarm_h
#define alarm_h
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">AlarmTag</span>
<span class="p">{</span>             <span class="cm">/* the HSM version of the Alarm component */</span>
  <span class="c1">// 闹钟功能比较简单，只要ON和OFF两种状态，不需要层次式状态机</span>
  <span class="c1">// 用FSM有限状态机就行了</span>
  <span class="n">QFsm</span> <span class="n">super</span><span class="p">;</span> <span class="cm">/* derive from QFsm */</span>
  <span class="kt">uint32_t</span> <span class="n">alarm_time</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Alarm</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Alarm_ctor</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span>
<span class="cp">#define Alarm_init(me_) QFsm_init((QFsm *)(me_), (QEvent *)0)
#define Alarm_dispatch(me_, e_) QFsm_dispatch((QFsm *)(me_), e_)
#endif </span><span class="cm">/* alarm_h */</span><span class="cp">
</span></pre></table></code></div></div><p><em>Alarm 组件(闹钟功能)的定义 alarm.c:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"alarm.h"</span><span class="cp">
#include</span> <span class="cpf">"clock.h"</span><span class="cp">
</span><span class="cm">/* FSM state-handler functions */</span>
<span class="n">QState</span> <span class="nf">Alarm_initial</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">Alarm_off</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">Alarm_on</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">Alarm_ctor</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 调用基类构造函数</span>
  <span class="n">QFsm_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Alarm_initial</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* HSM definition -------------------------------------------------------*/</span>
<span class="n">QState</span> <span class="nf">Alarm_initial</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Alarm_off</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 闹钟关状态</span>
<span class="n">QState</span> <span class="nf">Alarm_off</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="cm">/* while in the off state, the alarm is kept in decimal format */</span>
    <span class="c1">// 将时间内部二进制表示形式转为人类可读小时和分钟分离的十进制格式，如725转为1205，表示12:05</span>
    <span class="c1">// 用于设置时间时为人类用户提供方便</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">%</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"*** Alarm OFF %02ld:%02ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="cm">/* upon exit, the alarm is converted to binary format */</span>
    <span class="c1">// 退出前转换回去</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">ALARM_ON_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Alarm_on</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// OFF状态允许设置闹钟</span>
  <span class="k">case</span> <span class="n">ALARM_SET_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="cm">/* while setting, the alarm is kept in decimal format */</span>
    <span class="c1">// 设置的的闹钟是人类可读的十进制格式</span>
    <span class="kt">uint32_t</span> <span class="n">alarm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">+</span> <span class="p">((</span><span class="n">SetEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">digit</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10000</span><span class="p">;</span>
    <span class="c1">// 合法性判断</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">alarm</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">alarm</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">))</span>
    <span class="p">{</span> <span class="cm">/*alarm in range?*/</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">=</span> <span class="n">alarm</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="cm">/* alarm out of range -- start over */</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"*** Alarm SET %02ld:%02ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_IGNORED</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="n">QState</span> <span class="nf">Alarm_on</span><span class="p">(</span><span class="n">Alarm</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"*** Alarm ON %02ld:%02ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span> <span class="o">%</span> <span class="mi">60</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// ON状态禁止设置闹钟</span>
  <span class="k">case</span> <span class="n">ALARM_SET_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"*** Cannot set Alarm when it is ON</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">ALARM_OFF_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Alarm_off</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ON状态下处理由 AlarmClock 容器发送的TIME事件，获取当前时间进行比较</span>
  <span class="k">case</span> <span class="n">TIME_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">TimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">==</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm_time</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"ALARM!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="cm">/* asynchronously post the event to the container AO */</span>
      <span class="c1">// 时间到达时发送事件给容器</span>
      <span class="n">QActive_postFIFO</span><span class="p">(</span><span class="n">APP_alarmClock</span><span class="p">,</span> <span class="n">Q_NEW</span><span class="p">(</span><span class="n">QEvent</span><span class="p">,</span> <span class="n">ALARM_SIG</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_IGNORED</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>AlarmClock 容器（计时功能）定义 clock.c:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
#include</span> <span class="cpf">"alarm.h"</span><span class="cp">
#include</span> <span class="cpf">"clock.h"</span><span class="cp">
</span><span class="cm">/*.....................................................................*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">AlarmClockTag</span>
<span class="p">{</span>                        <span class="cm">/* the AlarmClock active object */</span>
  <span class="n">QActive</span> <span class="n">super</span><span class="p">;</span>         <span class="cm">/* derive from QActive */</span>
  <span class="c1">// 当前时间</span>
  <span class="kt">uint32_t</span> <span class="n">current_time</span><span class="p">;</span> <span class="cm">/* the current time in seconds */</span>
  <span class="c1">// 定时事件</span>
  <span class="n">QTimeEvt</span> <span class="n">timeEvt</span><span class="p">;</span>      <span class="cm">/* time event generator (generates time ticks) */</span>
  <span class="c1">// 包含了Alarm组件（闹钟功能）</span>
  <span class="n">Alarm</span> <span class="n">alarm</span><span class="p">;</span>           <span class="cm">/* Alarm orthogonal component */</span>
<span class="p">}</span> <span class="n">AlarmClock</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">AlarmClock_ctor</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* default ctor */</span>
<span class="cm">/* hierarchical state machine ... */</span>
<span class="n">QState</span> <span class="nf">AlarmClock_initial</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">AlarmClock_timekeeping</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">AlarmClock_mode12hr</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">AlarmClock_mode24hr</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">AlarmClock_final</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">AlarmClock_ctor</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* default ctor */</span>
  <span class="n">QActive_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">AlarmClock_initial</span><span class="p">);</span>
  <span class="n">Alarm_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm</span><span class="p">);</span>                <span class="cm">/* orthogonal component ctor */</span>
  <span class="n">QTimeEvt_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeEvt</span><span class="p">,</span> <span class="n">TICK_SIG</span><span class="p">);</span> <span class="cm">/* private time event ctor */</span>
<span class="p">}</span>
<span class="cm">/* HSM definition -------------------------------------------------------*/</span>
<span class="n">QState</span> <span class="nf">AlarmClock_initial</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Alarm_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm</span><span class="p">);</span> <span class="cm">/* the initial transition in the component */</span>
  <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlarmClock_timekeeping</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">AlarmClock_final</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span> <span class="cm">/* avoid the compiler warning about unused parameter */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"-&gt; final</span><span class="se">\n</span><span class="s">Bye!Bye!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">BSP_exit</span><span class="p">();</span> <span class="cm">/* terminate the application */</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">AlarmClock_timekeeping</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="cm">/* periodic timeout every second */</span>
    <span class="n">QTimeEvt_fireEvery</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeEvt</span><span class="p">,</span>
                       <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span> <span class="n">BSP_TICKS_PER_SEC</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">QTimeEvt_disarm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">timeEvt</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Q_INIT_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlarmClock_mode24hr</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">CLOCK_12H_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlarmClock_mode12hr</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">CLOCK_24H_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlarmClock_mode24hr</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">ALARM_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Wake up!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">ALARM_SET_SIG</span><span class="p">:</span>
  <span class="k">case</span> <span class="n">ALARM_ON_SIG</span><span class="p">:</span>
  <span class="k">case</span> <span class="n">ALARM_OFF_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="cm">/* synchronously dispatch to the orthogonal component */</span>
    <span class="c1">// 对于和组件相关的事件，通过组件提供的dispatch()函数转发给它</span>
    <span class="n">Alarm_dispatch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">TERMINATE_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlarmClock_final</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">AlarmClock_mode24hr</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"*** 24-hour mode</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">TICK_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">TimeEvt</span> <span class="n">pe</span><span class="p">;</span> <span class="cm">/* temporary synchronous event for the component */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">==</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* roll over in 24-hr mode? */</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%02ld:%02ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">%</span> <span class="mi">60</span><span class="p">);</span>
    <span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sig</span> <span class="o">=</span> <span class="n">TICK_SIG</span><span class="p">;</span>
    <span class="n">pe</span><span class="p">.</span><span class="n">current_time</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span><span class="p">;</span>
    <span class="cm">/* synchronously dispatch to the orthogonal component */</span>
    <span class="c1">// 每个tick都发送当前时间给组件</span>
    <span class="n">Alarm_dispatch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pe</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlarmClock_timekeeping</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">AlarmClock_mode12hr</span><span class="p">(</span><span class="n">AlarmClock</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"*** 12-hour mode</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">TICK_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">TimeEvt</span> <span class="n">pe</span><span class="p">;</span> <span class="cm">/* temporary synchronous event for the component */</span>
    <span class="kt">uint32_t</span> <span class="n">h</span><span class="p">;</span> <span class="cm">/* temporary variable to hold hour */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* roll over in 12-hr mode? */</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%02ld:%02ld %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">h</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">:</span> <span class="mi">12</span><span class="p">,</span>
           <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span> <span class="o">%</span> <span class="mi">60</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">?</span> <span class="s">"PM"</span> <span class="o">:</span> <span class="s">"AM"</span><span class="p">);</span>
    <span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sig</span> <span class="o">=</span> <span class="n">TICK_SIG</span><span class="p">;</span>
    <span class="n">pe</span><span class="p">.</span><span class="n">current_time</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">current_time</span><span class="p">;</span>
    <span class="cm">/* synchronously dispatch to the orthogonal component */</span>
    <span class="n">Alarm_dispatch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">alarm</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pe</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">AlarmClock_timekeeping</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>结论</p><ul><li>它把行为的独立部分分区为不同的<code class="language-plaintext highlighter-rouge">状态机对象</code>。这个分割比正交区域更深入，因为对象同时有明确的<code class="language-plaintext highlighter-rouge">行为</code>和明确的<code class="language-plaintext highlighter-rouge">数据</code>。<li>进行分区引进了<code class="language-plaintext highlighter-rouge">容器-组件</code>（也叫父-子，或主-仆）关系。容器实现主要的功能并把其他 （次要的）<code class="language-plaintext highlighter-rouge">特征</code>授权给组件。容器和组件都是<code class="language-plaintext highlighter-rouge">状态机</code>。<li><code class="language-plaintext highlighter-rouge">组件</code>常在不同的容器或相同的容器内被<code class="language-plaintext highlighter-rouge">重用</code>（容器可以实例化某个给定类型组件的多个组件）。<li>容器同组件<code class="language-plaintext highlighter-rouge">共享</code>它的执行<code class="language-plaintext highlighter-rouge">线程</code>。<li>容器通过直接<code class="language-plaintext highlighter-rouge">派送事件</code>给组件来进行通讯。组件通过发送事件给容器来通知它，而不是通过直接地事件派送方法。<li>组件使用<code class="language-plaintext highlighter-rouge">提醒器模式</code>去通知容器（例如，通知事件特别为<code class="language-plaintext highlighter-rouge">内部</code>而不是外部通讯被创造出来）。如果有某个给定类型的多个组件，这个通知事件必须确定<code class="language-plaintext highlighter-rouge">起源</code>的组件（组件把它的 ID 号作为通知事件的一个参数传递）。<li>容器和组件可以<code class="language-plaintext highlighter-rouge">共享数据</code>。典型的，数据是容器（允许不同容器的多个实例）的一个数据成员。 典型的，容器担保对它所选择的组件是友元关系。<li>容器完全对它的组件<code class="language-plaintext highlighter-rouge">负责</code>。特别的，它必须明确的触发在全部组件的<code class="language-plaintext highlighter-rouge">初始转换</code>。同时明确的<code class="language-plaintext highlighter-rouge">派发事件</code>给组件。如果容器“忘记”在它的某些状态派发事件给某些组件，就会产生错误。<li>容器可以<code class="language-plaintext highlighter-rouge">动态</code>的开始和停止组件（例如，在容器状态机的的某些特定状态）。<li>状态机的结合并没有局限于只有一层。组件可以有状态机子组件，也就是说，组件可以是较低层子组件的容器。这样一种组件的<code class="language-plaintext highlighter-rouge">递归</code>结构可以到达任意深的层次。</ul></ul><h3 id="转换到历史状态"><span class="mr-2">转换到历史状态</span><a href="#转换到历史状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>目的</ul><p>从某个组合状态转换出来，但是记住最近的活动子状态，这样在后面你可以返回这个子状态。</p><ul><li>问题</ul><p>如让烤面包炉的门在工作中被打开后，再次关闭，能够恢复开门前的执行的动作。</p><p>UML 状态图使用 2 类<code class="language-plaintext highlighter-rouge">历史伪状态</code>处理这种情况：浅历史和深历史</p><ul><li>解决方法</ul><p>它把 doorClosed 状态最近的活动<code class="language-plaintext highlighter-rouge">叶子状态</code>存储在一个专用的数据成员 <code class="language-plaintext highlighter-rouge">doorClosed_history</code> 里。doorOpen 状态的转换到<code class="language-plaintext highlighter-rouge">历史</code>（带 圆圈的 H* ）时使用这个属性作为这个转换的目标。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/historystate.jpg" alt="historystate" data-proofer-ignore></p><ul><li>实例代码</ul><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/historystate2.jpg" alt="historystate2" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qep_port.h"</span><span class="cp">
</span><span class="cm">/*.....................................................................*/</span>
<span class="k">enum</span> <span class="n">ToasterOvenSignals</span>
<span class="p">{</span>
  <span class="n">OPEN_SIG</span> <span class="o">=</span> <span class="n">Q_USER_SIG</span><span class="p">,</span>
  <span class="n">CLOSE_SIG</span><span class="p">,</span>
  <span class="n">TOAST_SIG</span><span class="p">,</span>
  <span class="n">BAKE_SIG</span><span class="p">,</span>
  <span class="n">OFF_SIG</span><span class="p">,</span>
  <span class="n">TERMINATE_SIG</span> <span class="cm">/* terminate the application */</span>
<span class="p">};</span>
<span class="cm">/*.....................................................................*/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ToasterOvenTag</span>
<span class="p">{</span>
  <span class="n">QHsm</span> <span class="n">super</span><span class="p">;</span>                       <span class="cm">/* derive from QHsm */</span>
  <span class="c1">// 继承自QHsm，扩展了用于存放历史状态的doorClosed_history</span>
  <span class="n">QStateHandler</span> <span class="n">doorClosed_history</span><span class="p">;</span> <span class="cm">/* history of the doorClosed state */</span>
<span class="p">}</span> <span class="n">ToasterOven</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">ToasterOven_ctor</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* default ctor */</span>
<span class="n">QState</span> <span class="nf">ToasterOven_initial</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">ToasterOven_doorOpen</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">ToasterOven_off</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">ToasterOven_heating</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">ToasterOven_toasting</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">ToasterOven_baking</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">ToasterOven_doorClosed</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QState</span> <span class="nf">ToasterOven_final</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">ToasterOven_ctor</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* default ctor */</span>
  <span class="n">QHsm_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ToasterOven_initial</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* HSM definitio -------------------------------------------------------*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_initial</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">doorClosed_history</span> <span class="o">=</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ToasterOven_off</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_doorClosed</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_final</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"-&gt; final</span><span class="se">\n</span><span class="s">Bye!Bye!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_doorClosed</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"door-Closed;"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Q_INIT_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_off</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">OPEN_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_doorOpen</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">TOAST_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_toasting</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">BAKE_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_baking</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">OFF_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_off</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">TERMINATE_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_final</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_off</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"toaster-Off;"</span><span class="p">);</span>
    <span class="c1">// 所有叶状态进入时都要更新一次doorClosed_history</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">doorClosed_history</span> <span class="o">=</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ToasterOven_off</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_doorClosed</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_heating</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"heater-On;"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"heater-Off;"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_doorClosed</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_toasting</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"toasting;"</span><span class="p">);</span>
    <span class="c1">// 所有叶状态进入时都要更新一次doorClosed_history</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">doorClosed_history</span> <span class="o">=</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ToasterOven_toasting</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_heating</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_baking</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span> <span class="cm">/* avoid compiler warning about unused parameter */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"baking;"</span><span class="p">);</span>
    <span class="c1">// 所有叶状态进入时都要更新一次doorClosed_history</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">doorClosed_history</span> <span class="o">=</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ToasterOven_baking</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ToasterOven_heating</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="n">QState</span> <span class="nf">ToasterOven_doorOpen</span><span class="p">(</span><span class="n">ToasterOven</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">Q_ENTRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"door-Open,lamp-On;"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Q_EXIT_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"lamp-Off;"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">CLOSE_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="c1">// 恢复历史状态</span>
    <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">doorClosed_history</span><span class="p">);</span> <span class="cm">/* transition to HISTORY */</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>结论</p><li>需要一个用于<code class="language-plaintext highlighter-rouge">存储历史状态</code>的变量，这个变量是个指针，指向了状态处理函数<li>转换到历史伪状态（深历史和浅历史）使用标准的 <code class="language-plaintext highlighter-rouge">Q_TRAN()</code> 宏编码，这里目标被特定为历史变量。<li>为了实现<a href="#伪状态-pseudostates"><code class="language-plaintext highlighter-rouge">深历史伪状态</code></a>，需要在相应组合状态的每个叶子状态的<code class="language-plaintext highlighter-rouge">进入动作</code>上明确的设置历史变量。<li>为了实现<code class="language-plaintext highlighter-rouge">浅历史伪状态</code>，需要在每一个从所需层次的<code class="language-plaintext highlighter-rouge">退出动作</code>上明确的设置历史变量。例如，图5.12中的 doorClosed 浅历史需要在从 toasting 的退出动作把 doorClosed_history 设置为 &amp;ToasterOven_toasting，在从 baking 的退出动作把它设置为 &amp;ToasterOven_baking ，以及 doorClosed 全部<code class="language-plaintext highlighter-rouge">直接子状态</code>。<li>你可以通过<code class="language-plaintext highlighter-rouge">复位</code>相应的<code class="language-plaintext highlighter-rouge">历史变量</code>明确的<code class="language-plaintext highlighter-rouge">清理</code>任何组合状态的<code class="language-plaintext highlighter-rouge">历史</code>。</ul><h2 id="实时框架的概念"><span class="mr-2">实时框架的概念</span><a href="#实时框架的概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="cpu-管理"><span class="mr-2">CPU 管理</span><a href="#cpu-管理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>传统的事件驱动型架构对实时框架不是非常适合。最起码在三个方面存在问题：</p><ol><li><strong>响应性</strong>：单一事件队列不允许对工作的任何合理的<code class="language-plaintext highlighter-rouge">优先次序</code>。每个事件，无论优先级，必 须等待直到它前面的全部事件被处理完后才能被处理。<li><strong>不支持对应用程序上下文的管理</strong>：流行的<code class="language-plaintext highlighter-rouge">事件 - 动作范型</code>在响应事件时忽略应用程序的 上下文，这样应用程序员就即兴发挥，到最后搞出“面条”代码。不幸的是，事件 - 动作 范型和状态机不兼容。<li><strong>全局数据</strong>：在传统的事件架构里，全部的事件处理函数存取一样的全局数据。这阻碍了对问 题的<code class="language-plaintext highlighter-rouge">分区</code>，并为任何形式的多任务带来了<code class="language-plaintext highlighter-rouge">并发性</code>危机。</ol><h3 id="活动对象计算模式"><span class="mr-2">活动对象计算模式</span><a href="#活动对象计算模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/room.jpg" alt="room" data-proofer-ignore></p><p><strong>活动对象</strong> = （控制的线程 + 事件队列 + 状态机）</p><p>应用程序包含了多个<code class="language-plaintext highlighter-rouge">活动对象</code>，每个都封装了一个<code class="language-plaintext highlighter-rouge">控制线程（事件循环）</code>，一个私有的<code class="language-plaintext highlighter-rouge">事件队列</code>和一个<code class="language-plaintext highlighter-rouge">状态机</code>。</p><ul><li><code class="language-plaintext highlighter-rouge">控制线程（事件循环）</code>: 图(a)中为一个环形标记（方框右下角），具体见图(b)，事件循环调用和这个活动对象联合的 dispatch()函数。 dispatch()函数执行调度和处理事件的工作， 类似于在传统事件驱动型架构的事件处理函数。<li><code class="language-plaintext highlighter-rouge">事件队列</code>：(a)中的 event queue<li><code class="language-plaintext highlighter-rouge">状态机</code>：(a)中的 internal state machine</ul><h4 id="系统结构"><span class="mr-2">系统结构</span><a href="#系统结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/kernelosapp.jpg" alt="kernelosapp" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">RTOS</code> 层在底部提供多任务和基本服务，比如<code class="language-plaintext highlighter-rouge">消息队列</code>，为存储事件确定内存分区等等。基于这些服务， <code class="language-plaintext highlighter-rouge">QF</code> 实时框架提供 <code class="language-plaintext highlighter-rouge">QActive</code> 类用于活动对象的<code class="language-plaintext highlighter-rouge">派生</code>。 <code class="language-plaintext highlighter-rouge">QActive</code> 类是从 QHsm 基础类派生而来，这意味着活动对象是状态机，并且继承了在 QHsm 基础类（见第四章）定义的<code class="language-plaintext highlighter-rouge">dispatch()</code>操作。另外， <code class="language-plaintext highlighter-rouge">QActive</code> 包含了一个<code class="language-plaintext highlighter-rouge">执行线程</code>和一个<code class="language-plaintext highlighter-rouge">事件队列</code>，它基于底层 RTOS 上的消息队列。应用程序通过从 QActive 基础类派生<code class="language-plaintext highlighter-rouge">活动对象</code>以及从 QEvent 类派生带有参数的<code class="language-plaintext highlighter-rouge">事件</code>，从而扩展了实时框架。</p><h4 id="异步通讯"><span class="mr-2">异步通讯</span><a href="#异步通讯" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>活动对象专门的通过它们的<code class="language-plaintext highlighter-rouge">事件队列</code>接收事件。所以事件都被<code class="language-plaintext highlighter-rouge">异步</code>投递，意味着一个事件生产者仅发送一个事件给接收者活动对象的事件队列，但是<code class="language-plaintext highlighter-rouge">不会原地等待</code>这个事件的实际处理过程。</p><p>活动对象之间也可以通过这种方式传递事件，而不只局限于内部。</p><h4 id="运行---到---完成-rtc"><span class="mr-2">运行 - 到 - 完成 RTC</span><a href="#运行---到---完成-rtc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>每一个活动对象用运行到完成（ run-to-completion）方式来处理事件，它是通过活动对象的事件循环的结构来保证的。</p><h4 id="封装"><span class="mr-2">封装</span><a href="#封装" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>封装意味着活动对象<code class="language-plaintext highlighter-rouge">不共享数据</code>和任何其他资源。</p><p>数据通过<code class="language-plaintext highlighter-rouge">消息</code>机制传递</p><h3 id="事件派发机制"><span class="mr-2">事件派发机制</span><a href="#事件派发机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>两类事件派发机制:</p><ul><li><code class="language-plaintext highlighter-rouge">简单的事件直接发送机制</code>：一个事件的生产者直接发送这个事件到消费者活动对象的<code class="language-plaintext highlighter-rouge">事件队列</code>。<li><code class="language-plaintext highlighter-rouge">订阅派发机制</code>，这里一个生产者“发行”一个事件给框架，框架然后把这个事件派发给所有已经“<code class="language-plaintext highlighter-rouge">订阅</code>”了这个事件的活动对象。发行-订阅机制提供了在事件产生者和消费者之间较低的耦合。</ul><h4 id="直接事件发送"><span class="mr-2">直接事件发送</span><a href="#直接事件发送" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>例如，QF 实时框架提供了操作 QActive_postFIFO()</p><p>这个事件传递的方式需要事件产生者密切的“<code class="language-plaintext highlighter-rouge">知道</code>”接收者。这种知识，散布在参与应用程序的组件中，使组件之间的<code class="language-plaintext highlighter-rouge">耦合</code>非常强烈和在运行时不灵活。</p><h4 id="订阅派发机制"><span class="mr-2">订阅派发机制</span><a href="#订阅派发机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>事件的产生者和消费者不需要互相了解对方（<code class="language-plaintext highlighter-rouge">松耦合</code>）。<li>通过这个机制的事件交换必须被公开的了解，全部参与者必须有<code class="language-plaintext highlighter-rouge">相同的语义</code>。<li>需要一个<code class="language-plaintext highlighter-rouge">介质</code>去接收所发行的事件，再把它们派发给感兴趣的订阅者。<li><code class="language-plaintext highlighter-rouge">多对多</code>交互作用（对象-到-对象）被<code class="language-plaintext highlighter-rouge">一对多</code>交互作用（对象-到-介质）所取代</ul><h3 id="事件内存管理"><span class="mr-2">事件内存管理</span><a href="#事件内存管理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>事件频繁产生消耗，内存重用很重要</p><h4 id="零复制的事件派发"><span class="mr-2">零复制的事件派发</span><a href="#零复制的事件派发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">复制</code>整个事件到消息队列的蛮力方法是一个传统的 RTOS 能做的最好方法，因为一个 RTOS 在事件离开队列后<code class="language-plaintext highlighter-rouge">不能够控制</code>它们。另一方面，一个<code class="language-plaintext highlighter-rouge">实时框架</code>可以更加有效，因为由于控制的倒置，框架实际在管理一个事件的全部<code class="language-plaintext highlighter-rouge">生命周期</code>。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/eventgc.jpg" alt="eventgc" data-proofer-ignore></p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/eventgc2.jpg" alt="eventgc2" data-proofer-ignore></p><p>一个事件的生命周期开始于框架分配<code class="language-plaintext highlighter-rouge">事件内存</code>并返回一个指向这个内存的<code class="language-plaintext highlighter-rouge">指针</code>给事件生产者，如图(1)，生产者然后<code class="language-plaintext highlighter-rouge">填充</code>事件<code class="language-plaintext highlighter-rouge">参数</code>，执行写入所提供的事件指针。然后，事件生产者发送这个事件<code class="language-plaintext highlighter-rouge">指针</code>给接收者活动对象的<code class="language-plaintext highlighter-rouge">队列</code>，如图(2)</p><p>稍后，活动对象开始<code class="language-plaintext highlighter-rouge">处理</code>事件。活动对象读取通过指针从队列里<code class="language-plaintext highlighter-rouge">提取</code>的事件数据。最后，框架在垃圾收集步骤自动的<code class="language-plaintext highlighter-rouge">回收</code>事件。请注意<strong>事件从来没有被复制</strong>。同时框架确信事件没有被过早回收。当然，框架必须也保证用一个<code class="language-plaintext highlighter-rouge">线程安全</code>的方式执行全部操作。</p><h4 id="静态和动态的事件"><span class="mr-2">静态和动态的事件</span><a href="#静态和动态的事件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><strong>静态事件</strong>：没有参数或参数不会变的事件，可以静态分配，永远不变，如上图(3)<li><strong>动态事件</strong>：参数会变的事件，需要事件池动态分配</ul><h4 id="多路传输事件和引用计数器算法"><span class="mr-2">多路传输事件和引用计数器算法</span><a href="#多路传输事件和引用计数器算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用订阅分发机制时也可以使用<code class="language-plaintext highlighter-rouge">零复制</code>派发事件指针。但该指针被<code class="language-plaintext highlighter-rouge">多个</code>活动对象使用，问题是如何知道<code class="language-plaintext highlighter-rouge">最后一个</code>活动对象完成了对这个给定事件的处理，这样它占用的空间可以被<code class="language-plaintext highlighter-rouge">回收</code>。</p><p>一个简便的方法是使用标准的<code class="language-plaintext highlighter-rouge">引用计数器算法</code>，每个动态事件有个计数器，开始为 0，每次发生事件加 1，每次被回收时减 1，到 0 删除事件内存</p><h4 id="事件的所有权"><span class="mr-2">事件的所有权</span><a href="#事件的所有权" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/eventowner.jpg" alt="eventowner" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">生产者</code>仅能通过调用 <code class="language-plaintext highlighter-rouge">new_()</code> 操作来获得一个新事件的所有权。但是最后生产者必须把所有权<code class="language-plaintext highlighter-rouge">转让</code>给框架，如生产者发送或发行事件，主动要求删除不完整事件</p><p><code class="language-plaintext highlighter-rouge">消费者</code>活动对象在<code class="language-plaintext highlighter-rouge">框架</code>调用 <code class="language-plaintext highlighter-rouge">dispatch(e)</code> 操作时获得当前事件 e 的所有权(只读)。当 dispatch()操作返回到框架时，所有权被终止。</p><h4 id="内存池"><span class="mr-2">内存池</span><a href="#内存池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">堆</code>一般有碎片化、泄露、悬空指针、难以预测、无法重入、空间浪费（管理信息）等问题</p><p>内存池会有一定优势，QF 实时框架，可以管理多达 3 个拥有不同块尺寸（<code class="language-plaintext highlighter-rouge">小，中，大</code>）的事件池。</p><h4 id="时间管理"><span class="mr-2">时间管理</span><a href="#时间管理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/timeevt.jpg" alt="timeevt" data-proofer-ignore></p><p>当活动对象需要安排一个超时服务，它准备它的某个<code class="language-plaintext highlighter-rouge">时间事件</code>以便在未来的某时刻发送给自己。</p><p>时间事件为这个目的提供的公共操作：为<code class="language-plaintext highlighter-rouge">一次性</code>超时提供<code class="language-plaintext highlighter-rouge">postIn()</code>，为<code class="language-plaintext highlighter-rouge">周期性</code>超时提供 <code class="language-plaintext highlighter-rouge">postEvery()</code> 。</p><p>应用程序可以明确的使用 <code class="language-plaintext highlighter-rouge">disarm()</code> 操作在任何时刻<code class="language-plaintext highlighter-rouge">解除</code> (disarm) 任何（周期性的或一次性的）时间事件，之后该事件空间可以<code class="language-plaintext highlighter-rouge">重用</code>。</p><p>可以通过 <code class="language-plaintext highlighter-rouge">rearm()</code> 操作<code class="language-plaintext highlighter-rouge">重新设定</code> (rearmed)，如刷新看门狗</p><h4 id="系统时钟节拍"><span class="mr-2">系统时钟节拍</span><a href="#系统时钟节拍" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>系统时钟节拍典型地是一个以预先确定的速率发生的<code class="language-plaintext highlighter-rouge">周期性中断</code>，典型的速率在 10 和 100Hz 之间。</p><p>下图用某种夸张的方式展示了在一个节拍间隔内一个周期性时间事件的不同的延迟：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/systemtick.jpg" alt="systemtick" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">高优先级</code>的任务能更<code class="language-plaintext highlighter-rouge">及时</code>获得节拍，且跳动(jitter)较少。</p><p>一个仅为了一个节拍而准备的时间事件会立刻过期，比如上图第 3 个节拍处理时已经在第 4 个节拍之后了，因为还在处理第 3 个节拍对应的的事件动作，可能会导致第 4 个节拍事件<code class="language-plaintext highlighter-rouge">没有产生</code>(类似中断丢失)，导致第 4 个节拍对应的动作无法执行。解决方法是事件要对应两个节拍，也就是原来指定第 4 个节拍发生的动作应该指定为 4 和 5 都能发生。</p><h3 id="错误和例外的处理"><span class="mr-2">错误和例外的处理</span><a href="#错误和例外的处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><dl><dt>契约式设计 Design by Contract, DbC 方法<dd>通过<code class="language-plaintext highlighter-rouge">断言assertion</code>来保证程序正常，它们既<code class="language-plaintext highlighter-rouge">不预防</code>错误也实际上<code class="language-plaintext highlighter-rouge">不处理</code>错误<dd>更适合小型系统，正常状态不应该有错误，有错误就复位，不允许跑飞的程序继续运行<dt>防御式编程<dd>通过接收<code class="language-plaintext highlighter-rouge">更宽范围</code>的输入或允许操作的次序不必定符合对象的状态，让操作对错误更加<code class="language-plaintext highlighter-rouge">强壮</code>。<dd>适合大型系统，尽可能规避错误，即使有错误也要尝试处理和恢复，不能退出进程或重启。因为大型系统运行有很高的不确定性，比如用户的输入无法预测。</dl><p>QF 框架规定了一些<code class="language-plaintext highlighter-rouge">断言宏</code>来处理错误</p><h4 id="c-和-c-里可定制的断言"><span class="mr-2">C 和 C++ 里可定制的断言</span><a href="#c-和-c-里可定制的断言" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="cp">#ifdef Q_NASSERT </span><span class="cm">/* Q_NASSERT defined–assertion checking disabled */</span><span class="cp">
</span><span class="c1">// 如果Q_NASSERT被定义，取消所有的断言，宏全定义成空语句</span>
<span class="cp">#define Q_DEFINE_THIS_FILE
#define Q_DEFINE_THIS_MODULE(name_)
#define Q_ASSERT(test_) ((void)0)
#define Q_ALLEGE(test_) ((void)(test_))
#define Q_ERROR() ((void)0)
#else </span><span class="cm">/* Q_NASSERT not defined–assertion checking enabled */</span><span class="cp">
</span><span class="cm">/* callback invoked in case the condition passed to assertion fails */</span>
<span class="cp">#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span>
<span class="cp">#endif
</span><span class="c1">// 断言失败时Q_onAssert被调用，一般就是关中断做些保存然后复位</span>
<span class="kt">void</span> <span class="nf">Q_onAssert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="n">Q_ROM</span> <span class="o">*</span><span class="k">const</span> <span class="n">Q_ROM_VAR</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">);</span>
<span class="c1">// 本文件的文件名，别的文件include这个头文件后，会变成那个文件的名字，作为日志打印时的标识符</span>
<span class="c1">// 这里使用了static变量l_this_file作为宏定义而不是__FILE__，防止每次使用Q_DEFINE_THIS_FILE宏时__FILE__被多次复制</span>
<span class="cp">#define Q_DEFINE_THIS_FILE \
  static char const Q_ROM Q_ROM_VAR l_this_file[] = __FILE__;
</span><span class="c1">// Q_DEFINE_THIS_FILE替代品,需要自定义</span>
<span class="cp">#define Q_DEFINE_THIS_MODULE(name_) \
  static char const Q_ROM Q_ROM_VAR l_this_file[] = #name_;
</span><span class="cm">/* general purpose assertion */</span>
<span class="c1">// 避免悬吊if(dangling-if)，详见上文</span>
<span class="c1">// test是一个条件，为true或是false</span>
<span class="cp">#define Q_ASSERT(test_) \
  if (test_)            \
  {                     \
  }                     \
  else                  \
    (Q_onAssert(l_this_file, __LINE__))
</span><span class="cm">/* general purpose assertion that ALWAYS evaluates the test_ argument */</span>
<span class="cp">#define Q_ALLEGE(test_) Q_ASSERT(test_)
</span><span class="cm">/* Assertion that always fails */</span>
<span class="cp">#define Q_ERROR() \
  (Q_onAssert(l_this_file, __LINE__))
#endif </span><span class="cm">/* Q_NASSERT */</span><span class="cp">
</span><span class="cm">/* assertion that checks for a precondition */</span>
<span class="cp">#define Q_REQUIRE(test_) Q_ASSERT(test_)
</span><span class="cm">/* assertion that checks for a postcondition */</span>
<span class="cp">#define Q_ENSURE(test_) Q_ASSERT(test_)
</span><span class="cm">/* assertion that checks for an invariant */</span>
<span class="cp">#define Q_INVARIANT(test_) Q_ASSERT(test_)
</span><span class="cm">/* compile-time assertion */</span>
<span class="c1">// 用于编译时的测试，利用C语言特性数组维数不能为0，如果test_为0，编译就会失败</span>
<span class="c1">// Q_ASSERT用于运行时测试断言，Q_ASSERT_COMPILE用于编译时测试断言，各有各的用途。比如运行时动态变化的变量要用Q_ASSERT，对于编译时确定的固定的量要用Q_ASSERT_COMPILE</span>
<span class="cp">#define Q_ASSERT_COMPILE(test_) \
  extern char Q_assert_compile[(test_)]
#endif </span><span class="cm">/* qassert_h */</span><span class="cp">
</span></pre></table></code></div></div><h3 id="基于框架的软件追踪"><span class="mr-2">基于框架的软件追踪</span><a href="#基于框架的软件追踪" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>简单的讲，软件追踪类似于在代码里安排一些 printf()语句，它被称为<code class="language-plaintext highlighter-rouge">检测代码</code>，记录并分析以后从目标系统取回来的所感兴趣的分立事件。当然，一个好的软件追踪检测设备可以做到比简单的 printf()更少的侵入并更有效。</p><p>从框架自身得到的软件追踪数据，允许你为全部系统里的活动对象生成完整的，带有时间戳的顺序图和详细的状态机活动图。</p><p>使用 QS 构件(Q-Spy)实现</p><h2 id="实时框架的实现"><span class="mr-2">实时框架的实现</span><a href="#实时框架的实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>QF 框架的代码实现详解，对上一章的补充</p><h3 id="qf-实时框架的关键特征"><span class="mr-2">QF 实时框架的关键特征</span><a href="#qf-实时框架的关键特征" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>可移植性</p><p>所以 QF 源代码使用可移植的 ANSI-C ，或者<a href="http://www.caravan.net/ec2plus/"><code class="language-plaintext highlighter-rouge">嵌入式 C++子集</code></a>（wiki 上说这个项目从 2002 年开始就停止了，而且 C++之父也不看好）编写，所有处理器相关的，编译器相关的，或操作系统相关的代码被抽象成一个清楚定义的平台抽象层 PAL（ platform abstraction layer）。</p><li><p>可伸缩性</p><p>QF 被设计用于一个<code class="language-plaintext highlighter-rouge">细粒度</code>的对象库的部署，你可以静态的把它链接到你的应用程序。这个策略把责任交给链接器，让它在链接时自动排除任何没用到的代码，应用程序员不需为每个应用程序在编译时刻去配置 QF 代码。</p><li><p>对现代状态机的支持</p><p>QF 实时框架被设计为和 QEP 层次式事件处理紧密的工作，QEP 提供了 UML 兼容的直接实现，而 QF 提了并发执行这类状态机的基础设施。</p><li><p>直接事件发送和发布 - 订阅式事件派发</p><p>QF 实时框架支持使用 FIFO 和 LIFO 策略对特点活动对象进行直接事件发送。QF 也支持更加先进的发行 - 订阅事件派发机制。</p><li><p>零复制的事件内存管理</p><p>QF 支持 事件的基于引用计数算法的多路发送，对事件的<code class="language-plaintext highlighter-rouge">自动垃圾收集</code>，<code class="language-plaintext highlighter-rouge">高效</code>的静态事件，“<code class="language-plaintext highlighter-rouge">零复制</code>”事件延迟， 和可多多达 3 个为了最佳内存使用而拥有<code class="language-plaintext highlighter-rouge">不同块尺寸</code>的<code class="language-plaintext highlighter-rouge">事件池</code>。</p><li><p>开放式序号的时间事件</p><p>每个时间事件可以被作为一个一次性或周期性超时发生器而被激活。只有被激活（ active ） 的时间事件才消耗 CPU 周期。</p><li><p>原生的事件队列</p><p>QF 提供原生事件队列的 2 个版本。</p><p>第一个版本是为活动对象优化的，包含一个可移植的可以为<code class="language-plaintext highlighter-rouge">阻塞型内核</code>、<code class="language-plaintext highlighter-rouge">简单的合作式 vanilla 内核</code>或 <code class="language-plaintext highlighter-rouge">QK 可抢占型内核</code>而做修改的层。</p><p>第二个版本是一个简单的“线程安全的”队列，它不能阻塞，被设计为给中断发送事件和存储延迟的事件。</p><li><p>原生的内存池</p><p>QF 提供了一个快的，可确定的，和线程安全的内场池。 QF 在内部把内存池作为管理动态事件的事件池，但是你也可以为了在你系统中分配任何其他对象而使用内存池。</p><li><p>内置 Vanilla 调度器</p><p>QF 实时框架包含了一个可移植的，合作式 vanilla 内核</p><li><p>和 QK 可抢占式内核的紧密集成</p><p>QF 实时框架也可以和可确定的，可抢占的，非阻塞 QK 内核工作。</p><li><p>低功耗构架</p><p>绝大多数嵌入式微处理器 MCU 提供了一个低功耗睡眠模式的选择，用来通过调节给 CPU 和其他外设的时钟来节省能量。睡眠模式通过软件控制进入，在某个外部中断时退出。</p><li><p>基于断言的错误处理</p><p>契约式设计（ DbC）哲学</p><li><p>内置软件追踪测试设备</p><p>一个实时框架可以使用软件追踪技术提供比任何传统的 RTOS 更广泛和更详细的，关于运行中应用系统的信息。关闭 Q_SPY 宏时不产生空间和性能开销</p></ul><h3 id="qf-的结构"><span class="mr-2">QF 的结构</span><a href="#qf-的结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qf.jpg" alt="qf" data-proofer-ignore></p><p>QF 提供了核心基本类 <code class="language-plaintext highlighter-rouge">QActive</code> ，用于活动对象类的派生。 <code class="language-plaintext highlighter-rouge">QActive</code> 类是<code class="language-plaintext highlighter-rouge">抽象</code>的，意味着它不是打算用于被直接实例化，而是为了派生具体的活动对象类，比如图内的<code class="language-plaintext highlighter-rouge">Ship</code>，<code class="language-plaintext highlighter-rouge">Missile</code>和 <code class="language-plaintext highlighter-rouge">Tunnel</code> 。</p><p>QActive 类默认是从在 <code class="language-plaintext highlighter-rouge">QEP</code>事件处理器的 <code class="language-plaintext highlighter-rouge">QHsm</code> 层次式状态机类<code class="language-plaintext highlighter-rouge">派生</code>。这意味着，凭借着继承，<code class="language-plaintext highlighter-rouge">活动对象</code>是 HSM，并继承了 init() 和 dispatch() 状态机接口。 QActive 也包含了一个<code class="language-plaintext highlighter-rouge">执行线程</code>和一个<code class="language-plaintext highlighter-rouge">事件队列</code>，它可以是原生的 QF 类，或者由底层 RTOS 提供。</p><p>和<code class="language-plaintext highlighter-rouge">QEP</code>事件处理器一样， QF 使用同样的 <code class="language-plaintext highlighter-rouge">QEvent</code> 类来表示事件。另外，框架提供了时间事件类 <code class="language-plaintext highlighter-rouge">QTimeEvt</code>，应用程序使用它来产生超时请求。</p><p>QF 也提供了几个服务给应用程序，它们没有在图的类图展示出来。这些额外的 QF 服务包括<code class="language-plaintext highlighter-rouge">生成新的动态事件</code> (Q_NEW()) ，<code class="language-plaintext highlighter-rouge">发行事件</code>（ QF_publish()），<code class="language-plaintext highlighter-rouge">原生 QF 事件队列类</code> (QEQueue) ，<code class="language-plaintext highlighter-rouge">原生 QF 内存池类</code>（ QMPool ），和内建的<code class="language-plaintext highlighter-rouge">合作式 vanilla 内核</code></p><h4 id="qf-源代码的组织"><span class="mr-2">QF 源代码的组织</span><a href="#qf-源代码的组织" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 源代码文件典型地每个文件<code class="language-plaintext highlighter-rouge">只包含</code>一个函数或一个数据结构的定义。这个设计是为了把 QF 当作一个<code class="language-plaintext highlighter-rouge">细粒度</code>的库来部署，你可以静态的把它和你的应用程序链接。</p><p>这个策略把负担交给<code class="language-plaintext highlighter-rouge">链接器</code>，让它去在链接时排除任何没用的代码，而不是让程序员为每个应用程序在编译时配置 QF 代码。</p><p>TODO:新版本还是这样的吗，感觉整合了不少</p><h3 id="qf-里的临界区"><span class="mr-2">QF 里的临界区</span><a href="#qf-里的临界区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>QF 和其他任何系统层软件一样，必须保护某些指令的顺序不被破坏从而担保线程安全的操作。这个必须被<code class="language-plaintext highlighter-rouge">不可分割</code>地执行的代码区被称为<code class="language-plaintext highlighter-rouge">临界区</code>。</p><p><code class="language-plaintext highlighter-rouge">嵌入式</code>系统可以在进入临界区时<code class="language-plaintext highlighter-rouge">关中断</code>，在从临界区退出时<code class="language-plaintext highlighter-rouge">解锁中断</code>。</p><p>在不允许锁中断的系统里， QF 可以采用其他的由底层<code class="language-plaintext highlighter-rouge">操作系统</code>支持的机制，比如<code class="language-plaintext highlighter-rouge">互斥体</code>（ mutex ）</p><p>QF 平台抽象层包含 了 2 个宏 QF_INT_LOCK()和 QF_INT_UNLOCK() ，分别用来<code class="language-plaintext highlighter-rouge">进入临界区</code>和<code class="language-plaintext highlighter-rouge">退出临界区</code>。</p><h4 id="保存和恢复中断状态"><span class="mr-2">保存和恢复中断状态</span><a href="#保存和恢复中断状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>一种临界区实现方式：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lock_key</span><span class="p">;</span>
  <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
  <span class="c1">// 关中断前保存当前中断状态，用于后面恢复</span>
  <span class="n">lock_key</span> <span class="o">=</span> <span class="n">get_int_status</span><span class="p">();</span>
  <span class="c1">// 关闭中断，功能由编译器提供</span>
  <span class="n">int_lock</span><span class="p">();</span>
  <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
  <span class="cm">/* critical section of code */</span>
  <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
  <span class="c1">// 恢复中断状态，相当于开中断</span>
  <span class="n">set_int_status</span><span class="p">(</span><span class="n">lock_key</span><span class="p">);</span>
  <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>用于实现这个功能的宏定义：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 这个宏用于在预编译时告诉QF框架是否使用“保存和恢复中断状态”策略(该宏定义)，</span>
<span class="c1">// 还是下一节的“无条件锁住和解锁中断”策略(该宏不定义)</span>
<span class="cp">#define QF_INT_KEY_TYPE unsigned int
#define QF_INT_LOCK(key_)          \
    do                             \
    {                              \
        (key_) = get_int_status(); \
        int_lock();                \
    } while (0)
#define QF_INT_UNLOCK(key_) set_int_status(key_)
</span></pre></table></code></div></div><blockquote class="prompt-tip"><div><p>QF_INT_LOCK()宏的 do {…} while (0) 循环是语法正确的用来<code class="language-plaintext highlighter-rouge">组合指令</code>的<code class="language-plaintext highlighter-rouge">标准做法</code>。这个宏可以被安全的用于 <code class="language-plaintext highlighter-rouge">if-else</code> 语句（在宏后加分号），而不会造成<a href="https://en.wikipedia.org/wiki/Dangling_else">“悬吊 if”（ dangling-if ）</a>问题。</p></div></blockquote><p>“保存和恢复中断状态”政策的主要优点是可以<code class="language-plaintext highlighter-rouge">嵌套临界区</code>的能力。当 QF 函数从一个已经建立的临界段比如 ISR 里调用时，且<code class="language-plaintext highlighter-rouge">部分处理器</code>在进入 ISR 后自动关中断(进临界区)，需要在 ISR 内部先解锁中断才能使用 QF 函数(详见下节例子)，如果做不到就需要使用上述的办法<code class="language-plaintext highlighter-rouge">嵌套临界区</code>。</p><blockquote><p>为什么要解锁中断才能调用 QF 函数，见下一节</p></blockquote><h4 id="无条件上锁和解锁中断"><span class="mr-2">无条件上锁和解锁中断</span><a href="#无条件上锁和解锁中断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cm">/* QF_INT_LOCK_KEY not defined */</span>
<span class="cp">#define QF_INT_LOCK(key_) int_lock()
#define QF_INT_UNLOCK(key_) int_unlock()
</span></pre></table></code></div></div><p>“无条件上锁和解锁”策略是简单和快捷的，但是<code class="language-plaintext highlighter-rouge">不允许</code>临界区的<code class="language-plaintext highlighter-rouge">嵌套</code>且需要<code class="language-plaintext highlighter-rouge">基于优先级</code>的中断控制器，理由见上节</p><p>使用一个<code class="language-plaintext highlighter-rouge">基于优先级</code>的中断控制器时一个 ISR 的常规结构：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// 这是个ISR中断处理程序</span>
<span class="c1">// 绝大多数控制器在进入 ISR 时，中断被硬件上锁。中断控制器被关闭，所有中断被关闭，不论优先级</span>
<span class="c1">// 不能嵌套临界区并不意味着你不能嵌套中断。许多处理器拥有基于优先级的中断控制器</span>
<span class="kt">void</span> <span class="n">interrupt</span> <span class="nf">ISR</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* entered with interrupts locked in hardware */</span>
    <span class="c1">// 中断控制器必须被通知要进入这个中断。这个通知常在定向（跳转）到 ISR 之前自动在硬件层发生。</span>
    <span class="n">Acknowledge</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">to</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">controller</span> <span class="p">(</span><span class="n">optional</span><span class="p">)</span>
    <span class="c1">// 如果中断源是电平触发的，你需要明确的清除它，以便触发下一次该中断。</span>
    <span class="c1">// 因为这里同优先级的中断也被关闭了，本来就不能触发，所以之后清除也没关系</span>
    <span class="n">Clear</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">source</span><span class="p">,</span> <span class="k">if</span> <span class="n">level</span> <span class="n">triggered</span>
    <span class="c1">// 如果之前被关中断了就执行开中断，使能中断控制器，由于基于优先级的中断控制器存在，</span>
    <span class="c1">// 这样高优先级的中断可以执行，更低或相同优先级的中断依旧不能执行。此时ISR内临界区结束</span>
    <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* unlock the interrupts at the processor level */</span>
    <span class="c1">// 主 ISR 代码在临界区外执行，因此 QF 可以被安全的调用而不需嵌套临界区。</span>
    <span class="n">Handle</span> <span class="n">the</span> <span class="n">interrupt</span><span class="p">,</span> <span class="n">use</span> <span class="n">QF</span> <span class="n">calls</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span> <span class="n">QF_tick</span><span class="p">(),</span> <span class="n">Q_NEW</span> <span class="n">or</span> <span class="n">QF_publish</span><span class="p">()</span>
    <span class="c1">// 中断被锁住，为中断的离开建立临界区。</span>
    <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* lock the interrupts at the processor level */</span>
    <span class="c1">// EOI (end of interrupt) 指令被发往中断控制器，停止这个中断的优先权</span>
    <span class="n">Write</span> <span class="n">End</span><span class="o">-</span><span class="n">Of</span><span class="o">-</span><span class="n">Interrupt</span> <span class="p">(</span><span class="n">EOI</span><span class="p">)</span> <span class="n">instruction</span> <span class="n">to</span> <span class="n">the</span> <span class="n">Interrupt</span> <span class="n">Controller</span>
    <span class="c1">// 由编译器提供的中断退出步骤，从堆栈恢复 CPU寄存器，包括 CPU状态寄存器。典型地这个步骤会解锁中断。</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">基于优先级</code>的中断控制器<code class="language-plaintext highlighter-rouge">记忆</code>当前所服务的中断的优先级，并仅允许比当前优先级高的中断抢占这个 ISR 。<code class="language-plaintext highlighter-rouge">较低</code>的或<code class="language-plaintext highlighter-rouge">相同</code>优先级的中断在中断控制器层次被<code class="language-plaintext highlighter-rouge">锁住</code>，<code class="language-plaintext highlighter-rouge">即使</code>这些中断在处理器层次<code class="language-plaintext highlighter-rouge">被解锁</code>。中断优先排序发生在中断控制器硬件层，直到中断控制器接受到中断结束 EOI 指令为止。所以说这个“无条件上锁和解锁中断”策略需要<code class="language-plaintext highlighter-rouge">基于优先级</code>的<code class="language-plaintext highlighter-rouge">中断控制器</code>的支持，这样即使在ISR内部开中断，也不会导致低优先级中断插进来影响ISR主体的执行</p></blockquote><blockquote><p>TODO: 开中断是为了什么？是不是为了防止执行主 ISR 代码(QF 函数)的过程太长导致临界区时间太长。还是为了主 ISR 代码执行时需要用到某些中断</p><p>解答：QF 函数执行部分<code class="language-plaintext highlighter-rouge">内部</code>有些也使用的<code class="language-plaintext highlighter-rouge">关开中断</code>创建临界区的部分，为了防止<code class="language-plaintext highlighter-rouge">中断嵌套</code>，也就是<code class="language-plaintext highlighter-rouge">外面</code>关了中断，进了函数<code class="language-plaintext highlighter-rouge">内部</code>又关一次就会造成阻塞，也就是<code class="language-plaintext highlighter-rouge">死锁</code>。</p></blockquote><h4 id="中断上锁解锁的内部-qf-宏"><span class="mr-2">中断上锁/解锁的内部 QF 宏</span><a href="#中断上锁解锁的内部-qf-宏" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 平台抽象层 (platform abstraction layer)PAL 使用中断上锁/解锁宏<code class="language-plaintext highlighter-rouge">QF_INT_LOCK()</code>， <code class="language-plaintext highlighter-rouge">QF_INT_UNLOCK()</code> ，和 <code class="language-plaintext highlighter-rouge">QF_INT_KEY_TYPE</code> 。</p><p>中断上锁 / 解锁的内部宏:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#ifndef QF_INT_KEY_TYPE </span><span class="cm">/* simple unconditional interrupt locking/unlocking */</span><span class="cp">
</span>    <span class="cp">#define QF_INT_LOCK_KEY_
</span>    <span class="cp">#define QF_INT_LOCK_() QF_INT_LOCK(ignore)
</span>    <span class="cp">#define QF_INT_UNLOCK_() QF_INT_UNLOCK(ignore)
#else </span><span class="cm">/* policy of saving and restoring interrupt status */</span><span class="cp">
</span>    <span class="cp">#define QF_INT_LOCK_KEY_ QF_INT_KEY_TYPE intLockKey_;
</span>    <span class="cp">#define QF_INT_LOCK_() QF_INT_LOCK(intLockKey_)
</span>    <span class="cp">#define QF_INT_UNLOCK_() QF_INT_UNLOCK(intLockKey_)
#endif
</span></pre></table></code></div></div><p>末尾带下划线的宏保持使用两种不同策略时的<code class="language-plaintext highlighter-rouge">一致性</code>（自动选择）</p><p>示例：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QF_service_xyz</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QF_INT_LOCK_KEY_</span>
    <span class="p">...</span>
    <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="cm">/* critical section of code */</span>
    <span class="p">...</span>
    <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="主动对象"><span class="mr-2">主动对象</span><a href="#主动对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>QF 实时框架提供了基础结构 QActive 用于派生应用程序的特定好的对象。 QActive 结合了后面三个基本要素：</p><ol><li>它是一个<code class="language-plaintext highlighter-rouge">状态机</code>（从 QHsm 或其他拥有兼容接口的类派生）<li>它是一个<code class="language-plaintext highlighter-rouge">事件队列</code><li>它有一个带有唯一优先级的<code class="language-plaintext highlighter-rouge">执行线程</code></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre><td class="rouge-code"><pre><span class="c1">// 可以自定义基础类，只要实现了状态机接口，也就是可以不用QEP框架里的QHsm</span>
<span class="cp">#ifndef QF_ACTIVE_SUPER_
</span>    <span class="c1">// 基础类默认为QEP提供的QHsm类</span>
    <span class="cp">#define QF_ACTIVE_SUPER_ QHsm
</span>    <span class="c1">// 基础类构造函数名字</span>
    <span class="cp">#define QF_ACTIVE_CTOR_(me_, initial_) QHsm_ctor((me_), (initial_))
</span>    <span class="c1">// 基础类init初始化函数的名字</span>
    <span class="cp">#define QF_ACTIVE_INIT_(me_, e_) QHsm_init((me_), (e_))
</span>    <span class="c1">// 基础类dispatch()函数的名字</span>
    <span class="cp">#define QF_ACTIVE_DISPATCH_(me_, e_) QHsm_dispatch((me_), (e_))
</span>    <span class="c1">// 基础类构造函数的参数的类型</span>
    <span class="cp">#define QF_ACTIVE_STATE_ QState
#endif
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QActiveTag</span>
<span class="p">{</span>
    <span class="c1">/// QActive 的基础类(继承)</span>
    <span class="n">QF_ACTIVE_SUPER_</span> <span class="n">super</span><span class="p">;</span> <span class="cm">/* derives from QF_ACTIVE_SUPER_ */</span>
    <span class="c1">// 事件队列，可自定义</span>
    <span class="n">QF_EQUEUE_TYPE</span> <span class="n">eQueue</span><span class="p">;</span>  <span class="cm">/* event queue of active object */</span>
    <span class="c1">// TODO:这个osObject在 #[POSIX的 QF 移植] 中会提到</span>
<span class="cp">#ifdef QF_OS_OBJECT_TYPE
</span>    <span class="n">QF_OS_OBJECT_TYPE</span> <span class="n">osObject</span><span class="p">;</span> <span class="cm">/* OS-object for blocking the queue */</span>
<span class="cp">#endif
</span>    <span class="c1">// 线程处理</span>
<span class="cp">#ifdef QF_THREAD_TYPE
</span>    <span class="n">QF_THREAD_TYPE</span> <span class="kr">thread</span><span class="p">;</span> <span class="cm">/* execution thread of the active object */</span>
<span class="cp">#endif
</span>    <span class="c1">// 每个主动对象有唯一的优先级，最大为63，0是特殊的休眠优先级，也就是最大支持63个主动对象</span>
    <span class="kt">uint8_t</span> <span class="n">prio</span><span class="p">;</span>    <span class="cm">/* QF priority of the active object */</span>
    <span class="c1">// 用于一些移植，写入0会终止活动对象</span>
    <span class="kt">uint8_t</span> <span class="n">running</span><span class="p">;</span> <span class="cm">/* flag indicating if the AO is running */</span>
<span class="p">}</span> <span class="n">QActive</span><span class="p">;</span>

<span class="c1">// 开始执行</span>
<span class="kt">void</span> <span class="nf">QActive_start</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prio</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">qSto</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">qLen</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">stkSto</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">stkSize</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">ie</span><span class="p">);</span>
<span class="c1">// FIFO方式发送到活动对象的事件队列</span>
<span class="kt">void</span> <span class="nf">QActive_postFIFO</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="c1">// LIFO方式发送到活动对象的事件队列</span>
<span class="kt">void</span> <span class="nf">QActive_postLIFO</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="c1">// 构造函数</span>
<span class="kt">void</span> <span class="nf">QActive_ctor</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QState</span> <span class="n">initial</span><span class="p">);</span>
<span class="c1">// 停止活动对象执行线程</span>
<span class="kt">void</span> <span class="nf">QActive_stop</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span>
<span class="c1">// 和事件订阅相关</span>
<span class="kt">void</span> <span class="nf">QActive_subscribe</span><span class="p">(</span><span class="n">QActive</span> <span class="k">const</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QSignal</span> <span class="n">sig</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">QActive_unsubscribe</span><span class="p">(</span><span class="n">QActive</span> <span class="k">const</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QSignal</span> <span class="n">sig</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">QActive_unsubscribeAll</span><span class="p">(</span><span class="n">QActive</span> <span class="k">const</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span>
<span class="c1">// 用于高效的（“零复制”）事件延迟和事件恢复</span>
<span class="kt">void</span> <span class="nf">QActive_defer</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEQueue</span> <span class="o">*</span><span class="n">eq</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="nf">QActive_recall</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEQueue</span> <span class="o">*</span><span class="n">eq</span><span class="p">);</span>
<span class="c1">// 从活动对象的事件队列每次移除一个事件,这个函数仅被用在 QF 内部，并且从不用于应用程序层</span>
<span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="nf">QActive_get_</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span>
</pre></table></code></div></div><p>通过把宏 <code class="language-plaintext highlighter-rouge">QF_ACTIVE_XXX_</code> 定义到你<code class="language-plaintext highlighter-rouge">自己的类</code>，你可以排除在 <code class="language-plaintext highlighter-rouge">QF</code> 框架和 <code class="language-plaintext highlighter-rouge">QEP</code> 事件处理器之间的<code class="language-plaintext highlighter-rouge">依赖性</code>。</p><p>自定义示例：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#define QF_ACTIVE_SUPER_ MyClass
#define QF_ACTIVE_CTOR_(me_, ini_) MyClass_ctor((me_), (ini_))
#define QF_ACTIVE_INIT_(me_, e_) MyClass_init((me_), (e_))
#define QF_ACTIVE_DISPATCH_(me_, e_) MyClass_dispatch((me_), (e_))
#define QF_ACTIVE_STATE_ void*
</span></pre></table></code></div></div><h4 id="活动对象的内部状态机"><span class="mr-2">活动对象的内部状态机</span><a href="#活动对象的内部状态机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>每个<code class="language-plaintext highlighter-rouge">活动对象</code>都是一个<code class="language-plaintext highlighter-rouge">状态机</code>，如飞行和射击”游戏例子里的 Ship，Missile，或 Tunnel</p><p>活动对象由 QHsm 派生，利用<code class="language-plaintext highlighter-rouge">多态</code>特性可以使用<code class="language-plaintext highlighter-rouge">QHsm指针</code>使用派生活动对象的<code class="language-plaintext highlighter-rouge">状态机函数</code>(QEP 层)，所以无论活动对象添加了多少自定义的变量，都可以当作状态机使用。</p><h4 id="活动对象的事件队列"><span class="mr-2">活动对象的事件队列</span><a href="#活动对象的事件队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 的事件队列需要“<code class="language-plaintext highlighter-rouge">多写单读</code>”的存取权限，可以从其他地方(不同线程)发送事件到活动对象，活动对象线程每次取一个使用。所以需要<code class="language-plaintext highlighter-rouge">读写互斥锁</code>和<code class="language-plaintext highlighter-rouge">写者互斥锁</code></p><p>“<code class="language-plaintext highlighter-rouge">零复制</code>“事件队列不存储实际事件，仅存储执行<code class="language-plaintext highlighter-rouge">事件实例</code>的<code class="language-plaintext highlighter-rouge">指针</code>。</p><p>可以使用操作系统提供的消息队列，尽管有点大材小用</p><h4 id="执行线程和活动对象优先级"><span class="mr-2">执行线程和活动对象优先级</span><a href="#执行线程和活动对象优先级" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>活动对象线程的步骤：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 从事件队列获取事件，没事件时可以阻塞让线程休眠。</span>
<span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">QActive_get_</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="cm">/* get the next event for AO 'a' */</span>
<span class="c1">// 利用多态使用基类函数和基类指针作为参数执行派生后的函数实现</span>
<span class="n">QF_ACTIVE_DISPATCH_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>   <span class="cm">/* dispatch to the AO 'a' */</span>
<span class="c1">// QF垃圾回收器回收无用的事件</span>
<span class="n">QF_gc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>   <span class="cm">/* determine if event 'e' is garbage and collect it if so */</span>
</pre></table></code></div></div><p>QF 应用程序需要<code class="language-plaintext highlighter-rouge">代表</code>系统里的每个活动对象调用<code class="language-plaintext highlighter-rouge">QActive_start()</code>函数(启动活动对象)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QActive_start</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span>
                   <span class="kt">uint8_t</span> <span class="n">prio</span><span class="p">,</span>                        <span class="cm">/* 唯一优先级，the unique priority */</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">qSto</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">qLen</span><span class="p">,</span> <span class="cm">/* 事件队列空间，event queue */</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">stkSto</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">stkSize</span><span class="p">,</span>      <span class="cm">/* 栈空间，per-task stack */</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">ie</span><span class="p">)</span>                    <span class="cm">/* 初始事件，the initialization event */</span>
<span class="p">{</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>         <span class="cm">/* set the QF priority */</span>
    <span class="c1">// 注册到QF</span>
    <span class="n">QF_add</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>              <span class="cm">/* make QF aware of this active object */</span>
    <span class="c1">// 执行在活动对象里的状态机的最顶初始转换,参数 ie是一个指针，指向在活动对象状态机里用于最顶初始转换的初始事件。</span>
    <span class="n">QF_ACTIVE_INIT_</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">ie</span><span class="p">);</span> <span class="cm">/* execute the initial transition */</span>
    <span class="c1">// 初始化事件队列</span>
    <span class="n">Initialize</span> <span class="n">the</span> <span class="n">event</span> <span class="n">queue</span> <span class="n">object</span> <span class="err">'</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="err">'</span> <span class="n">using</span> <span class="n">qSto</span> <span class="n">and</span> <span class="n">qLen</span>
    <span class="c1">// 创建活动对象线程</span>
    <span class="n">Create</span> <span class="n">and</span> <span class="n">start</span> <span class="n">the</span> <span class="kr">thread</span> <span class="err">'</span><span class="n">me</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="err">'</span> <span class="n">of</span> <span class="n">the</span> <span class="n">underlying</span> <span class="n">kernel</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>“<code class="language-plaintext highlighter-rouge">初始事件</code>” ie 让你有机会提供一些信息给活动对象，这个活动对象(这里原文用的<code class="language-plaintext highlighter-rouge">which</code>，是指代上一句的<code class="language-plaintext highlighter-rouge">一些信息</code>还是<code class="language-plaintext highlighter-rouge">活动对象</code>？)在后面的初始化过程才被知道（比如，在 GUI 系统里的一个窗口处理句柄）。请注意，（在 C++里）活动对象的构造函数在 main() 之前运行，这时你没有所有的信息来初始化一个活动对象的全部方面。</p></blockquote><h3 id="qf-的事件管理"><span class="mr-2">QF 的事件管理</span><a href="#qf-的事件管理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>“零复制”事件派发方案</p><ol><li>被框架管理的<code class="language-plaintext highlighter-rouge">动态</code>事件<li>其他不被 QF 管理的（<code class="language-plaintext highlighter-rouge">静态</code>分配的）事件</ol><h4 id="事件的结构"><span class="mr-2">事件的结构</span><a href="#事件的结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QEventTag</span> <span class="p">{</span> <span class="cm">/* QEvent base structure */</span>
    <span class="n">QSignal</span> <span class="n">sig</span><span class="p">;</span> <span class="cm">/* public signal of the event instance */</span>
    <span class="c1">// 动态还是静态事件</span>
    <span class="kt">uint8_t</span> <span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* attributes of a dynamic event (0 for static event) */</span>
<span class="p">}</span> <span class="n">QEvent</span><span class="p">;</span>
</pre></table></code></div></div><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qeventdyn.jpg" alt="qeventdyn" data-proofer-ignore></p><p>7,6 表示事件池 id(大、中、小、静态 0)，5-0 表示事件引用计数器，引用计数器归 0 才回收</p><h4 id="动态事件分配"><span class="mr-2">动态事件分配</span><a href="#动态事件分配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>大中小三个事件池，事件用完空间可回收</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cm">/* Package-scope objects ---------------------------------------------------*/</span>
<span class="c1">// 事件池管理信息，不包含实际空间</span>
<span class="n">QF_EPOOL_TYPE_</span> <span class="n">QF_pool_</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/* allocate 3 event pools */</span>
<span class="c1">// 实际使用的池的数量</span>
<span class="kt">uint8_t</span> <span class="n">QF_maxPool_</span><span class="p">;</span>        <span class="cm">/* number of initialized event pools */</span>
<span class="cm">/*..........................................................................*/</span>
<span class="c1">// poolSto参数才是分配的实际事件空间</span>
<span class="kt">void</span> <span class="nf">QF_poolInit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">poolSto</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">poolSize</span><span class="p">,</span> <span class="n">QEventSize</span> <span class="n">evtSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* cannot exceed the number of available memory pools */</span>
    <span class="c1">// 合法性检查</span>
    <span class="n">Q_REQUIRE</span><span class="p">(</span><span class="n">QF_maxPool_</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">Q_DIM</span><span class="p">(</span><span class="n">QF_pool_</span><span class="p">));</span>
    <span class="cm">/* please initialize event pools in ascending order of evtSize: */</span>
    <span class="n">Q_REQUIRE</span><span class="p">((</span><span class="n">QF_maxPool_</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
                <span class="p">(</span><span class="n">QF_EPOOL_EVENT_SIZE_</span><span class="p">(</span><span class="n">QF_pool_</span><span class="p">[</span><span class="n">QF_maxPool_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">evtSize</span><span class="p">));</span>
    <span class="cm">/* perfom the platform-dependent initialization of the pool */</span>
    <span class="c1">// 所有框架操作需要的内存由应用程序提供给框架。这里实际分配空间为poolSto指向的内存</span>
    <span class="c1">// 这个宏默认提供QMPool_init（就是QF原生内存池）的分配功能</span>
    <span class="n">QF_EPOOL_INIT_</span><span class="p">(</span><span class="n">QF_pool_</span><span class="p">[</span><span class="n">QF_maxPool_</span><span class="p">],</span> <span class="n">poolSto</span><span class="p">,</span> <span class="n">poolSize</span><span class="p">,</span> <span class="n">evtSize</span><span class="p">);</span>
    <span class="c1">// 变量 QF_maxPool_ 被增加，表示多个池已被初始化</span>
    <span class="o">++</span><span class="n">QF_maxPool_</span><span class="p">;</span> <span class="cm">/* one more pool */</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>所有 QP 构件，包括 QF 框架，一致地假设，在<code class="language-plaintext highlighter-rouge">系统开始</code>时，没有明确初始值的变量被<code class="language-plaintext highlighter-rouge">初始化为 0</code> ，这是 ANSI-C 标准的要求。在嵌入式系统，这个初始化步骤对应于<code class="language-plaintext highlighter-rouge">清除.BSS段</code>(用来放<code class="language-plaintext highlighter-rouge">全局变量</code>)。你应该确信在你的系统里，在 main() 被调用前 .BSS 段确实被清除了。</p></blockquote><p><em>从最小事件尺寸池分配一个事件的简单策略</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="n">QEvent</span> <span class="o">*</span><span class="nf">QF_new_</span><span class="p">(</span><span class="n">QEventSize</span> <span class="n">evtSize</span><span class="p">,</span> <span class="n">QSignal</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QEvent</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
    <span class="cm">/* find the pool id that fits the requested event size ... */</span>
    <span class="kt">uint8_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 从小到大找到合适的池</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">evtSize</span> <span class="o">&gt;</span> <span class="n">QF_EPOOL_EVENT_SIZE_</span><span class="p">(</span><span class="n">QF_pool_</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
        <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">QF_maxPool_</span><span class="p">);</span> <span class="cm">/* cannot run out of registered pools */</span>
    <span class="p">}</span>
    <span class="c1">// 从池中获取e（分配空间）</span>
    <span class="n">QF_EPOOL_GET_</span><span class="p">(</span><span class="n">QF_pool_</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* get e -- platform-dependent */</span>
    <span class="c1">// 断言池未枯竭</span>
    <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>      <span class="cm">/* pool must not run out of events */</span>
    <span class="c1">// 设置信号</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>                    <span class="cm">/* set signal for this event */</span>
    <span class="cm">/* store the dynamic attributes of the event:
     * the pool ID and the reference counter == 0
     */</span>
    <span class="c1">// 设置池标记(高两位)</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="自动垃圾收集"><span class="mr-2">自动垃圾收集</span><a href="#自动垃圾收集" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>动态事件的引用计数器被存储在事件属性 dynamic_的<code class="language-plaintext highlighter-rouge">低 6 位</code> LSB 里，发送事件时递增，<code class="language-plaintext highlighter-rouge">归 0</code> 由 QF 自动检测<code class="language-plaintext highlighter-rouge">回收</code></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QF_gc</span><span class="p">(</span><span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 判断是否动态事件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* is it a dynamic event? */</span>
        <span class="n">QF_INT_LOCK_KEY_</span>
        <span class="c1">// 中断上锁,操作引用计数器需要临界区</span>
        <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>                              <span class="cm">/* isn't this the last reference? */</span>
            <span class="c1">// 大于1，递减</span>
            <span class="o">--</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* decrement the reference counter */</span>
            <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span> <span class="cm">/* this is the last reference to this event, recycle it */</span>
            <span class="c1">// 小于1，回收，先从高2位获取index索引，找到对应池，然后归还空间</span>
            <span class="kt">uint8_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
            <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">QF_maxPool_</span><span class="p">);</span> <span class="cm">/* index must be in range */</span>
            <span class="n">QF_EPOOL_PUT_</span><span class="p">(</span><span class="n">QF_pool_</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="延迟和恢复事件"><span class="mr-2">延迟和恢复事件</span><a href="#延迟和恢复事件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 分别通过 QActive 的类函数 QActive_defer() 和 QActive_recall() 实现明确的事件延迟和恢复。见<a href="#延迟的事件">延迟的事件</a></p><p>当事件在某个特别<code class="language-plaintext highlighter-rouge">不方便的时刻</code>到达时，可以被<code class="language-plaintext highlighter-rouge">延迟</code>一些时间直到系统有一个比较好的状态去处理这个事件，事件的延迟是很方便的</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QActive_defer</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEQueue</span> <span class="o">*</span><span class="n">eq</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">me</span><span class="p">;</span>                <span class="cm">/* avoid compiler warning about 'me' not used */</span>
    <span class="c1">// 发送给等待队列，这里计数器会被加1，防止被回收</span>
    <span class="c1">// 因为事件被处理后即使不执行操作放入等待队列，计数器也会被减1</span>
    <span class="n">QEQueue_postFIFO</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* increments ref-count of a dynamic event */</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="nf">QActive_recall</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEQueue</span> <span class="o">*</span><span class="n">eq</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 从等待队列取一个事件</span>
    <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">QEQueue_get</span><span class="p">(</span><span class="n">eq</span><span class="p">);</span> <span class="cm">/* get an event from deferred queue */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* event available? */</span>
        <span class="n">QF_INT_LOCK_KEY_</span>
        <span class="c1">// 发送到事件队列，用LIFO插队到第一个，引用计数器会被加1</span>
        <span class="n">QActive_postLIFO</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* post it to the front of the AO's queue */</span>
        <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span> <span class="cm">/* is it a dynamic event? */</span>
            <span class="n">Q_ASSERT</span><span class="p">((</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="c1">// 从等待队列里拿出来了，引用计数器要减1(事件队列里的处理后会自动减)</span>
            <span class="o">--</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* decrement the reference counter */</span>
        <span class="p">}</span>
        <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">;</span> <span class="cm">/*pass the recalled event to the caller (NULL if not recalled) */</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="qf-的事件派发机制"><span class="mr-2">QF 的事件派发机制</span><a href="#qf-的事件派发机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>QF 仅支持异步事件交换，发送者不等待事件处理</p><p>派发机制：</p><ul><li><strong>直接事件发送的简单机制</strong> – 一个事件的生产者直接发送这个事件给消费者活动对象的事件队列。<li><strong>订阅事件发送机制</strong> – 事件的生产者把事件发行给框架，框架然后把事件发行给所有订阅了这个事件的活动对象。</ul><h4 id="直接事件发送-1"><span class="mr-2">直接事件发送</span><a href="#直接事件发送-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 通过 <code class="language-plaintext highlighter-rouge">QActive_postFIFO()</code> 和 <code class="language-plaintext highlighter-rouge">QActive_postLIFO()</code> 函数支持直接事件发送</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">QActive_postFIFO</span><span class="p">(</span><span class="n">AO_ship</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">);</span> <span class="cm">/* post event 'e' to the Ship AO */</span>
</pre></table></code></div></div><p>这里参数 <code class="language-plaintext highlighter-rouge">AO_ship</code> 是 <code class="language-plaintext highlighter-rouge">QActive</code> 基类类型，利用了多态</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="n">QActive</span> <span class="o">*</span> <span class="k">const</span> <span class="n">AO_Ship</span><span class="p">;</span> <span class="cm">/* opaque pointer to the Ship AO */</span>
</pre></table></code></div></div><h4 id="发行-订阅事件发送"><span class="mr-2">发行-订阅事件发送</span><a href="#发行-订阅事件发送" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>初始化<code class="language-plaintext highlighter-rouge">发行-订阅</code>机制: QF_psInit()<li>订阅：QActive_subscribe(), QActive_unsubscribe(), QActive_unsubscribeAll()<li>发行：QF_publish()</ul><p><em>管理订阅信息的数据结构</em>：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QSubscrListTag</span> <span class="p">{</span>
    <span class="c1">// QF_MAX_ACTIVE - 1表示需要的位数</span>
    <span class="c1">// 除以8向上取整，表示需要的字节数</span>
    <span class="kt">uint8_t</span> <span class="n">bits</span><span class="p">[((</span><span class="n">QF_MAX_ACTIVE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">QSubscrList</span><span class="p">;</span>
</pre></table></code></div></div><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/subscriberbitmap.jpg" alt="subscriberbitmap" data-proofer-ignore></p><p>每类信号为一行，每行中的每一位对应一个主动对象，因为优先级和主动对象一一对应，所以通过优先级(1-63)对应位唯一标识，置位表示该事件被对应的主动对象订阅。如图中 bit15 对应优先级 16 的主动对象。</p><p>上图例子中每行 bit 为 64 个(目前 QF_MAX_ACTIVE 的范围是 1 到 63)，这也是<a href="#主动对象">主动对象</a>提到的优先级上限为 63 的原因</p><ul><li><p>初始化</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">QSubscrList</span> <span class="o">*</span><span class="n">QF_subscrList_</span><span class="p">;</span> <span class="cm">/* initialized to zero per C-standard */</span>
<span class="n">QSignal</span> <span class="n">QF_maxSignal_</span><span class="p">;</span>
<span class="cm">/* initialized to zero per C-standard */</span>
<span class="kt">void</span> <span class="nf">QF_psInit</span><span class="p">(</span><span class="n">QSubscrList</span> <span class="o">*</span><span class="n">subscrSto</span><span class="p">,</span> <span class="n">QSignal</span> <span class="n">maxSignal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QF_subscrList_</span> <span class="o">=</span> <span class="n">subscrSto</span><span class="p">;</span>
    <span class="n">QF_maxSignal_</span> <span class="o">=</span> <span class="n">maxSignal</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>订阅</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// me: 本对象，sig：要订阅的信号</span>
<span class="kt">void</span> <span class="nf">QActive_subscribe</span><span class="p">(</span><span class="n">QActive</span> <span class="k">const</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QSignal</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>

    <span class="kt">uint8_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
    <span class="c1">// 字节索引，QF_div8Lkup[p] = (p – 1)/8，</span>
    <span class="c1">// 可以每次算也可以用预生成在ROM的查找表</span>
    <span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Q_ROM_BYTE</span><span class="p">(</span><span class="n">QF_div8Lkup</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>
    <span class="n">QF_INT_LOCK_KEY_</span>
    <span class="n">Q_REQUIRE</span><span class="p">(((</span><span class="n">QSignal</span><span class="p">)</span><span class="n">Q_USER_SIG</span> <span class="o">&lt;=</span> <span class="n">sig</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sig</span> <span class="o">&lt;</span> <span class="n">QF_maxSignal_</span><span class="p">)</span>
                <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span>
                <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">QF_MAX_ACTIVE</span><span class="p">)</span>
                <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">==</span> <span class="n">me</span><span class="p">));</span>
    <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
    <span class="c1">// 找到字节内偏移，QF_pwr2Lkup[p] = 1 &lt;&lt; ((p – 1) % 8)，</span>
    <span class="c1">// 可以每次算也可以用预生成在ROM的查找表</span>
    <span class="n">QF_subscrList_</span><span class="p">[</span><span class="n">sig</span><span class="p">].</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">Q_ROM_BYTE</span><span class="p">(</span><span class="n">QF_pwr2Lkup</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>
    <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>发行</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="c1">// 给所有订阅者发行一个给定事件 e</span>
<span class="kt">void</span> <span class="nf">QF_publish</span><span class="p">(</span><span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QF_INT_LOCK_KEY_</span>
    <span class="cm">/* make sure that the published signal is within the configured range */</span>
    <span class="n">Q_REQUIRE</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span> <span class="o">&lt;</span> <span class="n">QF_maxSignal_</span><span class="p">);</span>
    <span class="c1">// 读取加修改，典型的临界区</span>
    <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* is it a dynamic event? */</span>
      <span class="c1">// e-&gt;dynamic_为0说明是高2位也是0，就是静态事件</span>
        <span class="cm">/*lint -e1773 Attempt to cast away const */</span>
        <span class="c1">// 增加一次引用计数器，防止刚发送给一个活动对象事件立刻被处理了的情况下，</span>
        <span class="c1">// 引用计数器直接归0，事件被回收，无法给其他活动对象发事件</span>
        <span class="c1">// QF_publish执行到最后给所有订阅的活动对象发完，应该要减1</span>
        <span class="o">++</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* increment reference counter, NOTE01 */</span>
    <span class="p">}</span>
    <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
<span class="cp">#if (QF_MAX_ACTIVE &lt;= 8)
</span>    <span class="p">{</span> <span class="c1">// 只有一个字节</span>
        <span class="c1">// 赋给临时变量，后面能随便修改</span>
        <span class="kt">uint8_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">QF_subscrList_</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">].</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span> <span class="c1">// 不为0表示有订阅</span>
            <span class="c1">// 找最高优先级的活动对象，也就是从高到低第一个为1的位，</span>
            <span class="c1">// 以 2 为底的对数查找快捷的确定在bitmask的MSB位</span>
            <span class="kt">uint8_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Q_ROM_BYTE</span><span class="p">(</span><span class="n">QF_log2Lkup</span><span class="p">[</span><span class="n">tmp</span><span class="p">]);</span>
            <span class="c1">// 清掉该位</span>
            <span class="n">tmp</span> <span class="o">&amp;=</span> <span class="n">Q_ROM_BYTE</span><span class="p">(</span><span class="n">QF_invPwr2Lkup</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>    <span class="cm">/* clear subscriber bit */</span>
            <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* must be registered */</span>
            <span class="cm">/* internally asserts if the queue overflows */</span>
            <span class="c1">// 向对应活动对象发送</span>
            <span class="n">QActive_postFIFO</span><span class="p">(</span><span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#else
</span>
    <span class="p">{</span>
        <span class="c1">// Q_DIM获取字节数sizeof(array_) / sizeof((array_)[0U]</span>
        <span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">QF_subscrList_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bits</span><span class="p">);</span>
        <span class="k">do</span>
        <span class="p">{</span> <span class="cm">/* go through all bytes in the subscription list */</span>
          <span class="c1">// 遍历该事件信号对应的订阅清单里的所有字节</span>
            <span class="kt">uint8_t</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="c1">// 从高到低遍历</span>
            <span class="o">--</span><span class="n">i</span><span class="p">;</span>
            <span class="c1">// 这里开始和上面单字节的一样了</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">QF_subscrList_</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">].</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">uint8_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Q_ROM_BYTE</span><span class="p">(</span><span class="n">QF_log2Lkup</span><span class="p">[</span><span class="n">tmp</span><span class="p">]);</span>
                <span class="n">tmp</span> <span class="o">&amp;=</span> <span class="n">Q_ROM_BYTE</span><span class="p">(</span><span class="n">QF_invPwr2Lkup</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>    <span class="cm">/*clear subscriber bit */</span>
                <span class="c1">// 这里和上面不一样，要移位一下</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>             <span class="cm">/* adjust the priority */</span>
                <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/*must be registered*/</span>
                <span class="cm">/* internally asserts if the queue overflows */</span>
                <span class="n">QActive_postFIFO</span><span class="p">(</span><span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">e</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif
</span>    <span class="c1">// 执行一次垃圾回收，将引用计数器减1，这里就是对应开头那里的增加1</span>
    <span class="n">QF_gc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="cm">/* run the garbage collector, see NOTE01 */</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>为什么加锁，见<a href="/posts/operating-systems-22/#比较并交换">比较并交换</a></p></blockquote><p>二进制算法查找表 <code class="language-plaintext highlighter-rouge">QF_log2Lkup[]</code> 映射<code class="language-plaintext highlighter-rouge">字节值</code>到 MSB 的 bit<code class="language-plaintext highlighter-rouge">数字</code> (找一个字节里的<code class="language-plaintext highlighter-rouge">最高有效位</code>所在的位置 1-8，可以通过表一一对应)：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/log2Lkup.jpg" alt="log2Lkup" data-proofer-ignore></p><blockquote class="prompt-warning"><div><p>注意：横坐标有部分缩放，是不等距的</p></div></blockquote><p>如果不用这个表，<code class="language-plaintext highlighter-rouge">运行时</code>用$log_2(x)$算也可以，这会造成重复计算开销，嵌入式系统可以使用这种预配置的表，缺点是<code class="language-plaintext highlighter-rouge">占用空间</code>，比如这个表是 256 个单字节数组，占用 256 Bytes</p></ul><h3 id="时间管理-1"><span class="mr-2">时间管理</span><a href="#时间管理-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>时间事件只能是<code class="language-plaintext highlighter-rouge">静态</code>的</p><p>一个时间事件在实例化时（在<code class="language-plaintext highlighter-rouge">构造</code>函数里）必须被分配一个<code class="language-plaintext highlighter-rouge">信号</code>，这个信号在后面<code class="language-plaintext highlighter-rouge">不能被改变</code>。后一个约束防止了时间事件在还被某个事件队列持有时，被意外的改变。</p><h4 id="时间事件结构和接口"><span class="mr-2">时间事件结构和接口</span><a href="#时间事件结构和接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QTimeEvtTag</span>
<span class="p">{</span>
    <span class="c1">// 从QEvent派生</span>
    <span class="n">QEvent</span> <span class="n">super</span><span class="p">;</span>             <span class="cm">/* derives from QEvent */</span>
    <span class="c1">// 双向链表前后指针</span>
    <span class="k">struct</span> <span class="n">QTimeEvtTag</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="cm">/* link to the previous time event in the list */</span>
    <span class="k">struct</span> <span class="n">QTimeEvtTag</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="cm">/* link to the next time event in the list */</span>
    <span class="c1">// 存储了时间事件的接收者(其他类型的事件好像没有派生这个变量)</span>
    <span class="n">QActive</span> <span class="o">*</span><span class="n">act</span><span class="p">;</span>             <span class="cm">/* the active object that receives the time event */</span>
    <span class="c1">// 每个tick（调用QF_tick()）递减，直到0发送事件</span>
    <span class="n">QTimeEvtCtr</span> <span class="n">ctr</span><span class="p">;</span>          <span class="cm">/* the internal down-counter of the time event */</span>
    <span class="c1">// 周期性时间事件的间隔，单次为0</span>
    <span class="n">QTimeEvtCtr</span> <span class="n">interval</span><span class="p">;</span>     <span class="cm">/* the interval for the periodic time event */</span>
<span class="p">}</span> <span class="n">QTimeEvt</span><span class="p">;</span>
<span class="c1">// 构造函数，里面会给事件一个信号，该事件可重用但不应修改它的信号</span>
<span class="c1">// 因为改了以后会导致原来接收这个事件的活动对象无法使用该事件</span>
<span class="kt">void</span> <span class="nf">QTimeEvt_ctor</span><span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QSignal</span> <span class="n">sig</span><span class="p">);</span>
<span class="c1">// 为什么用do{...}while (0)之前提到过了，为了在宏里安全包裹多步操作</span>
<span class="c1">// 设置定时器，用于一次性时间事件</span>
<span class="cp">#define QTimeEvt_postIn(me_, act_, nTicks_)      \
    do                                           \
    {                                            \
        (me_)-&gt;interval = (QTimeEvtCtr)0;        \
        QTimeEvt_arm_((me_), (act_), (nTicks_)); \
    } while (0)
</span><span class="c1">// 设置定时器，周期性时间事件</span>
<span class="cp">#define QTimeEvt_postEvery(me_, act_, nTicks_)   \
    do                                           \
    {                                            \
        (me_)-&gt;interval = (nTicks_);             \
        QTimeEvt_arm_((me_), (act_), (nTicks_)); \
    } while (0)
</span><span class="c1">// 解除定时器</span>
<span class="kt">uint8_t</span> <span class="nf">QTimeEvt_disarm</span><span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="n">me</span><span class="p">);</span>
<span class="c1">// 重设定时器</span>
<span class="kt">uint8_t</span> <span class="nf">QTimeEvt_rearm</span><span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QTimeEvtCtr</span> <span class="n">nTicks</span><span class="p">);</span>
<span class="cm">/* private helper function */</span>
<span class="c1">// 把时间事件插入已设定的定时器的链接表内</span>
<span class="kt">void</span> <span class="nf">QTimeEvt_arm_</span><span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QActive</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span> <span class="n">QTimeEvtCtr</span> <span class="n">nTicks</span><span class="p">);</span>
</pre></table></code></div></div><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/timeevtlist.jpg" alt="timeevtlist" data-proofer-ignore></p><p>已被设定的时间事件放于链表中，已解除的不在链表中</p><h4 id="系统时钟节拍和-qf_tick-函数"><span class="mr-2">系统时钟节拍和 QF_tick() 函数</span><a href="#系统时钟节拍和-qf_tick-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 需要获取节拍管理时间事件，一般就是在 <code class="language-plaintext highlighter-rouge">ISR</code> 中调用自己的 <code class="language-plaintext highlighter-rouge">QF_tick()</code></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QF_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* see NOTE01 */</span>
  <span class="n">QTimeEvt</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="c1">// 从链表头开始</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">QF_timeEvtListHead_</span><span class="p">;</span> <span class="cm">/* start scanning the list from the head */</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span><span class="c1">//t = t-&gt;next;遍历</span>
    <span class="c1">// 每次调用减1</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ctr</span> <span class="o">==</span> <span class="p">(</span><span class="n">QTimeEvtCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* is time evt about to expire? */</span>
      <span class="c1">// 到达倒计时</span>
      <span class="c1">// 判断是否是周期性事件</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QTimeEvtCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>                       <span class="cm">/* is it periodic timeout? */</span>
        <span class="n">t</span><span class="o">-&gt;</span><span class="n">ctr</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">;</span> <span class="cm">/* rearm the time event */</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="c1">// 不是周期性事件</span>
      <span class="p">{</span> <span class="cm">/* one-shot timeout, disarm by removing it from the list */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">QF_timeEvtListHead_</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// 当前指针是头指针时，头指针直接指向next，即使next是空也没关系</span>
          <span class="n">QF_timeEvtListHead_</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="c1">// 把定时器对象节点从链表中删除</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
          <span class="p">{</span> <span class="cm">/* not the last event? */</span>
            <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">t</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 标记该节点为未使用状态</span>
        <span class="n">t</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* mark the event disarmed */</span>
      <span class="p">}</span>
      <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span> <span class="cm">/* unlock interrupts before calling QF service */</span>
      <span class="cm">/* postFIFO() asserts internally that the event was accepted */</span>
      <span class="c1">// 发送事件</span>
      <span class="n">QActive_postFIFO</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">act</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">static</span> <span class="kt">uint8_t</span> <span class="k">volatile</span> <span class="n">dummy</span><span class="p">;</span>
      <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
      <span class="c1">// 在许多 CPU 里，中断解锁仅在下个机器指令后才生效,</span>
      <span class="c1">// 对 dummy 变量的赋值需要几个机器指令，这是编译器没办法优化掉的。这确保中断被实际解锁</span>
      <span class="c1">// 防止QF_INT_UNLOCK_和下一个QF_INT_LOCK_挨在一起，CPU要等一段时间才能重新上锁</span>
      <span class="n">dummy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* execute a few instructions, see NOTE02 */</span>
    <span class="p">}</span>
    <span class="c1">// 为了下一次循环上锁</span>
    <span class="n">QF_INT_LOCK_</span><span class="p">();</span> <span class="cm">/* lock interrupts again to advance the link */</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="arming-和-disarm-一个时间事件"><span class="mr-2">arming 和 disarm 一个时间事件</span><a href="#arming-和-disarm-一个时间事件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">QTimeEvt_arm_()</code>用于把<code class="language-plaintext highlighter-rouge">时间事件</code>插入已设定的定时器的<code class="language-plaintext highlighter-rouge">链接</code>表内</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QTimeEvt_arm_</span><span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QActive</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span> <span class="n">QTimeEvtCtr</span> <span class="n">nTicks</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">Q_REQUIRE</span><span class="p">((</span><span class="n">nTicks</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">QTimeEvtCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>                       <span class="cm">/* cannot arm a timer with 0 ticks */</span>
            <span class="o">&amp;&amp;</span> <span class="p">(((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sig</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">QSignal</span><span class="p">)</span><span class="n">Q_USER_SIG</span><span class="p">)</span> <span class="cm">/*valid signal */</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>                  <span class="cm">/* time evt must NOT be used */</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">act</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">));</span>                      <span class="cm">/* active object must be provided */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">ctr</span> <span class="o">=</span> <span class="n">nTicks</span><span class="p">;</span>
  <span class="c1">// Q_REQUIRE判断了me-&gt;prev == (QTimeEvt *)0，表示该节点未使用，</span>
  <span class="c1">// 所以这里赋值一下（不是0就行，这里指向了自己），表示该节点对应的计时器已启用</span>
  <span class="c1">// 后面会利用这个值判断该节点是否</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span> <span class="cm">/* mark the timer in use */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">act</span> <span class="o">=</span> <span class="n">act</span><span class="p">;</span>

  <span class="c1">// 对链表的操作要加锁</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="c1">// 放到链表头部</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">QF_timeEvtListHead_</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QF_timeEvtListHead_</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">QF_timeEvtListHead_</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">QF_timeEvtListHead_</span> <span class="o">=</span> <span class="n">me</span><span class="p">;</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>QTimeEvt_disarm()用于<code class="language-plaintext highlighter-rouge">关闭</code>已经设定的<code class="language-plaintext highlighter-rouge">定时器</code>：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kt">uint8_t</span> <span class="nf">QTimeEvt_disarm</span><span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">wasArmed</span><span class="p">;</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* is the time event actually armed? */</span>
    <span class="c1">// prev指针不为0表示已经被插入定时器链表了，但事件还没被发出去</span>
    <span class="c1">// 返回1向调用者保证， 这个时间事件还没有被发送也不会被发送，仅对单次定时器有效，</span>
    <span class="c1">// 因为多次的话即使事件发出去了，节点也还在链表内</span>
    <span class="n">wasArmed</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 从链表里删除</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">me</span> <span class="o">==</span> <span class="n">QF_timeEvtListHead_</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">QF_timeEvtListHead_</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* not the last in the list? */</span>
        <span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 设定为未使用</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">QTimeEvt</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* mark the time event as disarmed */</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span> <span class="cm">/* the time event was not armed */</span>
    <span class="c1">// 定时器未启用，可能是从未启用，也有可能是事件已经发出去后被关闭了</span>
    <span class="n">wasArmed</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">wasArmed</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/oneshottimeevent.jpg" alt="oneshottimeevent" data-proofer-ignore></p><p>当状态机处于 A 状态时设置了一个定时事件，但在定时器生效前发生了状态切换到 B（图中触发的 BUTTON_PRESS 事件），此时 A 设定的定时事件还存在，QF 框架还会给当前状态机发事件，当 B 收到该事件后用<code class="language-plaintext highlighter-rouge">自己的处理方式</code>处理，就会有问题，因为这个是状态 A 设定的，B 没设定过，不同状态的对<code class="language-plaintext highlighter-rouge">同一信号</code>的处理是<code class="language-plaintext highlighter-rouge">不同</code>的。</p><p>这时需要 A 在退出前<code class="language-plaintext highlighter-rouge">关闭定时器</code>（利用在 exit()中执行 QTimeEvt_disarm()），且用一个<code class="language-plaintext highlighter-rouge">全局变量</code>通知其他状态不要用已经在事件队列里的属于状态 A 的定时事件</p><h3 id="原生-qf-事件队列"><span class="mr-2">原生 QF 事件队列</span><a href="#原生-qf-事件队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>使用 QEQueue 数据结构管理，有两种类型：</p><ul><li><p>第一个变体是特别为活动对象设计和优化的事件队列</p><p>原生 QF 事件队列放弃的功能：</p><ul><li>比如可变尺寸的消息（原生 QF 事件队列是固定<code class="language-plaintext highlighter-rouge">等长</code>的，仅存储指向事件的指针）<li>阻塞在一个满队列（原生 QF 事件队列在<code class="language-plaintext highlighter-rouge">插入</code>时不能被阻塞，即使队列已满，不能处理满的情况）<li>定时阻塞在空队列（原生 QF 事件队列永远阻塞在空队列，意味着该线程不会在超时后去做其他事情）</ul><li><p>另一个更简单的 QF 事件队列的变体，是一个通用的“原始的”<code class="language-plaintext highlighter-rouge">线程安全</code>的<code class="language-plaintext highlighter-rouge">不能阻塞</code>的队列</p></ul><h4 id="qequeue-结构"><span class="mr-2">QEQueue 结构</span><a href="#qequeue-结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qequeuering.jpg" alt="qequeuering" data-proofer-ignore></p><blockquote><p>这个图片好像画错了</p></blockquote><p>QEQueue 环形队列里存放的是<code class="language-plaintext highlighter-rouge">事件指针</code>(QEvent*)，在 32 位机里就是<code class="language-plaintext highlighter-rouge">等长</code>的 4 个字节，指向事件实例</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="cp">#ifndef QF_EQUEUE_CTR_SIZE
</span>    <span class="cp">#define QF_EQUEUE_CTR_SIZE 1
#endif
#if (QF_EQUEUE_CTR_SIZE == 1)
</span>    <span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="n">QEQueueCtr</span><span class="p">;</span>
<span class="cp">#elif (QF_EQUEUE_CTR_SIZE == 2)
</span>    <span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">QEQueueCtr</span><span class="p">;</span>
<span class="cp">#elif (QF_EQUEUE_CTR_SIZE == 4)
</span>    <span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">QEQueueCtr</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="cp">#error "QF_EQUEUE_CTR_SIZE defined incorrectly, expected 1, 2, or 4"
#endif
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QEQueueTag</span>
<span class="p">{</span>
    <span class="c1">// 该值和tail位置的值相同，指向下一个要被使用的事件，frontEvt为空表示队列为空队列</span>
    <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">frontEvt</span><span class="p">;</span> <span class="cm">/* pointer to event at the front of the queue */</span>
    <span class="c1">// 环形队列起始位置指针</span>
    <span class="n">QEvent</span> <span class="k">const</span> <span class="o">**</span><span class="n">ring</span><span class="p">;</span>    <span class="cm">/* pointer to the start of the ring buffer */</span>
    <span class="c1">// 环形队列结束偏移</span>
    <span class="n">QEQueueCtr</span> <span class="n">end</span><span class="p">;</span>         <span class="cm">/* offset of the end of the ring buffer from the start */</span>
    <span class="c1">// 事件队列头(入队位置，FIFO)</span>
    <span class="n">QEQueueCtr</span> <span class="n">head</span><span class="p">;</span>        <span class="cm">/* offset to where next event will be inserted */</span>
    <span class="c1">// 事件队列尾(出队位置；入队位置，LIFO)</span>
    <span class="n">QEQueueCtr</span> <span class="n">tail</span><span class="p">;</span>        <span class="cm">/* offset of where next event will be extracted */</span>
    <span class="c1">// 环形队列空闲数量</span>
    <span class="n">QEQueueCtr</span> <span class="n">nFree</span><span class="p">;</span>       <span class="cm">/* number of free events in the ring buffer */</span>
    <span class="c1">// 最小空闲事件数，跟踪队列使用的最差情况，用于微调环形缓存的尺寸</span>
    <span class="n">QEQueueCtr</span> <span class="n">nMin</span><span class="p">;</span>        <span class="cm">/* minimum number of free events ever in the buffer */</span>
<span class="p">}</span> <span class="n">QEQueue</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="qequeue-的初始化"><span class="mr-2">QEQueue 的初始化</span><a href="#qequeue-的初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// 参数qSto为预分配空间</span>
<span class="kt">void</span> <span class="nf">QEQueue_init</span><span class="p">(</span><span class="n">QEQueue</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">qSto</span><span class="p">[],</span> <span class="n">QEQueueCtr</span> <span class="n">qLen</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">frontEvt</span> <span class="o">=</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* no events in the queue */</span>
  <span class="c1">// 取指针数组的地址</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qSto</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">qLen</span><span class="p">;</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">=</span> <span class="n">qLen</span><span class="p">;</span> <span class="cm">/* all events are free */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">nMin</span> <span class="o">=</span> <span class="n">qLen</span><span class="p">;</span>  <span class="cm">/* the minimum so far */</span>
<span class="p">}</span>
</pre></table></code></div></div><p>qSto==NULL 和 qLen=0 将队列设置为仅 1 个容量，因为 fromtEvt 也算一个</p><h4 id="原生-qf-活动对象队列"><span class="mr-2">原生 QF 活动对象队列</span><a href="#原生-qf-活动对象队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>活动对象事件队列的接口包含 3 个函数： <code class="language-plaintext highlighter-rouge">QActive_postFIFO()</code>，<code class="language-plaintext highlighter-rouge">QActive_postLIFO()</code>和 <code class="language-plaintext highlighter-rouge">QActive_get_()</code></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// 返回一个指向静态QEvent的指针</span>
<span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="nf">QActive_get_</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="c1">// 阻塞直到队列不为空（视实现而定，非抢占式的可能不阻塞）</span>
  <span class="n">QACTIVE_EQUEUE_WAIT_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* wait for event queue to get an event */</span>
  <span class="c1">// 取frontEvt的值，而不是找ring内的tail</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">frontEvt</span><span class="p">;</span>
  <span class="c1">// end初始化赋值为qLen，可以表示ring总长，这里判断是否全空</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nFree</span> <span class="o">!=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* any events in the buffer? */</span>
    <span class="cm">/* remove event from the tail */</span>
    <span class="c1">// 从tail取到frontEvt</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">frontEvt</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">tail</span><span class="p">];</span>
    <span class="c1">// index为0表示绕尾</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">tail</span> <span class="o">==</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>                                   <span class="cm">/* need to wrap the tail? */</span>
      <span class="c1">// 绕尾就要把值从0直接变成尾部的qLen，然后减1就是绕尾后的index</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">end</span><span class="p">;</span> <span class="cm">/* wrap around */</span>
    <span class="p">}</span>
    <span class="c1">// 从tail取出，tail递减</span>
    <span class="o">--</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
    <span class="c1">// 空闲数增加</span>
    <span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nFree</span><span class="p">;</span> <span class="cm">/* one more free event in the ring buffer */</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="c1">// 如果全空</span>
  <span class="p">{</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">frontEvt</span> <span class="o">=</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* queue becomes empty */</span>
    <span class="c1">// 队列为空信号</span>
    <span class="n">QACTIVE_EQUEUE_ONEMPTY_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QActive_postFIFO</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>                            <span class="cm">/* is it a dynamic event? */</span>
    <span class="o">++</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* increment the reference counter */</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">frontEvt</span> <span class="o">==</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 为空</span>
  <span class="p">{</span>                             <span class="cm">/* empty queue? */</span>
    <span class="c1">// 如果为空就直接赋值给frontEvt，不需要插入head再赋值给frontEvt</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">frontEvt</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>    <span class="cm">/* deliver event directly */</span>
    <span class="c1">// 队列非空信号，给QActive_get_()的QACTIVE_EQUEUE_WAIT_()</span>
    <span class="n">QACTIVE_EQUEUE_SIGNAL_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* signal the event queue */</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="c1">// 不为空</span>
  <span class="p">{</span> <span class="cm">/* queue is not empty, insert event into the ring-buffer */</span>
    <span class="cm">/* the queue must be able to accept the event (cannot overflow) */</span>
    <span class="c1">// 事件队列不能满，满的情况不能处理，用断言退出</span>
    <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nFree</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="cm">/* insert event into the ring buffer (FIFO) */</span>
    <span class="c1">// head位置插入</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
    <span class="c1">// 绕尾</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">head</span> <span class="o">==</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>                                   <span class="cm">/* need to wrap the head? */</span>
      <span class="c1">// 绕尾就要把值从0直接变成尾部的qLen，然后减1就是绕尾后的index</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">end</span><span class="p">;</span> <span class="cm">/* wrap around */</span>
    <span class="p">}</span>
    <span class="c1">// 递减head</span>
    <span class="o">--</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
    <span class="c1">// 递减free</span>
    <span class="o">--</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nFree</span><span class="p">;</span> <span class="cm">/* update number of free events */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nMin</span> <span class="o">&gt;</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nFree</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// nFree更小时，更新nMin</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nMin</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">nFree</span><span class="p">;</span> <span class="cm">/* update min so far */</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="-原始的线程安全的队列"><span class="mr-2">“ 原始的”线程安全的队列</span><a href="#-原始的线程安全的队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="cm">/* Application header file -----------------------------------------------*/</span>
<span class="cp">#include</span> <span class="cpf">"qequeue.h"</span><span class="cp">
</span><span class="k">extern</span> <span class="n">QEQueue</span> <span class="n">APP_isrQueue</span><span class="p">;</span> <span class="cm">/* global “raw” queue */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">IsrEvtTag</span>
<span class="p">{</span> <span class="cm">/* event with parameters to be passed to the ISR */</span>
  <span class="n">QEvent</span> <span class="n">super</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="n">IsrEvt</span><span class="p">;</span>
<span class="cm">/* ISR module ------------------------------------------------------------*/</span>
<span class="n">QEQueue</span> <span class="n">APP_isrQueue</span><span class="p">;</span> <span class="cm">/* definition of the “raw” queue */</span>
<span class="c1">// 自定义ISR中断处理程序</span>
<span class="kt">void</span> <span class="n">interrupt</span> <span class="nf">myISR</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
  <span class="c1">// 取一个事件，这里的QEQueue_get()即使队列为空也不阻塞</span>
  <span class="p">...</span> <span class="n">e</span> <span class="o">=</span> <span class="n">QEQueue_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">APP_isrQueue</span><span class="p">);</span> <span class="cm">/* get an event from the “raw” queue */</span>
  <span class="cm">/* event available? */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span><span class="c1">// 执行事件</span>
    <span class="n">Process</span> <span class="n">the</span> <span class="n">event</span> <span class="n">e</span><span class="p">(</span><span class="n">could</span> <span class="n">be</span> <span class="n">dispatching</span> <span class="n">to</span> <span class="n">a</span> <span class="n">state</span> <span class="n">machine</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="c1">// 因为是ISR管理事件，不是QF框架，要记得回收空间</span>
    <span class="n">QF_gc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="cm">/* explicitly recycle the event */</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="cm">/* Active object module --------------------------------------------------*/</span>
<span class="n">QState</span> <span class="nf">MyAO_stateB</span><span class="p">(</span><span class="n">MyAO</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">case</span> <span class="n">SOMETHING_INTERESTING_SIG</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="n">IsrEvt</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="n">Q_NEW</span><span class="p">(</span><span class="n">IsrEvt</span><span class="p">,</span> <span class="n">ISR_SIG</span><span class="p">);</span>
      <span class="n">pe</span><span class="o">-&gt;</span><span class="p">...</span> <span class="o">=</span> <span class="p">...</span> <span class="cm">/* set the event attributes */</span>
      <span class="c1">// 发送事件</span>
      <span class="n">QEQueue_postFIFO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">APP_isrQueue</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">pe</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">QSTATE</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">QState</span><span class="p">)</span><span class="o">&amp;</span><span class="n">MyAO_stateA</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* main module -----------------------------------------------------------*/</span>
<span class="k">static</span> <span class="n">QEvent</span> <span class="o">*</span><span class="n">l_isrQueueSto</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="cm">/* allocate a buffer for the “raw” queue */</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="cm">/* initialize the “raw” queue */</span>
  <span class="c1">// 初始化事件队列</span>
  <span class="n">QEQueue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">APP_isrQueue</span><span class="p">,</span> <span class="n">l_isrQueueSto</span><span class="p">,</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_isrQueueSto</span><span class="p">));</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>QEQueue 函数 QEQueue_postFIFO() ， QEQueue_postLIFO() 和 QEQueue_get()的实现是非常直接的，因为不需要平台相关的宏。所有这些函数都是<code class="language-plaintext highlighter-rouge">可重入</code>的(多线程安全)，因为它们使用<code class="language-plaintext highlighter-rouge">临界区</code>代码维护队列的完整性。</p><h3 id="原生-qf-内存池"><span class="mr-2">原生 QF 内存池</span><a href="#原生-qf-内存池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qmpool.jpg" alt="qmpool" data-proofer-ignore></p><p>图中<code class="language-plaintext highlighter-rouge">粗黑线</code>框起来的是一个块，<code class="language-plaintext highlighter-rouge">细黑线</code>分割了一个块，<code class="language-plaintext highlighter-rouge">左边</code>为下一空闲块<code class="language-plaintext highlighter-rouge">指针</code>。通过这种方法重用了<code class="language-plaintext highlighter-rouge">空闲块</code>的空间，不需要单独找地方存一张<code class="language-plaintext highlighter-rouge">空闲表</code>了</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QMPoolTag</span>
<span class="p">{</span>
  <span class="c1">// 空闲表表头，即首个空闲块的地址</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">free</span><span class="p">;</span>           <span class="cm">/* the head of the linked list of free blocks */</span>
  <span class="c1">// 池开始块地址</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>          <span class="cm">/* the start of the original pool buffer */</span>
  <span class="c1">// 池结束块地址</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>            <span class="cm">/* the last block in this pool */</span>
  <span class="c1">// 块大小</span>
  <span class="n">QMPoolSize</span> <span class="n">blockSize</span><span class="p">;</span> <span class="cm">/* maximum block size (in bytes) */</span>
  <span class="c1">// 块数量</span>
  <span class="n">QMPoolCtr</span> <span class="n">nTot</span><span class="p">;</span>       <span class="cm">/* total number of blocks */</span>
  <span class="c1">// 空闲块数量</span>
  <span class="n">QMPoolCtr</span> <span class="n">nFree</span><span class="p">;</span>      <span class="cm">/* number of free blocks remaining */</span>
  <span class="c1">// 空闲块曾经出现过的最小数量，用于分析使用情况</span>
  <span class="n">QMPoolCtr</span> <span class="n">nMin</span><span class="p">;</span>       <span class="cm">/* minimum number of free blocks ever in this pool */</span>
<span class="p">}</span> <span class="n">QMPool</span>
</pre></table></code></div></div><h4 id="原生-qf-内存池的初始化"><span class="mr-2">原生 QF 内存池的初始化</span><a href="#原生-qf-内存池的初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><em>QFreeBlock 结构用于对不同架构 CPU 实现内存对齐</em>：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 空闲链表节点，里面就一个指针</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">QFreeBlockTag</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">QFreeBlockTag</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">QFreeBlock</span><span class="p">;</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QMPool_init</span><span class="p">(</span><span class="n">QMPool</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">poolSto</span><span class="p">,</span>
                 <span class="kt">uint32_t</span> <span class="n">poolSize</span><span class="p">,</span> <span class="n">QMPoolSize</span> <span class="n">blockSize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 空闲链表</span>
  <span class="n">QFreeBlock</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">corr</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">nblocks</span><span class="p">;</span>
  <span class="cm">/* The memory block must be valid
   * and the poolSize must fit at least one free block
   * and the blockSize must not be too close to the top of the dynamic range
   */</span>
  <span class="n">Q_REQUIRE</span><span class="p">((</span><span class="n">poolSto</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 预分配空间不能为空</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">poolSize</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QFreeBlock</span><span class="p">))</span> <span class="c1">// 池大小必须能够至少放入一个空闲块，后面有断言poolSize &gt;= (uint32_t)blockSize，这里只是一种判断条件</span>
            <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">QMPoolSize</span><span class="p">)(</span><span class="n">blockSize</span> <span class="o">+</span> <span class="p">(</span><span class="n">QMPoolSize</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QFreeBlock</span><span class="p">))</span>
            <span class="o">&gt;</span> <span class="n">blockSize</span><span class="p">));</span>  <span class="c1">// blockSize值不应该接近QMPoolSize类型值上限，比如QMPoolSize是uint16，</span>
                            <span class="c1">// blockSize不应该接近65535，如果blockSize为65532，</span>
                            <span class="c1">// 这里加上QFreeBlock指针的4，就会溢出回绕，最终比blockSize小。</span>
  <span class="cm">/*lint -e923 ignore MISRA Rule 45 in this expression */</span>
  <span class="c1">// (uint32_t)sizeof(QFreeBlock) - (uint32_t)1得到非对齐mask，如4-1=3=0x0011，如果是对齐地址，&amp;操作后应该为0(相当于除以4的余数)，非对齐则不为0</span>
  <span class="n">corr</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">poolSto</span> <span class="o">&amp;</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QFreeBlock</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">1</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">corr</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 未对齐</span>
  <span class="p">{</span>                                             <span class="cm">/* alignment needed? */</span>
    <span class="c1">// 算对齐误差</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QFreeBlock</span><span class="p">)</span> <span class="o">-</span> <span class="n">corr</span><span class="p">;</span> <span class="cm">/*amount to align poolSto*/</span>
    <span class="c1">// poolSize相应缩小，放弃未对齐部分</span>
    <span class="n">poolSize</span> <span class="o">-=</span> <span class="n">corr</span><span class="p">;</span>                           <span class="cm">/* reduce the available pool size */</span>
  <span class="p">}</span>
  <span class="cm">/*lint -e826 align the head of free list at the free block-size boundary*/</span>
  <span class="c1">// 开始给QPool赋值，强制对齐下，会丢弃未对齐部分，从对齐地址开始使用</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">poolSto</span> <span class="o">+</span> <span class="n">corr</span><span class="p">);</span>
  <span class="cm">/* round up the blockSize to fit an integer # free blocks, no division */</span>
  <span class="c1">// me-&gt;blockSize通过运算变为blockSize</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">blockSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">QMPoolSize</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QFreeBlock</span><span class="p">);</span> <span class="cm">/* start with just one */</span>
  <span class="c1">// nblocks的计算避免用到除法，而是用while做加法计算</span>
  <span class="c1">// nBlocks = (blockSize + sizeof(QFreeBlock) – 1)/sizeof(QFreeBlock + 1)</span>
  <span class="n">nblocks</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/* # free blocks that fit in one memory block */</span>
  <span class="c1">// 加法增加，也能保证me-&gt;blockSize是sizeof(QFreeBlock)的整数倍，保证了每个块的地址也是对齐的</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">blockSize</span> <span class="o">&lt;</span> <span class="n">blockSize</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">blockSize</span> <span class="o">+=</span> <span class="p">(</span><span class="n">QMPoolSize</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QFreeBlock</span><span class="p">);</span>
    <span class="o">++</span><span class="n">nblocks</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">blockSize</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">blockSize</span><span class="p">;</span> <span class="cm">/* use the rounded-up value from now on */</span>
                             <span class="cm">/* the pool buffer must fit at least one rounded-up block */</span>
  <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">poolSize</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">blockSize</span><span class="p">);</span>
  <span class="cm">/* chain all blocks together in a free-list... */</span>
  <span class="c1">// 第一个直接减掉，因为已经加进链表了，见下面的while循环</span>
  <span class="n">poolSize</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">blockSize</span><span class="p">;</span> <span class="cm">/*don’t link the last block to the next */</span>
  <span class="c1">// 不是从0开始，因为第一个就是me-&gt;free，已经在了，见下面while循环</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">nTot</span> <span class="o">=</span> <span class="p">(</span><span class="n">QMPoolCtr</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>         <span class="cm">/* the last block already in the pool */</span>
  <span class="c1">// 空闲队列指针赋值</span>
  <span class="n">fb</span> <span class="o">=</span> <span class="p">(</span><span class="n">QFreeBlock</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>     <span class="cm">/*start at the head of the free list */</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">poolSize</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">blockSize</span><span class="p">)</span>
  <span class="p">{</span>                                  <span class="cm">/* can fit another block? */</span>
    <span class="c1">// TODO:这里的nblocks应该是me-&gt;nTot吧</span>
    <span class="n">fb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fb</span><span class="p">[</span><span class="n">nblocks</span><span class="p">];</span>         <span class="cm">/* point the next link to the next block */</span>
    <span class="c1">// 链表生成</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">fb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>                   <span class="cm">/* advance to the next block */</span>
    <span class="n">poolSize</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">blockSize</span><span class="p">;</span> <span class="cm">/* reduce the available pool size */</span>
    <span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">nTot</span><span class="p">;</span>                      <span class="cm">/* increment the number of blocks so far */</span>
  <span class="p">}</span>
  <span class="n">fb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">QFreeBlock</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* the last link points to NULL */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">nTot</span><span class="p">;</span>       <span class="cm">/* all blocks are free */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">nMin</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">nTot</span><span class="p">;</span>        <span class="cm">/* the minimum number of free blocks */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">poolSto</span><span class="p">;</span>        <span class="cm">/* the original start this pool buffer */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">fb</span><span class="p">;</span>               <span class="cm">/* the last block in this pool */</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>许多 CPU 架构对指针的正确<code class="language-plaintext highlighter-rouge">对齐</code>有特别的要求。例如， <code class="language-plaintext highlighter-rouge">ARM</code> 处理器需要一个指针被分配在一个可以<code class="language-plaintext highlighter-rouge">被 4 整除</code>的地址。其他的 CPU，比如 <code class="language-plaintext highlighter-rouge">Pentium</code> ，可以接受分配在<code class="language-plaintext highlighter-rouge">奇数地址</code>的指针，但是当指针在可被 4 整除的地址对齐时，<code class="language-plaintext highlighter-rouge">执行性能</code>会更加好。</p></blockquote><h4 id="从池里获得一个内存块"><span class="mr-2">从池里获得一个内存块</span><a href="#从池里获得一个内存块" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用 <code class="language-plaintext highlighter-rouge">QMPool_get()</code> 从内存池获取一个块，支持耗尽，耗尽返回 <code class="language-plaintext highlighter-rouge">NULL</code>。</p><blockquote><p>之前在<a href="#动态事件分配">动态事件分配</a>中提到如果是内存池用于动态事件队列，由于 QF 不支持<code class="language-plaintext highlighter-rouge">满队列</code>（耗尽），所以用完<code class="language-plaintext highlighter-rouge">无法插入</code>队列时会直接断言<code class="language-plaintext highlighter-rouge">报错</code>。</p></blockquote><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">QMPool_get</span><span class="p">(</span><span class="n">QMPool</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QFreeBlock</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="n">fb</span> <span class="o">=</span> <span class="p">(</span><span class="n">QFreeBlock</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span> <span class="cm">/* get a free block or NULL */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fb</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QFreeBlock</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>                      <span class="cm">/* free block available? */</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">fb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="cm">/* adjust list head to the next free block */</span>
    <span class="o">--</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="p">;</span>         <span class="cm">/* one less free block */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">nMin</span> <span class="o">&gt;</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">nMin</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="p">;</span> <span class="cm">/* remember the minimum so far */</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">fb</span><span class="p">;</span> <span class="cm">/* return the block or NULL pointer to the caller */</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="把一个内存块回收到池内"><span class="mr-2">把一个内存块回收到池内</span><a href="#把一个内存块回收到池内" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><code class="language-plaintext highlighter-rouge">QMPool_put()</code> 用来把块回收到池内</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// b是要回收的块的地址</span>
<span class="kt">void</span> <span class="nf">QMPool_put</span><span class="p">(</span><span class="n">QMPool</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">Q_REQUIRE</span><span class="p">((</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span> <span class="cm">/* must be in range */</span>
  <span class="c1">// TODO: 这里应该是小于不是小于等于，等于说明全空闲，就不能再释放了</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">&lt;=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">nTot</span><span class="p">));</span>       <span class="cm">/* # free blocks must be &lt; total */</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="p">((</span><span class="n">QFreeBlock</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">QFreeBlock</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span> <span class="cm">/* link into free list */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>   <span class="cm">/* set as new head of the free list */</span>
  <span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="p">;</span>    <span class="cm">/* one more free block in this pool */</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="原生-qf-优先级集合"><span class="mr-2">原生 QF 优先级集合</span><a href="#原生-qf-优先级集合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>可以用来表示活动对象优先级，此时每一位对应一个活动对象</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QPSet64Tag</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">bytes</span><span class="p">;</span>   <span class="cm">/* condensed representation of the priority set */</span>
  <span class="kt">uint8_t</span> <span class="n">bits</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* bitmasks representing elements in the set */</span>
<span class="p">}</span> <span class="n">QPSet64</span><span class="p">;</span>
</pre></table></code></div></div><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qpset.jpg" alt="qpset" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">uint8_t bits[8]</code>一共是 8 个 <code class="language-plaintext highlighter-rouge">1 字节</code>共 64 位，对应图上的 8x8 矩阵(bitmask)，<code class="language-plaintext highlighter-rouge">bits[0]</code>表示第 1 行,<code class="language-plaintext highlighter-rouge">bits[7]</code>表示第 8 行</p><p><code class="language-plaintext highlighter-rouge">uint8_t bytes</code>用于加快 bitmask <code class="language-plaintext highlighter-rouge">查找</code>，用来指示对应行的位中是否有<code class="language-plaintext highlighter-rouge">至少一个 1</code>(字节值大于等于 1)。相当于是把 1 个字节<code class="language-plaintext highlighter-rouge">压缩</code>成 1 位，将 <code class="language-plaintext highlighter-rouge">8 个字节</code>看成 <code class="language-plaintext highlighter-rouge">1 个字节</code>处理。如<code class="language-plaintext highlighter-rouge">bytes</code>的<code class="language-plaintext highlighter-rouge">第0位</code>指示<code class="language-plaintext highlighter-rouge">bits[0]</code>是否大于等于 1，如大于等于 1 则为 1。bytes 为<code class="language-plaintext highlighter-rouge">0x10010001</code>表示<code class="language-plaintext highlighter-rouge">bytes[0]</code>、<code class="language-plaintext highlighter-rouge">bytes[4]</code>、<code class="language-plaintext highlighter-rouge">bytes[7]</code>大于等于 1。</p><p><em>判断集合是否为空</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define QPSet64_notEmpty(me_) ((me_)-&gt;bytes != (uint8_t)0)
</span></pre></table></code></div></div><p><em>找出集合里最大的元素</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 先找bytes最高位，在找最高位对应的bits的最高位，bytes移位算偏移后相加</span>
<span class="cp">#define QPSet64_findMax(me_, n_)                                  \
  do                                                              \
  {                                                               \
    (n_) = (uint8_t)(QF_log2Lkup[(me_)-&gt;bytes] - 1);              \
    (n_) = (uint8_t)(((n_) &lt;&lt; 3) + QF_log2Lkup[(me_)-&gt;bits[n_]]); \
  } while (0)
</span></pre></table></code></div></div><blockquote><p>二进制对数查找表 <code class="language-plaintext highlighter-rouge">QF_log2Lkup</code> 见<a href="#发行-订阅事件发送">发行-订阅事件发送</a>的<code class="language-plaintext highlighter-rouge">发行</code>一节</p></blockquote><p><em>插入一个值</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#define QPSet64_insert(me_, n_)                       \
  do                                                  \
  {                                                   \
    (me_)-&gt;bits[QF_div8Lkup[n_]] |= QF_pwr2Lkup[n_];  \
    (me_)-&gt;bytes |= QF_pwr2Lkup[QF_div8Lkup[n_] + 1]; \
  } while (0)
</span></pre></table></code></div></div><blockquote><p>字节索引 <code class="language-plaintext highlighter-rouge">QF_div8Lkup[p] = (p – 1)/8</code>（把值转为 bits 的索引），找字节内偏移 <code class="language-plaintext highlighter-rouge">QF_pwr2Lkup[p] = 1 &lt;&lt; ((p – 1) % 8)</code>（p-1 是因为偏移和索引都是从 0 开始，参数 p 是从 1 开始）</p></blockquote><p>先给 bits 赋值，再给 bytes 赋值</p><p><em>移除一个值</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#define QPSet64_remove(me_, n_)                            \
  do                                                       \
  {                                                        \
    (me_)-&gt;bits[QF_div8Lkup[n_]] &amp;= QF_invPwr2Lkup[n_];    \
    if ((me_)-&gt;bits[QF_div8Lkup[n_]] == (uint8_t)0)        \
    {                                                      \
      (me_)-&gt;bytes &amp;= QF_invPwr2Lkup[QF_div8Lkup[n_] + 1]; \
    }                                                      \
} while(0)
</span></pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">QF_invPwr2Lkup[p]</code> 清除对应位</p></blockquote><h3 id="原生合作式-vanilla-内核"><span class="mr-2">原生合作式 vanilla 内核</span><a href="#原生合作式-vanilla-内核" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>QF 包含了一个简单的合作式 <code class="language-plaintext highlighter-rouge">vanilla</code> 内核</p><blockquote><p>在计算机科学领域，<code class="language-plaintext highlighter-rouge">香草vanilla</code>是一个用于表示“一个事物没有经过自定义的改动而仍然保留着它们<code class="language-plaintext highlighter-rouge">默认</code>的形式”的术语。这个术语已经广为流传并成为事实标准。香草一词来自于传统冰淇淋的<code class="language-plaintext highlighter-rouge">标准口味</code>，香草味。根据 Eric S. Raymond 的《The New Hacker’s Dictionary》一书记载，香草一词在感觉上比普通一词更能表达“<code class="language-plaintext highlighter-rouge">默认</code>”的含义。<a href="https://zh.m.wikipedia.org/zh-hans/%E9%A6%99%E8%8D%89%E8%BD%AF%E4%BB%B6">维基百科:香草软件</a></p></blockquote><p>vanilla 内核通过在一个<code class="language-plaintext highlighter-rouge">无限循环</code>内不断查询所有活动对象的事件队列来工作。内核总是挑选<code class="language-plaintext highlighter-rouge">最高优先级</code>的<code class="language-plaintext highlighter-rouge">预备运行</code>(非空事件队列)的<code class="language-plaintext highlighter-rouge">活动对象</code></p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/readyset.jpg" alt="readyset" data-proofer-ignore></p><p>图中所示 QPSet64 类型的 <code class="language-plaintext highlighter-rouge">QF_readySet_</code> 优先级集合用于表示系统内所有<code class="language-plaintext highlighter-rouge">非空事件队列</code>的“<code class="language-plaintext highlighter-rouge">预备集合</code>”，每一位对应一个活动对象。活动对象的事件队列为非空时对应位置 1 ，为空时置 0</p><h4 id="qvanillac-源文件"><span class="mr-2">qvanilla.c 源文件</span><a href="#qvanillac-源文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qf_pkg.h"</span><span class="cp">
#include</span> <span class="cpf">"qassert.h"</span><span class="cp">
</span><span class="cm">/* Package-scope objects -----------------------------------------------*/</span>
<span class="c1">// 禁止优化，因为可能在中断中改变</span>
<span class="n">QPSet64</span> <span class="k">volatile</span> <span class="n">QF_readySet_</span><span class="p">;</span> <span class="cm">/* QF-ready set of active objects */</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* nothing to do for the “vanilla” kernel */</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* nothing to cleanup for the “vanilla” kernel */</span>
  <span class="n">QF_onCleanup</span><span class="p">();</span> <span class="cm">/* cleanup callback */</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="c1">// main()中调用QF_run()，把控制权转让给QF框架，也就是运行 vanilla 内核</span>
<span class="kt">void</span> <span class="nf">QF_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* see NOTE01 */</span>
  <span class="kt">uint8_t</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">QActive</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
  <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="c1">// 配置回调函数并启动中断</span>
  <span class="n">QF_onStartup</span><span class="p">();</span> <span class="cm">/* invoke the QF startup callback */</span>
  <span class="k">for</span> <span class="p">(;;)</span>
  <span class="p">{</span> <span class="cm">/* the background loop */</span>
    <span class="n">QF_INT_LOCK_</span><span class="p">();</span><span class="c1">// 处理QF_readySet_上锁</span>
    <span class="c1">// 是否有事件要处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">QPSet64_notEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QF_readySet_</span><span class="p">))</span>
    <span class="p">{</span> <span class="c1">// 获取有事件的最高优先级的活动对象</span>
      <span class="n">QPSet64_findMax</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QF_readySet_</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
      <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span> <span class="c1">// 中断上锁是为了处理QF_readySet_，现在可以解锁了</span>
      <span class="c1">// 找这个活动对象的第一个待处理事件</span>
      <span class="n">e</span> <span class="o">=</span> <span class="n">QActive_get_</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>               <span class="cm">/* get the next event for this AO */</span>
      <span class="c1">// 执行状态函数</span>
      <span class="n">QF_ACTIVE_DISPATCH_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* dispatch to the AO */</span>
      <span class="n">QF_gc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>                          <span class="cm">/* determine if event is garbage and collect it if so */</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">// 没有事件的话不阻塞，要做其他事情，比如进入低功耗模式</span>
         <span class="c1">// 进入Idle函数前必须上锁，这是为了防止这时候其他任务通过中断产生了事件，因为vanilla 内核的非抢占性，导致依然按照原流程进入idle状态，这个事件就不能被及时处理了（像QK内核就可以在事件发生的时候在中断里就产生一次调度，把进入idle的动作抢占了）</span>
         <span class="c1">// 进入后在开启低功耗模式前必须解锁中断，防止死锁，因为需要中断来唤醒，不解锁中断就唤醒不了</span>
    <span class="p">{</span> <span class="cm">/* all active object queues are empty */</span>
<span class="cp">#ifndef QF_INT_KEY_TYPE // QF_onIdle是否有参数取决于临界区机制
</span>      <span class="n">QF_onIdle</span><span class="p">();</span> <span class="cm">/* see NOTE02 */</span>
<span class="cp">#else
</span>      <span class="n">QF_onIdle</span><span class="p">(</span><span class="n">intLockKey_</span><span class="p">);</span> <span class="cm">/* see NOTE02 */</span>
<span class="cp">#endif </span><span class="cm">/* QF_INT_KEY_TYPE */</span><span class="cp">
</span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="c1">// 启动活动对象线程</span>
<span class="kt">void</span> <span class="nf">QActive_start</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prio</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">qSto</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">qLen</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">stkSto</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">stkSize</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">ie</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Q_REQUIRE</span><span class="p">(((</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">prio</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prio</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">QF_MAX_ACTIVE</span><span class="p">)</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">stkSto</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">));</span> <span class="cm">/* does not need per-actor stack */</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stkSize</span><span class="p">;</span>                                     <span class="cm">/* avoid the “unused parameter” compiler warning */</span>
  <span class="n">QEQueue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">,</span> <span class="n">qSto</span><span class="p">,</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="n">qLen</span><span class="p">);</span> <span class="cm">/* initialize QEQueue */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>                                   <span class="cm">/* set the QF priority of this active object */</span>
  <span class="n">QF_add_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>                                       <span class="cm">/* make QF aware of this active object */</span>
  <span class="n">QF_ACTIVE_INIT_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">ie</span><span class="p">);</span>                   <span class="cm">/* execute initial transition */</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QActive_stop</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_remove_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>QF_onIdle()是否有参数取决于<a href="#qf-里的临界区">QF 里的临界区</a>类型，当使用简单的“<code class="language-plaintext highlighter-rouge">无条件中断解锁</code>”策略时，这个函数没有参数，但是在使用“<code class="language-plaintext highlighter-rouge">保存和恢复中断状态</code>” 策略时，它需要中断状态参数。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/vanillaidle.jpg" alt="vanillaidle" data-proofer-ignore></p><p>如图，如果进入 <code class="language-plaintext highlighter-rouge">Idle</code> 函数前<code class="language-plaintext highlighter-rouge">不关中断</code>，就会产生<code class="language-plaintext highlighter-rouge">竞争</code>，可能就有<code class="language-plaintext highlighter-rouge">新事件</code>插入了。然后 Idle 处理进入<code class="language-plaintext highlighter-rouge">低功耗模式</code>就不能<code class="language-plaintext highlighter-rouge">及时响应</code>这个事件了。</p><p>解决办法就是<code class="language-plaintext highlighter-rouge">进 Idle 前</code>关中断，然后在<code class="language-plaintext highlighter-rouge">进 Idle 后</code>且进入<code class="language-plaintext highlighter-rouge">低功耗模式</code>的<code class="language-plaintext highlighter-rouge">同时</code>开中断，注意这个“同时”，需要实现<code class="language-plaintext highlighter-rouge">原子操作</code>，也就是 MCU 的支持。</p><h4 id="qvanillah-头文件"><span class="mr-2">qvanilla.h 头文件</span><a href="#qvanillah-头文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>这个头文件最重要的功能是在事件被<code class="language-plaintext highlighter-rouge">发送</code>到和从活动对象事件队列<code class="language-plaintext highlighter-rouge">移除</code>时<code class="language-plaintext highlighter-rouge">更新预备集合</code> (<code class="language-plaintext highlighter-rouge">QF_readySet_</code>)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qvanilla_h
#define qvanilla_h
#include</span> <span class="cpf">"qequeue.h"</span><span class="c1"> /* “Vanilla” kernel uses the native QF event queue */</span><span class="cp">
#include</span> <span class="cpf">"qmpool.h"</span><span class="c1">  /* “Vanilla” kernel uses the native QF memory pool */</span><span class="cp">
#include</span> <span class="cpf">"qpset.h"</span><span class="c1">   /* “Vanilla” kernel uses the native QF priority set */</span><span class="cp">
</span>                     <span class="cm">/* the event queue and thread types for the “Vanilla” kernel */</span>
<span class="cp">#define QF_EQUEUE_TYPE QEQueue // 使用QEQueue作为事件队列
</span><span class="cm">/* native QF event queue operations */</span>
<span class="cp">#define QACTIVE_EQUEUE_WAIT_(me_) \  // 不阻塞，仅当它确信事件队列拥有最少一个事件时，它才调用 QActive_get_()
</span>  <span class="n">Q_ASSERT</span><span class="p">((</span><span class="n">me_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">.</span><span class="n">frontEvt</span> <span class="o">!=</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
<span class="cp">#define QACTIVE_EQUEUE_SIGNAL_(me_) \  // 发给空队列时修改优先集合
</span>  <span class="n">QPSet64_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QF_readySet_</span><span class="p">,</span> <span class="p">(</span><span class="n">me_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
<span class="cp">#define QACTIVE_EQUEUE_ONEMPTY_(me_) \ // 删除后成空队列时修改优先集合
</span>  <span class="n">QPSet64_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QF_readySet_</span><span class="p">,</span> <span class="p">(</span><span class="n">me_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
<span class="cm">/* native QF event pool operations */</span>
<span class="cp">#define QF_EPOOL_TYPE_ QMPool // 使用QMPool作为事件池
#define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) \
  QMPool_init(&amp;(p_), poolSto_, poolSize_, evtSize_)
#define QF_EPOOL_EVENT_SIZE_(p_) ((p_).blockSize)
#define QF_EPOOL_GET_(p_, e_) ((e_) = (QEvent *)QMPool_get(&amp;(p_)))
#define QF_EPOOL_PUT_(p_, e_) (QMPool_put(&amp;(p_), e_))
</span><span class="c1">// 共享变量声明为volatile不允许优化</span>
<span class="k">extern</span> <span class="n">QPSet64</span> <span class="k">volatile</span> <span class="n">QF_readySet_</span><span class="p">;</span> <span class="cm">/** QF-ready set of active objects */</span>
<span class="cp">#endif                                </span><span class="cm">/* qvanilla_h */</span><span class="cp">
</span></pre></table></code></div></div><h2 id="可抢占式运行-到-完成内核"><span class="mr-2">可抢占式“运行-到-完成”内核</span><a href="#可抢占式运行-到-完成内核" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="选择一个可抢占式内核的理由"><span class="mr-2">选择一个可抢占式内核的理由</span><a href="#选择一个可抢占式内核的理由" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>正常情况并不需要可抢占式内核</strong>：</p><ul><li>长过程被分割成了<code class="language-plaintext highlighter-rouge">短</code>的 RTC(run-to-completion) 步骤，不需要内核来<code class="language-plaintext highlighter-rouge">分割</code>（QP从设计层面就避免了长过程，如果用可抢占式内核就可以通过内核调度分割长过程）<li>活动对象执行线程不会<code class="language-plaintext highlighter-rouge">阻塞</code>（不阻塞意味着CPU控制权会在RTC步骤执行完成时被让出）<li>RTC 步骤足够短，<code class="language-plaintext highlighter-rouge">响应延迟</code>较低</ul><p><strong>需要可抢占式内核的情况</strong>：</p><p>需要密集的、对时序有极高要求的任务，且低优先级的任务 RTC 时间较长且不容易分解。</p><p>以一个 GPS 接收机系统为例。这个接收机在一个<code class="language-plaintext highlighter-rouge">定点</code> CPU 上执行大量的<code class="language-plaintext highlighter-rouge">浮点</code>运算去<code class="language-plaintext highlighter-rouge">计算</code> GPS 的位置（计算步骤不容易分解，且占用较长 RTC 时间）。同时， GPS 接收机必须<code class="language-plaintext highlighter-rouge">跟踪</code> GPS 卫星的<code class="language-plaintext highlighter-rouge">信号</code>，这牵涉到在小于<code class="language-plaintext highlighter-rouge">毫秒级</code>间隔内的<code class="language-plaintext highlighter-rouge">闭环控制回路</code>。很明显我们不容易把<code class="language-plaintext highlighter-rouge">位置计算</code>分解成<code class="language-plaintext highlighter-rouge">足够短</code>的 RTC 步骤从而允许<code class="language-plaintext highlighter-rouge">可靠的</code>信号跟踪，即使把信号跟踪定义为最高优先级，低优先级的 RTC 过程过长依然会影响时序。</p><blockquote><p>定点和浮点详见<a href="https://www.analog.com/cn/technical-articles/fixedpoint-vs-floatingpoint-dsp.html">定点vs浮点数字信号处理</a></p></blockquote><h3 id="rtc-内核简介"><span class="mr-2">RTC 内核简介</span><a href="#rtc-内核简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="使用单堆栈的可抢占式多任务处理"><span class="mr-2">使用单堆栈的可抢占式多任务处理</span><a href="#使用单堆栈的可抢占式多任务处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>常规实时内核需要为每个任务配置单独的<code class="language-plaintext highlighter-rouge">堆栈</code>，还要维护复杂的执行<code class="language-plaintext highlighter-rouge">上下文</code>。</p><p>需要在切换时保存上下文到任务<code class="language-plaintext highlighter-rouge">独立的栈</code>的原因是调度的<code class="language-plaintext highlighter-rouge">不确定性</code>，例：</p><p>A 切 B, B 切 C, C 切 D, D 切 A，此时 A 的上下文信息如果在全局栈中，必须把 B C D 的上下文全部出栈，这显然是不合理的，<strong>所以必须为每个任务单独配置堆栈，并在切换时把上下文信息保存在任务独立的栈中</strong>。</p><p>对于可确定<code class="language-plaintext highlighter-rouge">调度顺序</code>(基于优先级)而且遵从<code class="language-plaintext highlighter-rouge">运行到完成</code>规范的任务，就可以把每个任务的上下文信息都保存在<code class="language-plaintext highlighter-rouge">全局栈</code>中，例：</p><p>A 发事件给 B，因为 B 的优先级更高，所以内核立刻调度到 B，并把 A 的上下文保存到全局栈中，B 也可以发送事件给更高优先级的任务并执行，这样就形成<code class="language-plaintext highlighter-rouge">嵌套</code>，因为任务都是运行到完成，所以等栈顶任务执行完可以<code class="language-plaintext highlighter-rouge">有序退出</code>。</p><p>这种调度策略和基于<code class="language-plaintext highlighter-rouge">优先级</code>的中断控制器逻辑非常像。而且和函数的<code class="language-plaintext highlighter-rouge">嵌套调用</code>过程也非常像</p><h4 id="非阻塞型内核"><span class="mr-2">非阻塞型内核</span><a href="#非阻塞型内核" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>上面说的 RTC 内核有个局限，就是<code class="language-plaintext highlighter-rouge">不能阻塞</code>。原因就是虽然看上去是调度，但实际上还是一个<code class="language-plaintext highlighter-rouge">连续执行</code>的过程，就像函数的嵌套调用一样，不允许中间有阻塞。不过活动对象的设计就是不阻塞的，这也不是问题。</p><h4 id="同步抢占和异步抢占"><span class="mr-2">同步抢占和异步抢占</span><a href="#同步抢占和异步抢占" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><p>同步抢占</p><p>当一个较低优先级任务发送一个事件给一个较高优先级任务时，内核必须立刻暂停较低优先级任务的执行，并启动较高优先级的任务。</p><li><p>异步抢占</p><p>在<code class="language-plaintext highlighter-rouge">中断 ISR</code> 中发送一个事件给一个比被中断的任务更高优先级的任务时，当这个 ISR <code class="language-plaintext highlighter-rouge">完成后</code>，内核必须启动较高优先级任务的执行，而不是恢复这个较低优先级的任务。(因为中断的优先级总是比任务高，必须运行到完成后才运行执行任务)</p></ul><p><em>同步抢占</em>：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/highproitask.jpg" alt="highproitask" data-proofer-ignore></p><ul><li>（2）时低优先级任务发送事件给高优先级任务，且调度器开始调度。<li>（5）时高优先级任务发送事件给低优先级任务，调度器不执行调度，<li>（7）时高优先级任务运行完成并返回（2）时调用的调度器。<li>（8）调度器再一次检查是否有一个较高优先级任务准备运行，但是它没找到。 RTC调度器返回低优先级任务。</ul><p><em>异步抢占</em>：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/isrhighpriotask.jpg" alt="isrhighpriotask" data-proofer-ignore></p><ul><li>（3）中断服务程序 (ISR) 执行 <code class="language-plaintext highlighter-rouge">RTC 内核</code>特定的<code class="language-plaintext highlighter-rouge">进入动作</code>，它在一个堆栈变量中保存被中断任务的优先级，把 RTC 内核的当前优先级提升到 ISR 层（在任何任务之上）。这一步是为了防止第（4）步产生事件导致的调度，因为此时内核优先级比那个任务优先级高，就不会在 ISR 内部触发调度动作<li>（4）ISR 发送了一个事件给高优先级任务，发送事件的动作会让 RTC 调度器工作，它<code class="language-plaintext highlighter-rouge">立即返回</code>，因为没有任务有比当前的优先级更高的优先级（ISR 优先级比任何任务高）。ISR <code class="language-plaintext highlighter-rouge">继续运行</code><li>（5）ISR 继续运行，最后执行 RTC 内核相关的<code class="language-plaintext highlighter-rouge">退出动作</code><li><p>（6）RTC 内核相关的 ISR 退出，发送 End-Of-Interrupt(<code class="language-plaintext highlighter-rouge">EOI</code>) 指令给<code class="language-plaintext highlighter-rouge">中断控制器</code>，<code class="language-plaintext highlighter-rouge">恢复</code>被中断任务的被保留的<code class="language-plaintext highlighter-rouge">优先级</code>，并调用 <code class="language-plaintext highlighter-rouge">RTC 调度器</code>。</p><blockquote><p>退出中断有 <code class="language-plaintext highlighter-rouge">EOI</code> 和 <code class="language-plaintext highlighter-rouge">IRET</code> 两步，EOI 表示停止对当前的中断嵌套层进行优先级排序(此时可以插入任意优先级新中断)，IRET 表示从中断返回。这一步只发 EOI 表示还不想从中断返回</p></blockquote><li>（7）调度器<code class="language-plaintext highlighter-rouge">开中断</code>，并开始调度到高优先级任务。此时 RTC 调度器没有返回。<li>（9）高优先级任务执行完毕并返回到 RTC 调度器<li>（10）IRET 执行，IRET 恢复低优先级任务的上下文，从（2）开始的中断返回</ul><p>在第 (5) 步 RTC 内核相关的中断退出(执行 EOI 后)里，中断处理在概念上已经<code class="language-plaintext highlighter-rouge">结束</code>了，即使<code class="language-plaintext highlighter-rouge">中断堆栈帧</code>(interrupt stack frame) 继续保留在堆栈上并且 <code class="language-plaintext highlighter-rouge">IRET</code> 指令还没执行。在 EOI 指令之前，<code class="language-plaintext highlighter-rouge">中断控制器</code>仅允许比当前正在服务的中断更高优先级的中断。在 EOI 指令后，通过调用 RTC 调度器，中断被<code class="language-plaintext highlighter-rouge">解锁</code>，中断控制器允许所有的级别的中断，这正是在任务层所期望的行为。这样的话在（8）中高优先级任务执行时依旧可以触发中断和异步调度</p><h4 id="堆栈的利用"><span class="mr-2">堆栈的利用</span><a href="#堆栈的利用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><em>同步抢占</em>:</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/stacksync.jpg" alt="stacksync" data-proofer-ignore></p><ul><li>（2）发送事件给高优先级任务，调用了 RTC 调度器，<code class="language-plaintext highlighter-rouge">调度器堆栈帧</code>(stack frame)<code class="language-plaintext highlighter-rouge">入栈</code>所以栈增长了<li>（3）RTC 调度器调用高优先级任务，<code class="language-plaintext highlighter-rouge">任务堆栈帧</code>(stack frame)<code class="language-plaintext highlighter-rouge">入栈</code>，栈再次增长<li>（5）高优先级任务发送事件给低优先级任务，调用了 RTC 调度器，调度器堆栈帧(stack frame)<code class="language-plaintext highlighter-rouge">入栈</code>，随后因为不满足调度条件<code class="language-plaintext highlighter-rouge">立即返回</code>，调度器堆栈帧(stack frame)<code class="language-plaintext highlighter-rouge">出栈</code><li>（7）任务堆栈帧(stack frame)<code class="language-plaintext highlighter-rouge">出栈</code><li>（8）调度器在调度完成后<code class="language-plaintext highlighter-rouge">再次检查</code>是否有较高优先级的任务要运行，没有就<code class="language-plaintext highlighter-rouge">出栈</code></ul><p><em>异步抢占</em>:</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/stackasync.jpg" alt="stackasync" data-proofer-ignore></p><ul><li>（2）发生中断，由硬件控制将中断堆栈帧压栈，ISR 开始运行，并可能把某些别的上下文压入堆栈 （就是 ISR 程序，虚线所示）<li>（4）TODO：应该会发送事件触发一次调度器调用，怎么栈没增加<li>（6）RTC 调度器被调用，堆栈帧入栈<li>（7）使能中断并调度到高优先级任务，堆栈帧入栈<li>（8）高优先级任务运行到结束，出栈<li>（9）调度器再次检查，没有就出栈<li>（10）ISR 出栈（虚线），硬件执行 IRET 指令，中断出栈</ul><h4 id="和传统可抢占式内核的比较"><span class="mr-2">和传统可抢占式内核的比较</span><a href="#和传统可抢占式内核的比较" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>通过在<code class="language-plaintext highlighter-rouge">一个堆栈</code>管理所有的任务和中断的上下文， RTC 内核运行所需的 <code class="language-plaintext highlighter-rouge">RAM</code> 远比一个典型的阻塞式内核需要的少。</p><p>C 编译器生成的 ISR <code class="language-plaintext highlighter-rouge">进入时</code>仅保留可能在 C 函数被使用那些寄存器，而不是全部，比传统的少，降低了进入 ISR 时的堆栈和 CPU 消耗</p><h3 id="qk-的实现"><span class="mr-2">QK 的实现</span><a href="#qk-的实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="qk-源代码的组织"><span class="mr-2">QK 源代码的组织</span><a href="#qk-源代码的组织" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="gp">&lt;qp&gt;</span><span class="se">\q</span>pc<span class="se">\ </span>- QP/C root directory <span class="o">(</span>&lt;qp&gt;<span class="se">\q</span>pcpp <span class="k">for </span>QP/C++<span class="o">)</span>
<span class="go">|
+-include\ - QP platform-independent header files
| +-qk.h - QK platform-independent interface
| +-. . .
|
+-qk\ - QK preemptive kernel
| +-source\ - QK platform-independent source code (*.C files)
| | +-qk_pkg.h - internal, interface for the QK implementation
| | +-qk.c - definitionofQK_getVersion()andQActive_start()
| | +-qk_sched.c - definition of QK_schedule_()
| | +-qk_mutex.c - definition of QK_mutexLock()/QK_mutexUnlock()
| | +-qk_ext.c - definition of QK_scheduleExt_()
| |
| +-lint\ - QK options for lint
| +-opt_qk.lnt - PC-lint options for linting QK
|
+-ports\ - Platform-specific QP ports
| +-80x86\ - Ports to the 80x86 processor
| | +-qk\ - Ports to the QK preemptive kernel
| | | +-tcpp101\ - Ports with the Turbo C++ 1.01 compiler
| | | +-l\ - Ports using the Large memory model
| | | +-dbg\ - Debug build
| | | | +-qf.lib – QF library
| | | | +-qep.lib – QEP library
| | | +-rel\ - Release build
| | | +-spy\ - Spy build (with software instrumentation)
| | | +-make.bat – batch script for building the QP libraries
| | | +-qep_port.h – QEP platform-dependent include file
| | | +-qf_port.h – QF platform-dependent include file
| | | +-qk_port.h – QK platform-dependent include file
| | | +-qs_port.h – QS platform-dependent include file
| | | +-qp_port.h – QP platform-dependent include file
| +-cortex-m3\ - Ports to the Cortex-M3 processor
| | +-qk\ - Ports to the QK preemptive kernel
| | | +-iar\ - Ports with the IAR compiler
| |
+-examples\ - Platform-specific QP examples
| +-80x88\ - Examples for the 80x86 processor
| | +-qk\ - Examples for the QK preemptive kernel
| | | +- . . .
| +-cortex-m3\ - Examples for the Cortex-M3 processor
| | +-qk\ - Examples for the QK preemptive kernel
| | | +- . . .
| +- . . .
</span></pre></table></code></div></div><h4 id="头文件-qkh"><span class="mr-2">头文件 qk.h</span><a href="#头文件-qkh" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qkdataelements.jpg" alt="qkdataelements" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qk_h
#define qk_h
</span><span class="c1">// QK 内核使用原生 QF 事件队列</span>
<span class="cp">#include</span> <span class="cpf">"qequeue.h"</span><span class="c1">                  /* The QK kernel uses the native QF event queue */</span><span class="cp">
</span><span class="c1">// QK 内核使用原生 QF 内存池</span>
<span class="cp">#include</span> <span class="cpf">"qmpool.h"</span><span class="c1">                   /* The QK kernel uses the native QF memory pool */</span><span class="cp">
</span><span class="c1">// QK 内核使用原生 QF 优先级集合</span>
<span class="cp">#include</span> <span class="cpf">"qpset.h"</span><span class="c1">                    /* The QK kernel uses the native QF priority set */</span><span class="cp">
</span><span class="cm">/* public-scope objects */</span>
<span class="c1">// 优先级集合，相当于等待队列</span>
<span class="k">extern</span> <span class="n">QPSet64</span> <span class="k">volatile</span> <span class="n">QK_readySet_</span><span class="p">;</span> <span class="cm">/**&lt; QK ready-set */</span>
<span class="c1">// 当前正在运行的任务或中断的全局系统范围的优先级</span>
<span class="k">extern</span> <span class="kt">uint8_t</span> <span class="k">volatile</span> <span class="n">QK_currPrio_</span><span class="p">;</span> <span class="cm">/**&lt; current task/interrupt priority */</span>
<span class="c1">// 全局系统范围的中断嵌套层</span>
<span class="k">extern</span> <span class="kt">uint8_t</span> <span class="k">volatile</span> <span class="n">QK_intNest_</span><span class="p">;</span>  <span class="cm">/**&lt; interrupt nesting level */</span>
<span class="cm">/***************************************************************************************/</span>
<span class="cm">/* QF configuration for QK */</span>
<span class="cp">#define QF_EQUEUE_TYPE QEQueue
#if defined(QK_TLS) || defined(QK_EXT_SAVE)
</span><span class="c1">// 活动对象中的osObject变量的类型，比如Linux移植中使用pthread_cond_t用来表示条件变量控制线程休眠和唤醒，</span>
<span class="c1">// 这里QK里用来表示位掩码</span>
<span class="cp">#define QF_OS_OBJECT_TYPE uint8_t
</span><span class="c1">// 活动对象里的thread变量的类型，标识线程，如Linux移植中使用pthread_t标识活动对象的线程id。</span>
<span class="cp">#define QF_THREAD_TYPE void *
#endif </span><span class="cm">/* QK_TLS || QK_EXT_SAVE */</span><span class="cp">
</span><span class="cm">/* QK active object queue implementation...................................*/</span>
<span class="c1">// QK内核不阻塞，这个宏由QActive_get_调用，原用于事件队列为空时阻塞get,这里加了断言表示调用get时要保证事件队列非空，从而满足不阻塞要求</span>
<span class="cp">#define QACTIVE_EQUEUE_WAIT_(me_) \
  Q_ASSERT((me_)-&gt;eQueue.frontEvt != (QEvent *)0)
</span><span class="c1">// 当空的事件队列插入新事件时被调用，</span>
<span class="cp">#define QACTIVE_EQUEUE_SIGNAL_(me_)           \
  // 加入预备队列
</span>  <span class="n">QPSet64_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">,</span> <span class="p">(</span><span class="n">me_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span> \
  <span class="c1">// 如果发生在任务层，则调用调度器，否则发生在中断层，不调用调度器，因为任务不可能抢占中断</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QK_intNest_</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>              \
  <span class="p">{</span>                                           \
    <span class="n">QK_SCHEDULE_</span><span class="p">();</span>                           \
  <span class="p">}</span>                                           \
  <span class="k">else</span>                                        \
    <span class="p">((</span><span class="kt">void</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">// 移除事件导致事件队列为空时调用</span>
<span class="cp">#define QACTIVE_EQUEUE_ONEMPTY_(me_) \
  QPSet64_remove(&amp;QK_readySet_, (me_)-&gt;prio)
</span><span class="cm">/* QK event pool operations...............................................*/</span>
<span class="c1">// 使用QF事件池</span>
<span class="cp">#define QF_EPOOL_TYPE_ QMPool
#define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) \
  QMPool_init(&amp;(p_), poolSto_, poolSize_, evtSize_)
#define QF_EPOOL_EVENT_SIZE_(p_) ((p_).blockSize)
#define QF_EPOOL_GET_(p_, e_) ((e_) = (QEvent *)QMPool_get(&amp;(p_)))
#define QF_EPOOL_PUT_(p_, e_) (QMPool_put(&amp;(p_), (e_)))
</span><span class="kt">void</span> <span class="nf">QK_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>   <span class="cm">/* QK initialization */</span>
<span class="kt">void</span> <span class="nf">QK_onIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* QK idle callback */</span>
<span class="kt">char</span> <span class="k">const</span> <span class="n">Q_ROM</span> <span class="o">*</span><span class="n">Q_ROM_VAR</span> <span class="nf">QK_getVersion</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="c1">// QK自己实现的互斥体</span>
<span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="n">QMutex</span><span class="p">;</span> <span class="cm">/* QK priority-ceiling mutex */</span>
<span class="c1">// QK自己实现的互斥锁（用于临界区）</span>
<span class="n">QMutex</span> <span class="nf">QK_mutexLock</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">prioCeiling</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">QK_mutexUnlock</span><span class="p">(</span><span class="n">QMutex</span> <span class="n">mutex</span><span class="p">);</span>
<span class="cm">/* QK scheduler and extended scheduler */</span>
<span class="c1">// 如果QF_INT_KEY_TYPE未定义</span>
<span class="cp">#ifndef QF_INT_KEY_TYPE
</span><span class="c1">// 使用无条件中断上锁解锁</span>
<span class="kt">void</span> <span class="nf">QK_schedule_</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">QK_scheduleExt_</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* QK extended scheduler */</span>
<span class="cp">#define QK_SCHEDULE_() QK_schedule_()
#else
</span><span class="c1">// 使用保存和恢复中断状态，参数需要一个保存当前中断状态的变量</span>
<span class="kt">void</span> <span class="nf">QK_schedule_</span><span class="p">(</span><span class="n">QF_INT_KEY_TYPE</span> <span class="n">intLockKey</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">QK_scheduleExt_</span><span class="p">(</span><span class="n">QF_INT_KEY_TYPE</span> <span class="n">intLockKey</span><span class="p">);</span> <span class="cm">/* extended scheduler */</span>
<span class="cp">#define QK_SCHEDULE_() QK_schedule_(intLockKey_)
#endif </span><span class="cm">/* QF_INT_KEY_TYPE */</span><span class="cp">
#endif </span><span class="cm">/* qk_h */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="中断的处理"><span class="mr-2">中断的处理</span><a href="#中断的处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>可抢占型内核需要通过中断夺回<code class="language-plaintext highlighter-rouge">控制权</code>来执行调度，需要编写自己的ISR处理程序</p><p><em>QK 里的 ISR:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">interrupt</span> <span class="nf">YourISR</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span><span class="cm">/* typically entered with interrupts locked */</span>
  <span class="c1">// 一般进ISR中断是上锁的，但有些CPU不上锁</span>
  <span class="c1">// 清除中断源如有必要，防止中断丢失</span>
  <span class="n">Clear</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">source</span><span class="p">,</span> <span class="k">if</span> <span class="n">necessary</span>

  <span class="c1">// 如果中断原来就是上锁的，不用上锁，否则要先上锁</span>
  <span class="c1">// 修改QK_intNest_（需要临界区）让QK知道现在是在中断层，不允许任务抢占</span>
  <span class="o">++</span><span class="n">QK_intNest_</span><span class="p">;</span> <span class="cm">/* account for one more interrupt nesting level */</span>
  <span class="c1">// 退出临界区</span>
  <span class="n">Unlock</span> <span class="n">interrupts</span><span class="p">(</span><span class="n">depending</span> <span class="n">on</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">policy</span> <span class="n">used</span><span class="p">)</span>
  
  <span class="c1">// 执行QF相关服务</span>
  <span class="n">Execute</span> <span class="n">ISR</span> <span class="n">body</span><span class="p">,</span><span class="n">including</span> <span class="n">calling</span> <span class="n">QF</span> <span class="n">services</span><span class="p">,</span> <span class="n">such</span> <span class="n">as</span> <span class="o">:</span> 
    <span class="n">Q_NEW</span><span class="p">(),</span> <span class="n">QActive_postFIFO</span><span class="p">(),</span> <span class="n">QActive_postLIF</span><span class="p">(),</span> <span class="n">QF_publish</span><span class="p">(),</span> <span class="n">or</span> <span class="n">QF_tick</span><span class="p">()</span>
   
  <span class="n">Lock</span> <span class="n">interrupts</span><span class="p">,</span> <span class="k">if</span> <span class="n">they</span> <span class="n">were</span> <span class="n">unlocked</span> <span class="n">in</span> <span class="n">step</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
  <span class="c1">// 给中断控制器发送EOI</span>
  <span class="n">Send</span> <span class="n">the</span> <span class="n">EOI</span> <span class="n">instruction</span> <span class="n">to</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">controller</span>
  <span class="c1">// 通知QK结束了中断层，可以开始调度</span>
  <span class="o">--</span><span class="n">QK_intNest_</span><span class="p">;</span> <span class="cm">/* account for one less interrupt nesting level */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QK_intNest_</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>                 <span class="cm">/* coming back to the task level? */</span>
    <span class="n">QK_schedule_</span><span class="p">();</span> <span class="cm">/* handle potential asynchronous preemption */</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qktimeline.jpg" alt="qktimeline" data-proofer-ignore></p><h4 id="源文件-qk_schedc--qk-调度器"><span class="mr-2">源文件 qk_sched.c （ QK 调度器）</span><a href="#源文件-qk_schedc--qk-调度器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>qk_sched.c 源文件实现了 QK <code class="language-plaintext highlighter-rouge">调度器</code>，它是 QK 内核的最重要的部分。</p><p>仅在 2 个时刻调用 QK 调度器：</p><ul><li>当一个事件被发送给一个活动对象的一个事件队列（<code class="language-plaintext highlighter-rouge">同步抢占</code>）<li>在 ISR 处理的尾部（<code class="language-plaintext highlighter-rouge">异步抢占</code>）。</ul><p>QK 调度器是一个简单的常规 C 函数 <code class="language-plaintext highlighter-rouge">QK_schedule_()</code> ，它的工作是有效的找出预备运行的<code class="language-plaintext highlighter-rouge">最高优先级</code>的活动对象。为了执行这个工作， QK 调度器依靠 2 个数据元素：</p><ul><li><p>预备运行的任务的集合 <code class="language-plaintext highlighter-rouge">QK_readySet_</code></p><p>QPSet64类型，是个位图，每个bit表示一个活动对象，按照位排序1-64优先级</p><li><p>当前被服务的优先级 <code class="language-plaintext highlighter-rouge">QK_currPrio_</code></p><p>uint8_t类型，存储当前优先级</p></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qk_pkg.h"</span><span class="cp">
</span><span class="cm">/* Public-scope objects -------------------------------------------------*/</span>
<span class="c1">// 优先级位图</span>
<span class="n">QPSet64</span> <span class="k">volatile</span> <span class="n">QK_readySet_</span><span class="p">;</span> <span class="cm">/* QK ready-set */</span>
<span class="cm">/* start with the QK scheduler locked */</span>
<span class="c1">// 当前优先级</span>
<span class="kt">uint8_t</span> <span class="k">volatile</span> <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">QF_MAX_ACTIVE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// 嵌套级别，0表示任务层，大于等于1表示是非任务层</span>
<span class="kt">uint8_t</span> <span class="k">volatile</span> <span class="n">QK_intNest_</span><span class="p">;</span> <span class="cm">/* start with nesting level of 0 */</span>
<span class="cm">/*......................................................................*/</span>
<span class="cm">/* NOTE: the QK scheduler is entered and exited with interrupts LOCKED */</span>
<span class="cp">#ifndef QF_INT_KEY_TYPE
</span><span class="c1">// 中断上锁策略选择</span>
<span class="kt">void</span> <span class="nf">QK_schedule_</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#else
</span><span class="kt">void</span> <span class="n">QK_schedule_</span><span class="p">(</span><span class="n">QF_INT_KEY_TYPE</span> <span class="n">intLockKey_</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#endif
</span>  <span class="kt">uint8_t</span> <span class="n">p</span><span class="p">;</span>
  <span class="cm">/* the QK scheduler must be called at task level only */</span>
  <span class="c1">// 需要当前为任务层，如果是中断层不执行调度</span>
  <span class="n">Q_REQUIRE</span><span class="p">(</span><span class="n">QK_intNest_</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QPSet64_notEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="cm">/* determine the priority of the highest-priority task ready to run */</span>
    <span class="c1">// 从位图找优先级最高的已就绪对象</span>
    <span class="n">QPSet64_findMax</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="c1">// 判断这个对象优先级是否超过当前优先级</span>
    <span class="c1">// 注意此处如果任务执行中又发送事件给其他对象，导致再次调用本调度函数形成嵌套，通过这个判断可以终止嵌套，防止低优先级任务抢占</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">QK_currPrio_</span><span class="p">)</span>
    <span class="p">{</span><span class="cm">/* do we have a preemption? */</span>
      <span class="c1">// 保存优先级用于恢复</span>
      <span class="kt">uint8_t</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">QK_currPrio_</span><span class="p">;</span> <span class="cm">/* save the initial priority */</span>
      <span class="n">QActive</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="cp">#ifdef QK_TLS </span><span class="cm">/* thread-local storage used? */</span><span class="cp">
</span>      <span class="kt">uint8_t</span> <span class="n">pprev</span> <span class="o">=</span> <span class="n">pin</span><span class="p">;</span>
<span class="cp">#endif
</span>      <span class="k">do</span>
      <span class="p">{</span>
        <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">];</span> <span class="cm">/* obtain the pointer to the AO */</span>
        <span class="c1">// 更新当前优先级</span>
        <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>  <span class="cm">/* this becomes the current task priority */</span>
<span class="cp">#ifdef QK_TLS              </span><span class="cm">/* thread-local storage used? */</span><span class="cp">
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">pprev</span><span class="p">)</span>
        <span class="p">{</span>            <span class="cm">/* are we changing threads? */</span>
          <span class="n">QK_TLS</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="cm">/* switch new thread-local storage */</span>
          <span class="n">pprev</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
<span class="cp">#endif
</span>        <span class="c1">// 解锁中断，运行任务</span>
        <span class="n">QK_INT_UNLOCK_</span><span class="p">();</span>                  <span class="cm">/* unlock the interrupts */</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">QActive_get_</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>               <span class="cm">/* get the next event for this AO */</span>
        <span class="n">QF_ACTIVE_DISPATCH_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* dispatch to the AO */</span>
        <span class="n">QF_gc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>                          <span class="cm">/* garbage collect the event, if necessary */</span>
        <span class="c1">// 再次上锁</span>
        <span class="cm">/* determine the highest-priority AO ready to run */</span>
        <span class="c1">// 再次检测是否有高优先级任务等待执行，比如在上面的RTC步骤中发送事件给了其他任务（优先级比pin也就是调用本函数时的优先级高，在本函数返回前要把这些任务都处理完）</span>
        <span class="n">QK_INT_LOCK_</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">QPSet64_notEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">))</span>
        <span class="p">{</span>
          <span class="n">QPSet64_findMax</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">pin</span><span class="p">);</span>  <span class="cm">/* is the new priority higher than initial? */</span>
      <span class="c1">// 本次调度执行完成，假设内部有递归也递归执行完成，且所有优先级高于本函数调用时优先级的任务全部执行完成，本函数返回前恢复优先级</span>
      <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="n">pin</span><span class="p">;</span> <span class="cm">/* restore the initial priority */</span>
<span class="cp">#ifdef QK_TLS             </span><span class="cm">/* thread-local storage used? */</span><span class="cp">
</span>      <span class="k">if</span> <span class="p">(</span><span class="n">pin</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* no extended context for idle loop */</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">QF_active_</span><span class="p">[</span><span class="n">pin</span><span class="p">];</span>
        <span class="n">QK_TLS</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="cm">/* restore the original TLS */</span>
      <span class="p">}</span>
<span class="cp">#endif
</span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="源文件-qkc--qk-的启动和空闲循环"><span class="mr-2">源文件 qk.c （ QK 的启动和空闲循环）</span><a href="#源文件-qkc--qk-的启动和空闲循环" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qk_pkg.h"</span><span class="cp">
#include</span> <span class="cpf">"qassert.h"</span><span class="cp">
</span><span class="n">Q_DEFINE_THIS_MODULE</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* nothing to do for the QK preemptive kernel */</span>
  <span class="c1">// 给个机会让QK初始化</span>
  <span class="n">QK_init</span><span class="p">();</span> <span class="cm">/* might be defined in assembly */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_onCleanup</span><span class="p">();</span> <span class="cm">/* cleanup callback */</span>
  <span class="cm">/* nothing else to do for the QK preemptive kernel */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 从main调用QF_run转让控制权</span>
<span class="kt">void</span> <span class="nf">QF_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 实现QK内核的启动，可以和 vanilla 内核对比下</span>
  <span class="n">QK_INT_LOCK_KEY_</span>
  <span class="n">QK_INT_LOCK_</span><span class="p">();</span>
  <span class="c1">// 优先级QK_currPrio_从初始的QF_MAX_ACTIVE+1变为0，开始空闲循环</span>
  <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* set the priority for the QK idle loop */</span>
  <span class="c1">// 执行一次调度</span>
  <span class="n">QK_SCHEDULE_</span><span class="p">();</span>            <span class="cm">/* process all events produced so far */</span>
  <span class="n">QK_INT_UNLOCK_</span><span class="p">();</span>
  <span class="n">QF_onStartup</span><span class="p">();</span> <span class="cm">/* startup callback */</span>
  <span class="k">for</span> <span class="p">(;;)</span>
  <span class="p">{</span><span class="cm">/* the QK idle loop */</span>
    <span class="c1">// 给应用程序一个机会去把 CPU放入低功耗睡眠模式，或者执行其他任务(如软件追踪输出)，通常在应用程序层 (BSP) 实现 QK_onIdle()函数</span>
    <span class="c1">// 区别于vanilla 内核，QK内核进入idle前不用上锁（且不能上锁），因为可以实现抢占，只要有事件发生就会触发一次调度，不会导致事件未及时处理</span>
    <span class="n">QK_onIdle</span><span class="p">();</span> <span class="cm">/* invoke the QK on-idle callback */</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 启动活动对象</span>
<span class="kt">void</span> <span class="nf">QActive_start</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prio</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">qSto</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">qLen</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">tls</span><span class="p">,</span>
                   <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">ie</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Q_REQUIRE</span><span class="p">(((</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">prio</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prio</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">QF_MAX_ACTIVE</span><span class="p">));</span>
  <span class="n">QEQueue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">,</span> <span class="n">qSto</span><span class="p">,</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="n">qLen</span><span class="p">);</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>
  <span class="n">QF_add_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* make QF aware of this active object */</span>
<span class="cp">#if defined(QK_TLS) || defined(QK_EXT_SAVE)
</span>  <span class="n">me</span><span class="o">-&gt;</span><span class="n">osObject</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">flags</span><span class="p">;</span> <span class="cm">/* osObject contains the thread flags */</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">tls</span><span class="p">;</span>              <span class="cm">/* contains the pointer to the thread-local storage */</span>
<span class="cp">#else
</span>  <span class="n">Q_ASSERT</span><span class="p">((</span><span class="n">tls</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">0</span><span class="p">));</span>
<span class="cp">#endif
</span>  <span class="n">QF_ACTIVE_INIT_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">ie</span><span class="p">);</span> <span class="cm">/* execute initial transition */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QActive_stop</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_remove_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span> <span class="cm">/* remove this active object from the QF */</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="高级的-qk-特征"><span class="mr-2">高级的 QK 特征</span><a href="#高级的-qk-特征" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="优先级天花板互斥体"><span class="mr-2">优先级天花板互斥体</span><a href="#优先级天花板互斥体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>活动对象应该只通过<code class="language-plaintext highlighter-rouge">事件</code>进行通讯，并且<code class="language-plaintext highlighter-rouge">不共享</code>任何资源。</p><p>你也许想选择共享某些选定的资源，就算要付出增加活动对象之间<code class="language-plaintext highlighter-rouge">耦合</code>的成本。如果你想这么做，你让自己背上了要处理存取这些资源（共享的内存或设备）的内部<code class="language-plaintext highlighter-rouge">互锁</code>的负担。可以用 QF 宏QF_INT_LOCK() 和 QF_INT_UNLOCK() 实现的<code class="language-plaintext highlighter-rouge">临界区</code>机制</p><p>QK 支持优先级<code class="language-plaintext highlighter-rouge">天花板互斥体</code>(priority-ceiling mutex)，在存取一个共享资源时，防止任务级的抢占。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">your_function</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// QMutex类型的临时变量（uint8_t）</span>
  <span class="n">QMutex</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="c1">// 上锁</span>
  <span class="n">mutex</span> <span class="o">=</span> <span class="n">QK_mutexLock</span><span class="p">(</span><span class="n">PRIO_CEILING</span><span class="p">);</span>
  <span class="c1">// 临界区</span>
  <span class="n">You</span> <span class="n">can</span> <span class="n">safely</span> <span class="n">access</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span> <span class="n">here</span>
  <span class="n">QK_mutexUnlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>QK 互斥体(<code class="language-plaintext highlighter-rouge">&lt;qp&gt;\qpc\qk\source\qk_mutex.c</code>):</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="n">QMutex</span> <span class="nf">QK_mutexLock</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">prioCeiling</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="n">QK_INT_LOCK_KEY_</span>
  <span class="n">QK_INT_LOCK_</span><span class="p">();</span>
  <span class="c1">// 临时保存当前优先级</span>
  <span class="n">mutex</span> <span class="o">=</span> <span class="n">QK_currPrio_</span><span class="p">;</span> <span class="cm">/* the original QK priority to return */</span>
  <span class="c1">// 如果当前优先级小于天花板优先级（就是最高优先级，任务最大优先级加1，比所有任务都高）</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QK_currPrio_</span> <span class="o">&lt;</span> <span class="n">prioCeiling</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 当前优先级设为天花板优先级</span>
    <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="n">prioCeiling</span><span class="p">;</span> <span class="cm">/* raise the QK priority */</span>
  <span class="p">}</span>
  <span class="n">QK_INT_UNLOCK_</span><span class="p">();</span>
  <span class="c1">// 返回修改前的（调用本函数时）优先级，用于作为后面unlock时的参数</span>
  <span class="k">return</span> <span class="n">mutex</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*..............................................................*/</span>
<span class="kt">void</span> <span class="nf">QK_mutexUnlock</span><span class="p">(</span><span class="n">QMutex</span> <span class="n">mutex</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QK_INT_LOCK_KEY_</span>
  <span class="n">QK_INT_LOCK_</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QK_currPrio_</span> <span class="o">&gt;</span> <span class="n">mutex</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 恢复优先级</span>
    <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="n">mutex</span><span class="p">;</span> <span class="cm">/* restore the saved priority */</span>
    <span class="n">QK_SCHEDULE_</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">QK_INT_UNLOCK_</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其实类似于关中断让系统无法调度其他进程，只不过这个是应用层面的锁，不需要系统的关中断支持，这样就和操作系统和硬件解耦了。</p><h4 id="本地线程存储"><span class="mr-2">本地线程存储</span><a href="#本地线程存储" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>线程本地存储 (Thread-local storage,TLS) 是一种机制，<code class="language-plaintext highlighter-rouge">变量</code>通过它被<code class="language-plaintext highlighter-rouge">分配</code>，这样每个现存的线程有这个变量的一个<code class="language-plaintext highlighter-rouge">实例</code>。</p><p>该功能是为了解决多线程使用共用的全局变量时的冲突问题。</p><p>例如，ANSI C标准里的 errno 功能。errno 是一个 int 类型的宏，当程序出现问题时，设置该宏为一个<code class="language-plaintext highlighter-rouge">错误码</code>，也就是 errno 的值为上一次错误的错误码。但这个宏是所有线程<code class="language-plaintext highlighter-rouge">共享</code>的，也就是线程无法分清这是哪个线程设置的。</p><p>解决方式是把 errno 定义为一个指针，指向了类型为 <code class="language-plaintext highlighter-rouge">struct_reent</code> 的结构，每个线程都包含了这个结构的对象(线程本地存储)，上下文切换时让 errno 指针指向对应线程的这个对象。不仅解决了重入的问题，还扩展了 errno 的功能，因为<code class="language-plaintext highlighter-rouge">struct_reent</code>结构可以包含大量自定义的错误信息。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/tlsswitch.jpg" alt="tlsswitch" data-proofer-ignore></p><p>QK 通过提供一个上下文切换钩子 QK_TLS() 来支持 TLS概念，在每一次，每一个不同任务的优先级被处理时，它被调用。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define QK_TLS(act_) (_impure_ptr=(struct _reent *)(act_)-&gt;thread)
</span></pre></table></code></div></div><h4 id="扩展的上下文切换对协处理器的支持"><span class="mr-2">扩展的上下文切换（对协处理器的支持）</span><a href="#扩展的上下文切换对协处理器的支持" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>C编译器为中断程序生成的<code class="language-plaintext highlighter-rouge">上下文保存和恢复</code>通常仅包含CPU核心寄存器，<code class="language-plaintext highlighter-rouge">不包括</code>各种协处理器的寄存器，比如围绕 CPU 核心的浮点<code class="language-plaintext highlighter-rouge">协处理器</code>，专门的 DSP 引擎，基带处理器，视频加速器或其他的协处理器。这些寄存器称为<code class="language-plaintext highlighter-rouge">扩展上下文</code></p><p>两种情况不需要保存扩展上下文：</p><ul><li><code class="language-plaintext highlighter-rouge">ISR</code> 和 QK <code class="language-plaintext highlighter-rouge">空闲处理</code>都不会使用协处理器。空闲循环不对应于某个<code class="language-plaintext highlighter-rouge">活动对象</code>，因此它不需要拥有 TLS 内存区域来保存扩展的上下文。（因此， 仅当某个任务抢占别的任务时才需要保存扩展上下文）<li><code class="language-plaintext highlighter-rouge">同步抢占</code>时一般不需要，因为<a href="#同步抢占和异步抢占">同步抢占</a>相当于一次函数调用，发送事件时产生调度，然后等高优先级的处理完通过函数返回，不会在存取某个协处理器时发生</ul><p>这样就只<code class="language-plaintext highlighter-rouge">有异步抢占</code>时才需要保存扩展上下文，也就是在 QK_ISR_EXIT() 宏调用时。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#define QK_ISR_EXIT() do { \
  Lock interrupts \
  Send the EOI instruction to the interrupt controller \
  --QK_intNest_; \
  if (QK_intNest_ == 0) { \
    QK_scheduleExt_(); \
  } \
} while (0)
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">QK_scheduleExt_()</code> 取代 QK_scheduler_() 用于保存扩展上下文。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/tlsextregister.jpg" alt="tlsextregister" data-proofer-ignore></p><p>扩展上下文也包含在 TLS 区</p><p><em>QK 扩展调度器的实现（ <code class="language-plaintext highlighter-rouge">&lt;qp&gt;\qpc\qk\source\qk_ext.c</code>）</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre><td class="rouge-code"><pre><span class="cp">#ifndef QF_INT_KEY_TYPE
</span><span class="kt">void</span> <span class="nf">QK_scheduleExt_</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#else
</span><span class="kt">void</span> <span class="n">QK_scheduleExt_</span><span class="p">(</span><span class="n">QF_INT_KEY_TYPE</span> <span class="n">intLockKey_</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#endif
</span>  <span class="kt">uint8_t</span> <span class="n">p</span><span class="p">;</span>
  <span class="cm">/* the QK scheduler must be called at task level only */</span>
  <span class="n">Q_REQUIRE</span><span class="p">(</span><span class="n">QK_intNest_</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QPSet64_notEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="cm">/* determine the priority of the highest-priority task ready to run */</span>
    <span class="n">QPSet64_findMax</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">QK_currPrio_</span><span class="p">)</span>
    <span class="p">{</span>                             <span class="cm">/* do we have a preemption? */</span>
      <span class="kt">uint8_t</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">QK_currPrio_</span><span class="p">;</span> <span class="cm">/* save the initial priority */</span>
      <span class="n">QActive</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="cp">#ifdef QK_TLS </span><span class="cm">/* thread-local storage used? */</span><span class="cp">
</span>      <span class="kt">uint8_t</span> <span class="n">pprev</span> <span class="o">=</span> <span class="n">pin</span><span class="p">;</span>
<span class="cp">#endif
#ifdef QK_EXT_SAVE </span><span class="cm">/* extended context-switch used? */</span><span class="cp">
</span>      <span class="c1">// 扩展上下文保存，pin为0表示空闲循环，不保存</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pin</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>                      <span class="cm">/*no extended context for the idle loop */</span>
        <span class="c1">// 找到被抢占的活动对象的指针</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">QF_active_</span><span class="p">[</span><span class="n">pin</span><span class="p">];</span> <span class="cm">/* the pointer to the preempted AO */</span>
        <span class="c1">// 在调度前保存扩展上下文</span>
        <span class="c1">// 即使不启用TLS也会保存</span>
        <span class="n">QK_EXT_SAVE</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>      <span class="cm">/* save the extended context */</span>
      <span class="p">}</span>
<span class="cp">#endif
</span>      <span class="k">do</span>
      <span class="p">{</span>
        <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">QF_active_</span><span class="p">[</span><span class="n">p</span><span class="p">];</span> <span class="cm">/* obtain the pointer to the AO */</span>
        <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>  <span class="cm">/* this becomes the current task priority */</span>
<span class="cp">#ifdef QK_TLS              </span><span class="cm">/* thread-local storage used? */</span><span class="cp">
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">pprev</span><span class="p">)</span>
        <span class="p">{</span>            <span class="cm">/* are we changing threads? */</span>
          <span class="c1">// 切换TLS指针</span>
          <span class="n">QK_TLS</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="cm">/* switch new thread-local storage */</span>
          <span class="n">pprev</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
<span class="cp">#endif
</span>        <span class="n">QK_INT_UNLOCK_</span><span class="p">();</span>                  <span class="cm">/* unlock the interrupts */</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">QActive_get_</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>               <span class="cm">/* get the next event for this AO */</span>
        <span class="n">QF_ACTIVE_DISPATCH_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* dispatch to the AO */</span>
        <span class="n">QF_gc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>                          <span class="cm">/* garbage collect the event, if necessary */</span>
        <span class="n">QK_INT_LOCK_</span><span class="p">();</span>
        <span class="cm">/* determine the highest-priority AO ready to run */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">QPSet64_notEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">))</span>
        <span class="p">{</span>
          <span class="n">QPSet64_findMax</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QK_readySet_</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">pin</span><span class="p">);</span>  <span class="cm">/* is the new priority higher than initial? */</span>
      <span class="n">QK_currPrio_</span> <span class="o">=</span> <span class="n">pin</span><span class="p">;</span> <span class="cm">/* restore the initial priority */</span>
<span class="cp">#if defined(QK_TLS) || defined(QK_EXT_RESTORE)
</span>      <span class="c1">// 只有被抢占时才需要恢复，0表示还在空闲循环，没有活动对象运行，不用恢复</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pin</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>                      <span class="cm">/*no extended context for the idle loop */</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">QF_active_</span><span class="p">[</span><span class="n">pin</span><span class="p">];</span> <span class="cm">/* the pointer to the preempted AO */</span>
<span class="cp">#ifdef QK_TLS                </span><span class="cm">/* thread-local storage used? */</span><span class="cp">
</span>        <span class="c1">// 切换TLS指针</span>
        <span class="n">QK_TLS</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>           <span class="cm">/* restore the original TLS */</span>
<span class="cp">#endif
#ifdef QK_EXT_RESTORE      </span><span class="cm">/* extended context-switch used? */</span><span class="cp">
</span>        <span class="c1">// 恢复扩展上下文</span>
        <span class="n">QK_EXT_RESTORE</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="cm">/* restore the extended context */</span>
<span class="cp">#endif
</span>      <span class="p">}</span>
<span class="cp">#endif
</span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="移植-qk"><span class="mr-2">移植 QK</span><a href="#移植-qk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>QK 可以被移植到某个处理器和编译器，如果它们满足以下条件：</p><ol><li>处理器支持一个<code class="language-plaintext highlighter-rouge">硬件堆栈</code>，它可以容纳很多数据（最少 256 字节）。<li>C或 C++编译器可以生成<code class="language-plaintext highlighter-rouge">可重入代码</code>。特别的，编译器必须可以在堆栈分配<code class="language-plaintext highlighter-rouge">自动变量</code>。<li>可以从 C/C++ 里上锁和解锁<code class="language-plaintext highlighter-rouge">中断</code>。<li>系统提供了一个<code class="language-plaintext highlighter-rouge">时钟节拍中断</code>（通常是 10 到 100Hz ）。</ol><p>后面省略，没有用</p><h2 id="移植和配置-qf"><span class="mr-2">移植和配置 QF</span><a href="#移植和配置-qf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>QF 包含了一个被清楚定义的<code class="language-plaintext highlighter-rouge">平台抽象层 PAL</code>（ platform abstraction layer ），它封装了所有平台相关的代码，清晰把它和平台无关的代码区分开</p><h3 id="qp-平台抽象层"><span class="mr-2">QP 平台抽象层</span><a href="#qp-平台抽象层" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>QP 事件驱动式平台的所有软件构件，比如 <code class="language-plaintext highlighter-rouge">QEP</code> 事件处理器和 <code class="language-plaintext highlighter-rouge">QF</code> 实时框架，包含了一个<code class="language-plaintext highlighter-rouge">平台抽象层 PAL</code>。这个 PAL 是一个 indirection 层，它隐藏了 QP 运行时硬件和软件环境的差异，因此 QP 源代码不需要被修改从而在一个不同的环境运行。相反，修改 QP 的所有必需的改变被限制在 PAL 内。</p><h4 id="生成-qp-应用程序"><span class="mr-2">生成 QP 应用程序</span><a href="#生成-qp-应用程序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>你在使用的 QP 移植由 <code class="language-plaintext highlighter-rouge">qf_port.h</code> 头文件和 <code class="language-plaintext highlighter-rouge">QF 库文件</code>所在的目录分支决定。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qpport.jpg" alt="qpport" data-proofer-ignore></p><p>编译+链接，QP 库允许连接器在链接时消除任何没有被引用的 QP 代码</p><h4 id="创建-qp-库"><span class="mr-2">创建 QP 库</span><a href="#创建-qp-库" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 示例（QEP 或 QK 可以参考这个）：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qplibbuild.jpg" alt="qplibbuild" data-proofer-ignore></p><p>平台相关的 port 代码和平台无关的代码链接在一个 qf.lib 库中</p><h4 id="目录和文件"><span class="mr-2">目录和文件</span><a href="#目录和文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>PAL 使用一个一致的<code class="language-plaintext highlighter-rouge">目录结构</code>，允许你很容易的找到 QP 向某个给定 <code class="language-plaintext highlighter-rouge">CPU</code>，<code class="language-plaintext highlighter-rouge">操作系统</code>和<code class="language-plaintext highlighter-rouge">编译器</code>的移植。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre><td class="rouge-code"><pre>qpc\ - QP/C root directory (qpcpp\ for QP/C++),根目录可移动和改名，内部用的都是相对路径
|
+-ports\ - Platform-specific QP ports
| +-80x86\ - Ports to the 80x86 processor，CPU架构作为第一层，如80x86、ARM，在嵌入式领域，CPU架构比操作系统更重要
| | +-dos\ - Ports to DOS with the "vanilla" cooperative kernel，操作系统放在第二层
| | | +-tcpp101\ - Ports with the Turbo C++ 1.01 compiler，编译器在第三层，Turbo C+ +1.01、GCC等
| | | | +-l\ - Ports using the Large memory model，编译器可以为不同的 CPU模式生成代码。例如在 DOS下用于 80x86 的某个编译器，可以生成 small， compact ，large或huge内存模型。
| | | | | +-dbg\ - Debug build，QP 库文件可以使用不同的编译开关和优化选项来编译，存放开启调试编译选项的二进制文件
| | | | | | +-qf.lib - QF library，不同平台库文件命名规则也不同，Linux为libqf.a
| | | | | | +-qep.lib - QEP library
| | | | | +-rel\ - Release build,使用发行编译选项的二进制文件
| | | | | +-spy\ - Spy build (with software instrumentation)，带qs追踪的二进制文件
| | | | | +-make.bat - batch script for building the QP libraries，makefile文件
| | | | | +-qep_port.h - QEP platform-dependent include file
| | | | | +-qf_port.h - QFplatform-dependent include file，平台相关头文件
| | | | | +-qs_port.h - QSplatform-dependent include file
| | | | | +-qp_port.h - QPplatform-dependent include file
| | |
| | +-qk\ - Ports to the QK preemptive kernel
| | | +-. . .
| | |
| | +-ucos2\ - Ports to the mC/OS-II RTOS
| | | +-tcpp101\ - Ports with the Turbo C++ 1.01 compiler
| | | | +-l\ - Ports using the Large memory model
| | | | | +-ucos2.86\ - mC/OS-II v2.86 object code and header files
| | | | | +-src\ - Port-specific source files
| | | | | | +-qf_port.c - QF port to mC/OS-II source file
| | | | | +-. . .
| | |
| | +-linux\ - Ports to the Linux operating system (POSIX)
| | +-gnu\ - Ports with the GNU compiler
| | | | +-src\ - Port-specific source files
| | | | | +-qf_port.c - QF port to Linux source file
| | +-. . .
| |
| +-cortex-m3\ - Ports to the Cortex-M3 processor，传统ARM和m3架构差别较大，独立设置
| | +-vanilla\ - Ports to the "vanilla" cooperative kernel
| | | +-iar\ - Ports with the IAR compiler
| | | | +-dbg\ - Debug build
| | | | +-rel\ - Release build
| | | | +-spy\ - Spy build (with software instrumentation)
| | | | +-make.bat - batch script for building QP libraries
| | | | +-qep_port.h - QEP platform-dependent include file
| | | | +-qf_port.h - QF platform-dependent include file
| | | | +-qs_port.h - QS platform-dependent include file
| | | | +-qp_port.h - QP platform-dependent include file
| | |...
| | +-qk\ - Ports to the QK preemptive kernel
| | +-iar\ - Ports with the IAR compiler
| +-. . . - Ports to other CPUs
|
+-examples\ - Platform-specific QP examples
| +-80x86\ - Examples for the 80x86 processor
| | +-dos\ - Examples for DOS with the "vanilla" cooperative kernel
| | +-tcpp101\ - Examples with the Turbo C++ 1.01 compiler
| | +-l\ - Examples using the Large memory model
| | +-dpp\ - DPP example，哲学家就餐问题，单独目录
| | | +-dbg\ - Debug build
| | | | +-dpp.exe - Debug executable
| | | +-rel\ - Release build
| | | | +-dpp.exe - Release executable
| | | +-spy\ - Spy build (with software instrumentation)
| | | | +-dpp.exe - Spy executable
| | | +-DPP-DBG.PRJ - Turbo C++ project to build the Debug version
| | +-game\ - "Fly ’n’ Shoot" game example
| | +-. . .
| +-cortex-m3\ - Examples for the Cortex-M3 processor
| | +-vanilla\ - Examples for the "vanilla" cooperative kernel
| | | +-iar\ - Examples with the IAR compiler
| | +-dpp\ - DPP example
| | +-game\ - "Fly ’n’ Shoot" game example
| | +-. . . - Other examples
| +-. . . - Examples for other CPUs
|
+-include\ - Platform independent QP header files，平台无关头文件
| +-qep.h - QEP platform-independent interface
| +-qf.h - QF platform-independent interface
| +-qk.h - QK platform-independent interface
| +-qs.h - QS platform-independent interface
| +-. . . - Other platform-independent QP header files
|
+-qep\ - QEP event processor，每个 QP 构件的平台独立的源代码在独立的目录里。
| +-source\ - QEP platform-independent source code (*.C files)
| | +-. . .
+-qf\ - QF real-time framework
| +-source\ - QF platform-independent source code (*.C files)
| | +-. . .
+-qk\ - QK preemptive kernel
| +-source\ - QK platform-independent source code (*.C files)
| | +-. . .
+-qs\ - QS software tracing
| +-source\ - QS platform-independent source code (*.C files)
| | +-. . .
</pre></table></code></div></div><h4 id="头文件-qep_porth"><span class="mr-2">头文件 qep_port.h</span><a href="#头文件-qep_porth" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>TODO:Q_ROM 和哈佛架构相关，需要了解下</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qep_port_h
#define qep_port_h
</span><span class="cm">/* special keyword used for ROM objects */</span>
<span class="cp">#define Q_ROM ????
</span><span class="cm">/* specific pointer variant for accessing const objects in ROM */</span>
<span class="cp">#define Q_ROM_VAR ????
</span><span class="cm">/* platform-specific access to constant data bytes in ROM */</span>
<span class="cp">#define Q_ROM_BYTE(rom_var_) ????
</span><span class="cm">/* size of the QSignal data type */</span>
<span class="cp">#define Q_SIGNAL_SIZE ?
</span><span class="cm">/* exact-width integer types */</span> 
<span class="c1">// 使用编译器提供的标准stdint.h头文件或自定义编写来定义QP需要的扩展类型</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="c1">              /* WG14/N843 C99 Standard, Section 7.18.1.1 */</span><span class="cp">
</span><span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="kt">int8_t</span><span class="p">;</span>      <span class="cm">/* signed 8-bit integer */</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">short</span> <span class="kt">int16_t</span><span class="p">;</span>    <span class="cm">/* signed 16-bit integer */</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="kt">int32_t</span><span class="p">;</span>     <span class="cm">/* signed 32-bit integer */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="kt">uint8_t</span><span class="p">;</span>   <span class="cm">/* unsigned 8-bit integer */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">uint16_t</span><span class="p">;</span> <span class="cm">/* unsigned 16-bit integer */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">uint32_t</span><span class="p">;</span>  <span class="cm">/* unsigned 32-bit integer */</span>
<span class="cp">#include</span> <span class="cpf">"qep.h"</span><span class="c1">                 /* QEP platform-independent public interface */</span><span class="cp">
#endif                           </span><span class="cm">/* qep_port_h */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="头文件-qf_porth"><span class="mr-2">头文件 qf_port.h</span><a href="#头文件-qf_porth" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>头文件 qf_port.h 包含了 PAL宏的定义， typedef，包含文件，和用于移植和配置 QF 实时框架的常数。 这是目前为止在整个 QP PAL 里最复杂和重要的文件。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qf_port_h
#define qf_port_h
</span><span class="cm">/* Types of platform-specific QActive data members *************************/</span>
<span class="c1">// 可以使用RTOS/OS提供的消息队列，也可以用QF自带的原生队列用于事件队列</span>
<span class="cp">#define QF_EQUEUE_TYPE ????
</span><span class="c1">// 使用QF原生队列时必需，QF_OS_OBJECT_TYPE 数据成员包含一个操作系统相关的原语，在队列为空时有效的阻塞原生 QF 事件队列。</span>
<span class="cp">#define QF_OS_OBJECT_TYPE ????
</span><span class="c1">// 包含和活动对象联合的线程处理</span>
<span class="cp">#define QF_THREAD_TYPE ????
</span><span class="cm">/* Base class for derivation of QActive ***********************************/</span>
<span class="c1">// 下面的宏用于自定义QActive的基类（默认时QHsm），一般不使用，命名结尾有下划线'_'作为标志</span>
<span class="cp">#define QF_ACTIVE_SUPER_ ????
#define QF_ACTIVE_CTOR_(me_, initial_) ????
#define QF_ACTIVE_INIT_(me_, e_) ????
#define QF_ACTIVE_DISPATCH_(me_, e_) ????
#define QF_ACTIVE_STATE_ ????
</span><span class="cm">/* The maximum number of active objects in the application ******************/</span>
<span class="c1">// 活动对象最大数量，不超过63，8或更小时性能更高</span>
<span class="cp">#define QF_MAX_ACTIVE ????
</span><span class="cm">/* Various object sizes within the QF framework ***************************/</span>
<span class="c1">// 都有默认值，空间大小和计数器大小</span>
<span class="cp">#define QF_EVENT_SIZ_SIZE 2
#define QF_EQUEUE_CTR_SIZE 1
</span><span class="c1">// 内存池块大小，每块2字节</span>
<span class="cp">#define QF_MPOOL_SIZ_SIZE 2
</span><span class="c1">// 内存池计数器大小，为2表示最大表示0xFFFF个块</span>
<span class="cp">#define QF_MPOOL_CTR_SIZE 2
#define QF_TIMEEVT_CTR_SIZE 2
</span><span class="cm">/* QF critical section mechanism *****************************************/</span>
<span class="c1">// 临界区</span>
<span class="c1">// “保存和恢复中断状态”的策略和“无条件上锁和解锁中断”策略标志</span>
<span class="cp">#define QF_INT_KEY_TYPE ????
#define QF_INT_LOCK(key_) ????
#define QF_INT_UNLOCK(key_) ????
</span><span class="cm">/* Include files used by this QF port *************************************/</span>
<span class="c1">// 内核头文件</span>
<span class="cp">#include</span> <span class="cpf">&lt;????.h&gt;</span><span class="c1">     /* underlying OS/RTOS/Kernel interface */</span><span class="cp">
#include</span> <span class="cpf">"qep_port.h"</span><span class="c1"> /* QEP port */</span><span class="cp">
#include</span> <span class="cpf">"qequeue.h"</span><span class="c1">  /* native QF event-queue */</span><span class="cp">
#include</span> <span class="cpf">"qmpool.h"</span><span class="c1">   /* native QF memory-pool */</span><span class="cp">
#include</span> <span class="cpf">"qvanilla.h"</span><span class="c1"> /* native QF "vanilla" kernel */</span><span class="cp">
#include</span> <span class="cpf">"qf.h"</span><span class="c1">       /* platform-independent QF interface */</span><span class="cp">
</span><span class="cm">/**********************************************************************
 * Interface used only inside QF, but not in applications
 */</span>
<span class="cm">/* Active object event queue operations ***********************************/</span>
<span class="c1">// 仅用于QF和使用原生事件队列时的宏，名字结尾有下划线，避免用于用户应用。</span>
<span class="c1">// 信号量耗尽阻塞</span>
<span class="cp">#define QACTIVE_EQUEUE_WAIT_(me_) ????
</span><span class="c1">// 信号量补充解除阻塞</span>
<span class="cp">#define QACTIVE_EQUEUE_SIGNAL_(me_) ????
</span><span class="c1">// 通知事件队列为空，比如vanilla需要在队列为空时将活动对象移出预备执行队列</span>
<span class="cp">#define QACTIVE_EQUEUE_ONEMPTY_(me_) ????
</span><span class="cm">/* QF event pool operations **********************************************/</span>
<span class="c1">// 事件池</span>
<span class="cp">#define QF_EPOOL_TYPE_ ????
#define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) ????
#define QF_EPOOL_EVENT_SIZE_(p_) ????
#define QF_EPOOL_GET_(p_, e_) ????
#define QF_EPOOL_PUT_(p_, e_) ????
</span><span class="cm">/* Global objects required by the QF port ***********************************/</span>
<span class="k">extern</span> <span class="o">????</span> <span class="p">;</span>
<span class="p">...</span>
<span class="cp">#endif </span><span class="cm">/* qf_port_h */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="源代码-qf_portc"><span class="mr-2">源代码 qf_port.c</span><a href="#源代码-qf_portc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>qf_port.c 源文件定义了 QF 移植和平台相关的代码。不是所有 QF 移植都需要这个文件。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
</pre><td class="rouge-code"><pre><span class="c1">// 这个 qf_pkg.h 头文件包括 qf_port.h ，但是它还定义了一些内部宏和仅在 QF 构件内部共享的对象。</span>
<span class="cp">#include</span> <span class="cpf">"qf_pkg.h"</span><span class="cp">
</span><span class="c1">// qf_port.h 源文件使用 QP 断言</span>
<span class="cp">#include</span> <span class="cpf">"qassert.h"</span><span class="cp">
</span><span class="c1">// 见上面[C 和 C++ 里可定制的断言]，用于指定模块名，用于日志打印时显示的名称</span>
<span class="n">Q_DEFINE_THIS_MODULE</span><span class="p">(</span><span class="n">qf_port</span><span class="p">)</span>
<span class="cm">/* Global objects -------------------------------------------------------*/</span>
<span class="p">...</span>
<span class="cm">/* Local objects---------------------------------------------------------*/</span>
<span class="p">...</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">char</span> <span class="k">const</span> <span class="n">Q_ROM</span> <span class="o">*</span><span class="n">Q_ROM_VAR</span>
<span class="nf">QF_getPortVersion</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">Q_ROM</span> <span class="n">Q_ROM_VAR</span> <span class="n">version</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"4.0.00"</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">version</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="c1">// 系统将控制权交给QF框架</span>
<span class="kt">void</span> <span class="nf">QF_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QActive_start</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span>
                   <span class="kt">uint8_t</span> <span class="n">prio</span><span class="p">,</span>                        <span class="cm">/* the unique priority */</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">qSto</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">qLen</span><span class="p">,</span> <span class="cm">/* event queue */</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">stkSto</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">stkSize</span><span class="p">,</span>      <span class="cm">/* per-task stack */</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">ie</span><span class="p">)</span>                    <span class="cm">/* the initialization event */</span>
<span class="p">{</span>
  <span class="c1">// 配置优先级</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>         <span class="cm">/* set the QF priority */</span>
  <span class="c1">// 注册到QF</span>
  <span class="n">QF_add_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>             <span class="cm">/* make QF aware of this active object */</span>
  <span class="c1">// 触发最顶初始转换（相当于初始化）</span>
  <span class="n">QF_ACTIVE_INIT_</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">ie</span><span class="p">);</span> <span class="cm">/* execute the initial transition */</span>
  <span class="cm">/* Initialize the event queue object ’me-&gt;eQueue’ using qSto and qLen */</span>
  <span class="c1">// 初始化事件队列</span>
  <span class="cm">/* Create and start the thread ’me-&gt;thread’ of the underlying RTOS */</span>
  <span class="c1">// 启动线程</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QActive_stop</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* Cleanup me-&gt;eQueue or me-&gt;osObject */</span>
  <span class="c1">// 执行清理工作，是否非栈中的内存</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="cm">/* You need to define QActive_postFIFO(), QActive_postLIFO(), and
 * QActive_get_() only if your QF port uses the queue facility from
 * the underlying OS/RTOS.
 */</span>
<span class="c1">// 只有用了底层OS提供的队列工具时，才需要重写这三个函数，如果用的QF自带的事件队列则不需要</span>
<span class="kt">void</span> <span class="nf">QActive_postFIFO</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>                            <span class="cm">/* is it a dynamic event? */</span>
    <span class="o">++</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* increment the reference counter */</span>
  <span class="p">}</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
  <span class="cm">/* Post event pointer ’e’ to the message queue of the RTOS ’me-&gt;eQueue’
   * using the FIFO policy without blocking. Also assert that the queue
   * accepted the event pointer.
   */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QActive_postLIFO</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_INT_LOCK_KEY_</span>
  <span class="n">QF_INT_LOCK_</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">dynamic_</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>                            <span class="cm">/* is it a dynamic event? */</span>
    <span class="o">++</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dynamic_</span><span class="p">;</span> <span class="cm">/* increment the reference counter */</span>
  <span class="p">}</span>
  <span class="n">QF_INT_UNLOCK_</span><span class="p">();</span>
  <span class="cm">/* Post event pointer ’e’ to the message queue of the RTOS ’me-&gt;eQueue’
   * using the LIFO policy without blocking. Also assert that the queue
   * accepted the event pointer.
   */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="nf">QActive_get_</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* Get the next event from the active object queue ’me-&gt;eQueue’.
   * Block indefinitely as long as the queue is empty. Assert no errors
   * in the queue operation. Return the event pointer to the caller.
   */</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="和平台相关的-qf-回调函数"><span class="mr-2">和平台相关的 QF 回调函数</span><a href="#和平台相关的-qf-回调函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>下面这几个函数是属于应用程序而不是QF框架的(意思就是就算这几个函数不定义，QF也能正常运行，不是必需的)。它们不在QF_port.c中定义，在 <code class="language-plaintext highlighter-rouge">QP 应用开发</code>中有说明</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">QF_onStartup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></table></code></div></div><p>在 QF 取得应用程序的控制之前这个回调函数被调用。 QF_onStartup()回调函数的主要意图是<code class="language-plaintext highlighter-rouge">初始化并启动中断</code>(TICK时钟中断)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">QF_onCleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></table></code></div></div><p>在 QF <code class="language-plaintext highlighter-rouge">返回</code>底层操作系统或 RTOS 前，调用 QF_onCleanup(void)。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">QF_onIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="err">或</span> <span class="kt">void</span> <span class="n">QF_onIdle</span><span class="p">(</span><span class="n">QF_INT_KEY_TYPE</span> <span class="n">lockKey</span><span class="p">)</span>
</pre></table></code></div></div><p>内建在 QF 里的合作式 vanilla 内核调用 QF_onIdle() 。这个回调函数的声明取决于在 QF 移植里采用的<code class="language-plaintext highlighter-rouge">中断上锁策略</code>。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">Q_onAssert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="n">Q_ROM</span> <span class="o">*</span> <span class="k">const</span> <span class="n">Q_ROM_VAR</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">断言失败</code>时的处理</p><h4 id="系统时钟节拍调用-qf_tick-"><span class="mr-2">系统时钟节拍（调用 QF_tick() ）</span><a href="#系统时钟节拍调用-qf_tick-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>需要定时调用 QF_tick() 来让 QF 正常工作。一般是在系统节拍 ISR 中调用。如果是 Linux 这种不允许修改 ISR 的，就要开个节拍器线程再加上睡眠和定时唤醒来模拟。</p><h4 id="创建-qf-库"><span class="mr-2">创建 QF 库</span><a href="#创建-qf-库" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>不是所有 QF 源文件都要包含。</p><p><code class="language-plaintext highlighter-rouge">qa_fifo.c</code>,<code class="language-plaintext highlighter-rouge">qa_lifo.c</code>,<code class="language-plaintext highlighter-rouge">qa_get_.c</code>，如果自己定义了QActive_postFIFO()，QActive_postLIFO()，和 QActive_get_()可以不包含，也就是仅在使用 QF 原生的队列时才包含</p><p><code class="language-plaintext highlighter-rouge">qvanilla.c</code>，仅当你使用vanilla合作式内核时才需包含这个文件。</p><h3 id="移植合作式-vanilla-内核"><span class="mr-2">移植合作式 Vanilla 内核</span><a href="#移植合作式-vanilla-内核" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>把 vanilla 内核本身移植到目标 CPU 和编译器上</p><h4 id="头文件-qep_porth-1"><span class="mr-2">头文件 qep_port.h</span><a href="#头文件-qep_porth-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>展示了用于 80x86/DOS/Turbo C++ 1.01/Large内存模型的 qep_port.h头文件</p><p><em>用于 <code class="language-plaintext highlighter-rouge">80x86/DOS/Turbo C++ 1.01/Large </code>内存模型的 qep_port.h 头文件:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qep_port_h
#define qep_port_h
</span><span class="cm">/* Exact-width integer types for DOS/Turbo C++ 1.01/Large memory model */</span>
<span class="c1">// 因为Turbo C++不是标准编译器，所以不带stdint.h，要自己指定扩展类型</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="kt">int8_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="kt">int16_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="kt">int32_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="kt">uint8_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="kt">uint16_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">uint32_t</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">"qep.h"</span><span class="c1"> /* QEP platform-independent public interface */</span><span class="cp">
#endif           </span><span class="cm">/* qep_port_h */</span><span class="cp">
</span></pre></table></code></div></div><p><em>用于 <code class="language-plaintext highlighter-rouge">Cortex-M3/IAR</code> 的 qep_port.h头文件:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qep_port_h
#define qep_port_h
</span><span class="c1">// IAR是标准的编译器，所以携带stdint.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="c1"> /* C99-standard exact-width integer types */</span><span class="cp">
#include</span> <span class="cpf">"qep.h"</span><span class="c1">    /* QEP platform-independent public interface */</span><span class="cp">
#endif              </span><span class="cm">/* qep_port_h */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="头文件-qf_porth-1"><span class="mr-2">头文件 qf_port.h</span><a href="#头文件-qf_porth-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>最重要的移植决定是选择上锁和解锁中断的策略。见<a href="#保存和恢复中断状态">保存和恢复中断状态</a></p><p>通常，你的第一安全选择应该是更先进的<code class="language-plaintext highlighter-rouge">保存和恢复中断状态</code>策略。然而，如果你发现在 ISR 内解锁中断是安全的，因为你的目标处理器可以在硬件对<code class="language-plaintext highlighter-rouge">中断优先级排序</code>，你可以使用简单和快捷的<code class="language-plaintext highlighter-rouge">无条件中断解锁</code>策略</p><p><em>用于 80x86/DOS/Turbo C++ 1.01/Large 内存模型的 qf_port.h 头文件：</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qf_port_h
#define qf_port_h
</span><span class="cm">/* DOS critical section entry/exit */</span>
<span class="cm">/* QF_INT_KEY_TYPE not defined: "unconditional interrupt unlocking" policy */</span>
<span class="c1">// 80x86/DOS/Turbo C++ 1.01/Large内存模型内有基于优先级的中断控制器8259A，所以用无条件中断解锁策略</span>
<span class="cp">#define QF_INT_LOCK(dummy) disable()
#define QF_INT_UNLOCK(dummy) enable()
#include</span> <span class="cpf">&lt;dos.h&gt;</span><span class="c1">      /* DOS API, including disable()/enable() prototypes */</span><span class="cp">
#undef outportb       </span><span class="cm">/*don’t use the macro because it has a bug in Turbo C++ 1.01*/</span><span class="cp">
#include</span> <span class="cpf">"qep_port.h"</span><span class="c1"> /* QEP port */</span><span class="cp">
#include</span> <span class="cpf">"qvanilla.h"</span><span class="c1"> /* The "Vanilla" cooperative kernel */</span><span class="cp">
#include</span> <span class="cpf">"qf.h"</span><span class="c1">       /* QF platform-independent public interface */</span><span class="cp">
#endif                </span><span class="cm">/* qf_port_h */</span><span class="cp">
</span></pre></table></code></div></div><p><em>Cortex-M3/IAR的 qf_port.h 头文件:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qf_port_h
#define qf_port_h
</span><span class="cm">/* QF critical section entry/exit */</span>
<span class="cm">/* QF_INT_KEY_TYPE not defined: "unconditional interrupt unlocking" policy */</span>
<span class="c1">// Cortex-M3 有一个标准的嵌套向量中断控制器 NVIC, 所以用无条件中断解锁策略</span>
<span class="cp">#define QF_INT_LOCK(dummy) __disable_interrupt()
#define QF_INT_UNLOCK(dummy) __enable_interrupt()
#include</span> <span class="cpf">&lt;intrinsics.h&gt;</span><span class="c1"> /* IAR intrinsic functions */</span><span class="cp">
#include</span> <span class="cpf">"qep_port.h"</span><span class="c1">   /* QEP port */</span><span class="cp">
#include</span> <span class="cpf">"qvanilla.h"</span><span class="c1">   /* The "Vanilla" cooperative kernel */</span><span class="cp">
#include</span> <span class="cpf">"qf.h"</span><span class="c1">         /* QF platform-independent public interface */</span><span class="cp">
#endif                  </span><span class="cm">/* qf_port_h */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="系统时钟节拍qf_tick"><span class="mr-2">系统时钟节拍（QF_tick()）</span><a href="#系统时钟节拍qf_tick" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>DOS的系统时钟节拍 ISR ，它由连接到 IRQ0 的 <code class="language-plaintext highlighter-rouge">8253/8254</code> 时间计数器芯片的<code class="language-plaintext highlighter-rouge">通道 0</code> 触发</p><p><em>80x86/DOS/Turbo C++ 1.01/Large 内存模式下的系统时钟节拍 ISR:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">interrupt</span> <span class="nf">ISR_tmr0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>                       <span class="cm">/* entered with interrupts LOCKED */</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* unlock interrupts */</span>
  <span class="c1">// 执行QF框架内的tick处理函数</span>
  <span class="n">QF_tick</span><span class="p">();</span>
  <span class="cm">/* do some application-specific work ... */</span>
  <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>   <span class="cm">/* lock interrupts again */</span>
  <span class="n">outportb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span> <span class="cm">/* write EOI to the master 8259A PIC */</span>
<span class="p">}</span>
</pre></table></code></div></div><p>用于 Cortex-M3 的系统时钟节拍 ISR ，它由特别为这个目的而设计的，被称为 <code class="language-plaintext highlighter-rouge">SysTick</code> 的周期性定时器触发。进 ISR 是中断是解锁的，无需手动解锁。NVIC 中断控制器自动完成发送 EOI，不需要手动发送 EOI 指令</p><p><em>Cortex-M3/IAR的 SysTick ISR:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ISR_SysTick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* entered with interrupts UNLOCKED */</span>
  <span class="n">QF_tick</span><span class="p">();</span>
  <span class="cm">/* do some application-specific work ... */</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="空闲处理qf_onidel"><span class="mr-2">空闲处理（QF_onIdel()）</span><a href="#空闲处理qf_onidel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>只要 vanilla 内核探测到系统里所有活动对象时间队列为空，它就调用 <code class="language-plaintext highlighter-rouge">QF_onIdle()</code> 回调函数。</p><p>一般用于开启低功耗模式</p><p>80x86 没有低功耗模式，所以只解锁中断</p><p><em>用于 80x86/DOS 的 QF_onIdle() 回调函数:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QF_onIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>                       <span class="cm">/* entered with interrupts LOCKED */</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* always unlock interrupts */</span>
  <span class="cm">/* do some more application-specific work ... */</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>用于 Cortex-M3/IAR 的 QF_onIdle() 回调函数:</em></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QF_onIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* entered with interrupts LOCKED */</span>
<span class="cp">#ifdef NDEBUG
</span>  <span class="cm">/* Put the CPU and peripherals to the low-power mode.
   * NOTE: You might need to customize the clock management for your
   * application, by gating the clock to the selected peripherals.
   * See the datasheet for your particular Cortex-M3 MCU.
   */</span>
  <span class="c1">// 用 WFI 指令暂停 CPU（低功耗模式），需要通过中断唤醒</span>
  <span class="kr">__asm</span><span class="p">(</span><span class="s">"WFI"</span><span class="p">);</span> <span class="cm">/* Wait-For-Interrupt */</span>
<span class="cp">#endif
</span>  <span class="c1">// 必须通过中断唤醒，所以这里一定要开中断</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* always unlock interrupts */</span>
  <span class="cm">/* optionally do some application-specific work ... */</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="qf-移植到-ucos-ii-常规-rtos"><span class="mr-2">QF 移植到 uc/os-II (常规 RTOS)</span><a href="#qf-移植到-ucos-ii-常规-rtos" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>TODO:uc/os-II不太了解，以后用到再说</p><h3 id="qf-移植到-linux-常规-posix-兼容的操作系统"><span class="mr-2">QF 移植到 Linux （常规 POSIX 兼容的操作系统）</span><a href="#qf-移植到-linux-常规-posix-兼容的操作系统" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>大型操作系统和RTOS/裸机的区别是不允许关开中断，只能使用系统提供的 API（POSIX API、Win32 API）做有限的操作</p><h4 id="头文件-qep_porth-2"><span class="mr-2">头文件 qep_port.h</span><a href="#头文件-qep_porth-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qep_port_h
#define qep_port_h
</span><span class="cm">/* 2-byte (64K) signal space */</span>
<span class="c1">// 增加信号数量，64K个</span>
<span class="cp">#define Q_SIGNAL_SIZE 2
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="c1"> /* C99-standard exact-width integers */</span><span class="cp">
#include</span> <span class="cpf">"qep.h"</span><span class="c1">    /* QEP platform-independent public interface */</span><span class="cp">
#endif              </span><span class="cm">/* qep_port_h */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="头文件-qf_porth-2"><span class="mr-2">头文件 qf_port.h</span><a href="#头文件-qf_porth-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qf_port_h
#define qf_port_h
</span><span class="cm">/* Linux event queue and thread types */</span>
<span class="c1">// 使用QF原生QEQueue作为事件队列</span>
<span class="cp">#define QF_EQUEUE_TYPE QEQueue
</span><span class="c1">// 使用POSIX中的条件变量作为事件队列为空时的阻塞标志</span>
<span class="cp">#define QF_OS_OBJECT_TYPE pthread_cond_t
</span><span class="c1">// 每个活动对象一个线程</span>
<span class="cp">#define QF_THREAD_TYPE pthread_t
</span><span class="cm">/* The maximum number of active objects in the application */</span>
<span class="c1">// 最大活动对象(线程)数</span>
<span class="cp">#define QF_MAX_ACTIVE 63
</span><span class="cm">/* various QF object sizes configuration for this port */</span>
<span class="c1">// Linux一般需要32位的CPU，所以块大小和数量都定义成4字节</span>
<span class="cp">#define QF_EVENT_SIZ_SIZE 4
#define QF_EQUEUE_CTR_SIZE 4
#define QF_MPOOL_SIZ_SIZE 4
#define QF_MPOOL_CTR_SIZE 4
#define QF_TIMEEVT_CTR_SIZE 4
</span><span class="cm">/* QF critical section entry/exit for Linux, see NOTE01 */</span>
<span class="cm">/* QF_INT_KEY_TYPE not defined, "unconditional interrupt locking" policy */</span>
<span class="c1">// 不定义QF_INT_KEY_TYPE，“无条件中断上锁和解锁”策略</span>
<span class="c1">// 使用pthread_mutex_lock创建临界区</span>
<span class="cp">#define QF_INT_LOCK(dummy) pthread_mutex_lock(&amp;QF_pThreadMutex_)
#define QF_INT_UNLOCK(dummy) pthread_mutex_unlock(&amp;QF_pThreadMutex_)
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="c1">  /* POSIX-thread API */</span><span class="cp">
#include</span> <span class="cpf">"qep_port.h"</span><span class="c1"> /* QEP port */</span><span class="cp">
#include</span> <span class="cpf">"qequeue.h"</span><span class="c1">  /* Linux needs event-queue */</span><span class="cp">
#include</span> <span class="cpf">"qmpool.h"</span><span class="c1">   /* Linux needs memory-pool */</span><span class="cp">
#include</span> <span class="cpf">"qf.h"</span><span class="c1">       /* QF platform-independent public interface */</span><span class="cp">
</span><span class="cm">/************************************************************************
 * interface used only inside QF, but not in applications
 */</span>
<span class="cm">/* OS-object implementation for Linux */</span>
<span class="c1">// 利用条件变量实现的阻塞和运行信号，总是用while包裹pthread_cond_wait，见另一篇文章</span>
<span class="cp">#define QACTIVE_EQUEUE_WAIT_(me_)               \
  while ((me_)-&gt;eQueue.frontEvt == (QEvent *)0) \
  pthread_cond_wait(&amp;(me_)-&gt;osObject, &amp;QF_pThreadMutex_)
#define QACTIVE_EQUEUE_SIGNAL_(me_) \
  pthread_cond_signal(&amp;(me_)-&gt;osObject)
#define QACTIVE_EQUEUE_ONEMPTY_(me_) ((void)0)
</span><span class="cm">/* native QF event pool operations */</span>
<span class="cp">#define QF_EPOOL_TYPE_ QMPool
#define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) \
  QMPool_init(&amp;(p_), poolSto_, poolSize_, evtSize_)
#define QF_EPOOL_EVENT_SIZE_(p_) ((p_).blockSize)
#define QF_EPOOL_GET_(p_, e_) ((e_) = (QEvent *)QMPool_get(&amp;(p_)))
#define QF_EPOOL_PUT_(p_, e_) (QMPool_put(&amp;(p_), e_))
</span><span class="c1">// 定义信号量</span>
<span class="k">extern</span> <span class="n">pthread_mutex_t</span> <span class="n">QF_pThreadMutex_</span><span class="p">;</span> <span class="cm">/* mutex for QF critical section */</span>
</pre></table></code></div></div><blockquote><p>条件变量的定义见<a href="/posts/operating-systems-24/">条件变量</a></p></blockquote><h4 id="qf_portc-源代码"><span class="mr-2">qf_port.c 源代码</span><a href="#qf_portc-源代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>qf_port.c 源文件提供了在 QF 和 POSIX API 之间的“胶合代码”</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qf_pkg.h"</span><span class="cp">
#include</span> <span class="cpf">"qassert.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1">   /* for mlockall() */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="c1"> /* for select() */</span><span class="cp">
</span><span class="n">Q_DEFINE_THIS_MODULE</span><span class="p">(</span><span class="n">qf_port</span><span class="p">)</span>
<span class="cm">/* Global objects ------------------------------------------------------*/</span>
<span class="c1">// 全局互斥体</span>
<span class="n">pthread_mutex_t</span> <span class="n">QF_pThreadMutex_</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="cm">/* Local objects -------------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">l_running</span><span class="p">;</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 页上锁，防止交换到硬盘，桌面Linux不支持</span>
  <span class="cm">/* lock memory so we’re never swapped out to disk */</span>
  <span class="cm">/*mlockall(MCL_CURRENT | MCL_FUTURE); uncomment when supported */</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">sparam</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">timeout</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* timeout for select() */</span>
  <span class="c1">// 应用程序初始化回调函数</span>
  <span class="n">QF_onStartup</span><span class="p">();</span>               <span class="cm">/* invoke startup callback */</span>
  <span class="cm">/* try to maximize the priority of the ticker thread, see NOTE01 */</span>
  <span class="c1">// 将当前线程设置成 SCHED_FIFO 调度策略和在这个策略里的最高优先级，需要root权限</span>
  <span class="c1">// 高优先级是为了实时性，因为这个线程包含了tick处理操作</span>
  <span class="n">sparam</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">sched_get_priority_max</span><span class="p">(</span><span class="n">SCHED_FIFO</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pthread_setschedparam</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">(),</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sparam</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* success, this application has sufficient privileges */</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="cm">/* setting priority failed, probably due to insufficient privieges */</span>
  <span class="p">}</span>
  <span class="n">l_running</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">l_running</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 在run线程里定期调用tick处理，而不是在tick ISR中，因为在Linux里没有权限访问中断</span>
    <span class="n">QF_tick</span><span class="p">();</span> <span class="cm">/* process the time tick */</span>
    <span class="c1">// select会修改timeout的值，需要每次重新赋值变量</span>
    <span class="n">timeout</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
    <span class="c1">// 向上取整至一个tick，如果tick是10ms,这里的8ms会自动变10ms</span>
    <span class="c1">// select使用空的I/O作为参数表示总是休眠（因为空的I/O不会触发唤醒信号），直到timeout到达</span>
    <span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span> <span class="cm">/* sleep for the full tick, NOTE05 */</span>
  <span class="p">}</span>
  <span class="c1">// 应用程序清理回调函数</span>
  <span class="n">QF_onCleanup</span><span class="p">();</span> <span class="cm">/* invoke cleanup callback */</span>
  <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QF_pThreadMutex_</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 可以在QF_run的循环过程中停止</span>
  <span class="n">l_running</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* stop the loop in QF_run() */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 线程函数，参数是活动对象</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">thread_routine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>                                         <span class="cm">/* the expected POSIX signature */</span>
  <span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* allow the thread loop to run */</span>
  <span class="k">while</span> <span class="p">(((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
  <span class="p">{</span>                                                   <span class="cm">/* QActive_stop() stopps the loop */</span>
    <span class="c1">// 活动对象三个步骤，等待事件、执行事件处理、清理</span>
    <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">QActive_get_</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>   <span class="cm">/*wait for the event */</span>
    <span class="n">QF_ACTIVE_DISPATCH_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="cm">/* dispatch to SM */</span>
    <span class="n">QF_gc</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>                                         <span class="cm">/* check if the event is garbage, and collect it if so */</span>
  <span class="p">}</span>
  <span class="c1">// 线程退出前从QF框架中取消注册该活动对象</span>
  <span class="n">QF_remove_</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span> <span class="cm">/* remove this object from any subscriptions */</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>           <span class="cm">/* return success */</span>
<span class="p">}</span>
<span class="cm">/*.....................................................................*/</span>
<span class="kt">void</span> <span class="nf">QActive_start</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prio</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">qSto</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">qLen</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">stkSto</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">stkSize</span><span class="p">,</span>
                   <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">ie</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span><span class="p">;</span>
  <span class="c1">// 在Linux中，活动对象线程的堆栈由系统分配（pthread_create()函数），无需外部提供</span>
  <span class="n">Q_REQUIRE</span><span class="p">(</span><span class="n">stkSto</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* p-threads allocate stack internally */</span>
  <span class="c1">// 原生QF队列</span>
  <span class="n">QEQueue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">eQueue</span><span class="p">,</span> <span class="n">qSto</span><span class="p">,</span> <span class="p">(</span><span class="n">QEQueueCtr</span><span class="p">)</span><span class="n">qLen</span><span class="p">);</span>
  <span class="c1">// 条件变量初始化,事件队列控制信号</span>
  <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">osObject</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// 设置优先级</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>
  <span class="c1">// 注册至QF</span>
  <span class="n">QF_add_</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>                     <span class="cm">/* make QF aware of this active object */</span>
  <span class="c1">// 初始化活动对象的状态机（就是状态机里的最顶初始转换），参数 ie 是一个指针，指向在活动对象状态机里用于最顶初始转换的初始事件。</span>
  <span class="n">QF_ACTIVE_INIT_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="n">ie</span><span class="p">);</span> <span class="cm">/* execute the initial transition */</span>
  <span class="cm">/* SCHED_FIFO corresponds to real-time preemptive priority-based scheduler
  * NOTE: This scheduling policy requires the superuser privileges
  */</span>
  <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="c1">// 配置线程调度策略，需要root权限</span>
  <span class="n">pthread_attr_setschedpolicy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">);</span>
  <span class="cm">/* see NOTE04 */</span>
  <span class="c1">// 配置线程优先级，把系统中最大的n个优先级给这n个活动对象</span>
  <span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">prio</span> <span class="o">+</span> <span class="p">(</span><span class="n">sched_get_priority_max</span><span class="p">(</span><span class="n">SCHED_FIFO</span><span class="p">)</span> <span class="o">-</span> <span class="n">QF_MAX_ACTIVE</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">pthread_attr_setschedparam</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
  <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_DETACHED</span><span class="p">);</span>
  <span class="c1">// 开始创建线程</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_routine</span><span class="p">,</span> <span class="n">me</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* Creating the p-thread with the SCHED_FIFO policy failed.
     * Most probably this application has no superuser privileges,
     * so we just fall back to the default SCHED_OTHER policy
     * and priority 0.
     */</span>
    <span class="c1">// 如果权限不够，失败了，就要修改参数</span>
    <span class="n">pthread_attr_setschedpolicy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">SCHED_OTHER</span><span class="p">);</span>
    <span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pthread_attr_setschedparam</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
    <span class="n">Q_ALLEGE</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_routine</span><span class="p">,</span> <span class="n">me</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QActive_stop</span><span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 用于中途停止活动对象</span>
  <span class="n">me</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>            <span class="cm">/* stop the event loop in QActive_run() */</span>
  <span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">osObject</span><span class="p">);</span> <span class="cm">/* cleanup the condition variable */</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="开发-qp-应用程序"><span class="mr-2">开发 QP 应用程序</span><a href="#开发-qp-应用程序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="开发-qp-应用程序的准则"><span class="mr-2">开发 QP 应用程序的准则</span><a href="#开发-qp-应用程序的准则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="准则"><span class="mr-2">准则</span><a href="#准则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>活动对象应该仅通过某个<code class="language-plaintext highlighter-rouge">异步事件</code>交换来相互作用，不应该<code class="language-plaintext highlighter-rouge">共享内存</code>或其他资源。<li>活动对象不应该<code class="language-plaintext highlighter-rouge">阻塞</code>或者在RTC处理的中间<code class="language-plaintext highlighter-rouge">忙等待</code>事件。</ul><h4 id="启发式"><span class="mr-2">启发式</span><a href="#启发式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>事件驱动型编程，<code class="language-plaintext highlighter-rouge">非阻塞</code>，快速返回<li>实现在活动对象之间的<code class="language-plaintext highlighter-rouge">松散耦合</code>，避免资源共享<li>把较长的处理<code class="language-plaintext highlighter-rouge">分解</code>成较短的步骤<li>画出<code class="language-plaintext highlighter-rouge">顺序图</code></ul><h3 id="哲学家就餐问题"><span class="mr-2">哲学家就餐问题</span><a href="#哲学家就餐问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/philosopher.jpg" alt="philosopher" data-proofer-ignore></p><h4 id="第一步需求"><span class="mr-2">第一步：需求</span><a href="#第一步需求" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>5个哲学家，5个餐叉，吃面需要2个餐叉，吃完会思考，核心是防止死锁和饿死。</p><h4 id="第二步顺序图"><span class="mr-2">第二步：顺序图</span><a href="#第二步顺序图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/sequencediagram.jpg" alt="sequencediagram" data-proofer-ignore></p><p><code class="language-plaintext highlighter-rouge">Table</code> 对象管理餐叉，每个 <code class="language-plaintext highlighter-rouge">Philo</code> 对象管理一个哲学家</p><p>触发 QF 定时事件<code class="language-plaintext highlighter-rouge">Philo[m]</code>终止思考，开始饥饿，向Table发送事件(HUNGRY(m))请求就餐许可(有足够的叉子)。Table 将就餐许可事件(EAT(m))发送给对应对象。<code class="language-plaintext highlighter-rouge">Philo[m]</code>进入就餐状态直到下一个定时事件，发送完成事件(DONE(m))归还叉子。</p><h4 id="第三步信号事件和活动对象"><span class="mr-2">第三步：信号，事件和活动对象</span><a href="#第三步信号事件和活动对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="cp">#ifndef dpp_h
#define dpp_h
</span><span class="c1">// 对哲学家就餐问题自定义的事件信号</span>
<span class="k">enum</span> <span class="n">DPPSignals</span>
<span class="p">{</span>
  <span class="n">EAT_SIG</span> <span class="o">=</span> <span class="n">Q_USER_SIG</span><span class="p">,</span> <span class="cm">/* published by Table to let a philosopher eat */</span>
  <span class="n">DONE_SIG</span><span class="p">,</span>             <span class="cm">/* published by Philosopher when done eating */</span>
  <span class="n">TERMINATE_SIG</span><span class="p">,</span>        <span class="cm">/* published by BSP to terminate the application */</span>
  <span class="n">MAX_PUB_SIG</span><span class="p">,</span>          <span class="cm">/* the last published signal */</span>
  <span class="c1">// 这个信号是直接发送的</span>
  <span class="n">HUNGRY_SIG</span><span class="p">,</span>           <span class="cm">/* posted directly from hungry Philosopher to Table */</span>
  <span class="n">MAX_SIG</span>               <span class="cm">/* the last signal */</span>
<span class="p">};</span>
<span class="c1">// 派生自QEvent的事件，增加了一个philoNum变量</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TableEvtTag</span>
<span class="p">{</span>
  <span class="n">QEvent</span> <span class="n">super</span><span class="p">;</span>     <span class="cm">/* derives from QEvent */</span>
  <span class="kt">uint8_t</span> <span class="n">philoNum</span><span class="p">;</span> <span class="cm">/* Philosopher number */</span>
<span class="p">}</span> <span class="n">TableEvt</span><span class="p">;</span>
<span class="k">enum</span>
<span class="p">{</span>
  <span class="n">N_PHILO</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">};</span>                     <span class="cm">/* number of Philosophers */</span>
<span class="c1">// 构造函数，再main开始时调用</span>
<span class="kt">void</span> <span class="nf">Philo_ctor</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* ctor that instantiates all Philosophers */</span>
<span class="kt">void</span> <span class="nf">Table_ctor</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">QActive</span> <span class="o">*</span><span class="k">const</span> <span class="n">AO_Philo</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">];</span> <span class="cm">/* "opaque" pointers to Philo AOs */</span>
<span class="k">extern</span> <span class="n">QActive</span> <span class="o">*</span><span class="k">const</span> <span class="n">AO_Table</span><span class="p">;</span>          <span class="cm">/* "opaque" pointer to Table AO */</span>
<span class="cp">#endif                                   </span><span class="cm">/* dpp_h */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="第四步状态机"><span class="mr-2">第四步：状态机</span><a href="#第四步状态机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/ddpstatemachines.jpg" alt="ddpstatemachines" data-proofer-ignore></p><p>这里产生<code class="language-plaintext highlighter-rouge">HUNGRY</code>事件和<code class="language-plaintext highlighter-rouge">DONE</code>事件不是由<code class="language-plaintext highlighter-rouge">定时</code>事件触发而是<code class="language-plaintext highlighter-rouge">进入退出</code>动作时触发，更<code class="language-plaintext highlighter-rouge">精确</code>的反应了语义，提高后续的<code class="language-plaintext highlighter-rouge">可维护性</code></p><p>准则：偏向使用<code class="language-plaintext highlighter-rouge">进入</code>动作和<code class="language-plaintext highlighter-rouge">退出</code>动作，而不是<code class="language-plaintext highlighter-rouge">转换</code>动作。</p><p><em>哲学家和餐叉编号</em>：</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/philoforknum.jpg" alt="philoforknum" data-proofer-ignore></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="n">Q_DEFINE_THIS_FILE</span>
<span class="cm">/* Active object class -----------------------------------------------------*/</span>
<span class="c1">// 活动对象Table从QActive派生，增加了两个变量，管理叉子和饥饿度</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TableTag</span>
<span class="p">{</span>
  <span class="n">QActive</span> <span class="n">super</span><span class="p">;</span>             <span class="cm">/* derives from QActive */</span>
  <span class="kt">uint8_t</span> <span class="n">fork</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">];</span>     <span class="cm">/* states of the forks */</span>
  <span class="kt">uint8_t</span> <span class="n">isHungry</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">];</span> <span class="cm">/* remembers hungry philosophers */</span>
<span class="p">}</span> <span class="n">Table</span><span class="p">;</span>
<span class="k">static</span> <span class="n">QState</span> <span class="nf">Table_initial</span><span class="p">(</span><span class="n">Table</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span> <span class="cm">/* pseudostate */</span>
<span class="k">static</span> <span class="n">QState</span> <span class="nf">Table_serving</span><span class="p">(</span><span class="n">Table</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span> <span class="cm">/* state handler */</span>
<span class="c1">// 如上图，n顺时针递增，人和右叉为一组，标记为n，计算左边或右边组的序号</span>
<span class="cp">#define RIGHT(n_) ((uint8_t)(((n_) + (N_PHILO - 1)) % N_PHILO))
#define LEFT(n_) ((uint8_t)(((n_) + 1) % N_PHILO))
</span><span class="k">enum</span> <span class="n">ForkState</span>
<span class="p">{</span>
  <span class="n">FREE</span><span class="p">,</span>
  <span class="n">USED</span>
<span class="p">};</span>
<span class="cm">/* Local objects ----------------------------------------------------------*/</span>
<span class="c1">// static让其他文件无法访问</span>
<span class="k">static</span> <span class="n">Table</span> <span class="n">l_table</span><span class="p">;</span> <span class="cm">/* the single instance of the Table active object */</span>
<span class="cm">/* Global-scope objects ---------------------------------------------------*/</span>
<span class="c1">// 指针设为const不能更改，可以让编译器把该指针分配在ROM里</span>
<span class="n">QActive</span> <span class="o">*</span><span class="k">const</span> <span class="n">AO_Table</span> <span class="o">=</span> <span class="p">(</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">l_table</span><span class="p">;</span> <span class="cm">/* "opaque" AO pointer */</span>
<span class="cm">/*........................................................................*/</span>
<span class="c1">// 构造函数，C需要手动调用，C++会自动调用</span>
<span class="kt">void</span> <span class="nf">Table_ctor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">Table</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">l_table</span><span class="p">;</span>
  <span class="c1">// 实例化超类，为super部分初始化</span>
  <span class="n">QActive_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">super</span><span class="p">,</span> <span class="p">(</span><span class="n">QStateHandler</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Table_initial</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N_PHILO</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">FREE</span><span class="p">;</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="c1">// 最顶初始转换</span>
<span class="n">QState</span> <span class="nf">Table_initial</span><span class="p">(</span><span class="n">Table</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span> <span class="cm">/* avoid the compiler warning about unused parameter */</span>
  <span class="c1">// 订阅信号</span>
  <span class="n">QActive_subscribe</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span> <span class="n">DONE_SIG</span><span class="p">);</span>
  <span class="n">QActive_subscribe</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span> <span class="n">TERMINATE_SIG</span><span class="p">);</span>
  <span class="cm">/* signal HUNGRY_SIG is posted directly */</span>
  <span class="k">return</span> <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Table_serving</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="n">QState</span> <span class="nf">Table_serving</span><span class="p">(</span><span class="n">Table</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
  <span class="c1">// Table相关事件，定义见上一节</span>
  <span class="n">TableEvt</span> <span class="o">*</span><span class="n">pe</span><span class="p">;</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">HUNGRY_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="c1">// 人工延长单RTC处理的时间，方便进行压力测试</span>
    <span class="n">BSP_busyDelay</span><span class="p">();</span>
    <span class="c1">// 提取事件参数</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">((</span><span class="n">TableEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">philoNum</span><span class="p">;</span>
    <span class="cm">/* phil ID must be in range and he must be not hungry */</span>
    <span class="n">Q_ASSERT</span><span class="p">((</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">N_PHILO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">n</span><span class="p">]));</span>
    <span class="c1">// 屏幕打印</span>
    <span class="n">BSP_displyPhilStat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">"hungry "</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">FREE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">FREE</span><span class="p">))</span>
    <span class="p">{</span><span class="c1">// 左右叉都空闲的情况</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">USED</span><span class="p">;</span>
      <span class="c1">// 生成eat事件</span>
      <span class="n">pe</span> <span class="o">=</span> <span class="n">Q_NEW</span><span class="p">(</span><span class="n">TableEvt</span><span class="p">,</span> <span class="n">EAT_SIG</span><span class="p">);</span>
      <span class="n">pe</span><span class="o">-&gt;</span><span class="n">philoNum</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">QF_publish</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">pe</span><span class="p">);</span>
      <span class="n">BSP_displyPhilStat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">"eating "</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">DONE_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">BSP_busyDelay</span><span class="p">();</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">((</span><span class="n">TableEvt</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">philoNum</span><span class="p">;</span>
    <span class="cm">/* phil ID must be in range and he must be not hungry */</span>
    <span class="n">Q_ASSERT</span><span class="p">((</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">N_PHILO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">n</span><span class="p">]));</span>
    <span class="c1">// 吃完开始思考</span>
    <span class="n">BSP_displyPhilStat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">"thinking"</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="cm">/* both forks of Phil [n] must be used */</span>
    <span class="n">Q_ASSERT</span><span class="p">((</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">USED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">USED</span><span class="p">));</span>
    <span class="c1">// 归还叉子</span>
    <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">FREE</span><span class="p">;</span>
    <span class="c1">// 右边的人是否饥饿</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">RIGHT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="cm">/* check the right neighbor */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">FREE</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">USED</span><span class="p">;</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">pe</span> <span class="o">=</span> <span class="n">Q_NEW</span><span class="p">(</span><span class="n">TableEvt</span><span class="p">,</span> <span class="n">EAT_SIG</span><span class="p">);</span>
      <span class="n">pe</span><span class="o">-&gt;</span><span class="n">philoNum</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
      <span class="n">QF_publish</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">pe</span><span class="p">);</span>
      <span class="n">BSP_displyPhilStat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"eating "</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 左边的左边的人是否饥饿</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="cm">/* check the left neighbor */</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="cm">/* left fork of the left neighbor */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">FREE</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">USED</span><span class="p">;</span>
      <span class="n">me</span><span class="o">-&gt;</span><span class="n">isHungry</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">pe</span> <span class="o">=</span> <span class="n">Q_NEW</span><span class="p">(</span><span class="n">TableEvt</span><span class="p">,</span> <span class="n">EAT_SIG</span><span class="p">);</span>
      <span class="n">pe</span><span class="o">-&gt;</span><span class="n">philoNum</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
      <span class="n">QF_publish</span><span class="p">((</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">pe</span><span class="p">);</span>
      <span class="n">BSP_displyPhilStat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"eating "</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// 终止</span>
  <span class="k">case</span> <span class="n">TERMINATE_SIG</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">QF_stop</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">Q_HANDLED</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Q_SUPER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="第五步初始化并启动应用程序"><span class="mr-2">第五步：初始化并启动应用程序</span><a href="#第五步初始化并启动应用程序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>注意点：</p><ul><li>活动对象的相对优先级<li>预先分配的事件队列的尺寸<li>活动对象启动顺序</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="cm">/* Local-scope objects ---------------------------------------------------*/</span>
<span class="c1">// 所有事件队列的内存缓存被静态分配</span>
<span class="k">static</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">l_tableQueueSto</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">];</span>
<span class="k">static</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">][</span><span class="n">N_PHILO</span><span class="p">];</span>
<span class="c1">// 用于订阅者列表的内存空间也被静态分配，这是个bitmap，之前提到过</span>
<span class="k">static</span> <span class="n">QSubscrList</span> <span class="n">l_subscrSto</span><span class="p">[</span><span class="n">MAX_PUB_SIG</span><span class="p">];</span>
<span class="c1">// 使用"小尺寸"事件池</span>
<span class="k">static</span> <span class="k">union</span> <span class="n">SmallEvent</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">min_size</span><span class="p">;</span><span class="c1">// min_size无意义，这句是为了让SmallEvent至少比一个指针占用空间大</span>
  <span class="n">TableEvt</span> <span class="n">te</span><span class="p">;</span>
  <span class="c1">// 可以添加其他自定义事件</span>
  <span class="cm">/* other event types to go into this pool */</span>
<span class="p">}</span> <span class="n">l_smlPoolSto</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_PHILO</span><span class="p">];</span> <span class="cm">/* storage for the small event pool */</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">Philo_ctor</span><span class="p">();</span>                               <span class="cm">/* instantiate all Philosopher active objects */</span>
  <span class="n">Table_ctor</span><span class="p">();</span>                               <span class="cm">/* instantiate the Table active object */</span>
  <span class="n">BSP_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>                       <span class="cm">/* initialize the Board Support Package */</span>
  <span class="n">QF_init</span><span class="p">();</span>                                  <span class="cm">/* initialize the framework and the underlying RT kernel */</span>
  <span class="c1">// 订阅功能初始化</span>
  <span class="n">QF_psInit</span><span class="p">(</span><span class="n">l_subscrSto</span><span class="p">,</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_subscrSto</span><span class="p">));</span> <span class="cm">/* init publish-subscribe */</span>
  <span class="c1">// 用于动态事件的池，默认使用QF原生内存池管理，</span>
  <span class="c1">// 这里用了BSS段空间(static变量)作为原始空间（有些嵌入式没有堆空间，这是标准做法）</span>
  <span class="n">QF_poolInit</span><span class="p">(</span><span class="n">l_smlPoolSto</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">l_smlPoolSto</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">l_smlPoolSto</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span><span class="cm">/* initialize event pools... */</span>
  <span class="c1">// 先初始化哲学家对象,</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N_PHILO</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* start the active objects... */</span>
    <span class="n">QActive_start</span><span class="p">(</span><span class="n">AO_Philo</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* no private stack */</span>
                  <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// 后初始化table管理对象</span>
  <span class="n">QActive_start</span><span class="p">(</span><span class="n">AO_Table</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">N_PHILO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">l_tableQueueSto</span><span class="p">,</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_tableQueueSto</span><span class="p">),</span>
                <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* no private stack */</span>
                <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">QF_run</span><span class="p">();</span> <span class="cm">/* run the QF application */</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="第六步优雅的结束应用程序"><span class="mr-2">第六步：优雅的结束应用程序</span><a href="#第六步优雅的结束应用程序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>在嵌入式系统中不需要考虑，一般就是无限运行直到复位。</p><h3 id="在不同的平台运行-dpp"><span class="mr-2">在不同的平台运行 DPP</span><a href="#在不同的平台运行-dpp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="在-dos-上的-vanilla-内核"><span class="mr-2">在 DOS 上的 Vanilla 内核</span><a href="#在-dos-上的-vanilla-内核" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="p">...</span>

<span class="cm">/* Local-scope objects---------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">interrupt</span> <span class="p">(</span><span class="o">*</span><span class="n">l_dosTmrISR</span><span class="p">)();</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">interrupt</span> <span class="p">(</span><span class="o">*</span><span class="n">l_dosKbdISR</span><span class="p">)();</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">l_delay</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span> <span class="cm">/* limit for the loop counter in busyDelay() */</span>
<span class="cp">#define TMR_VECTOR 0x08
#define KBD_VECTOR 0x09
</span><span class="cm">/*......................................................................*/</span>
<span class="c1">// Turbo C++ 1.01编译器提供了一个扩展关健词 interrupt ，它允许你使用 C/C++ 编写ISR</span>
<span class="kt">void</span> <span class="n">interrupt</span> <span class="nf">ISR_tmr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 80x86处理器在进ISR时自动关中断，不过可以在ISR内手动开中断</span>
  <span class="c1">// 由8259A可编程中断控制器管理中断优先级</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* unlock interrupts */</span>
  <span class="c1">// QF_tick()内部会关中断，且使用了“无条件中断上锁和解锁”策略，</span>
  <span class="c1">// 不支持中断嵌套，为了防止死锁，需要提前开中断，在临界区外调用QF_tick()</span>
  <span class="n">QF_tick</span><span class="p">();</span>            <span class="cm">/* call QF_tick() outside of critical section */</span>
  <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>   <span class="cm">/* lock interrupts again */</span>
  <span class="c1">// 中断结束 end-of-interrupt(EOI)指令被发往主 8259A ，因此它结束这个中断级别的优先级。</span>
  <span class="n">outportb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span> <span class="cm">/* write EOI to the master 8259A PIC */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 按键中断</span>
<span class="kt">void</span> <span class="n">interrupt</span> <span class="nf">ISR_kbd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">kcr</span><span class="p">;</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>                  <span class="cm">/* unlock interrupts */</span>
  <span class="n">key</span> <span class="o">=</span> <span class="n">inport</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>                    <span class="cm">/*key scan code from the 8042 kbd controller */</span>
  <span class="n">kcr</span> <span class="o">=</span> <span class="n">inport</span><span class="p">(</span><span class="mh">0x61</span><span class="p">);</span>                    <span class="cm">/* get keyboard control register */</span>
  <span class="n">outportb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">kcr</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">));</span> <span class="cm">/* toggle acknowledge bit high */</span>
  <span class="n">outportb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">,</span> <span class="n">kcr</span><span class="p">);</span>                   <span class="cm">/* toggle acknowledge bit low */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">129</span><span class="p">)</span>
  <span class="p">{</span>                                          <span class="cm">/* ESC key pressed? */</span>
    <span class="k">static</span> <span class="n">QEvent</span> <span class="n">term</span> <span class="o">=</span> <span class="p">{</span><span class="n">TERMINATE_SIG</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span> <span class="cm">/* static event */</span>
    <span class="n">QF_publish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>                       <span class="cm">/* publish to all interested AOs */</span>
  <span class="p">}</span>
  <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>   <span class="cm">/* lock interrupts again */</span>
  <span class="n">outportb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span> <span class="cm">/* write EOI to the master 8259A PIC */</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_onStartup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* save the origingal DOS vectors ... */</span>
  <span class="c1">// 保存原始中断向量，在最后清理时恢复</span>
  <span class="n">l_dosTmrISR</span> <span class="o">=</span> <span class="n">getvect</span><span class="p">(</span><span class="n">TMR_VECTOR</span><span class="p">);</span>
  <span class="n">l_dosKbdISR</span> <span class="o">=</span> <span class="n">getvect</span><span class="p">(</span><span class="n">KBD_VECTOR</span><span class="p">);</span>
  <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
  <span class="c1">// 配置自定义的中断向量</span>
  <span class="n">setvect</span><span class="p">(</span><span class="n">TMR_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ISR_tmr</span><span class="p">);</span>
  <span class="n">setvect</span><span class="p">(</span><span class="n">KBD_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ISR_kbd</span><span class="p">);</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_onCleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* restore the original DOS vectors ... */</span>
  <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
  <span class="c1">// 恢复中断向量</span>
  <span class="n">setvect</span><span class="p">(</span><span class="n">TMR_VECTOR</span><span class="p">,</span> <span class="n">l_dosTmrISR</span><span class="p">);</span>
  <span class="n">setvect</span><span class="p">(</span><span class="n">KBD_VECTOR</span><span class="p">,</span> <span class="n">l_dosKbdISR</span><span class="p">);</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
  <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* exit to DOS */</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="c1">// 见[qvanilla.c 源文件](#qvanillac-源文件)</span>
<span class="kt">void</span> <span class="nf">QF_onIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>                       <span class="cm">/* called with interrupts LOCKED */</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* always unlock interrutps */</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">BSP_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// 读取参数</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 忙等待时长</span>
    <span class="n">l_delay</span> <span class="o">=</span> <span class="n">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="cm">/* set the delay counter for busy delay */</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Dining Philosopher Problem example"</span>
         <span class="s">"</span><span class="se">\n</span><span class="s">QEP %s</span><span class="se">\n</span><span class="s">QF %s</span><span class="se">\n</span><span class="s">"</span>
         <span class="s">"Press ESC to quit...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
         <span class="n">QEP_getVersion</span><span class="p">(),</span>
         <span class="n">QF_getVersion</span><span class="p">());</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 用于手动调用延长RTC执行时间，方便调试</span>
<span class="kt">void</span> <span class="nf">BSP_busyDelay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="k">volatile</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l_delay</span><span class="p">;</span>
  <span class="c1">// 忙等待</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0UL</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* busy-wait loop */</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 打印执行信息，仅被活动对象 Table 调用</span>
<span class="kt">void</span> <span class="nf">BSP_displyPhilStat</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Philosopher %2d is %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">Q_onAssert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="n">Q_ROM</span> <span class="o">*</span><span class="k">const</span> <span class="n">Q_ROM_VAR</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">// 断言失败时终止</span>
  <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* cut-off all interrupts */</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Assertion failed in %s, line %d"</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
  <span class="n">QF_stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="在-cortex-m3-上的-vanilla-内核"><span class="mr-2">在 Cortex-M3 上的 Vanilla 内核</span><a href="#在-cortex-m3-上的-vanilla-内核" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/vanillacortexm3.jpg" alt="vanillacortexm3" data-proofer-ignore></p><p>t（思考）， e（就餐）和 h（饥饿）</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="c1">// 驱动库</span>
<span class="cp">#include</span> <span class="cpf">"hw_ints.h"</span><span class="cp">
</span><span class="p">...</span><span class="cm">/* other Luminary Micro driver library include files */</span>

<span class="cm">/* Local-scope objects ---------------------------------------------------*/</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">l_delay</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span> <span class="cm">/* limit for the loop counter in busyDelay() */</span>

<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">ISR_SysTick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Cortex-M3 进入 ISR 时，中断是解锁的，这就有别于80x86</span>
  <span class="n">QF_tick</span><span class="p">();</span> <span class="cm">/* process all armed time events */</span>
  <span class="cm">/* add any application-specific clock-tick processing, as needed */</span>
<span class="p">}</span>
<span class="p">...</span>

<span class="cm">/*......................................................................*/</span>
<span class="c1">// 板的初始化</span>
<span class="kt">void</span>
<span class="nf">BSP_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span> <span class="cm">/* unused: avoid the complier warning */</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argv</span><span class="p">;</span> <span class="cm">/* unused: avoid the compiler warning */</span>
              <span class="cm">/* Set the clocking to run at 20MHz from the PLL. */</span>
  <span class="n">SysCtlClockSet</span><span class="p">(</span><span class="n">SYSCTL_SYSDIV_10</span> <span class="o">|</span> <span class="n">SYSCTL_USE_PLL</span> <span class="o">|</span> <span class="n">SYSCTL_OSC_MAIN</span> <span class="o">|</span> <span class="n">SYSCTL_XTAL_6MHZ</span><span class="p">);</span>
  <span class="cm">/* Enable the peripherals used by the application. */</span>
  <span class="n">SysCtlPeripheralEnable</span><span class="p">(</span><span class="n">SYSCTL_PERIPH_GPIOA</span><span class="p">);</span>
  <span class="n">SysCtlPeripheralEnable</span><span class="p">(</span><span class="n">SYSCTL_PERIPH_GPIOC</span><span class="p">);</span>
  <span class="cm">/* Configure the LED, push button, and UART GPIOs as required. */</span>
  <span class="n">GPIODirModeSet</span><span class="p">(</span><span class="n">GPIO_PORTA_BASE</span><span class="p">,</span> <span class="n">GPIO_PIN_0</span> <span class="o">|</span> <span class="n">GPIO_PIN_1</span><span class="p">,</span>
                 <span class="n">GPIO_DIR_MODE_HW</span><span class="p">);</span>
  <span class="n">GPIODirModeSet</span><span class="p">(</span><span class="n">GPIO_PORTC_BASE</span><span class="p">,</span> <span class="n">PUSH_BUTTON</span><span class="p">,</span> <span class="n">GPIO_DIR_MODE_IN</span><span class="p">);</span>
  <span class="n">GPIODirModeSet</span><span class="p">(</span><span class="n">GPIO_PORTC_BASE</span><span class="p">,</span> <span class="n">USER_LED</span><span class="p">,</span> <span class="n">GPIO_DIR_MODE_OUT</span><span class="p">);</span>
  <span class="n">GPIOPinWrite</span><span class="p">(</span><span class="n">GPIO_PORTC_BASE</span><span class="p">,</span> <span class="n">USER_LED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="cm">/* Initialize the OSRAM OLED display. */</span>
  <span class="c1">// 初始化显示驱动</span>
  <span class="n">OSRAMInit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">OSRAMStringDraw</span><span class="p">(</span><span class="s">"Dining Philos"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">OSRAMStringDraw</span><span class="p">(</span><span class="s">"0 ,1 ,2 ,3 ,4"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">BSP_displyPhilStat</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  <span class="n">OSRAMStringDraw</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">6</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">BSP_busyDelay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="k">volatile</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l_delay</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0UL</span><span class="p">)</span>
  <span class="p">{</span> <span class="cm">/* busy-wait loop */</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_onStartup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* Set up and enable the SysTick timer. It will be used as a reference
   * for delay loops in the interrupt handlers. The SysTick timer period
   * will be set up for BSP_TICKS_PER_SEC.
   */</span>
  <span class="c1">// 设置节拍速率</span>
  <span class="n">SysTickPeriodSet</span><span class="p">(</span><span class="n">SysCtlClockGet</span><span class="p">()</span> <span class="o">/</span> <span class="n">BSP_TICKS_PER_SEC</span><span class="p">);</span>
  <span class="n">SysTickEnable</span><span class="p">();</span>
  <span class="c1">// 配置节拍中断优先级，0xC0为倒数第二低的优先级</span>
  <span class="n">IntPrioritySet</span><span class="p">(</span><span class="n">FAULT_SYSTICK</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">);</span> <span class="cm">/* set the priority of SysTick */</span>
  <span class="n">SysTickIntEnable</span><span class="p">();</span>                  <span class="cm">/* Enable the SysTick interrupts */</span>
  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>                <span class="cm">/* set the interrupt flag in PRIMASK */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="c1">// 没有操作系统，不需要清理，退出直接复位</span>
<span class="kt">void</span> <span class="nf">QF_onCleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_onIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* entered with interrupts LOCKED, see NOTE01 */</span>
  <span class="cm">/* toggle the User LED on and then off, see NOTE02 */</span>
  <span class="n">GPIOPinWrite</span><span class="p">(</span><span class="n">GPIO_PORTC_BASE</span><span class="p">,</span> <span class="n">USER_LED</span><span class="p">,</span> <span class="n">USER_LED</span><span class="p">);</span> <span class="cm">/* User LED on */</span>
  <span class="n">GPIOPinWrite</span><span class="p">(</span><span class="n">GPIO_PORTC_BASE</span><span class="p">,</span> <span class="n">USER_LED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>        <span class="cm">/* User LED off */</span>
<span class="cp">#ifdef NDEBUG
</span>  <span class="cm">/* Put the CPU and peripherals to the low-power mode.
   * you might need to customize the clock management for your application,
   * see the datasheet for your particular Cortex-M3 MCU.
   */</span>
  <span class="c1">// 低功耗模式</span>
  <span class="kr">__asm</span><span class="p">(</span><span class="s">"WFI"</span><span class="p">);</span> <span class="cm">/* Wait-For-Interrupt */</span>
<span class="cp">#endif
</span>  <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* always unlock the interrupts */</span>
<span class="p">}</span>
<span class="cm">/*......................................................................*/</span>
<span class="kt">void</span> <span class="nf">Q_onAssert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="n">Q_ROM</span> <span class="o">*</span><span class="k">const</span> <span class="n">Q_ROM_VAR</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">file</span><span class="p">;</span>         <span class="cm">/* avoid compiler warning */</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">line</span><span class="p">;</span>         <span class="cm">/* avoid compiler warning */</span>
  <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span> <span class="cm">/* make sure that all interrupts are disabled */</span>
  <span class="c1">// 实际使用要去掉这个循环</span>
  <span class="k">for</span> <span class="p">(;;)</span>
  <span class="p">{</span> <span class="cm">/* NOTE: replace the loop with reset for the final version */</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/* error routine that is called if the Luminary library encounters an error */</span>
<span class="kt">void</span> <span class="nf">__error__</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pcFilename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ulLine</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Q_onAssert</span><span class="p">(</span><span class="n">pcFilename</span><span class="p">,</span> <span class="n">ulLine</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="ucos-ii"><span class="mr-2">uC/OS-II</span><a href="#ucos-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/ucos2dpp.jpg" alt="ucos2dpp" data-proofer-ignore></p><p><em>main.c</em>：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="cm">/* Local-scope objects ---------------------------------------------------*/</span>
<span class="p">...</span> 
<span class="k">static</span> <span class="n">OS_STK</span> <span class="n">l_philoStk</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">][</span><span class="mi">256</span><span class="p">];</span> <span class="cm">/* stacks for the Philosophers */</span>
<span class="k">static</span> <span class="n">OS_STK</span> <span class="n">l_tableStk</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>              <span class="cm">/* stack for the Table */</span>
<span class="k">static</span> <span class="n">OS_STK</span> <span class="n">l_ucosTaskStk</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>           <span class="cm">/* stack for the ucosTask */</span>
<span class="cm">/*........................................................................*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">...</span> 
  <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N_PHILO</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// 需要为每个活动对象分配私有堆栈</span>
    <span class="n">QActive_start</span><span class="p">(</span><span class="n">AO_Philo</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                  <span class="n">l_philoStk</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">l_philoStk</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">QActive_start</span><span class="p">(</span><span class="n">AO_Table</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">N_PHILO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">l_tableQueueSto</span><span class="p">,</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_tableQueueSto</span><span class="p">),</span>
                <span class="n">l_tableStk</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">l_tableStk</span><span class="p">),</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
  <span class="cm">/* create a uC/OS-II task to start interrupts and poll the keyboard */</span>
  <span class="c1">// 比其他系统多加了个任务，见下面的bsp.c</span>
  <span class="n">OSTaskCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucosTask</span><span class="p">,</span>
               <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/* pdata */</span>
               <span class="o">&amp;</span><span class="n">l_ucosTaskStk</span><span class="p">[</span><span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_ucosTaskStk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
               <span class="mi">0</span><span class="p">);</span> <span class="cm">/* the highest uC/OS-II priority */</span>
  <span class="n">QF_run</span><span class="p">();</span>        <span class="cm">/* run the QF application */</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>bsp.c</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
#include</span> <span class="cpf">"video.h"</span><span class="cp">
</span><span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">ucosTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">pdata</span><span class="p">;</span>    <span class="cm">/* avoid the compiler warning about unused parameter */</span>
  <span class="n">QF_onStartup</span><span class="p">();</span> <span class="cm">/* start interrupts including the clock tick, NOTE01 */</span>
  <span class="k">for</span> <span class="p">(;;)</span>
  <span class="p">{</span>
    <span class="c1">// for循环里要加阻塞转让控制权</span>
    <span class="n">OSTimeDly</span><span class="p">(</span><span class="n">OS_TICKS_PER_SEC</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span> <span class="cm">/* sleep for 1/10 s */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kbhit</span><span class="p">())</span>
    <span class="p">{</span> <span class="cm">/* poll for a new keypress */</span>
      <span class="kt">uint8_t</span> <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">getch</span><span class="p">();</span>
      <span class="c1">// 检测是否按了 ESC 键</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="mh">0x1B</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* is this the ESC key? */</span>
        <span class="c1">// 发布静态的 TERMINATE 事件</span>
        <span class="n">QF_publish</span><span class="p">(</span><span class="n">Q_NEW</span><span class="p">(</span><span class="n">QEvent</span><span class="p">,</span> <span class="n">TERMINATE_SIG</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span> <span class="cm">/* other key pressed */</span>
        <span class="n">Video_printNumAt</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">13</span> <span class="o">+</span> <span class="n">N_PHILO</span><span class="p">,</span> <span class="n">VIDEO_FGND_YELLOW</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="c1">// 节拍中断，因为使用“保存和恢复中断状态”策略支持中断嵌套，进入ISR后不需要开中断</span>
<span class="kt">void</span> <span class="nf">OSTimeTickHook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">QF_tick</span><span class="p">();</span>
  <span class="cm">/* add any application-specific clock-tick processing, as needed */</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="c1">// Idle进入低功耗模式</span>
<span class="kt">void</span> <span class="nf">OSTaskIdleHook</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="cm">/* put the MCU to sleep, if desired */</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></table></code></div></div><h4 id="linux"><span class="mr-2">Linux</span><a href="#linux" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/linuxddp.jpg" alt="linuxddp" data-proofer-ignore></p><p><em>bsp.c</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span><span class="p">...</span> 
<span class="n">Q_DEFINE_THIS_FILE</span>
<span class="cm">/* Local objects ---------------------------------------------------------*/</span>
<span class="c1">// Linux控制台默认配置不允许异步接收用户按键，需要修改控制台配置，这个变量备份了修改前的配置</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">termios</span> <span class="n">l_tsav</span><span class="p">;</span> <span class="cm">/* structure with saved terminal attributes */</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">l_delay</span><span class="p">;</span>      <span class="cm">/* limit for the loop counter in busyDelay() */</span>
<span class="cm">/*.......................................................................*/</span>
<span class="c1">// 异步监控控制台输入的线程，按下ESC终止应用</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">idleThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* the expected P-Thread signature */</span>
  <span class="k">for</span> <span class="p">(;;)</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">timeout</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* timeout for select() */</span>
    <span class="n">fd_set</span> <span class="n">con</span><span class="p">;</span>                   <span class="cm">/* FD set representing the console */</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">con</span><span class="p">);</span>
    <span class="n">FD_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">con</span><span class="p">);</span>
    <span class="n">timeout</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
    <span class="cm">/* sleep for the full tick or until a console input arrives */</span>
    <span class="c1">// 使用select()作为阻塞机制</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">select</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">con</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span>
    <span class="p">{</span> <span class="cm">/* any descriptor set? */</span>
      <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
      <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'\33'</span><span class="p">)</span>
      <span class="p">{</span> <span class="cm">/* ESC pressed? */</span>
        <span class="c1">// 按ESC发布退出事件</span>
        <span class="n">QF_publish</span><span class="p">(</span><span class="n">Q_NEW</span><span class="p">(</span><span class="n">QEvent</span><span class="p">,</span> <span class="n">TERMINATE_SIG</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* return success */</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">BSP_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Dining Philosopher Problem example"</span>
         <span class="s">"</span><span class="se">\n</span><span class="s">QEP %s</span><span class="se">\n</span><span class="s">QF %s</span><span class="se">\n</span><span class="s">"</span>
         <span class="s">"Press ESC to quit...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
         <span class="n">QEP_getVersion</span><span class="p">(),</span>
         <span class="n">QF_getVersion</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">l_delay</span> <span class="o">=</span> <span class="n">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="cm">/* set the delay from the argument */</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_onStartup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>                     <span class="cm">/* startup callback */</span>
  <span class="k">struct</span> <span class="n">termios</span> <span class="n">tio</span><span class="p">;</span> <span class="cm">/* modified terminal attributes */</span>
  <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span><span class="p">;</span>
  <span class="n">pthread_t</span> <span class="n">idle</span><span class="p">;</span>
  <span class="c1">// 修改前保存终端属性</span>
  <span class="n">tcgetattr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_tsav</span><span class="p">);</span>           <span class="cm">/* save the current terminal attributes */</span>
  <span class="n">tcgetattr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tio</span><span class="p">);</span>              <span class="cm">/* obtain the current terminal attributes */</span>
  <span class="n">tio</span><span class="p">.</span><span class="n">c_lflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ICANON</span> <span class="o">|</span> <span class="n">ECHO</span><span class="p">);</span> <span class="cm">/* disable the canonical mode &amp; echo */</span>
  <span class="c1">// 关闭终端属性中的不允许异步输入模式</span>
  <span class="n">tcsetattr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TCSANOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tio</span><span class="p">);</span>     <span class="cm">/* set the new attributes */</span>
  <span class="cm">/* SCHED_FIFO corresponds to real-time preemptive priority-based scheduler
   * NOTE: This scheduling policy requires the superuser priviledges
   */</span>
  <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="c1">// 将idle线程配置为SCHED_FIFO调度策略</span>
  <span class="n">pthread_attr_setschedpolicy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">);</span>
  <span class="c1">// 将idle线程优先级配置为最低</span>
  <span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">sched_get_priority_min</span><span class="p">(</span><span class="n">SCHED_FIFO</span><span class="p">);</span>
  <span class="n">pthread_attr_setschedparam</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
  <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_DETACHED</span><span class="p">);</span>
  <span class="c1">// 创建idle线程</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idleThread</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* Creating the p-thread with the SCHED_FIFO policy failed.
     * Most probably this application has no superuser privileges,
     * so we just fall back to the default SCHED_OTHER policy
     * and priority 0.
     */</span>
    <span class="c1">// 如果创建失败就尝试另外的配置重新创建</span>
    <span class="n">pthread_attr_setschedpolicy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">SCHED_OTHER</span><span class="p">);</span>
    <span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pthread_attr_setschedparam</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
    <span class="n">Q_ALLEGE</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idleThread</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">QF_onCleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* cleanup callback */</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Bye! Bye!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">tcsetattr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TCSANOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_tsav</span><span class="p">);</span> <span class="cm">/* restore the saved terminal attributes */</span>
  <span class="n">QS_EXIT</span><span class="p">();</span>                      <span class="cm">/* perform the QS cleanup */</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">BSP_displyPhilStat</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Philosopher %2d is %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">BSP_busyDelay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="k">volatile</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l_delay</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0UL</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*.......................................................................*/</span>
<span class="kt">void</span> <span class="nf">Q_onAssert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="n">Q_ROM</span> <span class="o">*</span><span class="k">const</span> <span class="n">Q_ROM_VAR</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Assertion failed in %s, line %d"</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
  <span class="n">QF_stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>相关文章：<a href="/posts/operating-systems-27/#重要-apiselect或-poll">select()用法</a></p></blockquote><h3 id="调整事件队列和事件池的大小"><span class="mr-2">调整事件队列和事件池的大小</span><a href="#调整事件队列和事件池的大小" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">开发阶段</code>使用<code class="language-plaintext highlighter-rouge">超大</code>的队列、池和堆栈，仅在产品开发的<code class="language-plaintext highlighter-rouge">末期</code>才开始<code class="language-plaintext highlighter-rouge">缩小</code>它们。</p><h4 id="调整事件队列的大小"><span class="mr-2">调整事件队列的大小</span><a href="#调整事件队列的大小" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>事件队列的要求：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>平均事件产生速率 &lt;P(t)&gt; 不高于平均事件消耗速率 &lt;C(t)&gt;
</pre></table></code></div></div><p>一旦 <code class="language-plaintext highlighter-rouge">P(t)</code> 过大导致事件队列<code class="language-plaintext highlighter-rouge">满</code>，QP 会视其为<code class="language-plaintext highlighter-rouge">异常</code>，而不是<code class="language-plaintext highlighter-rouge">阻塞</code>生产者或<code class="language-plaintext highlighter-rouge">丢弃</code>事件</p><p><strong>解决方法</strong>：</p><ul><li><p>运行时评估：</p><ul><li>运行程序一段时间并检查 <code class="language-plaintext highlighter-rouge">nMin</code> 的值，评估事件队列大小是否合理</ul><li><p>静态分析</p><ul><li><p>事件队列的大小取决于活动对象的<code class="language-plaintext highlighter-rouge">优先级</code></p><p>一般的，<code class="language-plaintext highlighter-rouge">优先级</code>越高，必需的事件队列越短。因为一旦事件队列被填充，内核会<code class="language-plaintext highlighter-rouge">尽快</code>调度该活动对象线程运行处理事件</p><li><p>队列大小取决于最长的 <code class="language-plaintext highlighter-rouge">RTC</code> 步骤持续的<code class="language-plaintext highlighter-rouge">时间</code></p><p>处理越快，必需的事件队列越短。理想情况是，某个给定活动对象的所有 RTC 步骤都只需要相同的 CPU 周期来完成。</p><li><p>任何相关的事件生产都能增加队列的大小</p><p>有时候 ISR 或活动对象在一个 RTC 步骤内生产多个事件实例。应该避免短时间内产生较多事件</p></ul></ul><h4 id="调整事件池的大小"><span class="mr-2">调整事件池的大小</span><a href="#调整事件池的大小" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>取决于事件种类，和活动对象数量，事件实例的可重用性，事件池尺寸种类</p><h4 id="系统集成"><span class="mr-2">系统集成</span><a href="#系统集成" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QF 允许你在软件的<code class="language-plaintext highlighter-rouge">任何地方</code>发送或发行事件，而不限于仅从活动对象。比如可以在设备<code class="language-plaintext highlighter-rouge">驱动程序</code>中发布事件。</p><p>设备应该被视为一个<code class="language-plaintext highlighter-rouge">共享</code>的资源，对它的存取<code class="language-plaintext highlighter-rouge">限制</code>到仅一个活动对象内，避免共享资源竞争导致的各种问题。可以用一个活动对象封装多个设备。</p><h2 id="事件驱动型系统的软件追踪"><span class="mr-2">事件驱动型系统的软件追踪</span><a href="#事件驱动型系统的软件追踪" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/tracemodel.jpg" alt="tracemodel" data-proofer-ignore></p><p>上图展示了软件追踪的一个典型设置</p><p>嵌入式目标系统在运行被监测的代码，它在目标系统的 RAM 缓存区记录追踪数据。追踪数据通过一个数据连接被从这个缓存区送给一个主机，它存储、显示和分析这些信息。这个配置意味着软件追踪总是需要 2 个构件：</p><ul><li>用来收集和发送追踪数据的<a href="#qs-目标系统驻留构件">目标系统驻留构件</a><li>用来接收，解压，可视化和分析这些数据的<a href="#qspy-主机应用程序">主机驻留构件</a>。</ul><h3 id="qs-目标系统驻留构件"><span class="mr-2">QS 目标系统驻留构件</span><a href="#qs-目标系统驻留构件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qstarget.jpg" alt="qstarget" data-proofer-ignore></p><ul><li>侵入性小 - 数据格式化工作被从目标系统里移到主机执行<li>数据记录和发送数据给主机是分隔的，例如在目标 CPU 的空闲循环处传输数据。减少了发送数据的开销<li>支持数据压缩，如数据字典<li>带级别过滤器<li>带可配精度时间戳<li>探测传输错误并重传机制（高级数据连接控制协议 [High Level Data Link Control, HLDLC]）<li>轻量级传输 API</ul><h4 id="qs-源代码的组织"><span class="mr-2">QS 源代码的组织</span><a href="#qs-源代码的组织" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="gp">&lt;qp&gt;</span><span class="se">\q</span>pc<span class="se">\ </span>- QP/C root directory <span class="o">(</span>&lt;qp&gt;<span class="se">\q</span>pcpp <span class="k">for </span>QP/C++<span class="o">)</span>
<span class="go">    |
    +-include/ - QP platform-independent header files
    | +-qs.h - QS platform-independent active interface
    | +-qs_dummy.h - QS platform-independent inactive interface
    |
    +-qs/ - QS target component
    | +-source/ - QS platform-independent source code (*.C files)
    | | +-qs_pkg.h - internal, packet-scope interface for QS implementation
    | | +-qs.c - internal ring buffer and formatted output functions
    | | +-qs_.c - definition of basic unformatted output functions
    | | +-qs_blk.c - definition of block-oriented interface QS_getBlock()
    | | +-qs_byte.c - definition of byte-oriented interface QS_getByte()
    | | +-qs_f32.c - definition of 32-bit floating point output QS_f32()
    | | +-qs_f64.c - definition of 64-bit floating point output QS_f64()
    | | +-qs_mem.c - definition of memory-block output
    | | +-qs_str.c - definition of zero-terminated string output
    |
    +-ports\ - Platform-specific QP ports
    | +- . . .
    +-examples\ - Platform-specific QP examples
</span><span class="gp">    | +- . . .&lt;qp&gt;</span><span class="se">\q</span>pc<span class="se">\ </span>- QP/C root directory <span class="o">(</span>&lt;qp&gt;<span class="se">\q</span>pcpp <span class="k">for </span>QP/C++<span class="o">)</span>
<span class="go">    |
    +-include/ - QP platform-independent header files
    | +-qs.h - QS platform-independent active interface
    | +-qs_dummy.h - QS platform-independent inactive interface
    |
    +-qs/ - QS target component
    | +-source/ - QS platform-independent source code (*.C files)
    | | +-qs_pkg.h - internal, packet-scope interface for QS implementation
    | | +-qs.c - internal ring buffer and formatted output functions
    | | +-qs_.c - definition of basic unformatted output functions
    | | +-qs_blk.c - definition of block-oriented interface QS_getBlock()
    | | +-qs_byte.c - definition of byte-oriented interface QS_getByte()
    | | +-qs_f32.c - definition of 32-bit floating point output QS_f32()
    | | +-qs_f64.c - definition of 64-bit floating point output QS_f64()
    | | +-qs_mem.c - definition of memory-block output
    | | +-qs_str.c - definition of zero-terminated string output
    |
    +-ports\ - Platform-specific QP ports
    | +- . . .
    +-examples\ - Platform-specific QP examples
    | +- . . .
</span></pre></table></code></div></div><p>QS 源文件通常在<code class="language-plaintext highlighter-rouge">每个文件</code>里只包含<strong>一个函数</strong>或<strong>一个数据结构</strong>。这种设计的目的在于把 QS 部署成一个<code class="language-plaintext highlighter-rouge">精细粒度</code>的库，你可以把它静态的和里的应用程序链接。精细粒度意味着 QS 库由许多小的松散耦合的模块（目标文件）组成，而不是由一个包含所有功能的单一模块组成。</p><h4 id="qs-的平台无关头文件-qsh-和-qs_dummyh"><span class="mr-2">QS 的平台无关头文件 qs.h 和 qs_dummy.h</span><a href="#qs-的平台无关头文件-qsh-和-qs_dummyh" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><code class="language-plaintext highlighter-rouge">qs.h</code> - QS 功能的所有“活动”接口<li><code class="language-plaintext highlighter-rouge">qs_dummy.h</code> - QS 功能的所有“不活动”接口</ul><p><em>qs.h</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qs_h
#define qs_h
#ifndef Q_SPY
#error "Q_SPY must be defined to include qs.h"
#endif </span><span class="cm">/* Q_SPY */</span><span class="cp">
</span>
<span class="c1">// 枚举QS记录类型，相当于日志标记</span>
<span class="k">enum</span> <span class="n">QSpyRecords</span>
<span class="p">{</span>
    <span class="cm">/* QEP records */</span>
    <span class="n">QS_QEP_STATE_ENTRY</span><span class="p">,</span> <span class="cm">/**&lt; a state was entered */</span>
    <span class="n">QS_QEP_STATE_EXIT</span><span class="p">,</span>  <span class="cm">/**&lt; a state was exited */</span>
    <span class="p">...</span>
    <span class="cm">/* QF records */</span>
    <span class="n">QS_QF_ACTIVE_ADD</span><span class="p">,</span>         <span class="cm">/**&lt; an AO has been added to QF (started) */</span>
    <span class="n">QS_QF_ACTIVE_REMOVE</span><span class="p">,</span>      <span class="cm">/**&lt; an AO has been removed from QF (stopped) */</span>
    <span class="n">QS_QF_ACTIVE_SUBSCRIBE</span><span class="p">,</span>   <span class="cm">/**&lt; an AO subscribed to an event */</span>
    <span class="n">QS_QF_ACTIVE_UNSUBSCRIBE</span><span class="p">,</span> <span class="cm">/**&lt; an AO unsubscribed to an event */</span>
    <span class="n">QS_QF_ACTIVE_POST_FIFO</span><span class="p">,</span>   <span class="cm">/**&lt; an event was posted (FIFO) directly to AO */</span>
    <span class="p">...</span>
    <span class="cm">/* QK records */</span>
    <span class="n">QS_QK_MUTEX_LOCK</span><span class="p">,</span>   <span class="cm">/**&lt; the QK mutex was locked */</span>
    <span class="n">QS_QK_MUTEX_UNLOCK</span><span class="p">,</span> <span class="cm">/**&lt; the QK mutex was unlocked */</span>
    <span class="n">QS_QK_SCHEDULE</span><span class="p">,</span>     <span class="cm">/**&lt; the QK scheduled a new task to execute */</span>
    <span class="p">...</span>
    <span class="cm">/* Miscellaneous QS records */</span>
    <span class="n">QS_SIG_DICTIONARY</span><span class="p">,</span> <span class="cm">/**&lt; signal dictionary entry */</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">,</span> <span class="cm">/**&lt; object dictionary entry */</span>
    <span class="n">QS_FUN_DICTIONARY</span><span class="p">,</span> <span class="cm">/**&lt; function dictionary entry */</span>
    <span class="n">QS_ASSERT</span><span class="p">,</span>         <span class="cm">/** assertion failed */</span>
    <span class="p">...</span>
    <span class="cm">/* User records */</span>
    <span class="n">QS_USER</span> <span class="cm">/**&lt; the first record available for user QS records */</span>
    <span class="c1">// 从QS_USER开始可以自定义记录类型</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="cm">/* Macros for adding QS instrumentation to the client code .................*/</span>
<span class="c1">//所有 QS 服务被定义为预处理器的宏。这样，即使软件追踪被禁止，你也可以把它们留在代码中。</span>
<span class="cp">#define QS_INIT(arg_) QS_onStartup(arg_)
#define QS_EXIT() QS_onCleanup()
</span><span class="c1">// 全局 QS 过滤器，它把某个给定 QS 追踪记录打开或关闭。</span>
<span class="cp">#define QS_FILTER_ON(rec_) QS_filterOn(rec_)
#define QS_FILTER_OFF(rec_) QS_filterOff(rec_)
</span><span class="c1">// 本地 QS 过滤器。这个过滤器允许你有选择的追踪那些特定的状态机对象。</span>
<span class="cp">#define QS_FILTER_SM_OBJ(obj_) (QS_smObj_ = (obj_))
#define QS_FILTER_AO_OBJ(obj_) (QS_aoObj_ = (obj_))
#define QS_FILTER_MP_OBJ(obj_) (QS_mpObj_ = (obj_))
#define QS_FILTER_EQ_OBJ(obj_) (QS_eqObj_ = (obj_))
#define QS_FILTER_TE_OBJ(obj_) (QS_teObj_ = (obj_))
#define QS_FILTER_AP_OBJ(obj_) (QS_apObj_ = (obj_))
</span><span class="cm">/* Macros to generate user QS records (formatted data output) ..............*/</span>
<span class="c1">// 互斥锁，BEGIN上锁，END解锁，用于保护QS 追踪缓存</span>
<span class="cp">#define QS_BEGIN(rec_, obj_) ...
#define QS_END() ...
</span><span class="c1">// 不上锁（比如在临界区内再调用就不需要关中断了）</span>
<span class="cp">#define QS_BEGIN_NOLOCK(rec_, obj_) ...
#define QS_END_NOLOCK() ...
</span>    <span class="p">...</span>
<span class="cp">#define QS_I8 (w_, d_) QS_u8((uint8_t)(((w_) &lt;&lt; 4)) | QS_I8_T, (d_))
#define QS_U8 (w_, d_) QS_u8((uint8_t)(((w_) &lt;&lt; 4)) | QS_U8_T, (d_))
#define QS_I16(w_, d_) QS_u16((uint8_t)(((w_) &lt;&lt; 4)) | QS_I16_T, (d_))
#define QS_U16(w_, d_) QS_u16((uint8_t)(((w_) &lt;&lt; 4)) | QS_U16_T, (d_))
#define QS_I32(w_, d_) QS_u32((uint8_t)(((w_) &lt;&lt; 4)) | QS_I32_T, (d_))
#define QS_U32(w_, d_) QS_u32((uint8_t)(((w_) &lt;&lt; 4)) | QS_U32_T, (d_))
#define QS_F32(w_, d_) QS_f32((uint8_t)(((w_) &lt;&lt; 4)) | QS_F32_T, (d_))
#define QS_F64(w_, d_) QS_f64((uint8_t)(((w_) &lt;&lt; 4)) | QS_F64_T, (d_))
#define QS_STR(str_) QS_str(str_)
#define QS_STR_ROM(str_) QS_str_ROM(str_)
#define QS_MEM(mem_, size_) QS_mem((mem_), (size_))
#if (QS_OBJ_PTR_SIZE == 1)
#define QS_OBJ(obj_) QS_u8(QS_OBJ_T, (uint8_t)(obj_))
#elif (QS_OBJ_PTR_SIZE == 2)
#define QS_OBJ(obj_) QS_u16(QS_OBJ_T, (uint16_t)(obj_))
#elif (QS_OBJ_PTR_SIZE == 4)
#define QS_OBJ(obj_) QS_u32(QS_OBJ_T, (uint32_t)(obj_))
#else
#define QS_OBJ(obj_) QS_u32(QS_OBJ_T, (uint32_t)(obj_))
#endif
#if (QS_FUN_PTR_SIZE == 1)
#define QS_FUN(fun_) QS_u8(QS_FUN_T, (uint8_t)(fun_))
#elif (QS_FUN_PTR_SIZE == 2)
</span>    <span class="p">...</span>
<span class="cp">#endif
#if (Q_SIGNAL_SIZE == 1)
#define QS_SIG(sig_, obj_)   \
    QS_u8(QS_SIG_T, (sig_)); \
    QS_OBJ_(obj_)
#elif (Q_SIGNAL_SIZE == 2)
</span>    <span class="p">...</span>
<span class="cp">#endif
</span><span class="cm">/* Dictionary records ......................................................*/</span>
<span class="cp">#define QS_OBJ_DICTIONARY(obj_) ...
#define QS_FUN_DICTIONARY(fun_) ...
#define QS_SIG_DICTIONARY(sig_, obj_) ...
</span>    <span class="p">...</span>
<span class="cm">/* Macros used only internally in the QP code ..............................*/</span>
<span class="cp">#define QS_BEGIN_(rec_, obj_) ...
#define QS_END_() ...
#define QS_BEGIN_NOLOCK_(rec_, obj_) ...
#define QS_END_NOLOCK_() ...
</span><span class="cm">/* QS functions for managing the QS trace buffer ...........................*/</span>
<span class="kt">void</span>
<span class="nf">QS_initBuf</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">sto</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">stoSize</span><span class="p">);</span>
<span class="kt">uint16_t</span> <span class="nf">QS_getByte</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                     <span class="cm">/* byte-oriented interface */</span>
<span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="nf">QS_getBlock</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="n">pNbytes</span><span class="p">);</span> <span class="cm">/* block-oriented interface */</span>
<span class="cm">/* QS callback functions, typically implemented in the BSP .................*/</span>
<span class="kt">uint8_t</span> <span class="nf">QS_onStartup</span><span class="p">(</span><span class="kt">void</span> <span class="k">const</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">QS_onCleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">QS_onFlush</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">QSTimeCtr</span> <span class="nf">QS_onGetTime</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* qs_h */</span><span class="cp">
</span></pre></table></code></div></div><p><em>qs_dummy.h</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cp">#ifndef qs_dummy_h
#define qs_dummy_h
#ifdef Q_SPY
#error "Q_SPY must NOT be defined to include qs_dummy.h"
#endif
#define QS_INIT(arg_) ((uint8_t)1)
#define QS_EXIT() ((void)0)
#define QS_DUMP() ((void)0)
#define QS_FILTER_ON(rec_) ((void)0)
#define QS_FILTER_OFF(rec_) ((void)0)
#define QS_FILTER_SM_OBJ(obj_) ((void)0)
</span><span class="p">...</span>
<span class="cp">#define QS_GET_BYTE(pByte_) ((uint16_t)0xFFFF)
#define QS_GET_BLOCK(pSize_) ((uint8_t *)0)
#define QS_BEGIN(rec_, obj_) \
    if (0)                   \
    {
#define QS_END() }
#define QS_BEGIN_NOLOCK(rec_, obj_) QS_BEGIN(rec_, obj_)
#define QS_END_NOLOCK() QS_END()
#define QS_I8(width_, data_) ((void)0)
#define QS_U8(width_, data_) ((void)0)
</span>    <span class="p">...</span>
<span class="cp">#define QS_SIG(sig_, obj_) ((void)0)
#define QS_OBJ(obj_) ((void)0)
#define QS_FUN(fun_) ((void)0)
#define QS_SIG_DICTIONARY(sig_, obj_) ((void)0)
#define QS_OBJ_DICTIONARY(obj_) ((void)0)
#define QS_FUN_DICTIONARY(fun_) ((void)0)
#define QS_FLUSH() ((void)0)
</span>    <span class="p">...</span>
<span class="cp">#endif
</span></pre></table></code></div></div><h4 id="qs-的临界区"><span class="mr-2">QS 的临界区</span><a href="#qs-的临界区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QS 目标构件必须保护<code class="language-plaintext highlighter-rouge">追踪缓存</code>的内部完整性，它在并发运行的任务和中断之间被共享，所以需要被视为<code class="language-plaintext highlighter-rouge">临界区</code></p><p>当 QS 探测 <code class="language-plaintext highlighter-rouge">QF 临界区</code>的宏 QF_INT_LOCK() ， QF_INT_UNLOCK() 被定义时， QS 使用了<strong>这个定义</strong>作为它自己的临界区。</p><p>然而，当你在<strong>没有</strong> QF 实时框架的情况下使用 QS 时，你需要在<code class="language-plaintext highlighter-rouge">qs_port.h</code>头文件里定义 QS 的<code class="language-plaintext highlighter-rouge">平台相关</code>的中断上锁 / 解锁策略</p><blockquote><p>QS_BEGIN 和 QS_END()就是利用的<code class="language-plaintext highlighter-rouge">qs_port.h</code>里定义的锁宏</p></blockquote><p>自定义的锁_qs_port.h_:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define QS_INT_KEY_TYPE . . .
</span>    <span class="cp">#define QS_INT_LOCK(key_) . . .
</span>    <span class="cp">#define QS_INT_UNLOCK(key_) . . .
</span></pre></table></code></div></div><h4 id="qs-记录的一般结构"><span class="mr-2">QS 记录的一般结构</span><a href="#qs-记录的一般结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>QS 在分离的被称为 <code class="language-plaintext highlighter-rouge">QS“追踪记录”</code> 的小块里记录追踪数据。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">QS_BEGIN_xxx</span><span class="p">(</span><span class="n">record_type</span><span class="p">)</span> <span class="cm">/* trace record begin */</span>
    <span class="n">QS_yyy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="cm">/* QS data element */</span>
    <span class="n">QS_zzz</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="cm">/* QS data element */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="cm">/* QS data element */</span>
<span class="n">QS_END_xxx</span><span class="p">()</span> <span class="cm">/* trace record end */</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">QS_BEGIN/QS_END()</code>: 在记录的开始处<code class="language-plaintext highlighter-rouge">上锁</code>中断，在记录的结尾<code class="language-plaintext highlighter-rouge">解锁</code>中断。<li><code class="language-plaintext highlighter-rouge">QS_BEGIN_NOLOCK()/QS_END_NOLOCK()</code>: 用来创建应用程序相关的记录而<code class="language-plaintext highlighter-rouge">不需进入</code>临界区，它们仅能被用于某个<code class="language-plaintext highlighter-rouge">临界区内部</code>。</ul><blockquote><p>TODO:NOLOCK 有什么意义</p></blockquote><h4 id="qs-的过滤器"><span class="mr-2">QS 的过滤器</span><a href="#qs-的过滤器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><h5 id="全局开关过滤器"><span class="mr-2">全局开/关过滤器</span><a href="#全局开关过滤器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>预定义的类型就是<code class="language-plaintext highlighter-rouge">qs.h</code>中的<code class="language-plaintext highlighter-rouge">QSpyRecords</code>枚举型，通过过滤器启用/禁用对应类型的日志记录</p><p>全局开 / 关过滤器使用一个位掩码数据<code class="language-plaintext highlighter-rouge">QS_glbFilter_[]</code>而高效的实现，这个数组的<code class="language-plaintext highlighter-rouge">每一位</code>代表一个追踪记录。当前 QS<em>glbFilter</em>[]包含 32 字节，总共 32×8 位可以代表 <code class="language-plaintext highlighter-rouge">256</code> 个不同的追踪记录。其中大约四分之一已经被用于预定义的 QP 追踪记录。剩下四分之三可以用于应用程序。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define QS_BEGIN(rec_, obj_) \
    if (((QS_glbFilter_[(uint8_t)(rec_) &gt;&gt; 3U] \
        &amp; (1U &lt;&lt; ((uint8_t)(rec_) &amp; 7U))) != 0) . . .\
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">rec_</code>表示记录类型枚举 id，从 0 到 255，右移三位表示整除 8，因为最后三位被右移掉了，相当于把余数抹除了。这样<code class="language-plaintext highlighter-rouge">QS_glbFilter_[]</code>就能定位到该 id 对应的字节,如 255 对应第 32 个字节，46 对应第 5 个字节。然后再以上一步余数（和 7 进行与操作）为<code class="language-plaintext highlighter-rouge">mask</code>找到对应的位，代码中就是将 1 左移余数值生成一个字节 8 位里的某个 mask。如 46 余数是 6，1 左移 6 位，mask 就是 0x40，找到第 5 个字节中的 0x40 mask 对应的位</p><blockquote><p>上述表达式中需要重复计算的部分可以作为编译时常数值。 如<code class="language-plaintext highlighter-rouge">(QS_glbFilter_[5] &amp; 0x40) != 0)</code></p></blockquote><blockquote><p>这里将 <code class="language-plaintext highlighter-rouge">QS_glbFilter_</code>定义为单字节数组而不是多字节数组是为了兼容性。</p></blockquote><ul><li>宏<code class="language-plaintext highlighter-rouge">QS_FILTER_ON(rec_)</code>: 打开和记录 rec_ 对应的位<li>宏<code class="language-plaintext highlighter-rouge">QS_FILTER_OFF(rec_)</code>: 关闭和记录 rec_ 相对应的位</ul><h5 id="本地过滤器"><span class="mr-2">本地过滤器</span><a href="#本地过滤器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>以对象为单位管理过滤器。如只开启对某个活动对象的打印，关闭其他的</p><p>对象类型有：状态机、活动对象、内存池、事件队列、时间事件、一般的应用程序对象</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">本地过滤器<th style="text-align: left">对象类型<th style="text-align: left">例子<th style="text-align: left">适用的 QS 记录<tbody><tr><td style="text-align: left">QS_FILTER_SM_OBJ()<td style="text-align: left">状态机<td style="text-align: left">QS_FILTER_SM_OBJ(<br />&amp;l_qhsmTst);<td style="text-align: left">QS_QEP_STATE_EMPTY,<br />QS_QEP_STATE_ENTRY,<br />QS_QEP_STATE_EXIT,<br />QS_QEP_STATE_INIT,<br />QS_QEP_INIT_TRAN,<br />QS_QEP_INTERN_TRAN,<br />QS_QEP_TRAN,<br />QS_QEP_IGNORED<tr><td style="text-align: left">QS_FILTER_AO_OBJ()<td style="text-align: left">活动对象 t<td style="text-align: left">QS_FILTER_AO_OBJ(<br />&amp;l_philo[3]);<td style="text-align: left">QS_QF_ACTIVE_ADD,<br />QS_QF_ACTIVE_REMOVE,<br />QS_QF_ACTIVE_SUBSCRIBE,<br />QS_QF_ACTIVE_UNSUBSCRIBE,<br />QS_QF_ACTIVE_POST_FIFO,<br />QS_QF_ACTIVE_POST_LIFO,<br />QS_QF_ACTIVE_GET,<br />QS_QF_ACTIVE_GET_LAST<tr><td style="text-align: left">QS_FILTER_MP_OBJ()<br />( 见注释 1)<td style="text-align: left">内存池<td style="text-align: left">QS_FILTER_MP_OBJ(<br />l_regPoolSto);<td style="text-align: left">QS_QF_MPOOL_INIT,<br />QS_QF_MPOOL_GET<br />QS_QF_MPOOL_PUT<tr><td style="text-align: left">QS_FILTER_EQ_OBJ()<br />( 见注释 2)<td style="text-align: left">事件队列<td style="text-align: left">QS_FILTER_EQ_OBJ(<br />l_philQueueSto[3]);<td style="text-align: left">QS_QF_EQUEUE_INIT,<br />QS_QF_EQUEUE_POST_FIFO,<br />QS_QF_EQUEUE_POST_LIFO,<br />QS_QF_EQUEUE_GET,<br />QS_QF_EQUEUE_GET_LAST<tr><td style="text-align: left">QS_FILTER_TE_OBJ()<td style="text-align: left">时间事件<td style="text-align: left">QS_FILTER_TE_OBJ(<br />&amp;l_philo[3].timeEvt);<td style="text-align: left">QS_QF_TICK,<br />QS_QF_TIMEEVT_ARM,<br />QS_QF_TIMEEVT_AUTO_DISARM,<br />QS_QF_TIMEEVT_DISARM_ATTEMPT,<br />QS_QF_TIMEEVT_DISARM,<br />QS_QF_TIMEEVT_REARM,<br />QS_QF_TIMEEVT_POST,<br />QS_QF_TIMEEVT_PUBLISH<tr><td style="text-align: left">QS_FILTER_AP_OBJ()<td style="text-align: left">一般的应用程序对象<td style="text-align: left">QS_FILTER_AP_OBJ(<br />&amp;myAppObject);<td style="text-align: left">以 QS_USER 开始的应用程序相关的记录</table></div><h4 id="qs-数据协议"><span class="mr-2">QS 数据协议</span><a href="#qs-数据协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>类似 HDLC 协议</p><p>QS 协议被特别设计用来简化在目标系统里的数据管理的开销，同时允许探测到任何由于追踪缓存不足造成的<code class="language-plaintext highlighter-rouge">数据丢失</code>。这个协议不但可以探测到在数据和其他错误之间的缺陷，而且允许在任何错误后立即<code class="language-plaintext highlighter-rouge">重新同步</code>，把数据丢失减到最小。</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qstransport.jpg" alt="qstransport" data-proofer-ignore></p><p>帧序号+记录类型 ID+数据域+校验码+帧尾标记</p><h5 id="透明"><span class="mr-2">透明</span><a href="#透明" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>就是对帧内出现的帧尾标记字节(0x7E)做<code class="language-plaintext highlighter-rouge">转义</code></p><p>使用 0x7D 做转义前导符，对 0x7E 做转义，当然 0x7D 本身也要转义，方法为对要转义的字符和 0x20 异或</p><p>一个例子也许可以更清楚的说明这点。假设以下的追踪记录需要被插入追踪缓存（透明字节用粗 体字显示）：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Record ID = 0x7D, Record Data = 0x7D 0x08 0x01
</pre></table></code></div></div><p>假设当前的帧顺序号码是 0x7E，校验和通过计算下列字节而得到：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Checksum == (uint8_t)(~(0x7E + 0x7D + 0x7D + 0x08 + 0x01)) == 0x7E
</pre></table></code></div></div><p>实际被插入到 QS 追踪缓存的帧如下：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>0x7D 0x5E 0x7D 0x5D 0x7D 0x5D 0x08 0x01 0x7D 0x5E 0x7E
</pre></table></code></div></div><h5 id="大小端"><span class="mr-2">大小端</span><a href="#大小端" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>QS 传输协议规定了数据是小端（ little-endian ）</p><p>高位高地址，低位低地址，优先传输低位</p><h4 id="qs-追踪缓存区"><span class="mr-2">QS 追踪缓存区</span><a href="#qs-追踪缓存区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>追踪缓存区内保存的就是<code class="language-plaintext highlighter-rouge">HDLC</code>帧</p><p>特点：</p><ul><li>第一，在追踪缓存使用 HDLC 格式的数据，允许把向追踪缓存插入数据和从指针缓存已走数据解除耦合。可以按个数丢弃，<strong>无需考虑边界(自动检测边界)</strong><li>第二，在缓存里使用格式化的数据能够使用“最后的是最好的”追踪策略。因为<code class="language-plaintext highlighter-rouge">校验码</code>可以检测<strong>覆盖导致的错误</strong>，自动丢弃被覆盖的数据</ul><h5 id="初始化-qs-追踪缓存区-qs_initbuf"><span class="mr-2">初始化 QS 追踪缓存区 QS_initBuf()</span><a href="#初始化-qs-追踪缓存区-qs_initbuf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>需要为 QS 追踪缓存分配<code class="language-plaintext highlighter-rouge">静态存储</code>，当日志数据量大时，缓存也要大，防止绕尾破坏数据（虽然该错误能被检测和处理，但数据还是丢了）</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#ifdef Q_SPY </span><span class="cm">/* define QS callbacks */</span><span class="cp">
</span><span class="kt">uint8_t</span> <span class="nf">QS_onStartup</span><span class="p">(</span><span class="kt">void</span> <span class="k">const</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">qsBuf</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">];</span> <span class="cm">/* buffer for Quantum Spy */</span>
    <span class="n">QS_initBuf</span><span class="p">(</span><span class="n">qsBuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">qsBuf</span><span class="p">));</span>

    <span class="c1">// Initialize the QS data link</span>
    <span class="p">...</span>

    <span class="k">return</span> <span class="n">success</span><span class="p">;</span> <span class="cm">/* return 1 for success and 0 for failure */</span>
<span class="p">}</span>
<span class="cp">#endif
</span></pre></table></code></div></div><h4 id="面向字节的接口-qs_getbyte"><span class="mr-2">面向字节的接口： QS_getByte()</span><a href="#面向字节的接口-qs_getbyte" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>可以在任何时候从缓存移走一个字节</p><p>函数 QS_getByte() 不上锁中断，也不是可重入的。也就是用的时候要应用自己加锁</p><p>TODO：为什么要这么设计，函数体内关中断不行吗</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">igonre</span><span class="p">);</span>
<span class="k">while</span> <span class="p">((</span><span class="n">fifo</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">QS_getByte</span><span class="p">())</span> <span class="o">!=</span> <span class="n">QS_EOD</span><span class="p">))</span> <span class="cm">/* get the next byte */</span>
<span class="p">{</span>
    <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">igonre</span><span class="p">);</span>
    <span class="c1">// 从缓存读取(移走)一个字节放入TX发送缓存</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_base</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">b</span><span class="p">);</span> <span class="cm">/* insert byte into TX FIFO */</span>
    <span class="o">--</span><span class="n">fifo</span><span class="p">;</span>

    <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">igonre</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">igonre</span><span class="p">);</span>
</pre></table></code></div></div><h4 id="面向块的接口-qs_getblock"><span class="mr-2">面向块的接口： QS_getBlock()</span><a href="#面向块的接口-qs_getblock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>获取一个块，fifo 入参表示希望获取的长度，出参表示实际获得长度。函数返回块起始指针</p><p>需要应用加锁</p><p>返回长度小于输入长度时表示缓存读尽或还有回绕，再读一次，如果长度是 0 表示缓存读尽</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">uint16_t</span> <span class="n">fifo</span> <span class="o">=</span> <span class="n">UART_16550_TXFIFO_DEPTH</span><span class="p">;</span> <span class="cm">/* 16550 Tx FIFO depth */</span>
<span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
<span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
<span class="n">block</span> <span class="o">=</span> <span class="n">QS_getBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fifo</span><span class="p">);</span> <span class="cm">/* try to get next block to transmit */</span>
<span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">fifo</span><span class="o">--</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* any bytes in the block? */</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">block</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="字典追踪记录"><span class="mr-2">字典追踪记录</span><a href="#字典追踪记录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>当你编译并把应用程序映像装入目标系统后，关于对象名，函数名和信号名的符号信息被从代码中剥离。</p><p>QS 提供了专门的追踪记录，特别被设计用来在追踪记录本身包含目标代码的<code class="language-plaintext highlighter-rouge">符号信息</code>。用于 QSPY 主机应用程序的包含在追踪记录里的<code class="language-plaintext highlighter-rouge">字典记录</code>，非常类似传统的<code class="language-plaintext highlighter-rouge">单步调试器</code>使用的嵌入在目标文件里的<code class="language-plaintext highlighter-rouge">符号信息</code>。</p><p>QS 支持 3 类字典追踪记录：对象字典，函数字典和信号字典。</p><ul><li><p>对象字典</p><p>用宏 <code class="language-plaintext highlighter-rouge">QS_OBJ_DICTONARY()</code> 来生成对象字典，它把对象在内存的<code class="language-plaintext highlighter-rouge">地址</code>和它的<code class="language-plaintext highlighter-rouge">符号名</code>联合起来。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// 通过活动对象0的内存地址获取对象的名字</span>
<span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_philo</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></table></code></div></div><li><p>函数字典</p><p>使用宏 <code class="language-plaintext highlighter-rouge">QS_FUN_DICTONARY()</code> 来生成函数字典，它把<code class="language-plaintext highlighter-rouge">函数</code>在内存的<code class="language-plaintext highlighter-rouge">地址</code>和它的<code class="language-plaintext highlighter-rouge">符号名</code>联系起来。</p><li><p>信号字典</p><p>使用宏 <code class="language-plaintext highlighter-rouge">QS_SIG_DICTONARY()</code> 来生成信号字典，它把事件信号的<code class="language-plaintext highlighter-rouge">数值</code>和<code class="language-plaintext highlighter-rouge">状态机对象</code>这两者和信号的<code class="language-plaintext highlighter-rouge">符号名</code>联系起来。</p><p>同时使用信号的数值和状态对象的理由是，仅使用信号值不能有效的把符号化信号区分出来。只有全局发行的信号在系统范围内才是唯一的。其他信号，仅在本地使用，在系统的不同状态机里有完全不同的意义。</p></ul><h4 id="应用程序相关的-qs-追踪记录"><span class="mr-2">应用程序相关的 QS 追踪记录</span><a href="#应用程序相关的-qs-追踪记录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>应用程序相关的 QS 记录允许你从应用层代码生成追踪信息。你可以把应用相关的记录想像成和 <code class="language-plaintext highlighter-rouge">printf()</code> 等效的功能，但是它有更少的开销。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">QS_BEGIN</span><span class="p">(</span><span class="n">MY_QS_RECORD</span><span class="p">,</span> <span class="n">myObjectPointer</span><span class="p">)</span> <span class="cm">/* trace record begin */</span>
  <span class="n">QS_STR</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span> <span class="cm">/* string data element */</span>
  <span class="n">QS_U8</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="cm">/* uint8_t data, 3-decimal digits format */</span>
  <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="cm">/* QS data */</span>
  <span class="n">QS_MEM</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span> <span class="cm">/* memory block of a given size */</span>
<span class="n">QS_END</span><span class="p">()</span> <span class="cm">/* trace record end */</span>
</pre></table></code></div></div><p>由 QS_BEGIN 开始，QS_BEGIN 自带上锁功能，参数为一个 QS 记录类型 MY_QS_RECORD（用于<a href="#全局开关过滤器">全局过滤器</a>）和一个对象指针 myObjectPointer（用于<a href="#本地过滤器">本地过滤器</a>）</p><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/qsapp.jpg" alt="qsapp" data-proofer-ignore></p><p>上图是上述示例代码的表示</p><h4 id="移植和配置-qs"><span class="mr-2">移植和配置 QS</span><a href="#移植和配置-qs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>修改 qs_port.h</p><h3 id="qspy-主机应用程序"><span class="mr-2">QSPY 主机应用程序</span><a href="#qspy-主机应用程序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>使用 C++实现，它的用途仅是提供 QS 数据语法分析，存储，并把数据输出到其他强大的工具比如 MATLAB。</p><h3 id="向-matlab-输出追踪数据"><span class="mr-2">向 MATLAB 输出追踪数据</span><a href="#向-matlab-输出追踪数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>略</p><h3 id="向-qp-应用程序添加-qs-软件追踪"><span class="mr-2">向 QP 应用程序添加 QS 软件追踪</span><a href="#向-qp-应用程序添加-qs-软件追踪" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="cm">/* Local-scope objects -----------------------------------------------------*/</span>
<span class="k">static</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">l_tableQueueSto</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">];</span>
<span class="k">static</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">N_PHILO</span><span class="p">][</span><span class="n">N_PHILO</span><span class="p">];</span>
<span class="k">static</span> <span class="n">QSubscrList</span> <span class="n">l_subscrSto</span><span class="p">[</span><span class="n">MAX_PUB_SIG</span><span class="p">];</span>
<span class="k">static</span> <span class="k">union</span> <span class="n">SmallEvent</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">min_size</span><span class="p">;</span>
    <span class="n">TableEvt</span> <span class="n">te</span><span class="p">;</span>
    <span class="cm">/* other event types to go into this pool */</span>
<span class="p">}</span> <span class="n">l_smlPoolSto</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N_PHILO</span><span class="p">];</span> <span class="cm">/* storage for the small event pool */</span>
<span class="cm">/*..........................................................................*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">Philo_ctor</span><span class="p">();</span>         <span class="cm">/* instantiate all Philosopher active objects */</span>
    <span class="n">Table_ctor</span><span class="p">();</span>         <span class="cm">/* instantiate the Table active object */</span>
    <span class="n">BSP_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span> <span class="cm">/* initialize the BSP (including QS) */</span>
    <span class="n">QF_init</span><span class="p">();</span>            <span class="cm">/* initialize the framework and the underlying RT kernel */</span>
    <span class="cm">/* setup the QS filters ... */</span>
    <span class="c1">// 全局过滤器默认全禁止，这里全开一下</span>
    <span class="n">QS_FILTER_ON</span><span class="p">(</span><span class="n">QS_ALL_RECORDS</span><span class="p">);</span>
    <span class="c1">// 关闭一些打印较频繁的记录类型（全局过滤器）</span>
    <span class="n">QS_FILTER_OFF</span><span class="p">(</span><span class="n">QS_QF_INT_LOCK</span><span class="p">);</span>
    <span class="n">QS_FILTER_OFF</span><span class="p">(</span><span class="n">QS_QF_INT_UNLOCK</span><span class="p">);</span>
    <span class="n">QS_FILTER_OFF</span><span class="p">(</span><span class="n">QS_QK_SCHEDULE</span><span class="p">);</span>
    <span class="cm">/* provide object dictionaries... */</span>
    <span class="c1">// 创建对象字典</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="n">l_smlPoolSto</span><span class="p">);</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="n">l_tableQueueSto</span><span class="p">);</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
    <span class="n">QF_psInit</span><span class="p">(</span><span class="n">l_subscrSto</span><span class="p">,</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_subscrSto</span><span class="p">));</span> <span class="cm">/* init publish-subscribe */</span>
    <span class="cm">/* initialize event pools... */</span>
    <span class="n">QF_poolInit</span><span class="p">(</span><span class="n">l_smlPoolSto</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">l_smlPoolSto</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">l_smlPoolSto</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N_PHILO</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* start the active objects... */</span>
        <span class="n">QActive_start</span><span class="p">(</span><span class="n">AO_Philo</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                      <span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_philoQueueSto</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">QActive_start</span><span class="p">(</span><span class="n">AO_Table</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">N_PHILO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">l_tableQueueSto</span><span class="p">,</span> <span class="n">Q_DIM</span><span class="p">(</span><span class="n">l_tableQueueSto</span><span class="p">),</span>
                  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">QF_run</span><span class="p">();</span> <span class="cm">/* run the QF application */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="定义平台相关的-qs-回调函数"><span class="mr-2">定义平台相关的 QS 回调函数</span><a href="#定义平台相关的-qs-回调函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"qp_port.h"</span><span class="cp">
#include</span> <span class="cpf">"dpp.h"</span><span class="cp">
#include</span> <span class="cpf">"bsp.h"</span><span class="cp">
</span><span class="p">...</span>
<span class="cm">/* Local-scope objects -----------------------------------------------------*/</span>
<span class="cp">#ifdef Q_SPY
</span>    <span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">l_uart_base</span><span class="p">;</span> <span class="cm">/* QS data uplink UART base address */</span>
<span class="p">...</span>
<span class="cp">#define UART_16550_TXFIFO_DEPTH 16
#endif
</span><span class="p">...</span>
<span class="cm">/*..........................................................................*/</span>
<span class="kt">void</span>
<span class="nf">BSP_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">com</span> <span class="o">=</span> <span class="s">"COM1"</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">l_delay</span> <span class="o">=</span> <span class="n">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="cm">/* set the delay counter for busy delay */</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">com</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">com</span><span class="p">;</span> <span class="cm">/* avoid compiler warning if Q_SPY not defined */</span>
    <span class="p">}</span>
    <span class="c1">// QS未启用，QS_INIT()未自定义时，总是返回True</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">QS_INIT</span><span class="p">(</span><span class="n">com</span><span class="p">))</span>
    <span class="p">{</span> <span class="cm">/* initialize QS */</span>
        <span class="c1">// 断言</span>
        <span class="n">Q_ERROR</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="c1">// 在空闲循环里， QK 可抢占式内核调用 QK_onIdle()回调函数</span>
<span class="kt">void</span> <span class="nf">QK_onIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef Q_SPY
</span>    <span class="k">if</span> <span class="p">((</span><span class="n">inportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>                                            <span class="cm">/* Tx FIFO empty? */</span>
        <span class="kt">uint16_t</span> <span class="n">fifo</span> <span class="o">=</span> <span class="n">UART_16550_TXFIFO_DEPTH</span><span class="p">;</span> <span class="cm">/* 16550 Tx FIFO depth */</span>
        <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
        <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">QS_getBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fifo</span><span class="p">);</span> <span class="cm">/* try to get next block to transmit */</span>
        <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fifo</span><span class="o">--</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span> <span class="cm">/* any bytes in the block? */</span>
            <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">block</span><span class="o">++</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#endif
</span><span class="p">}</span>
<span class="p">...</span>
<span class="cm">/*--------------------------------------------------------------------------*/</span>
<span class="cp">#ifdef Q_SPY </span><span class="cm">/* define QS callbacks */</span><span class="cp">
</span><span class="cm">/*..........................................................................*/</span>
<span class="c1">// 配置 80x86 系列 PC 的某个标准 UART （ COM1 到 COM4 ）</span>
<span class="k">static</span> <span class="kt">uint8_t</span>
<span class="nf">UART_config</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">comName</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">baud</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">comName</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="p">{</span> <span class="cm">/* Set the base address of the COMx port */</span>
    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
        <span class="n">l_uart_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="mh">0x03F8</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span> <span class="cm">/* COM1 */</span>
    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
        <span class="n">l_uart_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="mh">0x02F8</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span> <span class="cm">/* COM2 */</span>
    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
        <span class="n">l_uart_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="mh">0x03E8</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span> <span class="cm">/* COM3 */</span>
    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
        <span class="n">l_uart_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="mh">0x02E8</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span> <span class="cm">/* COM4 */</span>
    <span class="nl">default:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* COM port out of range failure */</span>
    <span class="p">}</span>
    <span class="n">baud</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="mi">115200UL</span> <span class="o">/</span> <span class="n">baud</span><span class="p">);</span>       <span class="cm">/* divisor for baud rate */</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">));</span>      <span class="cm">/* Set divisor access bit (DLAB) */</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">baud</span><span class="p">);</span> <span class="cm">/* Load divisor */</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">baud</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">));</span>            <span class="cm">/* LCR:8-bits,no p,1stop */</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/*DTR,RTS,Out2*/</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                              <span class="cm">/* Put UART into the polling FIFO mode */</span>
    <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">));</span>            <span class="cm">/* FCR: enable, TX clear */</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>                                         <span class="cm">/* success */</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="c1">// 初始化 QS 构件</span>
<span class="kt">uint8_t</span> <span class="nf">QS_onStartup</span><span class="p">(</span><span class="kt">void</span> <span class="k">const</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">qsBuf</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">];</span> <span class="cm">/* buffer for Quantum Spy */</span>
    <span class="c1">// 初始化 QS 追踪缓存</span>
    <span class="n">QS_initBuf</span><span class="p">(</span><span class="n">qsBuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">qsBuf</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">UART_config</span><span class="p">((</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="mi">115200UL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="c1">// 执行 QS 的清理工作</span>
<span class="kt">void</span> <span class="nf">QS_onCleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="c1">// 回调函数 QS_onFlush() 把整个追踪缓存发送给主机。在每个字典追踪记录后调用这个函数， 用来避免在系统初始化时追踪缓存的溢出。</span>
<span class="kt">void</span> <span class="nf">QS_onFlush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">fifo</span> <span class="o">=</span> <span class="n">UART_16550_TXFIFO_DEPTH</span><span class="p">;</span> <span class="cm">/* 16550 Tx FIFO depth */</span>
    <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
    <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">block</span> <span class="o">=</span> <span class="n">QS_getBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fifo</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
        <span class="cm">/* busy-wait until TX FIFO empty */</span>
        <span class="c1">// 忙等待意味着阻塞，所有这个函数仅能在初始化时调用</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">inportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">fifo</span><span class="o">--</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span> <span class="cm">/* any bytes in the block? */</span>
            <span class="n">outportb</span><span class="p">(</span><span class="n">l_uart_base</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">block</span><span class="o">++</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">fifo</span> <span class="o">=</span> <span class="n">UART_16550_TXFIFO_DEPTH</span><span class="p">;</span> <span class="cm">/* re-load 16550 Tx FIFO depth */</span>
        <span class="n">QF_INT_LOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">QF_INT_UNLOCK</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="c1">// 获取时间戳</span>
<span class="n">QSTimeCtr</span> <span class="nf">QS_onGetTime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* see Listing 11.18 */</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* Q_SPY */</span><span class="cp">
</span><span class="cm">/*--------------------------------------------------------------------------*/</span>
</pre></table></code></div></div><h4 id="使用回调函数-qs_ongettime-产生-qs-时间戳"><span class="mr-2">使用回调函数 QS_onGetTime() 产生 QS 时间戳</span><a href="#使用回调函数-qs_ongettime-产生-qs-时间戳" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="/assets/img/2022-07-27-quantum-platform-1/getqstime.jpg" alt="getqstime" data-proofer-ignore></p><p>8254 芯片的计时器 0 是一个 16 位<code class="language-plaintext highlighter-rouge">向下</code>计数器，它被设置成当它从 0xFFFF <code class="language-plaintext highlighter-rouge">到 0</code> 下溢，每次到 0 时产生标准的 18.2Hz 时钟<code class="language-plaintext highlighter-rouge">节拍中断</code>，下一次计数时计数器回绕成 0xFFFF。 计数速率是 1.193182MHz ，大约每个计数是 0.838 微秒。</p><p>每次系统节拍中断就记一次 0x10000，精度就是 0x10000，还要获取<code class="language-plaintext highlighter-rouge">更精细</code>的值就要读上面说的计时器了，它的值会从 0xFFFF 到 0 。中断计数成上 0x10000 加上计数器的值就是完整的值了。</p><p>有个问题就是如果系统节拍中断丢失，就会少加 0x10000，需要通过手段规避</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="cm">/* Local-scope objects -----------------------------------------------------*/</span>
<span class="cp">#ifdef Q_SPY
</span>    <span class="k">static</span> <span class="n">QSTimeCtr</span> <span class="n">l_tickTime</span><span class="p">;</span> <span class="cm">/* keeps timestamp at tick */</span>
    <span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">l_lastTime</span><span class="p">;</span>  <span class="cm">/* last timestamp */</span>
<span class="cp">#endif
</span><span class="p">...</span>
<span class="c1">// 系统时钟节拍中断</span>
<span class="kt">void</span> <span class="n">interrupt</span> <span class="nf">ISR_tmr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">pin</span><span class="p">;</span>
<span class="cp">#ifdef Q_SPY
</span>    <span class="c1">// 在中断处理程序里加0x10000</span>
    <span class="n">l_tickTime</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="cm">/* add 16-bit rollover */</span>
<span class="cp">#endif
</span>    <span class="n">QK_ISR_ENTRY</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="n">TMR_ISR_PRIO</span><span class="p">);</span> <span class="cm">/* inform QK about entering the ISR */</span>
    <span class="n">QF_tick</span><span class="p">();</span>                       <span class="cm">/* call QF_tick() outside of critical section */</span>
    <span class="n">QK_ISR_EXIT</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>                <span class="cm">/* inform QK about exiting the ISR */</span>
<span class="p">}</span>
<span class="cm">/*..........................................................................*/</span>
<span class="cp">#ifdef Q_SPY </span><span class="cm">/* define QS callbacks */</span><span class="cp">
</span><span class="p">...</span>
<span class="c1">// 总是在代码的某个临界区调用 QS_onGetTime() 函数。</span>
<span class="n">QSTimeCtr</span> <span class="nf">QS_onGetTime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* invoked with interrupts locked */</span>
    <span class="kt">uint32_t</span> <span class="n">now</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">count16</span><span class="p">;</span> <span class="cm">/* 16-bit count from the 8254 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_tickTime</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 系统节拍器已使能</span>
    <span class="p">{</span>                                              <span class="cm">/* time tick has started? */</span>
        <span class="c1">// 8254的计数器 0 被锁住。这样才能安全读取</span>
        <span class="n">outportb</span><span class="p">(</span><span class="mh">0x43</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                         <span class="cm">/* latch the 8254's counter-0 count */</span>
        <span class="n">count16</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">inportb</span><span class="p">(</span><span class="mh">0x40</span><span class="p">);</span>         <span class="cm">/* read the low byte of counter-0 */</span>
        <span class="n">count16</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">inportb</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span> <span class="cm">/* add on the hi byte */</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">l_tickTime</span> <span class="o">+</span> <span class="p">(</span><span class="mh">0x10000</span> <span class="o">-</span> <span class="n">count16</span><span class="p">);</span>
        <span class="c1">// 说明丢失了一次系统节拍中断（这个检查假设 QS_onGetTime() 在每个回绕周期被调用一次。）</span>
        <span class="c1">// 因为假设了每个中断周期内至少调用一次，所以now正常肯定是大于等于l_lastTime的</span>
        <span class="c1">// 而且要假设周期内调用的时间是一样的</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l_lastTime</span> <span class="o">&gt;</span> <span class="n">now</span><span class="p">)</span>
        <span class="p">{</span>                   <span class="cm">/* are we going "back" in time? */</span>
            <span class="c1">// 手动加1</span>
            <span class="n">now</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="cm">/* assume that there was one rollover */</span>
        <span class="p">}</span>
        <span class="n">l_lastTime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">// 系统节拍器还未使能</span>
    <span class="p">{</span>
        <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">QSTimeCtr</span><span class="p">)</span><span class="n">now</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* Q_SPY */</span><span class="cp">
</span></pre></table></code></div></div><h4 id="从主动对象产生-qs-字典"><span class="mr-2">从主动对象产生 QS 字典</span><a href="#从主动对象产生-qs-字典" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><em>table.c</em>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">// 这个是哲学家就餐问题，有叉子、饥饿等名词，Table是活动对象类</span>
<span class="k">static</span> <span class="n">Table</span> <span class="n">l_table</span><span class="p">;</span> <span class="cm">/* the single instance of the Table active object */</span>
<span class="p">...</span>
<span class="c1">// 初始伪状态比较适合做生成字典操作</span>
<span class="kt">void</span> <span class="nf">Table_initial</span><span class="p">(</span><span class="n">Table</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="n">QEvent</span> <span class="k">const</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">e</span><span class="p">;</span> <span class="cm">/* suppress the compiler warning about unused parameter */</span>
    <span class="c1">// 这个宏可以获取参数的名字，所以要用l_table而不是me，即使它们的值相同</span>
    <span class="n">QS_OBJ_DICTIONARY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_table</span><span class="p">);</span>
    <span class="c1">// 函数字典</span>
    <span class="n">QS_FUN_DICTIONARY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">QHsm_top</span><span class="p">);</span>
    <span class="n">QS_FUN_DICTIONARY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Table_initial</span><span class="p">);</span>
    <span class="n">QS_FUN_DICTIONARY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Table_serving</span><span class="p">);</span>
    <span class="c1">// 全局发行的信号的信号字典记录必须和系统里所有的状态机相联系。</span>
    <span class="c1">// 所以要给这种信号添加额外信息，这里是第二个参数</span>
    <span class="c1">// 比如在另一个状态机里是1而不是0</span>
    <span class="n">QS_SIG_DICTIONARY</span><span class="p">(</span><span class="n">DONE_SIG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* global signals */</span>
    <span class="n">QS_SIG_DICTIONARY</span><span class="p">(</span><span class="n">EAT_SIG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">QS_SIG_DICTIONARY</span><span class="p">(</span><span class="n">TERMINATE_SIG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 可以直接用me的值(一个地址)作为额外信息，保证不会重复</span>
    <span class="n">QS_SIG_DICTIONARY</span><span class="p">(</span><span class="n">HUNGRY_SIG</span><span class="p">,</span> <span class="n">me</span><span class="p">);</span> <span class="cm">/* signal just for Table */</span>
    <span class="cm">/* signal HUNGRY_SIG is posted directly */</span>
    <span class="n">QActive_subscribe</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span> <span class="n">DONE_SIG</span><span class="p">);</span>
    <span class="n">QActive_subscribe</span><span class="p">((</span><span class="n">QActive</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="p">,</span> <span class="n">TERMINATE_SIG</span><span class="p">);</span>

    <span class="n">Q_TRAN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Table_serving</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>按照<a href="#本地过滤器">本地过滤器</a>中的对象说明，这个 l_table 应该是<code class="language-plaintext highlighter-rouge">活动对象</code></p><h4 id="添加应用程序相关的追踪记录"><span class="mr-2">添加应用程序相关的追踪记录</span><a href="#添加应用程序相关的追踪记录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#ifdef Q_SPY
</span>    <span class="p">...</span>
    <span class="k">enum</span> <span class="n">AppRecords</span> <span class="p">{</span> <span class="cm">/* application-specific trace records */</span>
        <span class="c1">// 自定义的记录类型需要从QS_USER开始</span>
        <span class="n">PHILO_STAT</span> <span class="o">=</span> <span class="n">QS_USER</span>
    <span class="p">};</span>
<span class="cp">#endif
</span><span class="p">...</span>
<span class="cm">/*..........................................................................*/</span>
<span class="kt">void</span>
<span class="nf">BSP_displyPhilStat</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Video_printStrAt</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">12</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">VIDEO_FGND_YELLOW</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
    <span class="c1">// 第一个是记录类型，用于全局过滤器，第二个是应用对象，用于本地过滤器，</span>
    <span class="c1">// 这里是活动对象类型，表示只记录这个活动对象相关记录</span>
    <span class="c1">// QS_BEGIN和QS_END划定临界区</span>
    <span class="n">QS_BEGIN</span><span class="p">(</span><span class="n">PHILO_STAT</span><span class="p">,</span> <span class="n">AO_Philo</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="cm">/* application-specific record begin */</span>
        <span class="n">QS_U8</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>                  <span class="cm">/* Philosopher number */</span>
        <span class="n">QS_STR</span><span class="p">(</span><span class="n">stat</span><span class="p">);</span>                 <span class="cm">/* Philosopher status */</span>
    <span class="n">QS_END</span><span class="p">()</span>
<span class="p">}</span>
</pre></table></code></div></div><pre><code class="language-log">// 笔者注：格式是 时间 记录类型: n stat
 0000525113 User000: 4 eating
 . . .
 0000591471 User000: 3 hungry
 . . .
 0000591596 User000: 2 hungry
 . . .
 0000591730 User000: 0 hungry
 . . .
 0000852276 User000: 4 thinking
 . . .
 0000852387 User000: 3 eating
 . . .
 0000983937 User000: 1 thinking
 . . .
 0000984047 User000: 0 eating
 . . .
 0001246064 User000: 3 thinking
</code></pre><h2 id="问题"><span class="mr-2">问题</span><a href="#问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>单过程处理时间，是否在 DMA 时主动让出控制权（时间较短，让出利用率也低，还有一致性问题）<li>内存分配，由于没有栈空间，需要堆类型的空间（QP 自带的内存池）<li>state local memory，每个 AO 自己的内部变量，即使是临时变量也会占用固定空间，为了退出后下次进入状态时使用，如果是临时变量会浪费空间</ol><h2 id="参考"><span class="mr-2">参考</span><a href="#参考" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="https://www.state-machine.com/doc/PSiCC2-CN.pdf">UML 状态图的实用 C/C++设计</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/quantum-platform/" class="post-tag no-text-decoration" >quantum platform</a> <a href="/tags/qp%E7%8A%B6%E6%80%81%E6%9C%BA/" class="post-tag no-text-decoration" >QP状态机</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记 - 普通人&amp;url=https://hjk.life/posts/quantum-platform-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记 - 普通人&amp;u=https://hjk.life/posts/quantum-platform-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://hjk.life/posts/quantum-platform-1/&amp;text=《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记 - 普通人" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记 - 普通人&amp;url=https://hjk.life/posts/quantum-platform-1/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/quantum-platform-1/">《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</a><li><a href="/posts/design-patterns-principles/">软件设计模式——七大设计原则</a><li><a href="/posts/const-c/">C语言中的const</a><li><a href="/posts/c-oop/">面向对象编程(OOP)的C语言实现</a><li><a href="/posts/operating-systems-28/">《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/operating-systems-27/"><div class="card-body"> <em class="timeago small" data-ts="1655344800" > 2022-06-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二十七) 基于事件的并发（进阶）</h3><div class="text-muted small"><p> 基于事件的并发（event-based concurrency），在一些现代系统中较为流行，比如 node.js，但它源自于 C/UNIX 系统，我们下面将讨论。 基于事件的并发针对两方面的问题。一方面是多线程应用中，正确处理并发很有难度。 正如我们讨论的，忘加锁、死锁和其他烦人的问题会发生。另一方面，开发者无法控制多线程在某一时刻的调度(由系统调度)。 基本想法：事件循环 我们使用的...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-28/"><div class="card-body"> <em class="timeago small" data-ts="1655348400" > 2022-06-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</h3><div class="text-muted small"><p> 系统架构 我们先看一个典型系统的架构（见图 36.1）。其中，CPU 通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能 I/O 设备通过常规的 I/O 总线（I/O bus）连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如 SCSI、SATA 或者 USB。它们将最慢的设备连接到系统，...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-34/"><div class="card-body"> <em class="timeago small" data-ts="1655427600" > 2022-06-17 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(三十四) 崩溃一致性：FSCK和日志(未完成)</h3><div class="text-muted small"><p> 文件系统面临的一个主要挑战在于，如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构。称为崩溃一致性问题（crash-consistency problem）。 崩溃一致性问题 理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地（atomically）移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/operating-systems-37/" class="btn btn-outline-primary" prompt="上一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(三十七) 分布式系统、远程过程调用（RPC）</p></a> <a href="/posts/ipv6-over-ipv4/" class="btn btn-outline-primary" prompt="下一篇"><p>为ipv4 only设备添加ipv6支持</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "ProphetHJK/prophethjk.github.io", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjk1MjU2NjI=", "data-category": "General", "data-category-id": "DIC_kwDOE6Qpns4CPYgF", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/prophethjk">Jinkai</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备20006745号-2</a> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VEN4M3BMXV"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VEN4M3BMXV'); }); </script>
