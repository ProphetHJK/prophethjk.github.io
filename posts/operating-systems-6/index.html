<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列" /><meta name="author" content="Jinkai" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本章将介绍一种著名的调度方法–多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。" /><meta property="og:description" content="本章将介绍一种著名的调度方法–多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。" /><link rel="canonical" href="https://hjk.life/posts/operating-systems-6/" /><meta property="og:url" content="https://hjk.life/posts/operating-systems-6/" /><meta property="og:site_name" content="普通人" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-18T09:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jinkai" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Jinkai"},"description":"本章将介绍一种著名的调度方法–多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。","url":"https://hjk.life/posts/operating-systems-6/","@type":"BlogPosting","headline":"《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列","dateModified":"2021-09-14T09:54:44+08:00","datePublished":"2021-03-18T09:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://hjk.life/posts/operating-systems-6/"},"@context":"https://schema.org"}</script><title>《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列 | 普通人</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="普通人"><meta name="application-name" content="普通人"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/Humanity.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">普通人</a></div><div class="site-subtitle font-italic">潜龙勿用</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/prophethjk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['prophethjk','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Jinkai </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2021-03-18, 09:00 +0800" >03-18<i class="unloaded">2021-03-18T09:00:00+08:00</i> </span></div><div> <span> 更新于 <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2021-09-14, 09:54 +0800" >09-14<i class="unloaded">2021-09-14T09:54:44+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3488 字">19 分钟 阅读</span></div></div><div class="post-content"><p>本章将介绍一种著名的调度方法–<code class="language-plaintext highlighter-rouge">多级反馈队列</code>（Multi-level Feedback Queue，<code class="language-plaintext highlighter-rouge">MLFQ</code>）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。</p><blockquote><p><strong>提示：从历史中学习</strong></p><p>多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。</p></blockquote><h2 id="mlfq基本规则">MLFQ：基本规则</h2><p>MLFQ 中有许多独立的<code class="language-plaintext highlighter-rouge">队列</code>（queue），每个队列有不同的<code class="language-plaintext highlighter-rouge">优先级</code>（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是<strong>优先执行较高优先级</strong>的工作（即在<strong>较高级队列</strong>中的工作）。对于同一个队列中的任务，采用<code class="language-plaintext highlighter-rouge">轮转调度</code>。</p><p><code class="language-plaintext highlighter-rouge">MLFQ</code>中工作优先级并不是固定的，而是会根据进程的行为<code class="language-plaintext highlighter-rouge">动态调整优先级</code>。例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是<strong>交互型进程</strong>的可能行为，MLFQ 因此会让它保持<strong>高优先级</strong>。相反，如果一个工作<strong>长时间地占用</strong> CPU，MLFQ 会<strong>降低其优先级</strong>。</p><p>MLFQ 的两条基本规则:</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。<li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B 。</ul><p><img data-proofer-ignore data-src="/assets/img/2021-03-18-operating-systems-6/mlfq-1.jpg" alt="mlfq-1" /></p><h2 id="尝试-1如何改变优先级">尝试 1：如何改变优先级</h2><p>我们必须决定，在一个工作的生命周期中，MLFQ 如何改变其优先级（在哪个队列中）。要做到这一点，我们必须记得工作负载：既有<strong>运行时间很短</strong>、<strong>频繁放弃 CPU</strong> 的<code class="language-plaintext highlighter-rouge">交互型工作</code>，也有需要<strong>很多 CPU 时间</strong>、<strong>响应时间却不重要</strong>的长时间<code class="language-plaintext highlighter-rouge">计算密集型工作</code>。下面是我们第一次尝试优先级调整算法。</p><ul><li><strong>规则 3</strong> ：工作进入系统时，放在最高优先级（最上层队列）。<li><strong>规则 4a</strong>：工作用完整个时间片后，降低其优先级（移入下一个队列）。<li><strong>规则 4b</strong>：如果工作在其时间片以内主动释放 CPU，则优先级不变。</ul><h3 id="实例-1单个长工作">实例 1：单个长工作</h3><p><img data-proofer-ignore data-src="/assets/img/2021-03-18-operating-systems-6/mlfq-2.jpg" alt="mlfq-2" /></p><p>从这个例子可以看出，该工作首先进入最高优先级（Q2）。执行一个 10ms 的时间片后，调度程序将工作的优先级减 1，因此进入 Q1。在 Q1 执行一个时间片后，最终降低优先级进入系统的最低优先级（Q0），并一直留在那里。</p><h3 id="实例-2加入一个短工作">实例 2：加入一个短工作</h3><p><img data-proofer-ignore data-src="/assets/img/2021-03-18-operating-systems-6/mlfq-3.jpg" alt="mlfq-3" /></p><p>B 在 T=100 时到达</p><p>如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，<strong>MLFQ 近似于 SJF</strong>(最短任务优先)。</p><h3 id="实例-3如果有-io-呢">实例 3：如果有 I/O 呢</h3><p><img data-proofer-ignore data-src="/assets/img/2021-03-18-operating-systems-6/mlfq-4.jpg" alt="mlfq-4" /></p><p>交互型工作 B（用灰色表示）每执行 1ms 便需要进行 I/O 操作，它与长时间运行的工作 A（用黑色表示）竞争 CPU。MLFQ 算法保持 B 在最高优先级，因为 B 总是让出 CPU。如果 B 是交互型工作，MLFQ 就进一步实现了它的目标，让交互型工作快速运行</p><h3 id="当前-mlfq-的一些问题">当前 MLFQ 的一些问题</h3><ol><li>饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。<li>愚弄调度程序（game the scheduler）。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。<li>一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间需要作为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。因为优先级一旦下降就无法提升</ol><h2 id="尝试-2提升优先级">尝试 2：提升优先级</h2><p>为解决[1]饥饿问题</p><ul><li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</ul><p><img data-proofer-ignore data-src="/assets/img/2021-03-18-operating-systems-6/mlfq-5.jpg" alt="mlfq-5" /></p><ol><li><strong>左边没有优先级提升</strong>，长工作在两个短工作到达后被饿死。<li><strong>右边每 50ms 就有一次优先级提升</strong>（这里只是举例，这个值可能过小），因此至少保证长工作会有一些进展，每过 50ms 就被提升到最高优先级，从而定期获得执行。</ol><p>添加时间段 S 导致了明显的问题：S 的值应该如何设置？德高望重的系统研究员 John Ousterhout 曾将这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例。</p><h2 id="尝试-3更好的计时方式">尝试 3：更好的计时方式</h2><p>为解决[2]愚弄调度程序问题</p><p>起因是规则 4a 和 4b 不合理，调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。</p><p>重写规则 4：</p><ul><li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。</ul><p><img data-proofer-ignore data-src="/assets/img/2021-03-18-operating-systems-6/mlfq-6.jpg" alt="mlfq-6" /></p><p>没有<strong>规则 4</strong>的保护时，进程可以在每个时间片结束前发起一次 I/O 操作，从而垄断 CPU 时间。有了这样的保护后，不论进程的 I/O 行为如何，都会慢慢地降低优先级，因而无法获得超过公平的 CPU 时间比例。同时由于<strong>规则 5</strong>的存在，原来的交互性进程还是可以在之后提升优先级。</p><h2 id="mlfq-调优及其他问题">MLFQ 调优及其他问题</h2><p>关于 MLFQ 调度算法还有一些问题。其中一个大问题是<strong>如何配置</strong>一个调度程序，例如：</p><ol><li>配置多少队列？<li>每一层队列的时间片配置多大？<li>为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？</ol><p>这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。</p><p><img data-proofer-ignore data-src="/assets/img/2021-03-18-operating-systems-6/mlfq-7.jpg" alt="mlfq-7" /></p><p>例如，大多数的 MLFQ 变体都支持不同队列可变的时间片长度。<strong>高优先级队列通常只有较短的时间片</strong>（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，<strong>低优先级队列</strong>中更多的是 CPU 密集型工作，配置<strong>更长的时间片</strong>会取得更好的效果。图 8.7 展示了一个例子，两个长工作在高优先级队列执行 10ms，中间队列执行 20ms，最后在最低优先级队列执行 40ms。</p><p><code class="language-plaintext highlighter-rouge">Solaris</code> 的 MLFQ 实现（<code class="language-plaintext highlighter-rouge">时分调度类 TS</code>）很容易配置。它提供了<code class="language-plaintext highlighter-rouge">一组表</code>来决定进程在其生命周期中如何调整优先级，每层的时间片多大，以及多久提升一个工作的优先级。管理员可以通过这些表，让调度程序的行为方式不同。该表默认有 60 层队列，时间片长度从 20ms（最高优先级），到几百 ms（最低优先级），每一秒左右提升一次进程的优先级。</p><p>其他一些 MLFQ 调度程序没用表，甚至没用本章中讲到的规则，有些采用数学公式来调整优先级。例如，<code class="language-plaintext highlighter-rouge">FreeBSD</code> 调度程序（4.3 版本），会基于当前进程使用了多少 CPU，通过公式计算某个工作的当前优先级。另外，使用量会随时间衰减，这提供了期望的优先级提升，但与这里描述方式不同。阅读 Epema 的论文，他漂亮地概括了这种使用量衰减（decay-usage）算法及其特征</p><p>最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的<code class="language-plaintext highlighter-rouge">建议</code>（advice），比如通过命令行工具 <code class="language-plaintext highlighter-rouge">nice</code>，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看 man 手册。</p><blockquote><p><strong>提示：尽可能多地使用建议</strong></p><p>操作系统很少知道什么策略对系统中的单个进程和每个进程算是好的，因此提供接口并允许用户或管理员给操作系统一些提示（hint）常常很有用。我们通常称之为建议（advice），因为操作系统不一定要关注它，但是可能会将建议考虑在内，以便做出更好的决定。这种用户建议的方式在操作系统中的各个领域经常十分有用，包括调度程序（通过 nice）、内存管理（madvise），以及文件系统（通知预取和缓存[P+95]）</p></blockquote><h2 id="mlfq小结">MLFQ：小结</h2><p>本章介绍了一种调度方式，名为<code class="language-plaintext highlighter-rouge">多级反馈队列</code>（MLFQ）。</p><p>本章包含了一组优化的 MLFQ 规则。为了方便查阅，我们重新列在这里。</p><ul><li><strong>规则 1</strong>：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。<li><strong>规则 2</strong>：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。<li><strong>规则 3</strong>：工作进入系统时，放在最高优先级（最上层队列）。<li><strong>规则 4</strong>：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。<li><strong>规则 5</strong>：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</ul><p>MLFQ 有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ 可以同时满足各种工作的需求：<strong>对于短时间运行的交互型工作，获得类似于 SJF/STCF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前</strong>。因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括<code class="language-plaintext highlighter-rouge">类 BSD UNIX 系统</code>、<code class="language-plaintext highlighter-rouge">Solaris</code>以及 <code class="language-plaintext highlighter-rouge">Windows NT</code> 和其后的 <code class="language-plaintext highlighter-rouge">Window 系列操作系统</code>。</p><h2 id="作业">作业</h2><p>程序 <code class="language-plaintext highlighter-rouge">mlfq.py</code> 允许你查看本章介绍的 MLFQ 调度程序的行为。详情请参阅 README 文件。</p><ol><li>只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算 MLFQ 的执行记录。限制每项作业的长度并关闭 I/O，让你的生活更轻松。<li>如何运行调度程序来重现本章中的每个实例？<li>将如何配置调度程序参数，像轮转调度程序那样工作？<li>设计两个工作的负载和调度程序参数，以便一个工作利用较早的规则 4a 和 4b（用-S 标志打开）来“愚弄”调度程序，在特定的时间间隔内获得 99%的 CPU。<li>给定一个系统，其最高队列中的时间片长度为 10ms，你需要如何频繁地将工作推回到最高优先级级别（带有-B 标志），以保证一个长时间运行（并可能饥饿）的工作得到至少 5%的 CPU？<li>调度中有一个问题，即刚完成 I/O 的作业添加在队列的哪一端。-I 标志改变了这个调度模拟器的这方面行为。尝试一些工作负载，看看你是否能看到这个标志的效果。</ol><h2 id="参考">参考</h2><ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/08.pdf">Operating Systems: Three Easy Pieces 中文版</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-systems/" class="post-tag no-text-decoration" >Operating Systems</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" class="post-tag no-text-decoration" >操作系统导论</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列 - 普通人&url=https://hjk.life/posts/operating-systems-6/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列 - 普通人&u=https://hjk.life/posts/operating-systems-6/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列 - 普通人&url=https://hjk.life/posts/operating-systems-6/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/docker-cross-compile/">移植Docker到ARM嵌入式设备</a><li><a href="/posts/design-patterns-principles/">软件设计模式——七大设计原则</a><li><a href="/posts/operating-systems-5/">《Operating Systems: Three Easy Pieces》学习笔记(五) 进程调度：介绍</a><li><a href="/posts/operating-systems-6/">《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列</a><li><a href="/posts/memory-fork-error/">Linux系统中内存不足导致system()执行失败的问题</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/cisco/">Cisco</a> <a class="post-tag" href="/tags/container/">container</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/operating-systems-1/"><div class="card-body"> <span class="timeago small" >03-11<i class="unloaded">2021-03-11T09:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(一) 操作系统介绍</h3><div class="text-muted small"><p> 本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出 虚拟化 CPU 首先看个例子 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/time.h&gt; #include &...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-2/"><div class="card-body"> <span class="timeago small" >03-12<i class="unloaded">2021-03-12T09:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二) 抽象：进程</h3><div class="text-muted small"><p> 本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出 进程 API 创建（create） 操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。 销毁（destroy） 由于存在创建...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-3/"><div class="card-body"> <span class="timeago small" >03-12<i class="unloaded">2021-03-12T17:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API</h3><div class="text-muted small"><p> fork()系统调用 在执行函数 fork()时，创建了一个子进程，此时是两个进程同时运行 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char *argv[]) { printf("hello world (pid:%d)\n",...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/operating-systems-5/" class="btn btn-outline-primary" prompt="上一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(五) 进程调度：介绍</p></a> <a href="/posts/vscode-git-gutter/" class="btn btn-outline-primary" prompt="下一篇"><p>关于VSCode使用Remote SSH时git gutter(代码差异装饰器)无法显示的问题</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://hjk.life/posts/operating-systems-6/'; this.page.identifier = '/posts/operating-systems-6/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://jksky.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (modeToggle !== null) { modeToggle.addEventListener('click', reloadDisqus); window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/prophethjk">Jinkai</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/cisco/">Cisco</a> <a class="post-tag" href="/tags/container/">container</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://hjk.life{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VEN4M3BMXV"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VEN4M3BMXV'); }); </script>
