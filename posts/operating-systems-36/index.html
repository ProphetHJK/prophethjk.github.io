<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护" /><meta name="author" content="Jinkai" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="磁盘故障模式" /><meta property="og:description" content="磁盘故障模式" /><link rel="canonical" href="https://hjk.life/posts/operating-systems-36/" /><meta property="og:url" content="https://hjk.life/posts/operating-systems-36/" /><meta property="og:site_name" content="普通人" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-17T10:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jinkai" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jinkai"},"dateModified":"2022-06-20T09:32:03+08:00","datePublished":"2022-06-17T10:00:00+08:00","description":"磁盘故障模式","headline":"《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护","mainEntityOfPage":{"@type":"WebPage","@id":"https://hjk.life/posts/operating-systems-36/"},"url":"https://hjk.life/posts/operating-systems-36/"}</script><title>《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护 | 普通人</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="普通人"><meta name="application-name" content="普通人"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/favicons/Humanity.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">普通人</a></div><div class="site-subtitle font-italic">潜龙勿用</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/prophethjk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['prophethjk','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/prophethjk">Jinkai</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1655431200" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-06-17 </em> </span> <span> 更新于 <em class="timeago" data-ts="1655688723" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-06-20 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2927 字"> <em>16 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="磁盘故障模式"><span class="mr-2">磁盘故障模式</span><a href="#磁盘故障模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="潜在扇区错误latent-sector-errorslse"><span class="mr-2">潜在扇区错误（Latent-Sector Errors，LSE）</span><a href="#潜在扇区错误latent-sector-errorslse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>如果磁头由于某种 原因接触到表面（磁头碰撞，head crash，在正常操作期间不应发生的情况），则可能会<code class="language-plaintext highlighter-rouge">讹误表面</code>，使得数据位<code class="language-plaintext highlighter-rouge">不可读</code>。宇宙射线也会导致数据<code class="language-plaintext highlighter-rouge">位翻转</code>，使内容不正确。</p><p>驱动器使用磁盘内<code class="language-plaintext highlighter-rouge">纠错码</code>（Error Correcting Code，ECC）来确定块中的磁盘位是否良好，并且在某些情况下，修复它们。</p><h3 id="块讹误block-corruption"><span class="mr-2">块讹误（block corruption）</span><a href="#块讹误block-corruption" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>磁盘块出现讹误（corrupt），但磁盘本身无法检测到。</p><p>例如，有缺陷的磁盘固件可能会将块写入<code class="language-plaintext highlighter-rouge">错误的位置</code>。在这种情况下，磁盘 ECC 指示块内容很好，但是从客户端的角度来看，在随后访问时返回错误的块。类似地，当一个块通过有<code class="language-plaintext highlighter-rouge">故障的总线</code>从主机传输到磁盘时，它可能会讹误。由此产生的讹误数据会<code class="language-plaintext highlighter-rouge">存入磁盘</code>，但它不是客户<code class="language-plaintext highlighter-rouge">所希望的</code>。这些类型的故障特别<code class="language-plaintext highlighter-rouge">隐蔽</code>，因为它们是无声的故障（silent fault）。返回故障数据时，磁盘没有报告问题。</p><p><img data-src="/assets/img/2022-06-17-operating-systems-36/T44.1.jpg" alt="T44.1" data-proofer-ignore></p><p>该表显示了在研究过程中<code class="language-plaintext highlighter-rouge">至少出现一次 LSE 或块讹误</code>的驱动器<code class="language-plaintext highlighter-rouge">百分比</code>（大约 3 年，超过 150 万个磁盘驱动器）。该表进一步将结果细分为“<code class="language-plaintext highlighter-rouge">廉价</code>”驱动器（通常为 <code class="language-plaintext highlighter-rouge">SATA驱动器</code>） 和“<code class="language-plaintext highlighter-rouge">昂贵</code>”驱动器（通常为 <code class="language-plaintext highlighter-rouge">SCSI</code> 或 <code class="language-plaintext highlighter-rouge">FibreChannel</code>）。</p><p>关于 LSE 的一些其他发现如下：</p><ul><li>具有多个 LSE 的昂贵驱动器可能会像廉价驱动器一样产生附加错误。<li>对于大多数驱动器，第二年的年度错误率会增加。<li>LSE 随磁盘大小增加。<li>大多数磁盘的 LSE 少于 50 个。<li>具有 LSE 的磁盘更有可能发生新增的 LSE。<li>存在显著的空间和时间局部性。<li>磁盘清理很有用（大多数 LSE 都是这样找到的）。</ul><p>关于讹误的一些发现如下：</p><ul><li>同一驱动器类别中不同驱动器型号的讹误机会差异很大。<li>老化效应因型号而异。<li>工作负载和磁盘大小对讹误几乎没有影响。<li>大多数具有讹误的磁盘只有少数讹误。<li>讹误不是与一个磁盘或 RAID 中的多个磁盘无关的。<li>存在空间局部性和一些时间局部性。<li>与 LSE 的相关性较弱。</ul><h2 id="处理潜在的扇区错误"><span class="mr-2">处理潜在的扇区错误</span><a href="#处理潜在的扇区错误" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>潜在的扇区错误很容易处理，因为它们（根据定义）很容易<code class="language-plaintext highlighter-rouge">被检测到</code>。当存储系统尝试访问块，并且磁盘<code class="language-plaintext highlighter-rouge">返回错误</code>时，存储系统应该就用它具有的任何<code class="language-plaintext highlighter-rouge">冗余机制</code>， 来返回正确的数据。</p><p>例如，在镜像 RAID 中，系统应该访问备用副本。在基于奇偶校验的 RAID-4 或 RAID-5 系统中，系统应通过奇偶校验组中的其他块重建该块。因此，利用标准冗余机制，可以容易地恢复诸如 LSE 这样的容易检测到的问题。</p><h2 id="检测讹误校验和"><span class="mr-2">检测讹误：校验和</span><a href="#检测讹误校验和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>如何处理数据讹误导致的无声故障？</p><dl><dt>校验和（checksum）<dd>校验和就是一个函数的结果，该函数以<code class="language-plaintext highlighter-rouge">一块数据</code>（例如 4KB 块）作为<code class="language-plaintext highlighter-rouge">输入</code>，并<code class="language-plaintext highlighter-rouge">计算</code>这段数据的函数，产生数据内容的小<code class="language-plaintext highlighter-rouge">概要</code>（比如 4 字节或 8 字节）。此摘要称为校验和</dl><h3 id="常见的校验和函数"><span class="mr-2">常见的校验和函数</span><a href="#常见的校验和函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="基于异或xor"><span class="mr-2">基于异或（XOR）</span><a href="#基于异或xor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用基于 XOR 的校验和，只需对需要校验和的数据块的<code class="language-plaintext highlighter-rouge">每个块</code>进行<code class="language-plaintext highlighter-rouge">异或运算</code>，从而生成一个值，表示整个块的 XOR。</p><p>XOR 计算规则：</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">$p$<th style="text-align: center">$q$<th>$p \oplus q$<tbody><tr><td style="text-align: center">True<td style="text-align: center">True<td>False<tr><td style="text-align: center">True<td style="text-align: center">False<td>True<tr><td style="text-align: center">False<td style="text-align: center">True<td>True<tr><td style="text-align: center">False<td style="text-align: center">False<td>False</table></div><p>交换律：${\displaystyle p\oplus q=q\oplus p}$</p><p>结合律：${\displaystyle p\oplus (q\oplus r)=(p\oplus q)\oplus r}$</p><p>恒等律：${\displaystyle p\oplus 0=p}$</p><p>归零律：${\displaystyle p\oplus p=0}$</p><p>自反：${\displaystyle p\oplus q\oplus q=p\oplus 0=p}$</p><p><strong>实例</strong>：</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="go">// 源数据
365e c4cd ba14 8a92 ecef 2c3a 40be f666
// 二进制
0011 0110 0101 1110 1100 0100 1100 1101
1011 1010 0001 0100 1000 1010 1001 0010
1110 1100 1110 1111 0010 1100 0011 1010
0100 0000 1011 1110 1111 0110 0110 0110
</span></pre></table></code></div></div><p>我们以<code class="language-plaintext highlighter-rouge">每行 4 个字节</code>为一组排列数据，所以很容易看出生成的校验和是什么。只需<code class="language-plaintext highlighter-rouge">对每列执行XOR</code>以获得最终的校验和值(有 0 个或 2 个 1 就是 0，有 1 个或 3 个 1 就是 1)：</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="go">0010 0000 0001 1011 1001 0100 0000 0011
</span></pre></table></code></div></div><p>XOR 是一个合理的校验和，但有其<code class="language-plaintext highlighter-rouge">局限性</code>。例如，如果每个校验和单元内<code class="language-plaintext highlighter-rouge">同一列</code>的<code class="language-plaintext highlighter-rouge">两个位</code>发生变化，则校验和将不会检测到讹误</p><h4 id="加法"><span class="mr-2">加法</span><a href="#加法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>这种方法具有<code class="language-plaintext highlighter-rouge">快速</code>的优点。计算它只需要在每个数据块上执行<code class="language-plaintext highlighter-rouge">二进制补码加法</code>，<code class="language-plaintext highlighter-rouge">忽略溢出</code>。它可以检测到数据中的许多变化，但如果数据被<code class="language-plaintext highlighter-rouge">移位</code>，则不好</p><h4 id="fletcher-校验和fletcher-checksum"><span class="mr-2">Fletcher 校验和（Fletcher checksum）</span><a href="#fletcher-校验和fletcher-checksum" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>它非常简单，涉及两个校验字节 s1 和 s2 的计算。</p><p>假设块 D 由字节 d1,…, dn 组成。s1 简单地定义如下：s1 = s1 + di mod 255（在所有 di 上计算）。s2 依次为：s2 = s2 + s1 mod 255（同样在所有 di 上）</p><p><code class="language-plaintext highlighter-rouge">fletcher 校验和</code>几乎与 <code class="language-plaintext highlighter-rouge">CRC</code>（下面描述）一样强，可以检测所有<code class="language-plaintext highlighter-rouge">单比特错误</code>，所有<code class="language-plaintext highlighter-rouge">双比特错误</code>和<code class="language-plaintext highlighter-rouge">大部分突发错误</code></p><h4 id="循环冗余校验crc"><span class="mr-2">循环冗余校验（CRC）</span><a href="#循环冗余校验crc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>你所做的只是将 D 视为一个<code class="language-plaintext highlighter-rouge">大的二进制数</code>（毕竟它只是一串位）并将其<code class="language-plaintext highlighter-rouge">除以约定的值</code>（<code class="language-plaintext highlighter-rouge">k</code>）。该除法的<code class="language-plaintext highlighter-rouge">其余部分</code>是 CRC 的值。</p><p>g(x)和 h(x)的<code class="language-plaintext highlighter-rouge">除运算</code>，可以通过 g 和 h 做<code class="language-plaintext highlighter-rouge">xor（异或）</code>运算。比如将 11001 与 10101 做 xor 运算：</p><p><img data-src="/assets/img/2022-06-17-operating-systems-36/crc001.gif" alt="crc1" data-proofer-ignore></p><p>明白了 xor 运算法则后，举一个例子使用<code class="language-plaintext highlighter-rouge">CRC-8</code>算法求 101001110100001 的效验码。CRC-8 标准的 h(x) = x^8 + x^7 + x^6 + x^4 + x^2 + 1，既 h 是 9 位的二进制串 111010101。</p><p><img data-src="/assets/img/2022-06-17-operating-systems-36/crc002.gif" alt="crc2" data-proofer-ignore></p><h4 id="缺陷"><span class="mr-2">缺陷</span><a href="#缺陷" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>无论使用何种方法，很明显没有完美的校验和：两个具有<code class="language-plaintext highlighter-rouge">不相同内容</code>的数据块可能具有<code class="language-plaintext highlighter-rouge">相同的校验和</code>，这被称为<code class="language-plaintext highlighter-rouge">碰撞</code>（collision）</p><h3 id="校验和布局"><span class="mr-2">校验和布局</span><a href="#校验和布局" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>最基本的方法就是为<code class="language-plaintext highlighter-rouge">每个磁盘扇区（或块）</code>存储校验和。给定数据块 D，我们称该数据的校验和为 C（D）。</p><p><img data-src="/assets/img/2022-06-17-operating-systems-36/F1.jpg" alt="F1" data-proofer-ignore></p><p>因为<code class="language-plaintext highlighter-rouge">校验和</code>通常<code class="language-plaintext highlighter-rouge">很小</code>（例如，<code class="language-plaintext highlighter-rouge">8 字节</code>），并且磁盘只能以扇区大小的块（<code class="language-plaintext highlighter-rouge">512 字节</code>）或其倍数<code class="language-plaintext highlighter-rouge">写入</code>，所以出现的一个问题是如何实现上述布局。驱动器制造商采用的一种解决方案是使用 <code class="language-plaintext highlighter-rouge">520 字节</code>扇区格式化驱动器，每个扇区<code class="language-plaintext highlighter-rouge">额外的 8 个字节</code>可用于存储校验和</p><p>在没有此类功能的磁盘中，文件系统必须找到一种方法来将<code class="language-plaintext highlighter-rouge">打包的校验和</code>存储到 512 字节的块中。一种可能性如下：</p><p><img data-src="/assets/img/2022-06-17-operating-systems-36/F2.jpg" alt="F2" data-proofer-ignore></p><p>多了写校验和扇区的操作，比前面的方法多了一步</p><h2 id="使用校验和"><span class="mr-2">使用校验和</span><a href="#使用校验和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>读数据计算校验和，读存储的校验和，比较是否相同</p><h2 id="一个新问题错误的写入"><span class="mr-2">一个新问题：错误的写入</span><a href="#一个新问题错误的写入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>“<code class="language-plaintext highlighter-rouge">错误位置的写入</code>（misdirected write）”。这出现在<code class="language-plaintext highlighter-rouge">磁盘和RAID控制器</code>中，它们正确地将数据写入磁盘，但<code class="language-plaintext highlighter-rouge">位置错误</code>。在<code class="language-plaintext highlighter-rouge">单磁盘系统</code>中，这意味着磁盘写入块 Dx 不是在地址 x（像期望那样），而是在地址 y（因此是“讹误的”Dy）。另外，在<code class="language-plaintext highlighter-rouge">多磁盘系统</code>中，控制器也可能将 Di，x 不是写入磁盘 i 的 x，而是写入<code class="language-plaintext highlighter-rouge">另一磁盘</code> j。</p><p>答案很简单：在每个<code class="language-plaintext highlighter-rouge">校验和</code>中<code class="language-plaintext highlighter-rouge">添加更多信</code>息。在这种情况下，添加<code class="language-plaintext highlighter-rouge">物理标识符</code>（Physical Identifier，物理 ID）非常有用。例如，如果存储的信息现在包含校验和 C（D） 以及块的磁盘和扇区号，则客户端很容易确定块内是否存在正确的信息。具体来说，如果客户端正在读取磁盘 10 上的块 4（D10,4），则存储的信息应包括该<code class="language-plaintext highlighter-rouge">磁盘号</code>和<code class="language-plaintext highlighter-rouge">扇区偏移量</code>，如下所示。如果<code class="language-plaintext highlighter-rouge">信息不匹配</code>，则发生了<code class="language-plaintext highlighter-rouge">错误位置写入</code>，并且现在检测到讹误。以下是在双磁盘系统上添加此信息的示例:</p><p><img data-src="/assets/img/2022-06-17-operating-systems-36/F3.jpg" alt="F3" data-proofer-ignore></p><h2 id="最后一个问题丢失的写入"><span class="mr-2">最后一个问题：丢失的写入</span><a href="#最后一个问题丢失的写入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><dl><dt>丢失的写入（lost write）<dd>当设备通知上层写入<code class="language-plaintext highlighter-rouge">已完成</code>，但事实上它从<code class="language-plaintext highlighter-rouge">未持久</code>，就会发生这种问题。因此，磁盘上留下的是该块的<code class="language-plaintext highlighter-rouge">旧内容</code>，而不是更新的新内容</dl><p>某些系统在系统的其他位置添加校验和，以检测丢失的写入。例如，Sun 的 Zettabyte 文件系统（ZFS）在文件系统的每个 inode 和间接块中，包含文件中每个块的校验和。因此，即使对数据块本身的写入丢失，inode 内的校验和也不会与旧数据匹配。只有当同时丢失对 inode 和数据的写入时，这样的方案才会失败。</p><h2 id="擦净"><span class="mr-2">擦净</span><a href="#擦净" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>这些校验和<code class="language-plaintext highlighter-rouge">何时</code>实际得到<code class="language-plaintext highlighter-rouge">检查</code>？当然，在应用程序访问数据时会发生一些检查，但大多数数据很少被访问，因此将保持未检查状态。</p><p>许多系统利用各种形式的<code class="language-plaintext highlighter-rouge">磁盘擦净</code>（disk scrubbing）。通过<code class="language-plaintext highlighter-rouge">定期读取</code>系统的每个块，并<code class="language-plaintext highlighter-rouge">检查校验和</code>是否仍然有效，磁盘系统可以减少某个数据项的所有副本都被破坏的可能性。典型的系统<code class="language-plaintext highlighter-rouge">每晚或每周</code>安排扫描。</p><h2 id="校验和的开销"><span class="mr-2">校验和的开销</span><a href="#校验和的开销" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="空间开销"><span class="mr-2">空间开销</span><a href="#空间开销" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>典型的比率可能是每 4KB 数据块的 8 字节校验和，磁盘空间开销为 <code class="language-plaintext highlighter-rouge">0.19%</code>。</p><p>访问数据时，内存中必须有足够的空间用于校验和以及数据本身。这种开销是 短暂的，并不是很重要。</p><h3 id="时间开销"><span class="mr-2">时间开销</span><a href="#时间开销" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><code class="language-plaintext highlighter-rouge">CPU</code> 必须<code class="language-plaintext highlighter-rouge">计算</code>每个块的校验和，包括存储数据时（确定存储的校验和的值），以及访问时（再次计算校验和， 并将其与存储的校验和进行比较）。</p><p>除了 CPU 开销之外，一些校验和方案可能会导致外部 I/O 开销，特别是当校验和与数据<code class="language-plaintext highlighter-rouge">分开存储</code>时（因此需要额外的 I/O 来访问它们），以及<code class="language-plaintext highlighter-rouge">后台擦净</code>所需的所有额外 I/O。</p><h2 id="小结"><span class="mr-2">小结</span><a href="#小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>我们已经讨论了现代存储系统中的数据保护，重点是校验和的实现和使用。不同的校验和可以防止不同类型的故障。随着存储设备的发展，毫无疑问会出现新的故障模式。也许这种变化将迫使研究界和行业重新审视其中的一些基本方法，或发明全新的方法。</p><h2 id="参考"><span class="mr-2">参考</span><a href="#参考" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/44.pdf">Operating Systems: Three Easy Pieces 中文版</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-systems/" class="post-tag no-text-decoration" >Operating Systems</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" class="post-tag no-text-decoration" >操作系统导论</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护 - 普通人&amp;url=https://hjk.life/posts/operating-systems-36/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护 - 普通人&amp;u=https://hjk.life/posts/operating-systems-36/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://hjk.life/posts/operating-systems-36/&amp;text=《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护 - 普通人" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=《Operating Systems: Three Easy Pieces》学习笔记(三十六) 数据完整性和保护 - 普通人&amp;url=https://hjk.life/posts/operating-systems-36/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/quantum-platform-1/">《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</a><li><a href="/posts/design-patterns-principles/">软件设计模式——七大设计原则</a><li><a href="/posts/const-c/">C语言中的const</a><li><a href="/posts/c-oop/">面向对象编程(OOP)的C语言实现</a><li><a href="/posts/operating-systems-28/">《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/operating-systems-27/"><div class="card-body"> <em class="timeago small" data-ts="1655344800" > 2022-06-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二十七) 基于事件的并发（进阶）</h3><div class="text-muted small"><p> 基于事件的并发（event-based concurrency），在一些现代系统中较为流行，比如 node.js，但它源自于 C/UNIX 系统，我们下面将讨论。 基于事件的并发针对两方面的问题。一方面是多线程应用中，正确处理并发很有难度。 正如我们讨论的，忘加锁、死锁和其他烦人的问题会发生。另一方面，开发者无法控制多线程在某一时刻的调度(由系统调度)。 基本想法：事件循环 我们使用的...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-28/"><div class="card-body"> <em class="timeago small" data-ts="1655348400" > 2022-06-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(二十八) I/O 设备</h3><div class="text-muted small"><p> 系统架构 我们先看一个典型系统的架构（见图 36.1）。其中，CPU 通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能 I/O 设备通过常规的 I/O 总线（I/O bus）连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如 SCSI、SATA 或者 USB。它们将最慢的设备连接到系统，...</p></div></div></a></div><div class="card"> <a href="/posts/operating-systems-34/"><div class="card-body"> <em class="timeago small" data-ts="1655427600" > 2022-06-17 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Operating Systems: Three Easy Pieces》学习笔记(三十四) 崩溃一致性：FSCK和日志(未完成)</h3><div class="text-muted small"><p> 文件系统面临的一个主要挑战在于，如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构。称为崩溃一致性问题（crash-consistency problem）。 崩溃一致性问题 理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地（atomically）移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/operating-systems-35/" class="btn btn-outline-primary" prompt="上一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(三十五) 崩溃一致性：FSCK和日志(未完成)</p></a> <a href="/posts/operating-systems-37/" class="btn btn-outline-primary" prompt="下一篇"><p>《Operating Systems: Three Easy Pieces》学习笔记(三十七) 分布式系统、远程过程调用（RPC）</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "ProphetHJK/prophethjk.github.io", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjk1MjU2NjI=", "data-category": "General", "data-category-id": "DIC_kwDOE6Qpns4CPYgF", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/prophethjk">Jinkai</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备20006745号-2</a> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-systems/">Operating Systems</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/dao/">DAO</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/5g/">5G</a> <a class="post-tag" href="/tags/btrfs/">btrfs</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VEN4M3BMXV"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VEN4M3BMXV'); }); </script>
