[ { "title": "移植Docker到ARM嵌入式设备", "url": "/posts/docker-cross-compile/", "categories": "技术", "tags": "Docker, OS-level virtualization, container", "date": "2021-10-13 09:00:00 +0800", "snippet": "本文将会介绍如何对 Docker 源码进行交叉编译并将 Docker 相关组件移植到 arm 嵌入式设备上Docker 源码下载Docker 相关组件的源码已经移动到了 moby 库，在https://github.com/moby/moby获取源码，我这边使用的是moby-17.05.0-ce这个 tag，因为嵌入式设备的资源空间有限，而新版本的 Docker 由于集成了大量功能，导致耗费资源较多，可能跑不起来。下载Source code：wget https://github.com/moby/moby/archive/refs/tags/v17.05.0-ce.tar.gz解压到合适位置：tar -zxvf v17.05.0-ce.tar.gz解压后目录如下图：准备编译环境Docker 编译需要在专用的 Docker 容器内进行，官方已经提供了完整的编译脚本，不过对于交叉编译的适配并不好，这里不使用自带的编译脚本，而是通过手动配置的办法进行编译进入 Docker bash通过 vim 编辑 Makefile 脚本，找到cross:这个编译选项，将 Makefile 脚本修改为:cross: build ## cross build the binaries for darwin, freebsd and\\nwindows $(DOCKER_RUN_DOCKER) /bin/bash以上操作表示进入 Docker 容器的 bash，而不是通过脚本直接编译使用 make 命令（DOCKER_CROSSPLATFORMS这个编译参数好像不加也没事）：DOCKER_CROSSPLATFORMS=&quot;linux/arm&quot; make cross之后容器构建脚本会开始执行构建命令，国内的网络环境可能下载不了某些库，如果有必要，自行修改源码目录下的Dockerfile。构建完成后就会进入容器的 bash：安装交叉编译工具链使用 golang 交叉编译还是比较方便的，可惜只支持静态链接，二进制文件较大，动态链接还没试成功过对于armv5el平台，需要对应的交叉编译工具链arm-linux-gnueabi-gcc，当前容器默认是没安装的，需要手动安装安装交叉编译工具链：echo &quot;deb http://ftp.de.debian.org/debian sid main&quot; &amp;gt;&amp;gt; /etc/apt/sources.listapt-get updateapt-get install gcc-arm-linux-gnueabi交叉编译依赖库docker 编译会有两个选择，binary/dynbinary即静态编译与动态编译（dynbinary 好像不支持交叉编译，反正我没试成功），因此须要提供的 arm 库的数量也不一样：# 静态编译提供的dev如下： libapparmor-dev libdevmapper-dev libseccomp-dev# 动态编译提供的dev如下： libapparmor-dev libdevmapper-dev libseccomp-dev libltdl-dev libattr1-dev libcap-dev intltool libtinfo-dev util-linux expat dbus ffi zlib glib-2.0 libsystemd-dev不过每个库都交叉编译比较麻烦，这里提供两种更简单的方法： 直接通过 apt 安装 如过当前的 debian 版本较新，可以直接通过 apt 安装，安装时指定对应的平台即可，armv5 对应是armel apt install libapparmor-dev:armelapt install libdevmapper-dev:armelapt install libseccomp-dev:armel 去 debian 仓库网页下载 部分 debian 的版本较老，仓库内可能没有对应的库，这时就要去手动下载，下面是部分库的地址： https://packages.debian.org/buster/libdevmapper-dev (注意依赖) https://packages.debian.org/buster/libseccomp-dev https://packages.debian.org/buster/libapparmor-dev 下载完是 deb 包，传到容器里，安装即可。如果无法安装就解压后覆盖到根目录 dpkg --force-architecture -i libdevmapper-dev_1.02.155-3_armel.deb 注意：交叉编译时可能优先使用容器内自带的 x86 的库做链接，如果报了链接出错就把原来的库删了: /usr/local/lib/libseccomp.so: file not recognized: file format not recognizedcollect2: error: ld returned 1 exit status rm /usr/local/lib/libseccomp.arm /usr/local/lib/libseccomp.sorm /usr/lib/libdevmapper.sorm /usr/lib/libdevmapper.a 设置编译相关环境变量#由于docker是golang进行编译的因此直接声明目标平台架构export GOARCH=arm#打开CGO支持export CGO_ENABLED=1#声明目标平台系统export GOOS=linux#声明编译工具export CC=arm-linux-gnueabi-gcc#声明编译docker的版本export DOCKER_GITCOMMIT=89658be#Docker编译参数，这里禁用了一些组件export DOCKER_BUILDTAGS=&#39;no_btrfs no_cri no_zfs exclude_disk_quota exclude_graphdriver_btrfs exclude_graphdriver_zfs no_buildkit&#39;编译 docker 依赖组件moby项目只包含了docker-client和docker-daemon，其他的组件需要通过脚本单独下载编译：#清理x64环境下的执行程序rm -rf /usr/local/bin/docker-*#编译执行程序sh /go/src/github.com/docker/docker/hack/dockerfile/install-binaries.sh runc tini proxy containerd编译完的文件自动部署在容器的/usr/local/bin/目录，需要自行拷贝出来。当然也可以自行修改install-binaries.sh脚本把二进制文件保存到自己希望的目录编译 docker使用 hack/make.sh 脚本进行编译 docker 与 dockerd 执行程序。#编译静态包（成功）hack/make.sh binary#编译动态包（失败）hack/make.sh dynbinary编译完的二进制文件在/go/src/github.com/docker/docker/bundles/17.05.0-ce 目录，该目录是宿主机目录的映射，可以在宿主机目录/repo/moby-17.05.0-ce/bundles/17.05.0-ce 提取文件。别忘了上一节的依赖组件root@racknerd-ae2d96:~/repo/moby-17.05.0-ce/bundles/17.05.0-ce/binary-client# file docker-17.05.0-cedocker-17.05.0-ce: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, Go BuildID=78906b998b797bc6afd511082f0928b0bd4c70a0, BuildID[sha1]=a1da4f0f805fc199891bba9ccc22d5b697186994, for GNU/Linux 3.2.0, with debug_info, not stripped移植程序把所有文件打包放入目标设备合适的目录17.05.0-ce├── binary-client│ ├── docker -&amp;gt; docker-17.05.0-ce│ ├── docker-17.05.0-ce│ ├── docker-17.05.0-ce.md5│ └── docker-17.05.0-ce.sha256└── binary-daemon├── docker-containerd├── docker-containerd-ctr├── docker-containerd-ctr.md5├── docker-containerd-ctr.sha256├── docker-containerd.md5├── docker-containerd.sha256├── docker-containerd-shim├── docker-containerd-shim.md5├── docker-containerd-shim.sha256├── dockerd -&amp;gt; dockerd-17.05.0-ce├── dockerd-17.05.0-ce├── dockerd-17.05.0-ce.md5├── dockerd-17.05.0-ce.sha256├── docker-init├── docker-init.md5├── docker-init.sha256├── docker-proxy├── docker-proxy.md5├── docker-proxy.sha256├── docker-runc├── docker-runc.md5└── docker-runc.sha256扩展：balena-engine介绍：An engine purpose-built for embedded and IoT use cases, based on Moby Project technology from Docker官网：https://www.balena.io/engine/移植 docker 的过程中无意中发现了 balena-engine，根据官网介绍这个软件是专门为 IoT 定制的精简版 docker，比 docker 更快更小。整体的编译方法和 docker 相同，编译时使用hack/make.sh binary-balena就行，二进制文件只有一个，其他都是软链接。运行 Docker后面的介绍以 balena-engine 为例，Docker 也是一样的运行环境检查先下载检测脚本https://github.com/moby/moby/blob/master/contrib/check-config.sh找到内核编译时的.config文件，使用check-config.sh对.config 进行检测，该操作可以不在目标机运行。Generally Necessary表示必须满足的，如果有missing项一定要把功能启用了，重新编译内核$ ./check-config.shinfo: reading kernel config from ./.config ...Generally Necessary:- cgroup hierarchy: nonexistent?? (see https://github.com/tianon/cgroupfs-mount)- CONFIG_NAMESPACES: enabled- CONFIG_NET_NS: enabled- CONFIG_PID_NS: enabled- CONFIG_IPC_NS: enabled- CONFIG_UTS_NS: enabled- CONFIG_CGROUPS: enabled- CONFIG_CGROUP_CPUACCT: enabled- CONFIG_CGROUP_DEVICE: enabled- CONFIG_CGROUP_FREEZER: enabled- CONFIG_CGROUP_SCHED: enabled- CONFIG_CPUSETS: enabled- CONFIG_MEMCG: enabled- CONFIG_KEYS: enabled- CONFIG_VETH: enabled- CONFIG_BRIDGE: enabled- CONFIG_BRIDGE_NETFILTER: enabled- CONFIG_NF_NAT_IPV4: enabled- CONFIG_IP_NF_FILTER: enabled- CONFIG_IP_NF_TARGET_MASQUERADE: enabled- CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: enabled- CONFIG_NETFILTER_XT_MATCH_CONNTRACK: enabled- CONFIG_NETFILTER_XT_MATCH_IPVS: enabled- CONFIG_IP_NF_NAT: enabled- CONFIG_NF_NAT: enabled- CONFIG_NF_NAT_NEEDED: enabled- CONFIG_POSIX_MQUEUE: enabled- CONFIG_DEVPTS_MULTIPLE_INSTANCES: enabledOptional Features:- CONFIG_USER_NS: missing- CONFIG_SECCOMP: missing- CONFIG_CGROUP_PIDS: missing- CONFIG_MEMCG_SWAP: missing- CONFIG_MEMCG_SWAP_ENABLED: missing- CONFIG_MEMCG_KMEM: missing- CONFIG_RESOURCE_COUNTERS: enabled- CONFIG_BLK_CGROUP: missing- CONFIG_BLK_DEV_THROTTLING: missing- CONFIG_IOSCHED_CFQ: enabled- CONFIG_CFQ_GROUP_IOSCHED: missing- CONFIG_CGROUP_PERF: enabled- CONFIG_CGROUP_HUGETLB: missing- CONFIG_NET_CLS_CGROUP: missing- CONFIG_NETPRIO_CGROUP: missing- CONFIG_CFS_BANDWIDTH: missing- CONFIG_FAIR_GROUP_SCHED: enabled- CONFIG_RT_GROUP_SCHED: enabled- CONFIG_IP_NF_TARGET_REDIRECT: enabled- CONFIG_IP_VS: missing- CONFIG_IP_VS_NFCT: missing- CONFIG_IP_VS_PROTO_TCP: missing- CONFIG_IP_VS_PROTO_UDP: missing- CONFIG_IP_VS_RR: missing- CONFIG_EXT3_FS: missing- CONFIG_EXT3_FS_XATTR: missing- CONFIG_EXT3_FS_POSIX_ACL: missing- CONFIG_EXT3_FS_SECURITY: missing (enable these ext3 configs if you are using ext3 as backing filesystem)- CONFIG_EXT4_FS: missing- CONFIG_EXT4_FS_POSIX_ACL: missing- CONFIG_EXT4_FS_SECURITY: missing enable these ext4 configs if you are using ext4 as backing filesystem- Network Drivers: - &quot;overlay&quot;: - CONFIG_VXLAN: missing Optional (for encrypted networks): - CONFIG_CRYPTO: enabled - CONFIG_CRYPTO_AEAD: enabled - CONFIG_CRYPTO_GCM: enabled - CONFIG_CRYPTO_SEQIV: enabled - CONFIG_CRYPTO_GHASH: enabled - CONFIG_XFRM: enabled - CONFIG_XFRM_USER: missing - CONFIG_XFRM_ALGO: missing - CONFIG_INET_ESP: missing - CONFIG_INET_XFRM_MODE_TRANSPORT: missing - &quot;ipvlan&quot;: - CONFIG_IPVLAN: missing - &quot;macvlan&quot;: - CONFIG_MACVLAN: missing - CONFIG_DUMMY: enabled - &quot;ftp,tftp client in container&quot;: - CONFIG_NF_NAT_FTP: enabled - CONFIG_NF_CONNTRACK_FTP: enabled - CONFIG_NF_NAT_TFTP: enabled - CONFIG_NF_CONNTRACK_TFTP: enabled- Storage Drivers: - &quot;aufs&quot;: - CONFIG_AUFS_FS: missing - &quot;btrfs&quot;: - CONFIG_BTRFS_FS: missing - CONFIG_BTRFS_FS_POSIX_ACL: missing - &quot;devicemapper&quot;: - CONFIG_BLK_DEV_DM: missing - CONFIG_DM_THIN_PROVISIONING: missing - &quot;overlay&quot;: - CONFIG_OVERLAY_FS: missing - &quot;zfs&quot;: - /dev/zfs: missing - zfs command: missing - zpool command: missingLimits:cat: /proc/sys/kernel/keys/root_maxkeys: No such file or directory./check-config.sh: line 351: [: -le: unary operator expectedcat: /proc/sys/kernel/keys/root_maxkeys: No such file or directory- /proc/sys/kernel/keys/root_maxkeys:挂载 cgroupDocker 使用依赖于 cgroup，通过以下 shell 脚本挂载 cgroup：#!/bin/bashset -eif grep -v &#39;^#&#39; /etc/fstab | grep -q cgroup; then echo &#39;cgroups mounted from fstab, not mounting /sys/fs/cgroup&#39; exit 0fi# kernel provides cgroups?if [ ! -e /proc/cgroups ]; then exit 0fi# 确保目录存在if [ ! -d /sys/fs/cgroup ]; then exit 0fi# mount /sys/fs/cgroup if not already doneif ! mountpoint -q /sys/fs/cgroup; then mount -t tmpfs -o uid=0,gid=0,mode=0755 cgroup /sys/fs/cgroupficd /sys/fs/cgroup# get/mount list of enabled cgroup controllersfor sys in $(awk &#39;!/^#/ { if ($4 == 1) print $1 }&#39; /proc/cgroups); do mkdir -p $sys if ! mountpoint -q $sys; then if ! mount -n -t cgroup -o $sys cgroup $sys; then rmdir $sys || true fi fidoneexit 0cgroup 挂载成功：安装 iptablesDocker 需要 iptables 配置网络，关于 iptables 的交叉编译，在我之前写的文章《strongSwan 与 Cisco CSR 1000V 建立 IPSec vpn 调试记录》里有提到配置环境变量需要配置 iptables 和 Docker 的运行环境变量关于 XTABLES_LIBDIR 的信息，见这篇文章《移植 iptables 扩展依赖问题》export PATH=$PATH:/media/disk/iptables/sbin:/media/disk/balena-engineexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media/disk/iptables/libexport XTABLES_LIBDIR=/media/disk/iptables/lib/xtables修改 Docker 配置文件Docker 的配置文件名为daemon.json，主要是配置 storage-driver 和 data-root，分别是文件系统驱动和数据根目录daemon.json：{ &quot;storage-driver&quot;: &quot;devicemapper&quot;, &quot;data-root&quot;: &quot;/media/disk/balena-engine/lib/docker&quot;, &quot;log-driver&quot;: &quot;json-file&quot;, &quot;log-opts&quot;: { &quot;max-size&quot;: &quot;10m&quot;, &quot;max-file&quot;: &quot;3&quot;, &quot;labels&quot;: &quot;production_status&quot;, &quot;env&quot;: &quot;os,customer&quot; }}运行 containerd 和 dockerd运行 dockerd 会自动拉起 containerd：balena-engine-daemon --config-file /media/disk/balena-engine/daemon.json编写 start-docker.sh 脚本：#/bin/sh./mountcgroup.shexport PATH=$PATH:/media/disk/iptables/sbin:/media/disk/balena-engineexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media/disk/iptables/libexport XTABLES_LIBDIR=/media/disk/iptables/lib/xtablesbalena-engine-daemon --config-file /media/disk/balena-engine/daemon.json启动日志：[root@sx binary-balena]# ./start-docker.shWARN[2021-10-13T06:56:16.290000000Z] could not change group /var/run/balena-engine.sock to balena-engine: group balena-engine not foundINFO[2021-10-13T06:56:16.310000000Z] libcontainerd: started new balena-engine-containerd process pid=1351INFO[0000] starting containerd module=containerd revision= version=1.0.0+unknownINFO[0000] setting subreaper... module=containerdINFO[0000] changing OOM score to -500 module=containerdINFO[0000] loading plugin &quot;io.containerd.content.v1.content&quot;... module=containerd type=io.containerd.content.v1INFO[0000] loading plugin &quot;io.containerd.snapshotter.v1.overlayfs&quot;... module=containerd type=io.containerd.snapshotter.v1INFO[0000] loading plugin &quot;io.containerd.metadata.v1.bolt&quot;... module=containerd type=io.containerd.metadata.v1INFO[0000] loading plugin &quot;io.containerd.differ.v1.walking&quot;... module=containerd type=io.containerd.differ.v1INFO[0000] loading plugin &quot;io.containerd.gc.v1.scheduler&quot;... module=containerd type=io.containerd.gc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.containers&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.content&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.diff&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.events&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.healthcheck&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.images&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.leases&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.namespaces&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.snapshots&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.monitor.v1.cgroups&quot;... module=containerd type=io.containerd.monitor.v1INFO[0000] loading plugin &quot;io.containerd.runtime.v1.linux&quot;... module=containerd type=io.containerd.runtime.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.tasks&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.version&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] loading plugin &quot;io.containerd.grpc.v1.introspection&quot;... module=containerd type=io.containerd.grpc.v1INFO[0000] serving... address=/var/run/balena-engine/containerd/balena-engine-containerd-debug.sock module=containerd/debugINFO[0000] serving... address=/var/run/balena-engine/containerd/balena-engine-containerd.sock module=containerd/grpcINFO[0000] containerd successfully booted in 0.190000s module=containerdINFO[2021-10-13T06:56:17.900000000Z] Graph migration to content-addressability took 0.00 secondsWARN[2021-10-13T06:56:17.920000000Z] Your kernel does not support swap memory limitWARN[2021-10-13T06:56:17.920000000Z] Your kernel does not support kernel memory limitWARN[2021-10-13T06:56:17.920000000Z] Your kernel does not support cgroup cfs periodWARN[2021-10-13T06:56:17.920000000Z] Your kernel does not support cgroup cfs quotasWARN[2021-10-13T06:56:17.920000000Z] Unable to find blkio cgroup in mountsWARN[2021-10-13T06:56:17.940000000Z] mountpoint for pids not foundINFO[2021-10-13T06:56:17.960000000Z] Loading containers: start.WARN[2021-10-13T06:56:18.010000000Z] Running modprobe nf_nat failed with message: `modprobe: can&#39;t change directory to &#39;/lib/modules&#39;: No such file or directory`, error: exit status 1WARN[2021-10-13T06:56:18.060000000Z] Running modprobe xt_conntrack failed with message: `modprobe: can&#39;t change directory to &#39;/lib/modules&#39;: No such file or directory`, error: exit status 1WARN[2021-10-13T06:56:19.810000000Z] Could not load necessary modules for IPSEC rules: Running modprobe xfrm_user failed with message: `modprobe: can&#39;t change directory to &#39;/lib/modules&#39;: No such file or directory`, error: exit status 1INFO[2021-10-13T06:56:26.480000000Z] Default bridge (balena0) is assigned with an IP address 172.17.0.0/16. Daemon option --bip can be used to set a preferred IP addressINFO[2021-10-13T06:56:28.920000000Z] Loading containers: done.WARN[2021-10-13T06:56:28.920000000Z] Could not get operating system name: Error opening /usr/lib/os-release: open /usr/lib/os-release: no such file or directoryWARN[2021-10-13T06:56:30.450000000Z] failed to retrieve balena-engine-init version: exec: &quot;balena-engine-init&quot;: executable file not found in $PATHINFO[2021-10-13T06:56:30.450000000Z] Docker daemon commit=89658be graphdriver(s)=vfs version=devINFO[2021-10-13T06:56:30.450000000Z] Daemon has completed initializationINFO[2021-10-13T06:56:31.060000000Z] API listen on /var/run/balena-engine.sock查看 Docker 信息：[root@sx binary-balena]# ./balena-engine infoContainers: 0 Running: 0 Paused: 0 Stopped: 0Images: 0Server Version: devStorage Driver: vfsLogging Driver: json-fileCgroup Driver: cgroupfsPlugins: Volume: local Network: bridge host null Log: journald json-fileSwarm: NodeID: Is Manager: false Node Address:Runtimes: bare runcDefault Runtime: runcInit Binary: balena-engine-initcontainerd version:runc version: 13e66eedaddfbfeda2a73d23701000e4e63b5471init version: N/A (expected: )Kernel Version: 3.10.108Operating System: &amp;lt;unknown&amp;gt;OSType: linuxArchitecture: armv5tejlCPUs: 1Total Memory: 57.15MiBName: sxID: W6OF:ZM5H:HNWK:YOLX:3KPV:S4ZX:5CKC:A5YE:NKEP:CMTK:2JIW:GFTNDocker Root Dir: /media/disk/balena-engine/lib/dockerDebug Mode (client): falseDebug Mode (server): falseRegistry: https://index.docker.io/v1/Labels:Experimental: falseInsecure Registries: 127.0.0.0/8Live Restore Enabled: falseWARNING: No swap limit supportWARNING: No kernel memory limit supportWARNING: No cpu cfs quota supportWARNING: No cpu cfs period support至此，Docker 已经启动完毕，后面就是通过 docker 命令安装镜像，启动容器之类的了，这里不在赘述。有关本地载入镜像的说明可以参考此博客《Docker 本地导入镜像/保存镜像/载入镜像/删除镜像》参考 在 mac 环境下交叉编译 ARM32 版 Docker 解决：dockerd: failed to start daemon: Devices cgroup isn‘t mounted Docker storage drivers Docker 之几种 storage-driver 比较 移植 iptables 扩展依赖问题 Docker 本地导入镜像/保存镜像/载入镜像/删除镜像" }, { "title": "软件设计模式——七大设计原则", "url": "/posts/design-patterns-principles/", "categories": "技术", "tags": "design patterns, design principles", "date": "2021-09-16 09:00:00 +0800", "snippet": " 概述 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。 是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 作用 提高思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 7种开发原则开闭原则 定义 Open Closed Principle，OCP 软件实体应当对扩展开放，对修改关闭。即, 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 作用 对软件测试的影响 测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。 提高代码的可复用性 粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。 提高软件的可维护性 稳定性高和延续性强，从而易于扩展和维护。 里氏替换原则 定义 Liskov Substitution Principle，LSP 继承必须确保基类所拥有的性质在子类中仍然成立。即, 子类可以扩展父类的功能，但不能改变父类原有的功能。 作用 是实现开闭原则的重要方式之一。 克服了继承中重写父类造成的可复用性变差的缺点。 类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 依赖倒置原则 定义 Dependence Inversion Principle，DIP **要面向接口编程，不要面向实现编程。**即, 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 作用 可以降低类间的耦合性。 可以减少并行开发引起的风险。 可以提高代码的可读性和可维护性。 单一职责原则 定义 Single Responsibility Principle，SRP 单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。 如果一个对象承担了太多的职责，至少存在以下两个缺点 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 作用 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。 接口隔离原则 定义 Interface Segregation Principle，ISP 客户端不应该被迫依赖于它不使用的方法 一个类对另一个类的依赖应该建立在最小的接口上 与单一职责原则的区别 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 作用 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。 迪米特法则 定义 Law of Demeter，LoD, 又叫作最少知识原则（Least Knowledge Principle，LKP) 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 作用 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 合成复用原则 定义 Composite Reuse Principle，CRP, 又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。 在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 作用 通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点: 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点: 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 总结 设计原则 一句话归纳 目的 开闭原则 对扩展开放，对修改关闭 降低维护带来的新风险 依赖倒置原则 高层不应该依赖低层，要面向接口编程 更利于代码结构的升级扩展 单一职责原则 一个类只干一件事，实现类要单一 便于理解，提高代码的可读性 接口隔离原则 一个接口只干一件事，接口要精简单一 功能解耦，高聚合、低耦合 迪米特法则 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 只和朋友交流，不和陌生人说话，减少代码臃肿 里氏替换原则 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 防止继承泛滥 合成复用原则 尽量使用组合或者聚合关系实现代码复用，少使用继承 降低代码耦合 实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。 记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。参考 23种经典设计模式(附c++实现代码) | 王竹兴| Blob 软件设计模式概述 CS-Notes 设计模式" }, { "title": "简单证书注册协议(SCEP)详解", "url": "/posts/scep/", "categories": "技术", "tags": "linux, scep, ipsec", "date": "2021-09-09 09:00:00 +0800", "snippet": "本文将会介绍简单证书注册协议(Simple certificate enrollment protocol, SCEP)，并对整个证书签发流程做详细的分析概述SCEP(Simple certificate enrollment protocol)，简单证书注册协议，最初由 CISCO 起草，简而言之，就是一个用来注册数字证书的协议。RFC 8894描述了简单的证书注册协议(SCEP)。该协议的旧版本成为实际工业标准，用于实际提供数字证书，主要用于网络设备。该协议旨在使任何标准网络用户的要求和颁发的数字证书尽可能简单。这些流程通常需要网络管理员的密集输入，因此不适合大规模部署。简单的证书注册协议仍然是最受欢迎和广泛可用的证书注册协议，被许多网络设备和软件制造商使用，他们正在开发简化的处理证书的方法，以便向日常用户大规模实施。例如，思科 IOS 操作系统(即使思科正在推动功能稍多的 EST)和 iPhone 注册企业 PKI。大多数 PKI 软件(特别是 RA 实现)都支持它，包括活动目录证书服务的网络设备注册服务 (NDES)。历史SCEP 由 Verisign 为思科设计，作为 CMS (CMC)证书管理、以及功能强大但体积相当庞大的证书管理协议(CMP)的精益替代方案。2010 年左右，思科暂停了 SCEP 的工作，转而开发了 EST。2015 年， Peter Gutmann 恢复了互联网草案(Internet Draft)，原因是 SCEP 在工业和其他标准中广泛使用。 他用更现代的算法更新了草稿，纠正了原始规范中的许多问题。2020 年 9 月，该草案作为RFC 8894发布，SCEP 从草案到标准花费了近 20 年。 新版本还支持注册非 RSA 证书(例如ECC公钥)。RA 简介注册机构(Registration Authority, RA) 是公开密钥基础设施(Public Key Infrastructures, PKI)中使用的证书注册功能。它负责接收来自人员、服务器、事物或其他应用程序的证书签名请求(CSR)–初始注册或续订。注册机构验证这些请求并转发给证书颁发机构 (Certificate Authority, CA)。注册机构还负责接收其他证书生命周期管理职能。例如，撤销。RA 实施接受请求的业务逻辑，需要能够验证请求方和应具有证书的一方的来源。出于无障碍和安全原因，注册机构通常与证书颁发机构分开。通过用户友好型 GUI 或集成友好型 API 和标准协议访问 RA。在Cisco Systems’ Simple Certificate Enrollment Protocol draft-nourse-scep-22这篇文章中讲述了客户端如何通过 SCEP 协议访问 RA 接口，由于 SCEP 协议当时还处于草案阶段，所以该文章只能作为参考。SCEP 的正式标准是RFC 8894。但是由于草案的大规模使用，本文还是会以草案作为基础对 SCEP 协议做介绍SCEP 实体SCEP 中定义的实体类型： 请求者(Requester) 例如，IPSec 客户端 服务器(Server) 证书颁发机构 (Certificate Authority, CA)或注册机构(Registration Authority, RA) SCEP 的特点 基于HTTP的请求/响应模式(使用 GET 方法，POST 也可以支持) 只支持RSA加密(目前国际通用、使用广泛的公钥算法也就 RSA, ECC， 而 ECC 是没有公钥加密，私钥解密标准的，我猜这个特点有这个原因吧) 证书请求用PKCS #10标准(也就是 CSR 格式的一种标准) 采用PKCS #7标准传输签名/加密数据(HTTP 请求非常不安全，容易被拦截，篡改) 支持服务器异步授权，客户端定期轮询 具有有限的证书吊销列表(CRL)检索支持(首选方法是通过 CRL 分发点(CDP)查询，出于可伸缩性原因) 不支持在线证书吊销(必须通过其它方法执行脱机) 需要在证书签名请求(CSR)中使用质询密码(Challenge Password)字段，该字段必须仅在服务器和请求者之间共享证书注册过程简述 取得 CA 证书的副本，并对其进行验证 生成一个 CSR(Certificate Signing Reques)，并把它安全地传输到 CA 轮询 SCEP 服务器，检查证书是不是已经被签名了 根据需要重新注册，以便在当前证书到期之前获得新证书。 根据需要检索 CRL。证书注册流程CA 认证:获取 CA 证书SCEP 使用 CA 证书来加密 CSR 的消息交换。因此，必须获得 CA 证书的副本。使用 GetCACert 操作。请求请求被发送作为 HTTP GET 请求。请求的信息包获取看起来类似于此：GET /cgi-bin/pkiclient.exe?operation=GetCACert响应响应只是二进制编码的 CA 证书 (X.509)。客户端需要验证 CA 证书通过指纹/哈希的检查。这必须通过带外(out-of-band)方法(呼叫系统管理员或信任点内指纹的预配置)完成。客户注册请求注册请求作为 HTTP GET 请求发送。请求的包捕获看起来与此类似：/cgi-bin/pkiclient.exe?operation=PKIOperation&amp;amp;message=MIIHCgYJKoZIhvcNAQcCoIIG%2BzCCBvcCAQExDjA…… “message=”之后的文本是从 GET 请求字符串中提取的 URL 编码字符串。 然后，文本被 URL 解码为 ASCII 文本字符串。该文本字符串是 base64 编码的签名数据(SignedData) PKCS#7。 签名数据(SignedData) PKCS#7 由客户端使用以下证书中的一种签署;它被用来证明客户发送它，且没有在传输过程中被篡改： 自签证书(首次注册时使用) 制造商安装证书 (MIC) 即将到期的当前证书(重新注册) 签名数据(SignedData) PKCS#7 的”签名数据”部分是信封数据(EnvelopedData) PKCS#7。 信封数据(EnvelopedData) PKCS#7 是一个包含”加密数据”和”解密密钥”的容器。解密密钥使用收件人的公钥加密。在此特定情况下，收件人是 CA：因此。只有 CA 才能实际解密“加密数据”。 信封数据(EnvelopedData) PKCS#7 的”加密数据(Encrypted Data)”部分是 CSR (PKCS#10)。响应对 SCEP 注册请求的响应是三种类型之一： Reject 拒绝 - 管理员以任何原因拒绝请求，例如： 无效密钥长度 无效质询密码(Challenge Password) CA 无法验证请求 请求要求 CA 提供未授权的属性 请求由 CA 不信任的身份签署 Pending 待定 - CA 管理员尚未审核该请求。 Success 成功 - 接受请求并包含签名证书。签名证书在称为”仅限退化证书-仅限 PCCS#7(Degenerate Certificates-Only PKCS#7)”的特殊类型的 PKCS #7 中保存，这是一种特殊容器，可容纳一个或多个 X.509 或 CRL，但不包含已签名或加密的数据有效载荷。客户重新注册在证书到期之前，客户需要获得新的证书。续订(renewal)和展期(rollover)之间有轻微的行为差异。当客户 ID 证书接近到期时，其到期日期与 CA 证书的到期日期不同(早于 CA 证书到期时间)时，就会发生续订。当 ID 证书接近到期，且时其到期日期与 CA 证书到期日期相同，就会发生展期。续订随着 ID 证书到期日期的临近，SCEP 客户可能想要获得新证书。客户端生成 CSR，并完成注册过程(如以前定义的)。当前证书用于签署签名数据 PKCS#7，这反过来又向 CA 证明身份。重新获得新证书后，客户立即删除当前证书，代之以新证书，新证书的有效期立即开始。展期展期是 CA 证书过期并生成新 CA 证书的特殊情况。CA 生成新的 CA 证书，一旦当前 CA 证书过期，该证书将生效。CA 通常会在展期前一段时间生成此”阴影 CA”证书，因为需要该证书才能为客户生成”阴影 ID”证书。当 SCEP 客户 ID 证书即将到期时，SCEP 客户端会向 CA 查询”影子 CA”证书。此操作与 GetNextCACert 操作一起完成，如下图所示：GET /cgi-bin/pkiclient.exe?operation=GetNextCACert一旦 SCEP 客户拥有”影子 CA”证书，它会在正常注册程序后申请”影子 ID”证书。CA 在”阴影 ID”证书上签名，并标有”阴影 CA”证书。与正常的续订请求不同，退回的”阴影 ID”证书在 CA 证书到期(展期)时生效。因此，客户需要保留 CA 和 ID 证书的预展和后展期证书副本。在 CA 到期(展期)时，SCEP 客户端删除当前的 CA 证书和 ID 证书，并将其替换为”阴影”副本。附录PKCS#7PKCS#7 is a defined data format that allows data to be signed or encrypted. The data format includes the original data and the associated metadata necessary in order to perform the cryptographic operation.PKCS#7 是一种定义的数据格式，允许签名或加密数据。数据格式包括执行加密操作所需的原始数据和相关元数据。Signed Envelope (SignedData)The signed envelope is a format that carries data and confirms that the encapsulated data is not altered in transit via digital signatures. It includes this information:签名信封是一种携带数据并确认封装数据在传输中不会通过数字签名更改的格式。它包括此信息：SignedData &amp;amp;colon;:= SEQUENCE { version CMSVersion, digestAlgorithms DigestAlgorithmIdentifiers, encapContentInfo EncapsulatedContentInfo, certificates [0] IMPLICIT CertificateSet OPTIONAL, crls [1] IMPLICIT RevocationInfoChoices OPTIONAL, signerInfos SignerInfos } Version number - With SCEP, version 1 used.版本编号 - 使用 SCEP 版本 1。 List of Digest Algorithms Used - With SCEP, there is only one Signer and thus only one Hashing Algorithm.使用的文摘算法列表 - 使用 SCEP，只有一个签名者，因此只有一个哈希算法。 Actual data that is signed - With SCEP, this is a PKCS#7 Enveloped-data format (Encrypted Envelope).已签名的实际数据 - 与 SCEP 一起，这是一个 PKCS#7 信封数据格式(加密信封)。 List of certificates of the signers - With SCEP, this is a self-signed certificate on initial enrollment or the current certificate if you re-enroll.签名者证书列表 - 通过 SCEP，如果您重新注册，这是初始注册时的自签名证书或当前证书。 List of the signers and the fingerprint generated by each signer - With SCEP, there is only one signer.签名者名单和每个签名者生成的指纹 - 有了 SCEP，只有一个签名者。The data encapsulated is not encrypted or obfuscated. This format simply provides protection against the message that is altered.封装的数据不加密或混淆。此格式仅提供完整性保护，防止消息被篡改。Enveloped Data (EnvelopedData)The Enveloped Data format carries data that is encrypted and can only be decrypted by the specified recipient(s). It includes this information:信封数据格式携带的数据是加密的，只能由指定的收件人解密。它包括此信息：EnvelopedData &amp;amp;colon;:= SEQUENCE { version CMSVersion, originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL, recipientInfos RecipientInfos, encryptedContentInfo EncryptedContentInfo, unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL } Version number - With SCEP, version 0 is used.版本编号 - 使用 SCEP 版本 0。 List of each of the recipients and the related encrypted data-encryption key - With SCEP, there is only one recipient (for requests: the CA server; for responses: the client).每个收件人的列表和相关的加密数据加密密钥 - 使用 SCEP，只有一个收件人(用于请求：CA 服务器; 用于响应：客户端)。 The encrypted data - This is encrypted with a randomly generated key (that has been encrypted with the recipient’s public key).加密数据 - 这是用随机生成的密钥(已与收件人的公钥加密)加密的。PKCS#10PKCS#10 describes the format of a CSR. A CSR contains the information that clients request be included within their certificates:PKCS#10 描述了 CSR 的格式。CSR 包含客户请求包含在其证书中的信息： Subject Name 主题名称 A copy of the public key 公共密钥副本 A challenge password (optional)质询密码(可选) Any certificate extensions reqested, such as:任何已重新访问的证书扩展，例如： Key Usage (KU)密钥用途 (KU) Extended Key Usage (EKU)扩展密钥使用 (EKU) Subject Alternative Name (SAN)主题替代名称 (SAN) Universal Principal Name (UPN)通用主名称 (UPN) A fingerprint of the request 请求的指纹Here is an example of a CSR:Certificate Request: Data&amp;amp;colon; Version: 0 (0x0) Subject: CN=scepclient Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:cd:46:5b:e2:13:f9:bf:14:11:25:6d:ff:2f:43: 64:75:89:77:f6:8a:98:46:97:13:ca:50:83:bb:10: cf:73:a4:bc:c1:b0:4b:5c:8b:58:25:38:d1:19:00: a2:35:73:ef:9e:30:72:27:02:b1:64:41:f8:f6:94: 7b:90:c4:04:28:a1:02:c2:20:a2:14:da:b6:42:6f: e6:cb:bb:33:c4:a3:64:de:4b:3a:7d:4c:a0:d4:e1: b8:d8:71:cc:c7:59:89:88:43:24:f1:a4:56:66:3f: 10:25:41:69:af:e0:e2:b8:c8:a4:22:89:55:e1:cb: 00:95:31:3f:af:51:3f:53:ad Exponent: 65537 (0x10001) Attributes: challengePassword : Requested Extensions: X509v3 Key Usage: critical Digital Signature, Key Encipherment X509v3 Subject Alternative Name: DNS:webserver.example.com Signature Algorithm: sha1WithRSAEncryption 8c:d6:4c:52:4e:c0:d0:28:ca:cf:dc:c1:67:93:aa:4a:93:d0: d1:92:d9:66:d0:99:f5:ad:b4:79:a5:da:2d:6a:f0:39:63:8f: e4:02:b9:bb:39:9d:a0:7a:6e:77:bf:d2:49:22:08:e2:dc:67: ea:59:45:8f:77:45:60:62:67:64:1d:fe:c7:d6:a0:c3:06:85: e8:f8:11:54:c5:94:9e:fd:42:69:be:e6:73:40:dc:11:a5:9a: f5:18:a0:47:33:65:22:d3:45:9f:f0:fd:1d:f4:6f:38:75:c7: a6:8b:3a:33:07:09:12:f3:f1:af:ba:b7:cf:a6:af:67:cf:47: 60:fcSCEP 请求请求消息格式请求以 HTTP GET 表格形式发送：GET CGI-path/pkiclient.exe?operation=operation&amp;amp;message=message HTTP/version分析 CGI-path - 依赖于服务器，并指向处理 SCEP 请求的共同网关接口 (CGI) 程序： 思科 IOS® CA 使用空路径字符串。 微软 CA 使用/certsrv/mscep/mscep.dll，它指向 MSCEP/网络设备注册服务 (NDES) IIS 服务。 operation - 识别执行的操作。 message - 携带该操作的其他数据(如果不需要实际数据，则可以为空)。使用 GET 方法，message部分可以是纯文本，或是由区分编码规则 (DER) 编码的 PKCS#7 转换的 Base64 格式数据。如果支持 POST方法，则可能以二进制格式取代的 GET 发送的 Base64 编码的内容。请求结构说明operation及其相关消息值的可能值： operation = PKIOperation时: message是一个 SCEP pkiMessage结构，基于 PKCS#7，并编码为 DER 和 Base64。 pkiMessage结构可以是这些类型的： PCCSReq：PCKCS#10 CSR GetCertInitial：CSR 签署状态的轮询 GetCert or GetCRL：证书或 CRL 检索 operation = GetCACert, GetNextCACert, or (optional)GetCACaps时 message可以被省略，也可以被设置为标识 CA 的名称。 SCEP 响应响应消息格式SCEP 响应将作为标准 HTTP 内容返回，Content-Type 取决于原始请求和返回的数据类型。DER 内容以二进制内容返回(不使用和请求一样的 Base64)。PKCS#7 内容可能包含或可能不包含加密/签名的信封数据(enveloped data);如果不包含(只包含一组证书)，它被称为退化的 PKCS#7。Content-TypeContent-Type 可能值： application/x-pki-message: 响应 PKIOperation 操作，这些请求附带 pkiMessage 类型：PKCSReq、GetCertInitial、GetCert 或 GetCRL 响应主体是 pkiMessage 类型：CertRep application/x-x509-ca-cert: 响应 GetCACert 操作 响应主体是 DER 编码的 X.509 CA 证书 application/x-x509-ca-ra-cert: 响应 GetCACert 操作 响应主体是包含 CA 和 RA 证书的 DER 编码的退化 PKCS#7 application/x-x509-next-ca-cert: 响应 GetNextCACert 操作 响应主体是 pkiMessage 类型的变体： CertRep pkiMessage 结构SCEP OIDs2.16.840.1.113733.1.9.2 scep-messageType2.16.840.1.113733.1.9.3 scep-pkiStatus2.16.840.1.113733.1.9.4 scep-failInfo2.16.840.1.113733.1.9.5 scep-senderNonce2.16.840.1.113733.1.9.6 scep-recipientNonce2.16.840.1.113733.1.9.7 scep-transId2.16.840.1.113733.1.9.8 scep-extensionReqSCEP pkiMessage PKCS#7 签名数据(SignedData) PKCS#7 信封数据(EnvelopedData)(称为 pkcsPKIEnvelope;可选，加密到消息接收者) messageData(CSR， 证书， CRL，…) 具有经过验证的属性的签名信息(SignerInfo with authenticatedAttributes)： transactionID, messageType, senderNonce pkiStatus, recipientNonce (response only) failInfo (response + failure only) SCEP messageType 请求： PCCSReq (19)： PCKCS#10 CSR GetCertInitial(20)：证书签署状态轮询 GetCert(21)： 证书检索 GetCRL (22)： CRL 检索 响应： CertRep(3)： 对证书或 CRL 请求的响应 SCEP pkiStatus SUCCESS (0)： 授予请求 (pkcsPKIEnvelope 中的响应) FAILURE(2)： 请求被拒绝 (失败信息属性中的详细信息) PENDING (3)： 请求等待人工批准参考 Simple Certificate Enrollment Protocol Overview - Cisco SCEP 协议简介_weixin_44966126 的博客-CSDN 博客 Cisco Systems’ Simple Certificate Enrollment Protocol draft-nourse-scep-22 Simple Certificate Enrollment Protocol - Wikipedia RFC 8894" }, { "title": "Linux系统中内存不足导致system()执行失败的问题", "url": "/posts/memory-fork-error/", "categories": "技术", "tags": "linux, system, fork", "date": "2021-09-08 09:00:00 +0800", "snippet": "在实际项目中遇到了现场大量设备升级后无法上线的问题，经过几天的分析发现是升级占用了大量内存导致system()函数执行失败，也就是无法通过C程序执行shell脚本，造成了设备异常。本文将对问题原因与解决方案做详细介绍问题简介现场设备挂网时间有1年多了，打算进行远程升级以支持更多功能与提高稳定性。首次选择了200个设备进行小批量验证，但升级成功率很低，有将近3/4的设备升级失败，且升级失败后大部分进入异常状态，无法进行通信，也就是处于离线状态。两天后离线的设备陆续上线，推测原因可能是异常时间较长导致主进程崩溃，随即触发了硬件看门狗复位设备，且重新上线后设备各项功能都正常。原因分析首先是分析日志，对于还可以正常通信的设备的日志进行分析，发现升级失败原因为升级包校验失败，升级包的传输应该是不会有问题的，校验失败应该另有隐情。仔细分析了报错信息后，发现频繁打印”script execute error.”，这个是应用里对system的一个封装函数的打印，发生条件是system()函数返回非0值。所以可以初步确定校验失败的原因就是校验脚本执行失败。实际上 system 函数内部干了三件事情： fork 创建一个子进程 在子进程中调用 exec 函数去执行 command 在父进程中调用 waitpid 去等待子进程结束关于fork的详细介绍，在我之前写的《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API一文里有介绍问题很有可能发生在fork阶段，从这方面入手进行了模拟测试，终于发现在系统内存占用较高时fork会有失败的现象。那又是什么导致现场占用内存这么高呢？问题肯定和校验脚本有关，因为每次发生问题都是在校验脚本开始执行之后。仔细检查了校验脚本，发现该脚本会解压一次升级文件并放在/tmp分区，tmp分区时tmpfs格式分区，也就是内存分区，将内存当作磁盘使用。tmpfs分区是动态分配的，做法是有多少占多少。当tmpfs分区占用太大时会导致内存不足。分析结果至此，问题已经明确，升级校验过程中执行的校验脚本在tmpfs分区解压了升级包，导致tmpfs分区占用过高，占用了部分内存。同时由于该设备是边缘网关，现场子节点较多，导致采集程序也占用了较高的内存，以上两者共同作用，导致了内存不足。内存不足引发fork失败，后续的升级脚本无法执行，通信模块复位也无法进行，导致升级失败和无法通信的现象解决方案 分析发现校验脚本不需要解压升级包，因为升级脚本会做这件事，把这步删了，可以省下很多内存 封装所有system()和fork()函数，对于调用失败的情况，复位设备，如果出现异常，统计到达一定次数后触发异常保护，比如关闭进程或重启系统下面是封装函数的源码：/** * @brief system函数封装 * * @param szCmd * @return int -1：执行失败; 0:执行成功; 其他:exit code */int systemcmd(const char *szCmd){ Log::Inf(&quot;systemcmd:&quot;); Log::Inf(&quot;%s&quot;, szCmd); pid_t status; status = pox_system(szCmd); if (time(NULL) - first_error_time &amp;gt; 3600) { system_exec_error = 0; } if (-1 == status) { Log::Err(&quot;system cmd exec error: -1&quot;); if (system_exec_error == 0) { first_error_time = time(NULL); } system_exec_error++; Log::Err(&quot;system cmd exec error times: %d&quot;, system_exec_error); if (system_exec_error &amp;gt;= MAX_EXEC_ERROR) { Log::Err(&quot;too many exec error, reboot dcu:%d&quot;, system_exec_error); saveErrorLog(); exit(0); } return -1; } else { Log::Inf(&quot;exit status value = [0x%x]&quot;, status); if (WIFEXITED(status)) { if (WEXITSTATUS(status) == 0) { Log::Inf(&quot;run shell script successfully.&quot;); } else { Log::Err(&quot;run shell script fail, script exit code: %d&quot;, WEXITSTATUS(status)); } return WEXITSTATUS(status); } else { Log::Err(&quot;exit status = [%d]&quot;, WIFEXITED(status)); return -1; } }}感想分析这个问题的过程其实走了很多弯路，比如还考虑过SIGCHLD信号的问题。在日志信息不全，时间紧迫的情况下，也能把问题分析出来，从这件事也印证出没有什么问题是解决不了的，遇到问题不要慌，按部就班一个个分析，总能有头绪的。当然还有程序设计上，对于系统函数要做一下封装，比如system()或者fork()函数，一是在执行异常时可以通过复位解决问题，二是防止分析日志的时候抓瞎。参考 fork之后父子进程的内存关系_Shreck66的专栏-CSDN博客 Linux 中 popen 函数与 system 函数的区别_胡小哲的博客-CSDN博客" }, { "title": "DHCPv6 relay的使用", "url": "/posts/dhcpv6-relay/", "categories": "技术", "tags": "dhcp, dhcpv6, relay", "date": "2021-09-08 09:00:00 +0800", "snippet": "本文将介绍如何使用DHCPv6 relay技术转发DHCPv6请求，包括widedhcpv6的交叉编译和配置DHCPv6简介在DHCPv6基础-曹世宏的博客一文对于DHCPv6协议做了详细的介绍，另可查看DHCPv6 IETF标准文档RFC8415，本文不再赘述。DHCPv6 relay(中继代理)的作用就是将原来的DHCPv6多播(multicast)方式转化为单播(unicast)报文，从而可以跨网关传输DHCPv6的请求响应，一般的使用场景是DHCPv6客户端与服务器不在同一个链路的情况工具 WIDE-DHCPv6 arm-none-linux-gnueabi-gcc(Sourcery CodeBench Lite 2014.05-29) 编译实现DHCPv6 relay功能的开源工具并不多，而且很多已经长时间没维护了，试了好几个工具后，最后选择了WIDE-DHCPv6作为项目中使用的工具。编辑configure修改configure文件echo &quot;$as_me: error: cannot check setpgrp when cross compiling&quot; &amp;gt;&amp;amp;2;}{ (exit 1); exit 1; };}为echo &quot;$as_me: error: cannot check setpgrp when cross compiling&quot; &amp;gt;&amp;amp;2;}#{ (exit 1); exit 1; };}执行配置脚本CFLAGS=&quot;-D_GNU_SOURCE&quot; ./configure --host=arm-none-linux-gnueabi --prefix=$PWD/build编辑cftoken.c添加int yywrap() {return 1;}执行编译与安装WIDE-DHCPv6不需要额外依赖，可直接编译，生成的目标文件为单独的二进制文件。执行以下命令即可：make &amp;amp; make install使用WIDE-DHCPv6的使用非常简单，甚至不需要配置文件，参数说明如下：NAME dhcp6relay — DHCPv6 relay agentSYNOPSIS dhcp6relay [-Ddf] [-b boundaddr] [-H hoplim] [-r relay-IF] [-s serveraddr] [-S script-file] [-p pid-file] interface ...DESCRIPTION dhcp6relay acts as an intermediary to deliver DHCPv6 messages between clients and servers, and is on the same link as a client. dhcp6relay needs command line arguments interface ..., which specifies the list of links accommodating clients. Options supported by dhcp6relay are: -d Print debugging messages. -D Even more debugging information is printed. -f Foreground mode (useful when debugging). Although dhcp6relay usually prints warning, debugging, or error messages to syslog(8), it prints the messages to standard error if this option is specified. -b boundaddr Specifies the source address to relay packets to servers (or other agents). -H hoplim Specifies the hop limit of DHCPv6 Solicit messages forwarded to servers. -r relay-IF Specifies the interface on which messages to servers are sent. When omitted, the same interface as interface will be used. When multiple interface are specified, this option cannot be omitted. -s serveraddr Specifies the DHCPv6 server address to relay packets to. If not specified, packets are relayed to ff05::1:3 (All DHCPv6 servers). -S script-file Specifies the script file to be executed when dhcp6relay receives a RELAY-REPLY message from a DHCPv6 server. Further detail of the script file syntax is available in dhcp6c(8) -p pid-file Use pid-file to dump the process ID of dhcp6relay.FILES /var/run/dhcp6relay.pid is the default file that contains pid of the currently running dhcp6relay.SEE ALSO dhcp6c(8), dhcp6s(8) Ralph Droms, Editor, Dynamic Host Configuration Protocol for IPv6 (DHCPv6), RFC 3315, 2003.HISTORY The dhcp6relay command first appeared in WIDE/KAME IPv6 protocol stack kit.根据该配置说明进行配置即可，其中-s参数比较重要，用于指定服务端的地址；最后需要加上网口用于监听客户端DHCPv6请求示例./dhcp6relay -dD -s fd12::58 tun0参考 DHCPv6基础-曹世宏的博客 RFC3315 RFC8415 Ubuntu Manpage:dhcp6relay—DHCPv6 relay agent" }, { "title": "使用PlantUML绘制类图", "url": "/posts/plantuml-vscode/", "categories": "技术", "tags": "PlantUML, UML, vscode, C++", "date": "2021-08-04 09:00:00 +0800", "snippet": "本文基于 vscode 的 PlantUML 插件绘制类图。类的 UML 表示使用 UML 表示一个类，主要由三部分组成。类名、属性、方法。其中属性和方法的访问修饰符用 - 、# 、+ 表示 private、protected、public。如图所示，表示A类有一个private属性，protected 构造函数和public方法。@startumlclass A{ - String field + A() # void method()}note right: 这是测试类 A@enduml类的关系在面向对象语言中，类的关系有很多种，可以概括为三类：泛化、依赖、关联。泛化泛化指父类跟子类的关系,表示is-a的关系。如父类是抽象类或普通类，则这种关系叫继承。如，父类是接口，则这种关系叫实现。UML 中，继承和实现由不同的标记表示。继承PlantUML 用 --|&amp;gt; 表示继承关系。实线和三角形的抽象表示，指向谁，即继承谁。@startuml class A abstract B &#39; A 继承 B A --|&amp;gt; B@enduml实现PlantUML 用 ..|&amp;gt; 表示实现关系。虚和三角形的抽象表示，指向谁，即实现谁。@startuml class A interface C &#39; A 实现 C A ..|&amp;gt; C@enduml依赖类之间，最弱的关联方式。常用于在 A 类的方法中使用 B 类的对象作为参数、局部变量或者对 B 类静态方法的调用。PlantUML 用 ..&amp;gt; 表示依赖关系。虚线和箭头的抽象表示，指向谁，即依赖谁。@startuml class A class B &#39; A 依赖 B A ..&amp;gt; B@enduml关联关联关系，即对象之间的引用关系。常使用类的属性表达。单向关联B 类作为 A 类的属性，表示 A 类与 B 类有关联。 PlantUML 用 --&amp;gt; 表示单向关联。实线线和箭头的抽象表示，指向谁，即关联谁。@startuml class A{ - B b } class B &#39; A 关联 B A --&amp;gt; B@enduml双向关联B 类作为 A 类的属性同时，A 类也是 B 类的属性，表示双向关联。 PlantUML 用 -- 表示双向关联。或者用&amp;lt;--&amp;gt;。@startuml class A{ - B b } class B{ - A a } &#39; A 关联 B A -- B@enduml自关联A 类关联 A 类自身。常见于单例模式。@startuml class A{ - A a } &#39; A 关联 A A --&amp;gt; A@enduml聚合在关联关系的基础上，延伸出聚合关系，强的关联关系，表示has-a关系。整体与部分的关系，部分不依赖于整体，可独立存在。常用于成员变量。如；汽车和轮胎的关系，轮胎可作为独立的商品出售。PlantUML 用 o-- 表示聚合关系。实线和空心菱形的抽象表示，指向谁，表示谁是整体。@startuml class Car{ - List&amp;lt;Wheel&amp;gt; wheels } class Wheel &#39; Car 关联 Wheel Car &quot;1&quot; o-- &quot;4&quot; Wheel@enduml图中数字1和4也表示一对多关联。N对N同理。组合在关联关系的基础上，延伸出另外一种关联关系，组合关系，表示contains-a关系。整体与部分的关系，部分依赖于整体，不可独立存在。常用于成员变量。如：身体和动作的关系。PlantUML 用 *-- 表示聚合关系。实线和实心菱形的抽象表示，指向谁，表示谁是整体。@startuml class Body{ - List&amp;lt;Action&amp;gt; actions } class Action &#39; Body 关联 Action Body &quot;1&quot; *-- &quot;N&quot; Action@endumlPlantUML 排版相比较其他的 UML 软件或插件。PlantUML 的优势在于，存储的是文本文件，可以方便的进行团队协作以及高度可定制化的依赖关系。但是，最大的缺点在于，排版是通过插件自动生成的，排版效果不尽人意。因此，PlantUML 提供四个关键字 up down left right。指定类与类之间的相对关系。default@startumlclass A1class B1A1 --&amp;gt; B1class A2class B2A2 &amp;lt;-- B2@enduml箭头向左时，被指向对象在上； 箭头向右时，被指向对象在下。up@startumlclass A1class B1A1 -up-&amp;gt; B1class A2class B2A2 &amp;lt;-up- B2@enduml使用 up 时，被指向对象在上。down@startumlclass A1class B1A1 -down-&amp;gt; B1class A2class B2A2 &amp;lt;-down- B2@enduml使用 down 时，被指向对象在下。left@startumlclass A1class B1A1 -left-&amp;gt; B1class A2class B2A2 &amp;lt;-left- B2@enduml使用 left 时，被指向对象在左。right@startumlclass A1class B1A1 -right-&amp;gt; B1class A2class B2A2 &amp;lt;-right- B2@enduml使用 right 时，被指向对象在右。总结画类图，只是 PlantUML 的功能之一，还可以使用它画时序图、用例图、活动图等。更多用法，请关注后续博客或访问官网。参考 使用PlantUML绘制类图 PlantUML官网" }, { "title": "strongSwan与Cisco CSR 1000V建立IPSec vpn调试记录", "url": "/posts/strongswan-cisco-ipsecvpn/", "categories": "技术", "tags": "strongSwan, Cisco, IPSec, VPN", "date": "2021-07-28 09:00:00 +0800", "snippet": "因项目需要，要让边缘计算网关与 Cisco CSR 1000V 连接，连接方式为 IPSec VPN，在本文记录下调试过程环境介绍客户端信息本次使用的客户端设备为一台边缘计算网关设备，运行 Linux 系统，使用 strongSwan 工具进行 vpn 连接 参数 值 MCU SCM601L216UE model ARM926EJ-S rev 5 (v5l) flash 256MB RAM 64MB OS Linux 3.10.108 strongswan 5.9.2 busybox 1.29.3 toolchain arm-none-linux-gnueabi-gcc 4.8.3 ip 公网 ipv4 服务端信息本次使用的服务端设备为一台服务器，运行 Cisco Cloud Services Router (CSR) 1000V 路由软件，部署在巴西，网络环境为 IPv4 NATCisco Cloud Services Router (CSR) 1000V 是一款软件路由器，企业或云提供商可将其作为虚拟机 (VM) 部署在提供商托管云中，提供路由器相关功能等。IPSec VPN 软件有几个开源项目支持互联网密钥交换 （IKE） 和 IPSec 协议来构建安全的 L2L 隧道： Free Secure Wide-Area Networking (freeS/WAN):版本较老，未积极维护 ipsec-tools:racoon - 不支持 Ikev2， 旧的 Linux kernel 2.6 Openswan:非常基本的 IKEv2 支持，旧的 Linux kernel 2.6 和更早的 API，不积极维护 strongSwan:支持 IKEv2 和 EAP/mobility，新的 Linux kernel 3.x 及之后的版本，使用 NETKEY API（这是 kernel 2.6 及以后的原生 IPSec 实现名称），积极维护，记录良好目前，最好的选择通常是 strongSwan。strongSwan 移植由于网关设备上并不包含 strongSwan 工具，需要从源码执行交叉编译，并移植strongSwan 下载从官网下载界面下载最新版本，当前最新版本为 5.9.2，https://download.strongswan.org/strongswan-5.9.2.tar.gzstrongSwan 交叉编译 解压下载的文件，进入 strongswan 目录，输入配置命令./configure --host=arm-none-linux-gnueabi --prefix=/media/disk/strongswan \\LDFLAGS=&quot;-Wl,-rpath,/root/repo/openssl/lib -L/root/repo/openssl/lib/&quot; \\CFLAGS=-I/root/repo/openssl-1.0.2l/include --disable-gmp --disable-aes \\--disable-hmac --enable-openssl --disable-ikev1 --disable-des \\--disable-vici --disable-swanctl --disable-curve25519 --disable-pkcs1 \\--disable-pkcs7 --disable-pkcs12 --disable-rc2 --enable-save-keys –host: 指定交叉编译工具的 prefix –prefix: 指定 install 目录 LDFLAGS: 指定 openssl 的库目录 CFLAGS: 指定 openssl 的头文件目录 –disable-gmp: 关闭 gmp 插件，gmp 提供 RSA/DH 加解密后端 –disable-aes：关闭自带的 aes 功能，使用 openssl 提供的 aes 功能 –disable-hmac: 关闭自带的 hmac 功能，使用 openssl 提供的 hmac 功能 –enable-openssl: 启用 openssl 插件，提供 RSA/ECDSA/DH/ECDH/ciphers/hashers/HMAC/X.509/CRL/RNG 加解密后端 –enable-save-keys: 启用密钥保存功能，能够在 esp 建立时保存密钥，仅作为调试使用有关 strongSwan 插件的相关信息，可在https://wiki.strongswan.org/projects/strongswan/wiki/Pluginlist查看执行后会显示如下内容 strongSwan will be built with the following plugins-----------------------------------------------------libstrongswan: sha2 sha1 md5 random nonce x509 revocation constraints pubkey pkcs8 pgp dnskey sshkey pem openssl fips-prf xcbc cmac drbglibcharon: attr kernel-netlink resolve save-keys socket-default stroke updown counterslibtnccs:libtpmtss: 输入 make &amp;amp; make install，程序文件会放在 prefix 对应的目录下注意：程序运行时的环境地址就是 prefix 指定的地址，程序会从该地址读取配置文件，所以移植程序时，需要放在和 prefix 相同的目录下启用内核功能需要的内核组件已在官网给出https://wiki.strongswan.org/projects/strongswan/wiki/KernelModules由于网关设备是嵌入式设备，就不使用模块化编译了，直接编译进内核就行Include the following modules: Networking ---&amp;gt; Networking options ---&amp;gt; Transformation user configuration interface [CONFIG_XFRM_USER] TCP/IP networking [CONFIG_INET] IP: advanced router [CONFIG_IP_ADVANCED_ROUTER] IP: policy routing [CONFIG_IP_MULTIPLE_TABLES] IP: AH transformation [CONFIG_INET_AH] IP: ESP transformation [CONFIG_INET_ESP] IP: IPComp transformation [CONFIG_INET_IPCOMP] The IPv6 protocol ---&amp;gt; [CONFIG_IPV6] IPv6: AH transformation [CONFIG_INET6_AH] IPv6: ESP transformation [CONFIG_INET6_ESP] IPv6: IPComp transformation [CONFIG_INET6_IPCOMP] IPv6: Multiple Routing Tables [CONFIG_IPV6_MULTIPLE_TABLES] Network packet filtering framework (Netfilter) ---&amp;gt; [CONFIG_NETFILTER] Core Netfilter Configuration ---&amp;gt; Netfilter Xtables support [CONFIG_NETFILTER_XTABLES] IPsec &quot;policy&quot; match support [CONFIG_NETFILTER_XT_MATCH_POLICY]Note: For kernel versions before 5.2, the required IPsec modes have to be enabled explicitly (they are built-in for newer kernels). Networking ---&amp;gt; Networking options ---&amp;gt; TCP/IP networking [CONFIG_INET] IP: IPsec transport mode [CONFIG_INET_XFRM_MODE_TRANSPORT] IP: IPsec tunnel mode [CONFIG_INET_XFRM_MODE_TUNNEL] IP: IPsec BEET mode [CONFIG_INET_XFRM_MODE_BEET] The IPv6 protocol ---&amp;gt; [CONFIG_IPV6] IPv6: IPsec transport mode [CONFIG_INET6_XFRM_MODE_TRANSPORT] IPv6: IPsec tunnel mode [CONFIG_INET6_XFRM_MODE_TUNNEL] IPv6: IPsec BEET mode [CONFIG_INET6_XFRM_MODE_BEET]Note: For kernel versions 4.2-4.5, you will have to select Encrypted Chain IV Generator manually in order to use any encryption algorithm in CBC mode. Cryptographic API Select algorithms you want to use... Encrypted Chain IV Generator [CRYPTO_ECHAINIV]相关工具移植openssl 交叉编译strongSwan 需要 openssl 作为加解密后端，来支持更多特性 ./config no-zlib no-asm shared -DOPENSSL_THREADS -pthread \\ -D_REENTRANT -D_THREAD_SAFE -D_THREADSAFE --prefix=$PWD/install \\ --cross-compile-prefix=arm-none-linux-gnueabi-# 需要手动删除Makefile中的-m64选项make &amp;amp; make installiproute2 交叉编译需要使用 iproute2 工具查看一些 IPSec 相关的信息，busybox 提供的功能不太全，所以也移植一下从官网下载https://www.kernel.org/pub/linux/utils/net/iproute2/，我这边使用的是 4.1.0 版本，太高的版本编译器不支持编辑 Makefile，修改CC = arm-none-linux-gnueabi-gcc，以及HOSTCC = arm-none-linux-gnueabi-gcc，只启用 ip 功能SUBDIRS=ip执行 make 命令，可执行文件在 ip 目录下iptables 交叉编译网关设备不带 iptables 工具，需要移植从官网下载 1.8.7 版本，https://www.netfilter.org/pub/iptables/./configure --host=arm-none-linux-gnueabi --prefix=$PWD/build --disable-nftablesmake &amp;amp; make installtcpdump 交叉编译tcpdump 是 Linux 平台的抓包工具，纯命令行界面，抓到的 pcap 格式数据可以在 wireshark 中展示去 tcpdump 官网https://www.tcpdump.org/下载最新版本，我下载的是4.99.1，同时下载libpcap最新版本，我下载的是1.10.1解压到同一父目录下，进入 tcpdump 目录，输入./configure --host=arm-none-linux-gnueabi --prefix=$PWD/build这里会自动找到父目录下的 libpcap 目录make &amp;amp; make install 使用方法： tcpdump -i eth0 -w /var/tcpdump/eth0.pcapisc-dhcp 移植isc-dhcp 是一个 dhcp 工具箱，包含了 dhcp client，dhcp server 和 dhcp relay agent，支持 ipv6，可以说是功能最全面的一款 DHCP 工具了 前往官网https://www.isc.org/dhcp/下载最新稳定版本，我用的是 4.2.6 版本 配置 ./configure BUILD_CC=gcc --host=arm-none-linux-gnueabi --prefix=$PWD/build ac_cv_file__dev_random=yes进入 bind 目录，解压 bind.tar.gzcd bindtar -zxvf bind.tar.gz进入 bind-9.9.5 目录，编辑 vim lib/export/dns/Makefile.incd bind-9.9.5vim lib/export/dns/Makefile.in将gen: ${srcdir}/gen.c ${CC} ${ALL_CFLAGS} ${LDFLAGS} -o $@ ${srcdir}/gen.c ${LIBS}改为gen: ${srcdir}/gen.c ${BUILD_CC} ${ALL_CFLAGS} ${LDFLAGS} -o $@ ${srcdir}/gen.c ${LIBS} 回到 dhcp 目录make &amp;amp; make installstrongSwan 配置移植后的 strongSwan 在/media/disk/strongswan 目录下，配置文件都在 etc 目录下，正常情况下只需修改 etc 目录下的配置即可etc 目录结构：.├── ipsec.conf├── ipsec.d│   ├── aacerts│   ├── acerts│   ├── cacerts│   ├── certs│   ├── crls│   ├── ocspcerts│   ├── private│   └── reqs├── ipsec.secrets├── strongswan.conf└── strongswan.d ├── charon │   ├── attr.conf │   ├── cmac.conf │   ├── constraints.conf │   ├── counters.conf │   ├── dnskey.conf │   ├── drbg.conf │   ├── fips-prf.conf │   ├── kernel-netlink.conf │   ├── md5.conf │   ├── nonce.conf │   ├── openssl.conf │   ├── pem.conf │   ├── pgp.conf │   ├── pkcs8.conf │   ├── pubkey.conf │   ├── random.conf │   ├── resolve.conf │   ├── revocation.conf │   ├── sha1.conf │   ├── sha2.conf │   ├── socket-default.conf │   ├── sshkey.conf │   ├── stroke.conf │   ├── updown.conf │   ├── x509.conf │   └── xcbc.conf ├── charon.conf ├── charon-logging.conf ├── pki.conf ├── scepclient.conf └── starter.conf设置环境变量strongSwan 依赖 lib 目录下的库文件，由于网关设备使用了 ramfs 无法将库文件放入 lib 目录下，需要在运行前手动配置export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media/disk/strongswan/libexport PATH=$PATH:/media/disk/strongswan/sbinipsec.conf 配置ipsec.conf 是老版本的配置文件，但比较直观，教程用的也比较多，还是选择用这个关于 ipsec.conf 的详细介绍，请看官网链接： 配置参数https://wiki.strongswan.org/projects/strongswan/wiki/ConfigSetupSection 连接参数https://wiki.strongswan.org/projects/strongswan/wiki/connsection贴一下个人配置：config setup # strictcrlpolicy=yes uniqueids = yes #charondebug=&quot;ike 3, knl 3, cfg 3, chd 3, lib 3, esp 3, tls 3&quot; # 调试信息等级 charondebug=&quot;ike 3, knl 3, cfg 3, esp 1, lib 3, chd 3, net 1, enc 1&quot;conn %default ikelifetime=24h keylife=8h rekeymargin=3m keyingtries=1 #authby=secret keyexchange=ikev2 mobike=no# 连接名称，host-host表示主机-主机，site-site表示子网-子网conn host-host type=transport left=%any # pem格式的客户端证书 leftcert=client.crt leftid=223.94.60.86 # 使用GRE协议 leftprotoport=47 right=128.201.18.34 # %any表示不指定，允许任何对端信息，一般用在right rightid=%any rightprotoport=47 keyexchange=ikev2 # ike握手加密算法 ike=aes256-sha256-modp1536 # esp加密算法 esp=aes256-sha256 auto=start # 自动重连 #dpdaction=restartipsec.secrets 配置ipsec.secrets 用于配置密钥密码信息 https://wiki.strongswan.org/projects/strongswan/wiki/Ipsecsecrets# PSK密码，安全等级较低，与ipsec.conf中的leftid,rightid对应223.94.60.86 : PSK &quot;#*SsG@Dq^@&amp;amp;DCr&quot;128.201.18.34 : PSK &quot;#*SsG@Dq^@&amp;amp;DCr&quot;10.230.93.19 : PSK &quot;#*SsG@Dq^@&amp;amp;DCr&quot;# 私钥位置，在etc/ipsec.d/private目录下: RSA client.keystrongswan.conf 配置strongswan.conf 是配置 strongSwan 这个应用相关的配置文件，包括插件启用，插件参数等 https://wiki.strongswan.org/projects/strongswan/wiki/strongswanconf# strongswan.conf - strongSwan configuration file## Refer to the strongswan.conf(5) manpage for details## Configuration changes should be made in the included filescharon { load_modular = yes multiple_authentication = no #install_routes = no plugins { include strongswan.d/charon/*.conf #kernel-netlink { #fwmark = !0x42 #} #socket-default { #fwmark = 0x42 #} kernel-libipsec { #allow_peer_ts = yes load = no } save-keys { esp = yes ike = yes load = yes wireshark_keys = /media/disk/tcpdump/keys } }}ipsec.d 目录ipsec.d 目录用于存放私钥与证书文件├── ipsec.d│   ├── aacerts│   ├── acerts│   ├── cacerts│   ├── certs│   ├── crls│   ├── ocspcerts│   ├── private│   └── reqsstrongswan.d 目录strongswan.d 目录用于存放应用与插件的精细配置strongSwan 运行strongSwan 的运行很简单，在完成配置后，只需在控制台运行ipsec start日志默认打印在syslog中查看状态ipsec statusall连接成功应该是这样的[root@sx sbin]# ./ipsec statusallStatus of IKE charon daemon (strongSwan 5.9.2, Linux 3.10.108, armv5tejl): uptime: 3 hours, since Aug 03 01:59:51 2021 malloc: sbrk 528384, mmap 0, used 195960, free 332424 worker threads: 11 of 16 idle, 5/0/0/0 working, job queue: 0/0/0/0, scheduled: 2 loaded plugins: charon save-keys sha2 sha1 md5 random nonce x509 revocation constraints pubkey pkcs8 pgp dnskey sshkey pem openssl fips-prf xcbc cmac drbg attr kernel-netlink resolve socket-default stroke updown countersListening IP addresses: 223.94.60.86 2001:db8:100::1 fd50:2000::2 fd25::3 fd24::3Connections: host-host: %any...128.201.18.34 IKEv2 host-host: local: [C=BR, ST=MG, O=Nansen, OU=Medicao, CN=strongs-01] uses public key authentication host-host: cert: &quot;C=BR, ST=MG, O=Nansen, OU=Medicao, CN=strongs-01&quot; host-host: remote: uses public key authentication host-host: child: dynamic[47] === dynamic[47] TRANSPORTSecurity Associations (1 up, 0 connecting): host-host[1]: ESTABLISHED 3 hours ago, 223.94.60.86[C=BR, ST=MG, O=Nansen, OU=Medicao, CN=strongs-01]...128.201.18.34[serialNumber=918UD8IEJZU, unstructuredName=CEMIGHER01A.ami.cemig.ad] host-host[1]: IKEv2 SPIs: 9f30ecd4bb9d05f6_i* d9ef0a0774caacba_r, public key reauthentication in 20 hours host-host[1]: IKE proposal: AES_CBC_256/HMAC_SHA2_256_128/PRF_HMAC_SHA2_256/MODP_1536 host-host{4}: INSTALLED, TRANSPORT, reqid 1, ESP in UDP SPIs: ce0100b2_i f84857bb_o host-host{4}: AES_CBC_256/HMAC_SHA2_256_128, 4350 bytes_i (51 pkts, 8s ago), 10403 bytes_o (103 pkts, 0s ago), rekeying in 7 hours host-host{4}: 223.94.60.86/32[47] === 128.201.18.34/32[47][root@sx sbin]#GRE 隧道本项目采用的是 host-host + GRE 模式，是为了 ip 的更换更加方便，GRE 可以实现 ipv6 in ipv4 的模式，从而让只支持 ipv4 的 vpn 隧道变为 ipv6 隧道。GRE 介绍通用路由封装（英语：Generic Routing Encapsulation，缩写：GRE）是一种可以在虚拟点对点链路中封装多种网络层协议的隧道协议。由思科系统开发，在RFC 2784中定义。GRE tun模式协议栈: OSI 模型分层 协议 5.会话层 X.225 4.传输层 UDP 3.网络层 (GRE 封装) IPv6 封装 GRE 3.网络层 IPv4 2.数据链路层 以太网 1.物理层 以太物理层 从上面的图表可以看出，协议封装（非特指 GRE）打破了 OSI 模型中定义的分层。这可以被看成两个不同协议栈中间的分割器，一个承载另一个。GRE 环境搭建在上面搭建好 host-host 隧道的基础上创建 GRE 隧道，这里需要注意下，GRE 隧道默认是位于三层（Layer 3）网络，不带 mac 信息的，在需要用到二层网络的地方需要使用 tap 模式 GRE tun 模式ip tunnel add gre1 mode gre remote 128.201.18.34 local 223.94.60.86 ttl 255ip link set gre1 upip addr add fd24::3/16 dev gre1 GRE tap 模式./ip link add gre1 type gretap remote 128.201.18.34 local 223.94.60.86 ttl 255./ip link set gre1 up./ip addr add fd24::3/16 dev gre1由于边缘计算网关 busybox 自带的 ip 命令功能不太全，所以用了iproute2工具此处的 ttl 值一定要设置，默认是根据包裹的协议的 ttl 来的，比如包的是 dhcp 协议，ttl 就变成 1 了，会导致问题添加路由默认 GRE 协议在创建的时候就配好路由，对端的路由需要配置配置到对端地址的路由ip -6 route add fd12::/16 dev gre1 metric 256如果使用的是 GRE-TAP，需要 mac 层信息，默认在发送报文前会发送 NDP 协议查找邻居，但是在 GRE 上不可行，所以要强制配好网关，网关地址即为对端 GRE 绑定地址ip -6 route add 2002:db8:1::/64 via fd25::1 dev gre2 metric 1024DHCPv6后续我会专门写一篇 DHCPv6 协议的介绍IKE协议ESP协议实例GRE-over-ipsec-tunnel 成功.zip参考 移植 dhcp-4.2.6 到 ARM-linux 通用路由封装 - 维基百科，自由的百科全书 strongSwan官网" }, { "title": "无线通信技术的变革与详解", "url": "/posts/wireless-comm/", "categories": "技术", "tags": "5G, QAM", "date": "2021-06-15 09:00:00 +0800", "snippet": "无线通信架构声音在无线网络中的传输这是一张关于无线通信过程的架构图，讲述了声音信号如何从发声人到接收人进行传递。 首先发送者的信号传递到了麦克风，由于人声的频率较低（100Hz 到 10000Hz），而无线通信频率较高（850/900/1800/1900MHz），需要通过调制器，将人声变成高频信号 之后通过功率放大器和发送天线，将信号发送出去 在对端接收到该信号后，通过逆过程，将信号转变为声音信号无线基站架构The baseband unit (BBU) is the baseband processing unit of telecom systems. The BBU has the advantage of modular design, small size, high integration, low power consumption and easy deployment. A typical wireless base station consists of the baseband processing unit (BBU) and the RF processing unit (remote radio unit - RRU). The BBU is placed in the equipment room and connected with the RRU via optical fiber. The BBU is responsible for communication through the physical interface.基带单元（BBU）是电信系统的基带处理单元。 BBU 具有模块化设计、体积小、集成度高、功耗低、部署方便等优点。 一个典型的无线基站由基带处理单元（BBU）和射频处理单元（远程无线电单元-RRU）组成。 BBU 放置在机房内，通过光纤与 RRU 相连。 BBU 负责通过物理接口进行通信。现代无线通信技术总览 蜂窝移动通信 调制技术(基带信号 → 高频信号) 通信方式(用来区分用户的技术) 1G FM/2FSK FDMA/频分多址 2G FSK/QPSK TDMA/时分多址 3G BPSK/QPSK/8PSK CDMA/码分多址 4G QAM/16QAM/64QAM OFDM/正交频分多址 调制技术介绍 发送端的原始电信号通常具有频率很低的频谱分量，一般不适宜直接在信道中进行传输。 通过调制可以将多个基带信号搬移到高频载波，实现频谱搬移。数字调制 幅移键控 ASK： 有幅度表示 1，无幅度表示 0 频移键控 FSK： 频率高表示 1，频率低表示 0 相移键控 PSK： 用不同相位表示不同信息 二进制相移键控 BPSK： 相移键控的特殊形式，只能用两个特定的相位表示 0 和 1 两个数字 正交相移键控 QPSK： 相移键控的特殊形式，可以使用 4 种相位，表示 4 种信息（两个比特），抗干扰能力减弱但速率提升 8 相移键控 8PSK： 相移键控的特殊形式，可以使用 8 种相位，表示 8 种信息（3 个比特），抗干扰能力进一步减弱但速率进一步提升 正交振幅调制 QAM： 如果期望混合后的信号的幅度和相位都能发生变化，用幅度和相位一起区分来区分不同波形，这就是 QAM 调制。当多进制调制中 N&amp;gt;=4, 不再采用 PSK 调制仅仅控制相位，而采用 QAM 调制控制相位与幅度，QAM 调制又称为高阶调制。 不同调制方式的比较 BPSK：2 进制相位调制，每个子载波携带 1 个比特的二进制数据，主要用于信道质量非常差的场景以及用于物联网应用的场景。 QPSK：4 进制相位调制, 每个子载波携带 2 个比特的二进制数据。 16QAM：16 进制相位幅度调制, 每个子载波携带 4 个比特的二进制数据。 64QAM：64 进制相位幅度调制, 每个子载波携带 6 个比特的二进制数据。 256QAM：256 进制相位幅度调制, 每个子载波携带 8 个比特的二进制数据。 1024QAM：1024 进制相位幅度调制, 每个子载波携带 10 个比特的二进制数据。主要应用在 5G.多址技术多址技术是用来区分用户的技术，先进的多址技术能让一个基站为更多用户服务移动通信是以多址技术来划分时代的FDMA-频分多址模拟信号(1G)是通过频率的不同来区分不同的用户（每个用户专属一段频率）TDMA-时分多址GSM(2G) 是通过及其微小的时隙来区别不同的用户（每个用户专属一段时间），类似于 CPU 调度策略中的时间片轮转(RR)CDMA-码分多址码分多址是指利用码序列相关性实现的多址通信;码分多址(CDMA)的基本思想是靠不同的地址码来区分的地址。每个配有不同的地址码，用户所发射的载波(为同一载波)既受基带数字信号调制，又受地址码调制。(类似于广播机制，同一频段客户端的都能收到，但只有属于自己的报文才会处理)接收时，只有确知其配给地址码的接收机，才能解调出相应的基带信号，而其他接收机因地址码不同，无法解调出信号。划分是根据码型结构不同来实现和识别的。一般选择伪随机码(PN 码)作地址码。由于 PN 码的码元宽度远小于 PCM 信号码元宽度(通常为整数倍)，这就使得加了伪随机码的信号频谱远大于原基带信号的频谱，因此，码分多址也称为扩频多址。 运营商 编码 联通 CDMA2000 Walsh 码（同步正交码） 移动 TD-SCDMA OVSF 码 电信 WCDMA OVSF 码 （正交可变扩频因子码） 虽然已有正交频分复用（OFDM） 的技术，但仍发展CDMA的原因主要为调制/解调并不需要太精确的频谱分析。而OFDM使用DFT需做复数运算，较CDMA使用Walsh Transform复杂。 CDMA 的优点条列如下： 运算量相对于频分多工减少很多 可以减少噪声及干涉的影响 可以应用在保密和安全传输上 就算只接收部分的信号，也有可能把原来的信号还原回来 相邻的区域的干扰问题可以减少OFDM-正交频分复用正交频分复用，英文原称 Orthogonal Frequency Division Multiplexing，缩写为OFDM，实际上是 MCM Multi-CarrierModulation 多载波调制的一种。其主要思想是：将信道分成若干正交子信道，将高速数据信号转换成并行的低速子数据流，调制到在每个子信道上进行传输。正交信号可以通过在接收端采用相关技术来分开，这样可以减少子信道之间的相互干扰 ICI。每个子信道上的信号带宽小于信道的相关带宽，因此每个子信道上的可以看成平坦性衰落，从而可以消除符号间干扰。而且由于每个子信道的带宽仅仅是原信道带宽的一小部分，信道均衡变得相对容易。在过去的频分复用（FDM）系统中，整个带宽分成 N 个子频带，子频带之间不重叠，为了避免子频带间相互干扰，频带间通常加保护带宽，但这会使频谱利用率下降。为了克服这个缺点，OFDM 采用 N 个重叠的子频带，子频带间正交，因而在接收端无需分离频谱就可将信号接收下来。OFDM 系统的一个主要优点是正交的子载波可以利用快速傅利叶变换（FFT/IFFT）实现调制和解调。OFDMA-正交频分多址正交频分多址 Orthogonal Frequency Division Multiple Access(OFDMA):OFDMA 是 OFDM 技术的演进，将 OFDM 和 FDMA 技术结合。在利用 OFDM 对信道进行副载波化后，在部分子载波上加载传输数据的传输技术。OFDM 是一种调制方式；OFDMA 是一种多址接入技术，用户通过 OFDMA 共享频带资源，接入系统。OFDMA 又分为子信道（Subchannel）OFDMA 和跳频 OFDMA。OFDMA技术与OFDM技术相比，用户可以选择条件较好的子载波进行数据传输，而不像OFDM技术那样，一个用户在整个频带内发送，从而保证了子载波都被对应信道条件较优的用户使用，获得了频率上的分集增益。在OFDMA中，一组用户可以同时接入到某一子载波。目前使用OFDMA的无线通信技术有：IEEE 802.16、Wi-Fi 6。参考 OFDMA-百度百科 正交频分复用-百度百科" }, { "title": "传输层安全(TLS)相关技术详解", "url": "/posts/tls-tech/", "categories": "技术", "tags": "DH, SSL/TLS, https", "date": "2021-06-09 09:00:00 +0800", "snippet": "TLS的目标传输层安全(TLS)是网络安全的主力。它允许网站向 Web 浏览器证明其身份，并保护所有交换的信息被加密且免受窥探。TLS 有两个主要目标：保密性和身份验证。两者对于在互联网上进行安全通信都至关重要。保密性主要由密钥安全交换技术和AES加密算法实现，身份验证主要由数字签名技术实现保密性对称密钥像RSA和DH这样的公共关键算法使用大量的CPU，是TLS握手中最慢的部分。笔记本电脑每秒只能执行几百个 RSA 加密，而对称密码 AES 的加密量约为 1000 万/秒。所以应用报文的加密使用的是对称加密技术，而RSA和DH仅用于对称密钥的交换。在 TLS 中，这种对称加密通常使用强大的块密码（如AES）完成。较旧的浏览器和平台可能会使用密码，如3DES或流密码RC4，这在现在被认为是不安全的。RSA密钥交换RSA密钥交换是目前最主流的密钥交换方式，握手方式如下：RSA密钥交换主要是用公钥加密对称密钥后传输，对方用私钥解密的过程RSA算法的本质是利用了一个数学原理：将两个大质数相乘非常容易，但要对其乘积进行因式分解却非常困难，详见RSA加密算法维基百科Diffie-Hellman密钥交换DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递对称密钥，他们之间可以这么做：甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙；乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121；乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。DH算法的安全性数字可以分为两大部分：不可再分的数：prime number 质数可以再分的数：composite number 和数每个数字可以描述为一个“锁”每个数字有且只有一种质因数分解，把质因数分解看做是“钥匙”，任何两个数的质因数分解都不同。对于锁，有一个基本的要求：朝一个方向容易，朝反方向难。one-way function单向函数。在数学中，模算术（时钟算术）就是一个单向函数 X MOD P，如果P选择为质数，那么其值会在时钟上（1到P-1上）等可能均匀分布。正向计算3^x mod 17 = ？很容易反向计算3^? mod 17 = 12不容易，比如说P选择一个数百位的质数，那么想求出？只能采用试错法在DH算法握手的过程中，指数不会被传递，也就是说在网络攻击中指数是需要被破解的对象详见迪菲-赫爾曼密鑰交換维基百科DHE密钥交换固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。ECDHE密钥交换DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— ECDHE 算法。ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。小红和小明使用 ECDHE 密钥交换算法的过程：双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；双方各自随机生成一个随机数作为私钥d，并与基点 G相乘得到公钥Q(Q = dG)，此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；双方交换各自的公钥，最后小红计算点(x1，y1) = d1Q2，小明计算点(x2，y2) = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥。这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。具体算法详见椭圆曲线迪菲-赫尔曼金钥交换维基百科身份验证数字签名RSA算法和DH算法都需要交换公钥，如何保证公钥没有被中间人篡改，也是握手过程中需要解决的问题。TODO:签名算法涉及的东西也很多，现在还没有学习完，等待后续补充RSA签名常用数字签名算法有： MD5withRSA SHA1withRSA SHA256withRSA它们实际上就是指定某种哈希算法进行RSA签名的方式。DSA签名除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。DSA只能配合SHA使用，常用的算法有： SHA1withDSA SHA256withDSA SHA512withDSA和RSA数字签名相比，DSA的优点是更快。ECDSA签名椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。参考 Keyless SSL: The Nitty Gritty Technical Details 图解 ECDHE 密钥交换算法 迪菲-赫爾曼密鑰交換维基百科 RSA加密算法维基百科 椭圆曲线迪菲-赫尔曼金钥交换维基百科" }, { "title": "关于VSCode使用Remote SSH时git gutter(代码差异装饰器)无法显示的问题", "url": "/posts/vscode-git-gutter/", "categories": "技术", "tags": "vscode, git, gutter", "date": "2021-05-08 09:00:00 +0800", "snippet": "diff decorations gutter介绍diff decorations gutter中文翻译为代码差异装饰器，就是在使用git或svn插件时代码编辑器序号旁边显示的彩色装饰条，点击可以看到改动后的内容和最后一次提交内容的差异这玩意看似简单，却是版本管理的利器，没有它我都不敢写代码了无法显示问题在使用Remote SSH进行远程开发时发现代码差异装饰器无法显示，通过查找发现是软链接的问题，就是打开的文件夹是软链接后的文件夹，导致VSCode无法识别。解决方法不要打开软链接文件夹，直接打开软链接指向的目录，问题解决" }, { "title": "《Operating Systems: Three Easy Pieces》学习笔记(六) 调度：多级反馈队列", "url": "/posts/operating-systems-6/", "categories": "学习笔记", "tags": "Operating Systems, 操作系统导论", "date": "2021-03-18 09:00:00 +0800", "snippet": "本章将介绍一种著名的调度方法–多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962 年，Corbato 首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。 提示：从历史中学习 多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。MLFQ：基本规则MLFQ 中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是优先执行较高优先级的工作（即在较高级队列中的工作）。对于同一个队列中的任务，采用轮转调度。MLFQ中工作优先级并不是固定的，而是会根据进程的行为动态调整优先级。例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。相反，如果一个工作长时间地占用 CPU，MLFQ 会降低其优先级。MLFQ 的两条基本规则: 规则 1：如果 A 的优先级 &amp;gt; B 的优先级，运行 A（不运行 B）。 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B 。尝试 1：如何改变优先级我们必须决定，在一个工作的生命周期中，MLFQ 如何改变其优先级（在哪个队列中）。要做到这一点，我们必须记得工作负载：既有运行时间很短、频繁放弃 CPU 的交互型工作，也有需要很多 CPU 时间、响应时间却不重要的长时间计算密集型工作。下面是我们第一次尝试优先级调整算法。 规则 3 ：工作进入系统时，放在最高优先级（最上层队列）。 规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。 规则 4b：如果工作在其时间片以内主动释放 CPU，则优先级不变。实例 1：单个长工作从这个例子可以看出，该工作首先进入最高优先级（Q2）。执行一个 10ms 的时间片后，调度程序将工作的优先级减 1，因此进入 Q1。在 Q1 执行一个时间片后，最终降低优先级进入系统的最低优先级（Q0），并一直留在那里。实例 2：加入一个短工作B 在 T=100 时到达如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ 近似于 SJF(最短任务优先)。实例 3：如果有 I/O 呢交互型工作 B（用灰色表示）每执行 1ms 便需要进行 I/O 操作，它与长时间运行的工作 A（用黑色表示）竞争 CPU。MLFQ 算法保持 B 在最高优先级，因为 B 总是让出 CPU。如果 B 是交互型工作，MLFQ 就进一步实现了它的目标，让交互型工作快速运行当前 MLFQ 的一些问题 饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。 愚弄调度程序（game the scheduler）。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。 一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间需要作为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。因为优先级一旦下降就无法提升尝试 2：提升优先级为解决[1]饥饿问题 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。 左边没有优先级提升，长工作在两个短工作到达后被饿死。 右边每 50ms 就有一次优先级提升（这里只是举例，这个值可能过小），因此至少保证长工作会有一些进展，每过 50ms 就被提升到最高优先级，从而定期获得执行。添加时间段 S 导致了明显的问题：S 的值应该如何设置？德高望重的系统研究员 John Ousterhout 曾将这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例。尝试 3：更好的计时方式为解决[2]愚弄调度程序问题起因是规则 4a 和 4b 不合理，调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。重写规则 4： 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。没有规则 4的保护时，进程可以在每个时间片结束前发起一次 I/O 操作，从而垄断 CPU 时间。有了这样的保护后，不论进程的 I/O 行为如何，都会慢慢地降低优先级，因而无法获得超过公平的 CPU 时间比例。同时由于规则 5的存在，原来的交互性进程还是可以在之后提升优先级。MLFQ 调优及其他问题关于 MLFQ 调度算法还有一些问题。其中一个大问题是如何配置一个调度程序，例如： 配置多少队列？ 每一层队列的时间片配置多大？ 为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。例如，大多数的 MLFQ 变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是 CPU 密集型工作，配置更长的时间片会取得更好的效果。图 8.7 展示了一个例子，两个长工作在高优先级队列执行 10ms，中间队列执行 20ms，最后在最低优先级队列执行 40ms。Solaris 的 MLFQ 实现（时分调度类 TS）很容易配置。它提供了一组表来决定进程在其生命周期中如何调整优先级，每层的时间片多大，以及多久提升一个工作的优先级。管理员可以通过这些表，让调度程序的行为方式不同。该表默认有 60 层队列，时间片长度从 20ms（最高优先级），到几百 ms（最低优先级），每一秒左右提升一次进程的优先级。其他一些 MLFQ 调度程序没用表，甚至没用本章中讲到的规则，有些采用数学公式来调整优先级。例如，FreeBSD 调度程序（4.3 版本），会基于当前进程使用了多少 CPU，通过公式计算某个工作的当前优先级。另外，使用量会随时间衰减，这提供了期望的优先级提升，但与这里描述方式不同。阅读 Epema 的论文，他漂亮地概括了这种使用量衰减（decay-usage）算法及其特征最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的建议（advice），比如通过命令行工具 nice，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看 man 手册。 提示：尽可能多地使用建议 操作系统很少知道什么策略对系统中的单个进程和每个进程算是好的，因此提供接口并允许用户或管理员给操作系统一些提示（hint）常常很有用。我们通常称之为建议（advice），因为操作系统不一定要关注它，但是可能会将建议考虑在内，以便做出更好的决定。这种用户建议的方式在操作系统中的各个领域经常十分有用，包括调度程序（通过 nice）、内存管理（madvise），以及文件系统（通知预取和缓存[P+95]）MLFQ：小结本章介绍了一种调度方式，名为多级反馈队列（MLFQ）。本章包含了一组优化的 MLFQ 规则。为了方便查阅，我们重新列在这里。 规则 1：如果 A 的优先级 &amp;gt; B 的优先级，运行 A（不运行 B）。 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。 规则 3：工作进入系统时，放在最高优先级（最上层队列）。 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。MLFQ 有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ 可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于 SJF/STCF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前。因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括类 BSD UNIX 系统、Solaris以及 Windows NT 和其后的 Window 系列操作系统。作业程序 mlfq.py 允许你查看本章介绍的 MLFQ 调度程序的行为。详情请参阅 README 文件。 只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算 MLFQ 的执行记录。限制每项作业的长度并关闭 I/O，让你的生活更轻松。 如何运行调度程序来重现本章中的每个实例？ 将如何配置调度程序参数，像轮转调度程序那样工作？ 设计两个工作的负载和调度程序参数，以便一个工作利用较早的规则 4a 和 4b（用-S 标志打开）来“愚弄”调度程序，在特定的时间间隔内获得 99%的 CPU。 给定一个系统，其最高队列中的时间片长度为 10ms，你需要如何频繁地将工作推回到最高优先级级别（带有-B 标志），以保证一个长时间运行（并可能饥饿）的工作得到至少 5%的 CPU？ 调度中有一个问题，即刚完成 I/O 的作业添加在队列的哪一端。-I 标志改变了这个调度模拟器的这方面行为。尝试一些工作负载，看看你是否能看到这个标志的效果。参考 Operating Systems: Three Easy Pieces 中文版" }, { "title": "《Operating Systems: Three Easy Pieces》学习笔记(五) 进程调度：介绍", "url": "/posts/operating-systems-5/", "categories": "学习笔记", "tags": "Operating Systems, 操作系统导论", "date": "2021-03-17 09:00:00 +0800", "snippet": "假设为了方便概念的描述，对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：工作负载 每一个工作运行相同的时间。 所有的工作同时到达。 一旦开始，每个工作保持运行直到完成。 所有的工作只是用 CPU（即它们不执行 IO 操作）。 每个工作的运行时间是已知的。调度指标任务的周转时间定义为任务完成时间减去任务到达系统的时间。更正式的周转时间定义 T_{周转时间} 是：T_{周转时间} = T_{完成时间}−T_{到达时间}因为我们假设所有的任务在同一时间到达，那么 T_{到达时间} = 0，因此 T_{周转时间}= T_{完成时间}。随着我们放宽上述假设，这个情况将改变先进先出（FIFO）先进先出（First In First Out 或 FIFO）调度，有时候也称为先到先服务（First Come First Served 或 FCFS）。假设有三个几乎同时到达的进程，到达顺序为 A,B,C，B 和 C 执行 10s，A 有执行 10s 和执行 100s 的情况，调度结果如下图：两者的平均周转周期 左：(10 + 20 + 30)/3 = 20 右：(100 + 110 + 120)/3 = 110 这个问题通常被称为护航效应（convoy effect），一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。最短任务优先（SJF）最短任务优先（Shortest Job First，SJF）：先运行最短的任务，然后是次短的任务，如此下去左图是在上一节条件下使用 SJF 策略时的表现，右图是在到达时间间隔 10s 条件下使用 SJF 策略时的表现：两者的平均周转周期 左：(10 + 20 + 120)/3 = 50 右：(100+(110−10)+(120−10))/3 = 103.33 从图中可以看出，当 ABC 几乎同时到达时，SJF 相较于 FIFO 有较好的表现，但当 B 和 C 在 A 之后不久到达，由于 SJF 无法抢占，它们仍然被迫等到 A 完成，从而遭遇同样的护航问题。最短完成时间优先(STCF)我们放宽第一节提出的假设条件 3（工作必须保持运行直到完成），也就是允许抢占向 SJF 添加抢占，称为最短完成时间优先（Shortest Time-to-Completion First，STCF）或抢占式最短作业优先（Preemptive Shortest Job First ，PSJF）调度程序每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作:平均周转周期为：(120 + 10 + 20)/3 = 50新度量指标：响应时间响应时间定义为从任务到达系统到首次运行的时间。更正式的定义是：T_{响应时间} = T_{首次运行} − T_{到达时间}用户将会坐在终端前面，同时也要求系统的交互性和响应性好，所以响应时间是有意义的例如，如果我们有上面的调度（A 在时间 0 到达，B 和 C 在时间 10 达到），每个作业的响应时间如下：作业 A 为 0，B 为 0，C 为 10（平均：3.33），STCF 和相关方法在响应时间上并不是很好，对用户来说，打开 C 软件后可能要 10s 后才会有响应时间片轮转轮转（Round-Robin，RR）调度：在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。因此，RR 有时被称为时间切片（time-slicing）。请注意，时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每 10ms 中断一次，则时间片可以是 10ms、20ms 或 10ms 的任何其他倍数。来看一个例子：假设 3 个任务 A、B 和 C 在系统中同时到达，并且它们都希望运行 5s。平均响应时间： SJF：(0 + 5 + 10)/ 3 = 5 RR：(0 + 1 + 2)/3 = 1 SJF 调度程序必须运行完当前任务才可运行下一个任务。相比之下，1s 时间片的 RR 可以快速地循环工作时间片长度时间片长度对于 RR 是至关重要的。时间片长度越短，RR 在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应 请注意，上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在CPU 高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本。结合 I/O首先，我们将放宽假设 4：所有程序都不执行 I/O。一种常见的方法是将 A 的每个 10ms 的子工作视为一项独立的工作。因此，当系统启动时，它的选择是调度 10ms 的 A，还是 50ms 的 B。对于 最短完成时间优先(STCF)，选择是明确的：选择较短的一个，在这种情况下是 A。然后，A 的工作已完成，只剩下 B，并开始运行。然后提交 A 的一个新子工作，它抢占 B 并运行 10ms。这样做可以实现重叠（overlap），一个进程在等待另一个进程的 I/O 完成时使用 CPU，系统因此得到更好的利用小结我们开发了两种调度程序。 第一种类型（SJF、STCF）优化周转时间，但对响应时间不利。 第二种类型（RR）优化响应时间，但对周转时间不利。 作业以后再做参考 Operating Systems: Three Easy Pieces 中文版" }, { "title": "《Operating Systems: Three Easy Pieces》学习笔记(四) 机制：受限直接执行", "url": "/posts/operating-systems-4/", "categories": "学习笔记", "tags": "Operating Systems, 操作系统导论", "date": "2021-03-16 09:00:00 +0800", "snippet": "本文中文版翻译质量堪忧，有不少名词翻译不知所云，建议对照英文版阅读前言在构建这样的虚拟化机制时存在一些挑战。 第一个是性能：如何在不增加系统开销的情况下实现虚拟化？ 第二个是控制权：如何有效地运行进程，同时保留对 CPU 的控制？ 控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息直接运行协议（无限制）直接执行指的是直接在 CPU 上运行程序，该操作没有任何限制。 操作系统 程序 在进程列表上创建条目为程序分配内存将程序加载到内存中根据 argc/argv 设置程序栈   清除寄存器执行 call main() 方法     执行 main()从 main 中执行 return 释放进程的内存将进程从进程列表中清除   直接运行带来两个问题： 受限制的操作：操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它 进程间切换： 操作系统如何让一个进程停下来并切换到另一个进程，从而实现虚拟化 CPU 所需的时分共享问题 1：受限制的操作 提示：采用受保护的控制权转移 硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。我们采用的方法是引入新的处理器模式:用户模式（user mode）在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出 I/O 请求。这样做会导致处理器引发异常，操作系统可能会终止进程。内核模式（kernel mode）操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出 I/O 请求和执行所有类型的受限指令。系统调用系统调用允许内核小心地向用户程序暴露某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。大多数操作系统提供几百个调用（详见 POSIX 标准）。早期的 UNIX 系统公开了更简洁的子集，大约 20 个调用。如果用户希望执行某种特权操作（如从磁盘读取），可以借助硬件提供的系统调用功能。要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。执行陷阱时，硬件需要小心，因为它必须确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够正确返回。例如，在 x86 上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈（kernel stack）上。从返回陷阱将从栈弹出这些值，并恢复执行用户模式程序（有关详细信息，请参阅英特尔系统手册）。其他硬件系统使用不同的约定，但基本概念在各个平台上是相似的。 补充：为什么系统调用看起来像过程调用 你可能想知道，为什么对系统调用的调用（如 open()或 read()）看起来完全就像 C 中的典型过程调用。也就是说，如果它看起来像一个过程调用，系统如何知道这是一个系统调用，并做所有正确的事情？原因很简单：它是一个过程调用，但隐藏在过程调用内部的是著名的陷阱指令。更具体地说，当你调用 open()（举个例子）时，你正在执行对 C 库的过程调用。其中，无论是对于 open()还是提供的其他系统调用，库都使用与内核一致的调用约定来将参数放在众所周知的位置（例如，在栈中或特定的寄存器中），将系统调用号也放入一个众所周知的位置（同样，放在栈或寄存器中），然后执行上述的陷阱指令。库中陷阱之后的代码准备好返回值，并将控制权返回给发出系统调用的程序。因此，C 库中进行系统调用的部分是用汇编手工编码的，因为它们需要仔细遵循约定，以便正确处理参数和返回值，以及执行硬件特定的陷阱指令。现在你知道为什么你自己不必写汇编代码来陷入操作系统了，因为有人已经为你写了这些汇编。陷阱表（trap table）内核通过在启动时设置陷阱表（trap table）来实现陷阱地址的初始化。当机器启动时，系统在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码？操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器，并且硬件知道在发生系统调用和其他异常事件时要做什么（即跳转到哪段代码）。受限直接运行协议LDE 协议有两个阶段:第一阶段： 操作系统@启动（内核模式） 硬件   初始化陷阱表       记住系统调用处理程序的地址   第一个阶段（在系统引导时），内核初始化陷阱表，并且 CPU 记住它的位置以供随后使用。内核通过特权指令来执行此操作（所有特权指令均以粗体突出显示）。第二阶段： 操作系统@运行（内核模式） 硬件 程序（应用模式） 在进程列表上创建条目为程序分配内存将程序加载到内存中根据 argv 设置程序栈用寄存器/程序计数器填充内核栈从陷阱返回       从内核栈恢复寄存器转向用户模式跳到 main       运行 main ……调用系统调用陷入操作系统   将寄存器保存到内核栈转向内核模式跳到陷阱处理程序   处理陷阱做系统调用的工作从陷阱返回       从内核栈恢复寄存器转向用户模式跳到陷阱之后的程序计数器       ……从 main 返回陷入（通过 exit()） 释放进程的内存将进程从进程列表中清除     第二个阶段（运行进程时），在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容（例如，在进程列表中分配一个节点，分配内存）。这会将 CPU 切换到用户模式并开始运行该进程。当进程希望发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。该进程然后完成它的工作，并从 main()返回。这通常会返回到一些存根代码，它将正确退出该程序（例如，通过调用 exit()系统调用，这将陷入 OS 中）。此时，OS 清理干净，任务完成了。问题 2：在进程之间切换 关键问题：如何重获 CPU 的控制权 操作系统如何重新获得 CPU 的控制权（regain control），以便它可以在进程之间切换？协作方式：等待系统调用在协作调度系统中，OS 通过等待系统调用，或某种非法操作发生，从而重新获得 CPU 的控制权。过去某些系统采用的一种方式（例如，早期版本的 Macintosh 操作系统或旧的 Xerox Alto 系统）称为协作（cooperative）方式。在这种风格下，操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃 CPU，以便操作系统可以决定运行其他任务。大多数进程通过进行系统调用，将 CPU 的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程如果应用程序执行了某些非法操作，也会将控制转移给操作系统。例如，如果应用程序以 0 为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制 CPU（并可能终止违规进程）。非协作方式：时钟中断时钟中断（timer interrupt）。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。请注意，硬件在发生中断时有一定的责任，尤其是在中断发生时，要为正在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复正在运行的程序。该操作可以视为隐式的操作，与显式的系统调用很相似。保存和恢复上下文当操作系统通过上述两种方式获取控制权后，就可以决定是否切换进程，这个决定是由调度程序（scheduler）做出当操作系统决定切换进程时，需要首先进行上下文切换（context switch），就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。 上下文切换并不仅仅保存和恢复寄存器，还包含了其他操作，如页表的切换等，在后续章节会提到受限直接执行协议（时钟中断）第一阶段： 操作系统@启动（内核模式） 硬件 初始化陷阱表     记住以下地址： -系统调用处理程序 -时钟处理程序 启动中断时钟     启动时钟每隔 x ms 中断 CPU 第二阶段： 操作系统@运行（内核模式） 硬件 程序（应用模式）     进程 A……   时钟中断将用户寄存器（A）保存到内核栈（A）转向内核模式跳到陷阱处理程序   处理陷阱调用 switch()例程 -保存内核寄存器（A）-&amp;gt;进程结构（A） -恢复内核寄存器（B）&amp;lt;-进程结构（B）-切换到内核栈（B）从陷阱返回（进入 B）       恢复用户寄存器（B）&amp;lt;-内核栈（B）转向用户模式跳到 B 的程序计数器       进程 B…… 该表展示了整个过程的时间线。在这个例子中，进程 A 正在运行，然后被中断时钟中断。硬件保存它的用户寄存器（到内核栈中），并进入内核（切换到内核模式）。在时钟中断处理程序中，操作系统决定从正在运行的进程 A 切换到进程 B。此时，它调用 switch()例程，该例程仔细保存当前内核寄存器的值（保存到 A 的进程结构(process structure)），恢复内核寄存器进程 B（从它的进程结构(process structure)），然后切换上下文（switch context），具体来说是通过改变栈指针来使用 B 的内核栈（而不是 A 的）。最后，操作系统从陷阱返回，恢复 B 的用户寄存器并开始运行它。请注意，在此协议中，有两种类型的寄存器保存/恢复: 第一种是发生时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。 原文：the user registers of the running process are implicitly saved by the hardware, using the kernel stack of that process 根据英文原文，此处确实是保存到了内核栈中 扩展：内核栈与用户栈 内核在创建进程时，会同时创建 task_struct 和进程相应堆栈。每个进程都会有两个堆栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，CPU 堆栈寄存器(SP)的内容是用户堆栈地址，使用用户栈。当进程在内核空间时，CPU 堆栈寄存器(SP)的内容是内核栈地址，使用的是内核栈。 第二种是当操作系统决定从 A 切换到 B。在这种情况下，A 的用户寄存器先被硬件保存到内核栈(A)，之后进入内核态，此时，用户寄存器切换成内核寄存器，存放系统和进程 A 相关的值，操作系统接管后，调用 switch()通过软件方式将内核寄存器中的值保存到 A 的进程结构，之后从 B 的进程结构恢复值到内核寄存器，并切换到进程 B 的内核栈(B)，然后从陷阱返回，从内核栈(B)恢复 B 的用户寄存器，运行 B 进程 原文：the kernel registers are explicitly saved by the software (i.e., the OS), but this time into memory in the process structure of the process. The latter action moves the system from running as if it just trapped into the kernel from A to as if it just trapped into the kernel from B. 为了理解这个逻辑，首先把切换这步去掉，假设 A 不切换成 B，即 A 的用户寄存器先被硬件保存到内核栈(A)，此时，包括PC寄存器（需要执行的下一条指令地址）在内的寄存器都被压入内核栈(A)，从陷阱返回后，从内核栈(A)恢复 A 的用户寄存器，将包括 PC 寄存器在内的寄存器恢复，此时继续执行 PC 寄存器保存的下一条指令。然后加上switch()操作，保存/恢复内核寄存器到对应的进程结构中。 TODO:此处后面再用实际操作系统的例子补充 分享：在 µC/OS-III 中遇到的上下文切换问题在实际项目中使用 µC/OS-III 系统时遇到过一个问题，某个进程的值在没有任何修改的情况下变为了异常值。问题说明：wlm_do()-&amp;gt;the_wlm_routine[the_wlm.status].func()-&amp;gt;wlm_chk_baudrate()-&amp;gt;atcmd(serfd(), &quot;AT\\r&quot;, E_OK, 500, NULL, 0)-&amp;gt;memset(prbuf, 0, rbuf_len)rbuf_len 的值变为了 536890260，显然是个异常值。问题分析：通过分析后排除了程序本身的问题，打算从操作系统角度进行问题。在关闭 GCC 优化的情况下，该值正常，也就是说可能和 GCC 的优化有关。GCC 优化会将部分常用的变量保持到寄存器中，从而提高读写速度。通过内存和寄存器跟踪工具，定位了该变量确实被保存在了寄存器中，也就是说寄存器出现了问题，和寄存器操作相关的就极有可能是上下文切换操作。通过跟踪发现寄存器的值在进程切换后出现了异常，导致该变量的值改变查看上下文切换实现源码：OS_CPU_PendSVHandler: CPSID I @ Prevent interruption during context switch MRS R0, PSP @ PSP is process stack pointer CMP R0, #0 BEQ OS_CPU_PendSVHandler_nosave @ equivalent code to CBZ from M3 arch to M0 arch @ Except that it does not change the condition code flags SUBS R0, R0, #0x10 @ Adjust stack pointer to where memory needs to be stored to avoid overwriting STM R0!, {R4-R7} @ Stores 4 4-byte registers, default increments SP after each storing SUBS R0, R0, #0x10 @ STM does not automatically call back the SP to initial location so we must do this manually LDR R1, =OSTCBCur @ OSTCBCur-&amp;gt;OSTCBStkPtr = SP; LDR R1, [R1] STR R0, [R1] @ R0 is SP of process being switched out @ At this point, entire context of process has been saved此处仅保存了 r4-r7 寄存器，少了对 r8-r11 寄存器的保存查看官网更新说明µC/OS-III v3.06.00 Changelog，有如下信息：bug 修复后的上下文切换源码如下：PendSV_Handler: CPSID I @ Prevent interruption during context switch MRS R0, PSP @ PSP is process stack pointer CMP R0, #0 BEQ OS_CPU_PendSVHandler_nosave @ equivalent code to CBZ from M3 arch to M0 arch @ Except that it does not change the condition code flags SUBS R0, R0, #0x24 @ Adjust SP to make space for Low, High &amp;amp; LR registers LDR R1, =OSTCBCur @ OSTCBCur-&amp;gt;OSTCBStkPtr = SP; LDR R1, [R1] STR R0, [R1] @ R0 is SP of process being switched out STMIA R0!, {R4-R7} @ Store R4-R7(Low Registers) on process stack MOV R4, R8 @ Move R8-R11 values to R4-R7 registers. MOV R5, R9 MOV R6, R10 MOV R7, R11 STMIA R0!, {R4-R7} @ Store R8-R11(High Registers) on process stack MOV R3, R14 @ R3 is LR of process being switched out STMIA R0!, {R3} @ Store LR (EXC_RETURN) on process stack. @ At this point, entire context of process has been saved此处保存了 r4-r11 寄存器至此，问题原因已明确问题原因：代码优化时将 rbuf_len 保存在了寄存器 r8 上，在进行上下文切换时，r8 寄存器没有被保存，导致 r8 寄存器的值被其他进程修改，切换回本进程后，r8 的值也无法恢复。思考：并发对中断的影响处理一个中断时发生另一个中断，会发生什么？一种方法是，在中断处理期间禁止中断（disable interrupt）。这样做可以确保在处理一个中断时，不会将其他中断交给 CPU。当然，操作系统这样做必须小心。禁用中断时间过长可能导致丢失中断，这（在技术上）是不好的。操作系统还开发了许多复杂的加锁（locking）方案，以保护对内部数据结构的并发访问。这使得多个活动可以同时在内核中进行，特别适用于多处理器，在下一部分关于并发的章节中将会看到思考：上下文切换的消耗你可能有一个很自然的问题：上下文切换需要多长时间？甚至系统调用要多长时间？如果感到好奇，有一种称为 lmbench的工具，可以准确衡量这些事情，并提供其他一些可能相关的性能指标。随着时间的推移，结果有了很大的提高，大致跟上了处理器的性能提高。例如，1996 年在 200-MHz P6 CPU 上运行 Linux 1.3.37，系统调用花费了大约 4μs，上下文切换时间大约为 6μs。现代系统的性能几乎可以提高一个数量级，在具有 2 GHz 或 3 GHz 处理器的系统上的性能可以达到亚微秒级。应该注意的是，并非所有的操作系统操作都会跟踪 CPU 的性能。正如 Ousterhout 所说的，许多操作系统操作都是内存密集型的，而随着时间的推移，内存带宽并没有像处理器速度那样显著提高。因此，根据你的工作负载，购买最新、性能好的处理器可能不会像你希望的那样加速操作系统。参考 Operating Systems: Three Easy Pieces 中文版" }, { "title": "《Operating Systems: Three Easy Pieces》学习笔记(三) 插叙：进程 API", "url": "/posts/operating-systems-3/", "categories": "学习笔记", "tags": "Operating Systems, 操作系统导论", "date": "2021-03-12 17:00:00 +0800", "snippet": "fork()系统调用在执行函数 fork()时，创建了一个子进程，此时是两个进程同时运行#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;int main(int argc, char *argv[]){ printf(&quot;hello world (pid:%d)\\n&quot;, (int)getpid()); int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child (new process) printf(&quot;hello, I am child (pid:%d)\\n&quot;, (int)getpid()); } else { // parent goes down this path (main) printf(&quot;hello, I am parent of %d (pid:%d)\\n&quot;, rc, (int)getpid()); } return 0;}输出如下：prompt&amp;gt; ./p1hello world (pid:29146)hello, I am parent of 29147 (pid:29146)hello, I am child (pid:29147)prompt&amp;gt;上面这段程序执行了一次 fork 操作，fork()函数是一个神奇的操作，它只被调用了一次，却产生了两个返回值。对于父进程来说，其返回值是子进程的 pid；对于子进程来说，其返回值为 0。子进程并不是完全拷贝了父进程，所以子进程不会从 main 开始执行，该程序的首行打印并未被子进程执行。它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等。此处父进程与子进程的执行顺序并不是绝对的，取决于 cpu 的调度算法，子进程也可能比父进程先执行完 TODO: fork()函数的具体原理还有待进一步学习wait()系统调用wait()函数用于使父进程（也就是调用 wait()的进程）阻塞，直到一个子进程结束或者该进程接收到了一个指定的信号为止。#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;int main(int argc, char *argv[]){ printf(&quot;hello world (pid:%d)\\n&quot;, (int)getpid()); int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child (new process) printf(&quot;hello, I am child (pid:%d)\\n&quot;, (int)getpid()); } else { // parent goes down this path (main) int wc = wait(NULL); printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\\n&quot;, rc, wc, (int)getpid()); } return 0;}prompt&amp;gt; ./p2hello world (pid:29266)hello, I am child (pid:29267)hello, I am parent of 29267 (wc:29267) (pid:29266)prompt&amp;gt;本例中，子进程却优先于父进程执行完毕，这是因为父进程调用了wait()操作当父进程先执行时，会等待子进程结束，才会继续执行exec()系统调用exec()这个系统调用可以让子进程执行与父进程不同的程序 关于exec函数族的更多相关内容，可以查看Linux 多任务编程（三）—exec 函数族及其基础实验#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;int main(int argc, char *argv[]){ printf(&quot;hello world (pid:%d)\\n&quot;, (int)getpid()); int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child (new process) printf(&quot;hello, I am child (pid:%d)\\n&quot;, (int)getpid()); char *myargs[3]; myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count) myargs[1] = strdup(&quot;p3.c&quot;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count printf(&quot;this shouldn&#39;t print out&quot;); } else { // parent goes down this path (main) int wc = wait(NULL); printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\\n&quot;, rc, wc, (int)getpid()); } return 0;}prompt&amp;gt; ./p3hello world (pid:29383)hello, I am child (pid:29384) 29 107 1030 p3.chello, I am parent of 29384 (wc:29384) (pid:29383)prompt&amp;gt;在这个例子中，子进程调用 execvp()来运行字符计数程序 wc。实际上，它针对源代码文件 p3.c 运行 wc，从而告诉我们该文件有多少行、多少单词，以及多少字节。给定可执行程序的名称（如 wc）及需要的参数（如 p3.c）后，exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 p3）替换为不同的运行程序（wc）。子进程执行 exec()之后，几乎就像 p3.c 从未运行过一样。对 exec()的成功调用永远不会返回。如果 exec 函数执行失败, 它会返回失败的信息, 而且进程继续执行后面的代码。 注意：此时子进程的 pid 号并没有变，且还是该父进程的子进程，所以并不会影响 wait()操作，等待该进程的操作（统计字节）完成后，wait()才会返回，父进程同时退出阻塞状态为什么这样设计 API事实证明，这种分离 fork()及 exec()的做法在构建 UNIX shell 的时候非常有用，因为这给了 shell 在 fork 之后 exec 之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现。shell 也是一个用户程序，它首先显示一个提示符（prompt），然后等待用户输入。你可以向它输入一个命令（一个可执行程序的名称及需要的参数），大多数情况下，shell 可以在文件系统中找到这个可执行程序，调用 fork()创建新进程，并调用 exec()的某个变体来执行这个可执行程序，调用 wait()等待该命令完成。子进程执行结束后，shell 从 wait()返回并再次输出一个提示符，等待用户输入下一条命令。fork()和 exec()的分离，让 shell 可以方便地实现很多有用的功能。比如：prompt&amp;gt; wc p3.c &amp;gt; newfile.txt在上面的例子中，wc 的输出结果被重定向（redirect）到文件 newfile.txt 中（通过 newfile.txt 之前的大于号来指明重定向）。shell 实现结果重定向的方式也很简单，当完成子进程的创建后，shell 在调用 exec()之前先关闭了标准输出（standard output），打开了文件 newfile.txt。这样，即将运行的程序 wc 的输出结果就被发送到该文件，而不是打印在屏幕上。扩展阅读：重定向重定向的工作原理，是基于对操作系统管理文件描述符方式的假设，首先看实例：#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;int main(int argc, char *argv[]){ int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file close(STDOUT_FILENO); open(&quot;./p4.output&quot;, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU); // now exec &quot;wc&quot;... char *myargs[3]; myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count) myargs[1] = strdup(&quot;p4.c&quot;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count } else { // parent goes down this path (main) int wc = wait(NULL); } return 0;}prompt&amp;gt; ./p4prompt&amp;gt; cat p4.output 32 109 846 p4.cprompt&amp;gt;要看懂上面的例子，首先要补充点Unix文件描述符的知识 每个 Unix 进程（除了可能的守护进程）应均有三个标准的 POSIX 文件描述符，对应于三个标准流： 整数值 名称 &amp;lt;unistd.h&amp;gt;符号常量 &amp;lt;stdio.h&amp;gt;文件流 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 Standard error STDERR_FILENO stderr UNIX 系统从 0 开始寻找可以使用的文件描述符，进程启动后默认打开了标准输出STDOUT_FILENO输出到屏幕，此时所有的对标准输出文件描述符的输出，如 printf()，都会打印的屏幕上： root@hjk:~/repo/os_test# ./a.out33 113 864 p4.c 如果使用close(STDOUT_FILENO)关闭了这个描述符，再去调用printf()，系统会提示找不到文件描述符 root@hjk:~/repo/os_test# ./a.outwc: write error: Bad file descriptor 此时再打开新的文件描述符，会将所有的对标准输出文件描述符的输出定向到该文件描述符上 open(&quot;./p4.output&quot;, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU) 因为 Unix 系统会从 0 开始寻找可用的文件描述符，当找不到STDOUT_FILENO自然会去找新打开的文件描述符 扩展阅读：管道UNIX管道也是用类似的方式实现的，但用的是 pipe()系统调用。在这种情况下，一个进程的输出被链接到了一个内核管道（pipe）上（队列），另一个进程的输入也被连接到了同一个管道上。因此，前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用这种方式串联在一起，共同完成某项任务。比如通过将 grep、wc 命令用管道连接可以完成从一个文件中查找某个词，并统计其出现次数的功能：grep -o foo file | wc -l作业 编写一个调用 fork()的程序。在调用 fork()之前，让主进程访问一个变量（例如 x）并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x 的值时，变量会发生什么？ 答：父进程在 fork 之前修改的值会同步到子进程中（fork 前子进程并不存在），当 fork 完成后，两个进程相互独立，修改 fork 前定义的变量时也是独立的。 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;int main(int argc, char *argv[]){ int x = 1; printf(&quot;hello world (pid:%d)\\n&quot;, (int)getpid()); x = 3; int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child (new process) x=4; printf(&quot;hello, I am child (pid:%d),x:%d\\n&quot;, (int)getpid(),x); } else { // parent goes down this path (main) wait(NULL); printf(&quot;hello, I am parent of %d (pid:%d),x:%d\\n&quot;, rc, (int)getpid(),x); } return 0;} 结果如下，两个进程的 x 独立，即便是子进程修改了 x，父进程中的 x 还是 fork 前的值 root@hjk:~/repo/os_test# ./a.outhello world (pid:17699)hello, I am child (pid:17700),x:4hello, I am parent of 17700 (pid:17699),x:3 编写一个打开文件的程序（使用 open()系统调用），然后调用 fork()创建一个新进程。子进程和父进程都可以访问 open()返回的文件描述符吗？当它们并发（即同时）写入文件时，会发生什么？ 答：都可以访问。并发时无影响。 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;int main(int argc, char *argv[]){ close(STDOUT_FILENO); int fd = open(&quot;./p4.output&quot;, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU); int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file // now exec &quot;wc&quot;... printf(&quot;child\\n&quot;); } else { // parent goes down this path (main) // int wc = wait(NULL); printf(&quot;father\\n&quot;); } // if(fd&amp;gt;=0) // { // close(fd); // } return 0;} p4.output 文件输出如下： fatherchild 使用 fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait()而做到这一点呢？ 答：使用 sleep 函数时父进程休眠一段时间 现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用 wait()会发生什么？ 答：wait()返回子进程的 pid，子进程中调用无影响，返回值为-1。 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;int main(int argc, char *argv[]){ close(STDOUT_FILENO); int fd = open(&quot;./p4.output&quot;, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU); int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file // now exec &quot;wc&quot;... int wc=wait(NULL); printf(&quot;child,pid:%d,wc:%d\\n&quot;,getpid(),wc); } else { // parent goes down this path (main) int wc = wait(NULL); // sleep(1); printf(&quot;father,pid:%d,wc:%d\\n&quot;,getpid(),wc); } // if(fd&amp;gt;=0) // { // close(fd); // } return 0;} p4.output 输出结果为： child,pid:4577,wc:-1father,pid:4576,wc:4577 对前一个程序稍作修改，这次使用 waitpid()而不是 wait()。什么时候 waitpid()会有用？ waitpid()参数值 说明 pid&amp;lt;-1 等待进程组号为 pid 绝对值的任何子进程。 pid=-1 等待任何子进程，此时的 waitpid()函数就退化成了普通的 wait()函数。 pid=0 等待进程组号与目前进程相同的任何子进程，也就是说任何和调用 waitpid()函数的进程在同一个进程组的进程。 pid&amp;gt;0 等待进程号为 pid 的子进程。 使用getpgrp()获取当前进程组号 答：当 pid 为0(pid=0),-1(pid=-1),child_pid(pid&amp;gt;0),getpgrp()*-1(pid&amp;lt;-1)时，waitpid()有用 编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO）。如果子进程在关闭描述符后调用 printf()打印输出，会发生什么？ 答：子进程无法打印，父进程无影响 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;int main(int argc, char *argv[]){ // close(STDOUT_FILENO); // int fd = open(&quot;./p4.output&quot;, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU); int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file // now exec &quot;wc&quot;... // int wc=wait(NULL); close(STDOUT_FILENO); printf(&quot;child,pid:%d,wc:%d\\n&quot;,getpid()); } else { // parent goes down this path (main) // int wc = waitpid(getpgrp(),NULL,0); // sleep(1); printf(&quot;father,pid:%d,wc:%d\\n&quot;,getpid()); } // if(fd&amp;gt;=0) // { // close(fd); // } return 0;} 输出为： root@hjk:~/repo/os_test# ./a.outfather,pid:11189,wc:0 编写一个程序，创建两个子进程，并使用 pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。 答：该程序将子进程2中的输出通过管道连接到子进程1的输入中 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;sys/wait.h&amp;gt; int main(int argc, char *argv[]) { // close(STDOUT_FILENO); // int fd = open(&quot;./p4.output&quot;, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU); int fds[2]; if(pipe(fds)==-1) { fprintf(stderr, &quot;open pipe failed\\n&quot;); exit(1); } int rc = fork(); if (rc &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file // int wc=wait(NULL); printf(&quot;child1,pid:%d\\n&quot;,getpid()); int len; char buf[10]; // 从pipe中读取 if((len=read(fds[0],buf,6))==-1) { perror(&quot;read from pipe&quot;); exit(1); } printf(&quot;buf:%s\\n&quot;,buf); exit(0); } else { // parent goes down this path (main) // wait(NULL); //创建第二个子进程 int rc2 = fork(); if (rc2 &amp;lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc2 == 0) { // child: redirect standard output to a file // int wc=wait(NULL); printf(&quot;child2,pid:%d\\n&quot;,getpid()); char buf[]= &quot;12345&quot;; // 写入pipe if(write(fds[1],buf,sizeof(buf))!=sizeof(buf)) { perror(&quot;write to pipe&quot;); exit(1); } exit(0); } } return 0; } 补充：有趣的小知识在做作业时发现，有时子进程打印的结果会在shell显示提示符后才打印出来，如下：root@hjk:~/repo/os_test# ./a.out father,pid:92505root@hjk:~/repo/os_test# child,pid:92506在本文的[为什么这样设计 API]一节中有提到shell执行程序的逻辑，下面解释下： shell 也是一个用户程序，它首先显示一个提示符（prompt） 运行程序时shell进程会fork一个子进程 子进程使用exec替换程序为要执行的程序，如a.out 此时shell进入wait状态，直到子进程退出 由于作业中编写的程序又创建了一个子进程，如果父进程先执行完，那么对于shell进程来说，它的子进程就已经结束了，shell结束wait状态，打印一行提示符。此时用户进程的子进程还未结束，又继续在标准输出上打印了信息，那就会有这种现象参考 Operating Systems: Three Easy Pieces 中文版" }, { "title": "《Operating Systems: Three Easy Pieces》学习笔记(二) 抽象：进程", "url": "/posts/operating-systems-2/", "categories": "学习笔记", "tags": "Operating Systems, 操作系统导论", "date": "2021-03-12 09:00:00 +0800", "snippet": "本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出进程 API创建（create）操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。销毁（destroy）由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，用户可能希望终止它们，因此停止失控进程的接口非常有用。等待（wait）有时等待进程停止运行是有用的，因此经常提供某种等待接口。其他控制（miscellaneous control）除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），然后恢复（继续运行）。状态（statu）通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。进程创建1. 加载数据到内存操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）从磁盘加载（load）到内存中，加载到进程的地址空间中。在早期的（或简单的）操作系统中，加载过程尽早（eagerly）完成，即在运行程序之前全部完成。现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。2. 为栈分配空间将代码和静态数据加载到内存后，必须为程序的运行时栈（run-time stack 或 stack）分配一些内存。C 程序使用栈存放局部变量、函数参数和返回地址。操作系统也可能会用参数初始化栈。具体来说，它会将参数填入 main()函数，即 argc 和 argv 数组。3. 为堆分配空间操作系统也可能为程序的堆（heap）分配一些内存。程序通过调用 malloc()来请求这样的空间，并通过调用 free()来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。4. I/O 初始化操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。例如，在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。5. 运行程序入口通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的其他工作，完成准备后，接下来就是启动程序，在入口处运行，即 main()。进程状态进程的三种状态 运行（running） 在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。 就绪（ready） 在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。 阻塞（blocked） 在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞，因此其他进程可以使用处理器 可以根据操作系统的载量，让进程在就绪状态和运行状态之间转换。从就绪到运行意味着该进程已经被调度（scheduled）。从运行转移到就绪意味着该进程已经取消调度（descheduled）。一旦进程被阻塞（例如，通过发起 I/O 操作），OS 将保持进程的这种状态，直到发生某种事件（例如，I/O 完成）。此时，进程再次转入就绪状态（也可能立即再次运行，如果操作系统这样决定）。关于调度的策略，原文写得过于仔细，我总结下，就是一个进程阻塞或停止时，就会去调度另一个就绪的进程，从而让 cpu 一直保持在满负荷状态数据结构为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程列表（process list），以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种方式跟踪被阻塞的进程。当 I/O 事件完成时，操作系统应确保唤醒正确的进程，让它准备好再次运行。// the registers xv6 will save and restore// to stop and subsequently restart a processstruct context{ int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp;};// the different states a process can be in// 可以看到实际操作系统对于进程状态的定义远不止上面介绍的3种enum proc_state{ UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE};// the information xv6 tracks about each process// including its register context and statestruct proc{ char *mem; // Start of process memory uint sz; // Size of process memory char *kstack; // Bottom of kernel stack // for this process enum proc_state state; // Process state int pid; // Process ID struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for the // current interrupt};该数据结构展示了 OS 需要跟踪 xv61 内核中每个进程的信息类型[CK+08]。“真正的”操作系统中存在类似的进程结构，如 Linux、macOS X 或 Windows。对于停止的进程，寄存器上下文将保存其寄存器的内容。除了运行、就绪和阻塞之外，还有其他一些进程可以处于的状态： 初始（initial）状态 有时候系统会有一个初始（initial）状态，表示进程在创建时处于的状态。 最终（final）状态 另外，一个进程可以处于已退出但尚未清理的最终（final）状态（在基于 UNIX 的系统中，这称为僵尸状态）。这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于 UNIX 的系统中，程序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如，wait()），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构 作业关于作业，本文只摘取部分我认为比较重要的部分 另一个重要的行为是 I/O 完成时要做什么。利用-I IO_RUN_LATER，当 I/O 完成时，I/O 完成的进程不会被优先调度，而是按照排队顺序来。相反，当时运行的进程一直运行。当你运行这个进程组合时会发生什么？（./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p）系统资源是否被有效利用？ $ ./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -pTime PID: 0 PID: 1 PID: 2 PID: 3 CPU IOs 1 RUN:io READY READY READY 1 2 WAITING RUN:cpu READY READY 1 1 3 WAITING RUN:cpu READY READY 1 1 4 WAITING RUN:cpu READY READY 1 1 5 WAITING RUN:cpu READY READY 1 1 6 WAITING RUN:cpu READY READY 1 1 7* READY DONE RUN:cpu READY 1 8 READY DONE RUN:cpu READY 1 9 READY DONE RUN:cpu READY 1 10 READY DONE RUN:cpu READY 1 11 READY DONE RUN:cpu READY 1 12 READY DONE DONE RUN:cpu 1 13 READY DONE DONE RUN:cpu 1 14 READY DONE DONE RUN:cpu 1 15 READY DONE DONE RUN:cpu 1 16 READY DONE DONE RUN:cpu 1 17 RUN:io_done DONE DONE DONE 1 18 RUN:io DONE DONE DONE 1 19 WAITING DONE DONE DONE 1 20 WAITING DONE DONE DONE 1 21 WAITING DONE DONE DONE 1 22 WAITING DONE DONE DONE 1 23 WAITING DONE DONE DONE 1 24* RUN:io_done DONE DONE DONE 1 25 RUN:io DONE DONE DONE 1 26 WAITING DONE DONE DONE 1 27 WAITING DONE DONE DONE 1 28 WAITING DONE DONE DONE 1 29 WAITING DONE DONE DONE 1 30 WAITING DONE DONE DONE 1 31* RUN:io_done DONE DONE DONE 1Stats: Total Time 31Stats: CPU Busy 21 (67.74%)Stats: IO Busy 15 (48.39%)在本题中，进程 0 首先进入 IO，此时由于-S SWITCH_ON_IO参数，进程 0 进入阻塞状态，cpu 被切换到运行进程 1，当进程 0 的 IO 完成后，进程 1 继续执行，直到完成。也就是 IO 完成事件不会被立即处理，由于进程 0 的 IO 动作较为频繁，会使它长时间处于 IO 完成等待状态，导致后续的 IO 操作时 cpu 已经无事可做了，在本例条件下降低了效率 现在运行相同的进程，但使用-I IO_RUN_IMMEDIATE 设置，该设置立即运行发出 I/O 的进程。这种行为有何不同？为什么运行一个刚刚完成 I/O 的进程会是一个好主意？$ ./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -pTime PID: 0 PID: 1 PID: 2 PID: 3 CPU IOs 1 RUN:io READY READY READY 1 2 WAITING RUN:cpu READY READY 1 1 3 WAITING RUN:cpu READY READY 1 1 4 WAITING RUN:cpu READY READY 1 1 5 WAITING RUN:cpu READY READY 1 1 6 WAITING RUN:cpu READY READY 1 1 7* RUN:io_done DONE READY READY 1 8 RUN:io DONE READY READY 1 9 WAITING DONE RUN:cpu READY 1 1 10 WAITING DONE RUN:cpu READY 1 1 11 WAITING DONE RUN:cpu READY 1 1 12 WAITING DONE RUN:cpu READY 1 1 13 WAITING DONE RUN:cpu READY 1 1 14* RUN:io_done DONE DONE READY 1 15 RUN:io DONE DONE READY 1 16 WAITING DONE DONE RUN:cpu 1 1 17 WAITING DONE DONE RUN:cpu 1 1 18 WAITING DONE DONE RUN:cpu 1 1 19 WAITING DONE DONE RUN:cpu 1 1 20 WAITING DONE DONE RUN:cpu 1 1 21* RUN:io_done DONE DONE DONE 1Stats: Total Time 21Stats: CPU Busy 21 (100.00%)Stats: IO Busy 15 (71.43%)在本例中，由于使用了-I IO_RUN_IMMEDIATE设置，IO 完成事件被立即处理，此时进程 0 继续运行，对于 IO 操作较为频繁的进程 0 来说这是一件好事思考：立即处理阻塞完成的进程是否是一个好主意?参考 Operating Systems: Three Easy Pieces 中文版 xv6 是在 ANSI C 中针对多处理器 x86 系统的 Unix 第六版的现代重新实现。它足够简单，是上手操作系统的一个不错选择 &amp;#8617; " }, { "title": "《Operating Systems: Three Easy Pieces》学习笔记(一) 操作系统介绍", "url": "/posts/operating-systems-1/", "categories": "学习笔记", "tags": "Operating Systems, 操作系统导论", "date": "2021-03-11 09:00:00 +0800", "snippet": "本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出虚拟化 CPU首先看个例子#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &quot;common.h&quot;int main(int argc, char *argv[]){ if (argc != 2) { fprintf(stderr, &quot;usage: cpu &amp;lt;string&amp;gt;\\n&quot;); exit(1); } char *str = argv[1]; while (1) { Spin(1); printf(&quot;%s\\n&quot;, str); } return 0;}该程序每秒打印一次输入参数，是个死循环，不会退出prompt&amp;gt; ./cpu A &amp;amp; ; ./cpu B &amp;amp; ; ./cpu C &amp;amp; ; ./cpu D &amp;amp;[1] 7353[2] 7354[3] 7355[4] 7356ABDCABDCACBD...当同时执行运行 4 个程序的命令时，打印几乎是同时运行的，而不是等待第一个程序运行结束才运行下个程序对应单核的处理器，同时运行 4 个进程是不可能的，所有这里就要介绍 CPU 的虚拟化事实证明，在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟 CPU 的假象。将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化 CPU（virtualizing the CPU）当然运行不同进程时的策略，如优先级等也是需要讨论的知识点：时分共享，上下文切换虚拟化内存#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &quot;common.h&quot;int main(int argc, char *argv[]){ int *p = malloc(sizeof(int)); // a1 assert(p != NULL); printf(&quot;(%d) memory address of p: %08x\\n&quot;, getpid(), (unsigned)p); // a2 *p = 0; // a3 while (1) { Spin(1); *p = *p + 1; printf(&quot;(%d) p: %d\\n&quot;, getpid(), *p); // a4 } return 0;}这是一个访问内存的程序（mem.c）该程序做了几件事。首先，它分配了一些内存（a1 行）。然后，打印出内存的地址（a2 行），然后将数字 0 放入新分配的内存的第一个空位中（a3 行）。最后，程序循环，延迟一秒钟并递增 p 中保存的值。在每个打印语句中，它还会打印出所谓的正在运行程序的进程标识符（PID）（a4 行）。该 PID 对每个运行进程是唯一的。该程序的输出如下：prompt&amp;gt; ./mem(2134) memory address of p: 00200000(2134) p: 1(2134) p: 2(2134) p: 3(2134) p: 4(2134) p: 5ˆC当只运行一个程序时，p 递增，一切正常prompt&amp;gt; ./mem &amp;amp;; ./mem &amp;amp;[1] 24113[2] 24114(24113) memory address of p: 00200000(24114) memory address of p: 00200000(24113) p: 1(24114) p: 1(24114) p: 2(24113) p: 2(24113) p: 3(24114) p: 3(24113) p: 4(24114) p: 4...当同时运行多个相同的程序时，分配的内存地址竟然是相同的，先抛开虚拟化的概念，以物理内存的角度看待，这几个程序分配的内存指针指向了同一块内存空间，也就是修改其中一个程序修改内存也会导致另一个程序中的值改变但是从结果来看这两块内存相互独立，并不影响，就好像每个正在运行的程序都有自己的私有内存，而不是与其他正在运行的程序共享相同的物理内存实际上，这正是操作系统虚拟化内存（virtualizing memory）时发生的情况。每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。但实际情况是，物理内存是由操作系统管理的共享资源。知识点：(等待补充)并发#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &quot;common.h&quot;volatile int counter = 0;int loops;void *worker(void *arg){ int i; for (i = 0; i &amp;lt; loops; i++) { counter++; } return NULL;}int main(int argc, char *argv[]){ if (argc != 2) { fprintf(stderr, &quot;usage: threads &amp;lt;value&amp;gt;\\n&quot;); exit(1); } loops = atoi(argv[1]); pthread_t p1, p2; printf(&quot;Initial value : %d\\n&quot;, counter); Pthread_create(&amp;amp;p1, NULL, worker, NULL); Pthread_create(&amp;amp;p2, NULL, worker, NULL); Pthread_join(p1, NULL); Pthread_join(p2, NULL); printf(&quot;Final value : %d\\n&quot;, counter); return 0;}主程序利用 Pthread_create()创建了两个线程（thread），每个线程中循环了 loops 次来递增全局变量counter。理想情况下，counter 最终的值应该为 2xloops，因为两个线程各把 counter 递增了 loops 次prompt&amp;gt; ./thread 100000Initial value : 0Final value : 143012 // huh??prompt&amp;gt; ./thread 100000Initial value : 0Final value : 137298 // what the??当运行时，发现值每次各不相同，且小于 2xloops。事实证明，这些奇怪的、不寻常的结果与指令如何执行有关，指令每一执行一条。遗憾的是，上面的程序中的关键部分是增加共享计数器的地方，它需要 3 条指令： 一条将计数器的值从内存加载到寄存器 一条将其递增 一条将其保存回内存。因为这 3 条指令甚不是以原子方式（atomically）执行（所有的指令一一性执行）的，所以奇怪的事情可能会发生。知识点:原子操作,持久性操作系统中管理磁盘的软件通常称为文件系统（file system）。因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;int main(int argc, char *argv[]){ int fd = open(&quot;/tmp/file&quot;, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU); assert(fd &amp;gt; -1); int rc = write(fd, &quot;hello world\\n&quot;, 13); assert(rc == 13); close(fd); return 0;}为了完成这个任务，该程序向操作系统发出 3 个调用。第一个是对 open()的调用，它打开文件并创建它。第二个是 write()，将一些数据写入文件。第三个是 close()，只是简单地关闭文件，从而表明程序不会再向它写入更多的数据。这些系统调用（system call）被转到称为文件系统（file system）的操作系统部分，然后该系统处理这些请求，并向用户返回某种错误代码。首先确定新数据将驻留在磁盘上的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。这样做需要向底层存储设备发出 I/O 请求，以读取现有结构或更新（写入）它们。所有写过设备驱动程序（device driver）的人都知道，让设备现表你执行某项操作是一个复杂而详细的过程。它需要深入了解低级别设备接口及其确切的语义。幸运的是，操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS 有时被视为标准库（standard library）。出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志（journaling）或写时复制（copy-on-write），仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。为了使不同的通用操作更高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的 B 树。设计目标一个最基本的目标，是建立一些抽象（abstraction），让系统方便和易于使用。抽象对我们在计算机科学中做的每件事都很有帮助。抽象使得编写一个大型程序成为可能，将其划分为小而且容易理解的部分设计和实现操作系统的一个目标，是提供高性能（performance）。换言之，我们的目标是最小化操作系统的开销（minimize the overhead）。但是虚拟化的设计是为了易于使用，无形之中会增大开销，比如虚拟页的切换，cpu 的调度等等，所以尽可能的保持易用性与性能的平衡至关重要另一个目标是在应用程序之间以及在 OS 和应用程序之间提供保护（protection）。因为我们希望让许多程序同时运行，所以要确保一个程序的恶意或偶然的不良行为不会损害其他程序。保护是操作系统基本原理之一的核心，这就是隔离（isolation）。让进程彼此隔离是保护的关键，因此决定了 OS 必须执行的大部分任务操作系统也必须不间断运行。当它失效时，系统上运行的所有应用程序也会失效。由于这种依赖性，操作系统往往力求提供高度的可靠性（reliability）。参考 Operating Systems: Three Easy Pieces 中文版" }, { "title": "Makefile和SHELL中$及$$的区别", "url": "/posts/makefile-shell/", "categories": "技术", "tags": "Makefile, shell", "date": "2021-03-10 09:00:00 +0800", "snippet": "最近在看linux内核代码时看到在Makefile中用到了$$()的使用方式，虽然能猜到什么意思，但不知道使用方法和具体含义，于是查找资料，在此写一个总结SHELL中的$说明在shell中，$的一种用法是引用shell变量，执行脚本时，$引用的变量会被替换为相应的字符串。当然shell中$的用法远不止于此，此处就不多做展开，想要了解更多，可以阅读Linux Shell中’$’符号的N种用法Makefile中的$说明Makefile中的$用法和shell中的大体类似，只不过在Makefile中，$仅能用于引用Makefile声明的变量，无法引用shell的变量。这里要注意下，使用make命令执行Makefile时并不是shell环境，当执行到Makefile的某个操作时才会执行shell，例：checkstack: $(OBJDUMP) -d vmlinux $$(find . -name &#39;*.ko&#39;) | \\ $(PERL) $(src)/scripts/checkstack.pl $(CHECKSTACK_ARCH)kernelrelease: @echo &quot;$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))&quot;kernelversion: @echo $(KERNELVERSION) 注：makefile中对变量的引用需要使用$()这种带括号的方式，否则只会识别$后的一个字母只有执行对应的Makefile命令的shell语句时才会进入shell环境，每行命令独立，每行都是单独的shell，所以上一行定义的shell变量并不适用于下一行。当然如果是使用了\\来合并行就可以摆脱这个限制了，比如例子中的checkstack命令下的shell命令虽然是两行但在同一个shell环境中执行Makefile中的$$说明Makefile命令中的shell语句也并非直接用于shell环境，make会对该语句进行预处理，如果想要引用shell中的变量，就要使用$号来把Makefile变量转换成shell变量$$的用法就是把Makefile引用转化为shell引用，可以理解为此时的$是一个转义符，也可以理解为去掉一个$后直接带入shell脚本中例1LIST = one two threeall: for i in $(LIST); do \\ echo $i; \\ done通过make预处理后转化为shell:for i in one two three; do \\ echo ; \\ done# 输出为空本例中，$i和$(LIST)会被先当成Makefile变量，LIST变量在Makefile中有定义，被转换为了one two three，由于i变量未在Makefile中定义，所以转化为了空。例2LIST = one two threeall: for i in $(LIST); do \\ echo $$i; \\ done通过make预处理后转化为shell:for i in one two three; do \\ echo $i; \\ done# 输出为# one# two# three例2中，$$i命令被make翻译成了shell命令中的$i，此时shell脚本可以正常执行，输出正确结果例3help: @echo &#39; (default: $$(INSTALL_MOD_PATH)/lib/firmware)&#39;输出结果为： (default: $(INSTALL_MOD_PATH)/lib/firmware) 注：Makefile中的@符号表示该行shell命令不回显，否则执行时make会把转化后的shell脚本打印一遍 注：单引号在shell中表示不执行转义或引用，按照原样字符串输出，此处$(INSTALL_MOD_PATH)不会被理解为变量例3中，$$(INSTALL_MOD_PATH)被翻译成$(INSTALL_MOD_PATH)，但由于存在单引号，导致shell变量不会被引用例4VERSION = 3PATCHLEVEL = 10SUBLEVEL = 108EXTRAVERSION =# kernel 版本号，为四个版本号的组合KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)# 从shell环境变量中提取shell的执行环境CONFIG_SHELL := $(shell if [ -x &quot;$$BASH&quot; ]; then echo $$BASH; \\ else if [ -x /bin/bash ]; then echo /bin/bash; \\ else echo sh; fi ; fi)# 选取脚本的目录，如果KBUILD_SRC未定义，则选择$(CURDIR)，$(CURDIR)表示当前目录绝对路径srctree := $(if $(KBUILD_SRC),$(KBUILD_SRC),$(CURDIR))KBUILD_VERBOSE = 1# 是否在控制台回显，如果有@则不回显ifeq ($(KBUILD_VERBOSE),1) quiet = Q =else quiet=quiet_ Q = @endifversion: $(Q)echo &quot;$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))&quot; &amp;gt; $@转化后的shell为：echo &quot;3.10.108$(/bin/bash /root/repo/makefile_test/scripts/setlocalversion /root/repo/makefile_test)&quot; &amp;gt; version# 假定setlocalversion脚本存在，且会输出一个&#39;+&#39;号，输出结果为：# 3.10.108+# 该值会被写入version文件例4为比较实际的例子，选自linux kernel的makefile中，相关变量的注释已经添加，结合前三个例子应该很好理解总结Makefile中的$用于引用Makefile变量，shell中的$用于引用shell变量，Makefile中的$$用于把Makefile引用转化为shell引用参考 Makefile中$$使用" }, { "title": "VSCode远程SSH连接方法", "url": "/posts/vscode-ssh-remote/", "categories": "技术", "tags": "vscode, ssh", "date": "2021-03-01 09:00:00 +0800", "snippet": "安装Remote-SSH在商店搜索Remote-SSH，并安装如需要连接windows自带的wsl虚拟机，可以使用Remote-WSL插件修改配置文件 打开远程资源管理器标签 选择设置图标 编辑ssh config文件使用私钥登录使用ssh-keygen生成公私钥对: 私钥id_rsa放置在Windows(SSH客户端)的用户.ssh目录下 公钥id_rsa.pub放置在ssh服务器的.ssh目录下，Linux下需重命名为authorized_keys完成后可直接登录，无需输入密码SSH频繁断开问题连接成功后会发现SSH频繁断开，且速度很慢原因Windows自带openSSH版本较老，与Linux中的版本不兼容使用ssh -V查看版本:解决方法使用git中自带的openSSH编辑环境变量，将C:\\Program Files\\Git\\usr\\bin添加至Path环境变量，并置于上层重新查看版本号,如显示版本为新版，则设置成功C:\\Users\\huangjinkai&amp;gt;ssh -VOpenSSH_8.3p1, OpenSSL 1.1.1g 21 Apr 2020关闭所有VSCode窗口后，重新打开，可以发现SSH使用流畅，不会有掉线现象参考 【工程调试记录】vscode远程连接卡顿、频繁掉线的一个解决方法" }, { "title": "STL getline读入\r问题", "url": "/posts/cpp-stl-getline/", "categories": "技术", "tags": "stl, c++, getline", "date": "2021-02-25 09:00:00 +0800", "snippet": "getline说明std::getline (string) istream&amp;amp; getline (istream&amp;amp; is, string&amp;amp; str, char delim); istream&amp;amp; getline (istream&amp;amp; is, string&amp;amp; str);Get line from stream into stringExtracts characters from is and stores them into str until the delimitation character delim is found (or the newline character, ‘\\n’, for (2)). 读取到’\\n‘作为结束The extraction also stops if the end of file is reached in is or if some other error occurs during the input operation.If the delimiter is found, it is extracted and discarded (i.e. it is not stored and the next input operation will begin after it).Note that any content in str before the call is replaced by the newly extracted sequence.Each extracted character is appended to the string as if its member push_back was called.Parameters is - istream object from which characters are extracted. str - string object where the extracted line is stored.The contents in the string before the call (if any) are discarded and replaced by the extracted line. Return ValueThe same as parameter is.A call to this function may set any of the internal state flags of is if: flag error eofbit The end of the source of characters is reached during its operations. failbit The input obtained could not be interpreted as a valid textual representation of an object of this type. In this case, distr preserves the parameters and internal data it had before the call.Notice that some eofbit cases will also set failbit. badbit An error other than the above happened. (see ios_base::iostate for more info on these)Additionally, in any of these cases, if the appropriate flag has been set with is’s member function ios::exceptions, an exception of type ios_base::failure is thrown.出现的错误使用vscode编辑txt格式文件时，默认的换行符为CRLF，即\\r\\n，而getline的默认分隔符为\\n，导致\\r也被读入string，造成乱码参考 getline (string) - C++ Reference" }, { "title": "SOAP,WSDL,DSMR详解", "url": "/posts/soap-wsdl-dsmr/", "categories": "技术", "tags": "SOAP, WSDL, DSMR", "date": "2021-02-23 10:00:00 +0800", "snippet": "前置阅读： XML命名空间 Schema 教程前言SOAP是我们Web Service中很常见的一个协议，SOAP确定了一种通过XML实现跨语言、跨机器传输调用的协议，WSDL更像是所提供服务的一个规范、一个文档，本篇文章介绍梳理一下他们的规则与逻辑，更好的认识一下SOAP协议及WSDL描述文件。SOAP简单对象访问协议SOAP(Simple Object Access Protocol)简单对象访问协议是交换数据的一种规范，在Web Service中，交换带结构信息。可基于HTTP等协议，使用XML格式传输，抽象于语言实现、平台和硬件。即多语言包括PHP、Java、.Net均可支持。优点是跨语言，非常适合异步通信和针对松耦合的C/S，缺点是必须做很多运行时检查。相关概念 SOAP封装(envelop),定义了一个框架，描述消息中的内容是什么，是谁发送的，谁应当接受并处理。 SOAP编码规则(encoding rules),定义了一种序列化的机制，表示应用程序需要使用的数据类型的实例。 SOAP RPC表示(RPC representation)，定义了一个协定，用于表示远程过程调用和应答。 SOAP绑定(binding)，定义了SOAP使用哪种协议交换信息。使用HTTP/TCP/UDP协议都可以。基本结构示例：&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&amp;lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot; soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&amp;gt;     &amp;lt;soap:Header&amp;gt;      ...      ...    &amp;lt;/soap:Header&amp;gt;     &amp;lt;soap:Body&amp;gt;          ...          ...          &amp;lt;soap:Fault&amp;gt;            ...            ...          &amp;lt;/soap:Fault&amp;gt;    &amp;lt;/soap:Body&amp;gt;&amp;lt;/soap:Envelope&amp;gt;一条SOAP消息就是一个普通的XML文档，Envelope元素与Body元素（包含调用和响应信息）必须存在，Header元素（包含头部信息）和Fault元素（提供有关在处理此消息所发生的错误的信息）可以作为可选存在SOAP封装(envelop)SOAP消息的根元素，可把XML文档定义为SOAP消息命名空间xmlns：SOAP命名空间,固定不变。 在WSDL中，SOAP命名空间为http://www.w3.org/2003/05/soap-envelopeSOAP在默认命名空间中定义了3个属性：actor，mustUnderstand，encodingStyle。这些被定义在SOAP头部的属性可定义容器如何对SOAP消息进行处理。 在WSDL中主要用到了mustUnderstand属性 mustUnderstand属性——用于标识标题项对其进行处理的接受者来说是强制的还是可选的。（0可选1强制）soap:mustUnderstand=&quot;0/1&quot; actor属性可用于将Header元素寻址到一个特定的端点 soap:actor=&quot;URI&quot; encodingStyle属性用于定义在文档中使用的数据类型。此属性可出现在任何SOAP元素中，并会被应用到元素的内容及元素的所有子元素上。SOAP消息没有默认的编码方式。soap:encodingstyle=&quot;URI&quot;SOAP Header元素可选的SOAP Header元素可包含有关SOAP消息的应用程序专用信息。如果Header元素被提供，则它必须是Envelope元素的第一个子元素&amp;lt;soap:Header&amp;gt;   &amp;lt;m:Trans xmlns:m=&quot;http://www.w3schools.com/transaction/&quot; soap:mustUnderstand=&quot;1&quot;&amp;gt; &amp;lt;!-- mustUnderstand表示处理此头部的接受者必须认可此元素，假如此元素接受者无法认可此元素，则在处理此头部时必须失效 --&amp;gt; 234   &amp;lt;/m:Trans&amp;gt; &amp;lt;/soap:Heaser&amp;gt;SOAP Body元素必须的SOAP Body元素可包含打算传送到消息最终端点的实际SOAP消息。SOAP Body元素的直接子元素可以使合格的命名空间SOAP Fault元素用于存留SOAP消息的错误和状态消息，可选的SOAP Fault元素用于指示错误消息。如果已提供了Fault元素，则它必须是Body元素的子元素，在一条SOAP消息中，Fault元素只能出现一次。SOAP Fault子元素： 供识别障碍的代码 可供人阅读的有关障碍的说明 有关是谁引发故障的信息 存留涉及Body元素的应用程序的专用错误信息faultcode值描述： versionMismatch SOAP Envelope的无效命名空间被发现 mustUnderstand Header元素的一个直接子元素(mustUnderstand=”1′)无法被理解 Client 消息被不正确的构成，或包含不正确的信息 Server 服务器有问题，因此无法处理进行下去与Restful协议对比TODOWSDL网络服务描述语言WSDL(Web Services Description Language)网络服务描述语言，WSDL 是一种使用 XML 编写的文档。这种文档可描述某个 Web Service。文档的后缀名为一般为wsdl 官网：http://schemas.xmlsoap.org/wsdl/ WS-RT的WSDL描述：http://schemas.xmlsoap.org/ws/2006/08/resourceTransfer/wsrt.wsdl基本结构&amp;lt;definitions&amp;gt;    &amp;lt;types&amp;gt;       definition of types........    &amp;lt;/types&amp;gt;    &amp;lt;message&amp;gt;       definition of a message....    &amp;lt;/message&amp;gt;    &amp;lt;portType&amp;gt;       definition of a port.......    &amp;lt;/portType&amp;gt;    &amp;lt;binding&amp;gt;       definition of a binding....    &amp;lt;/binding&amp;gt;    &amp;lt;service&amp;gt;       definition of a service....    &amp;lt;/service&amp;gt;&amp;lt;/definitions&amp;gt;一个WSDL文档通常包含7个重要的元素，即types、import、message、portType、operation、binding、service元素。这些元素嵌套在definitions元素中，definitions是WSDL文档的根元素。实例以盛付通的一个接口为例，介绍一下整个wsdl描述文件，网址如下http://cardpay.shengpay.com/api-acquire-channel/services/receiveOrderService?wsdlDefinitionsWSDL文档中对于definitions的描述：&amp;lt;xs:element name=&quot;definitions&quot; type=&quot;wsdl:tDefinitions&quot; &amp;gt; &amp;lt;xs:key name=&quot;message&quot; &amp;gt; &amp;lt;xs:selector xpath=&quot;wsdl:message&quot; /&amp;gt; &amp;lt;xs:field xpath=&quot;@name&quot; /&amp;gt; &amp;lt;/xs:key&amp;gt; &amp;lt;xs:key name=&quot;portType&quot; &amp;gt; &amp;lt;xs:selector xpath=&quot;wsdl:portType&quot; /&amp;gt; &amp;lt;xs:field xpath=&quot;@name&quot; /&amp;gt; &amp;lt;/xs:key&amp;gt; &amp;lt;xs:key name=&quot;binding&quot; &amp;gt; &amp;lt;xs:selector xpath=&quot;wsdl:binding&quot; /&amp;gt; &amp;lt;xs:field xpath=&quot;@name&quot; /&amp;gt; &amp;lt;/xs:key&amp;gt; &amp;lt;xs:key name=&quot;service&quot; &amp;gt; &amp;lt;xs:selector xpath=&quot;wsdl:service&quot; /&amp;gt; &amp;lt;xs:field xpath=&quot;@name&quot; /&amp;gt; &amp;lt;/xs:key&amp;gt; &amp;lt;xs:key name=&quot;import&quot; &amp;gt; &amp;lt;xs:selector xpath=&quot;wsdl:import&quot; /&amp;gt; &amp;lt;xs:field xpath=&quot;@namespace&quot; /&amp;gt; &amp;lt;/xs:key&amp;gt;&amp;lt;/xs:element&amp;gt;Types数据类型定义的容器，它使用某种类型系统(一般地使用XML Schema中的类型系统)。&amp;lt;xs:element name=&quot;receB2COrderRequest&quot; type=&quot;tns:ReceB2COrderRequest&quot;/&amp;gt;  &amp;lt;xs:element name=&quot;receB2COrderResponse&quot; type=&quot;tns:ReceB2COrderResponse&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;ReceB2COrderRequest&quot;&amp;gt;     &amp;lt;xs:sequence&amp;gt;       &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;buyerContact&quot; type=&quot;xs:string&quot;/&amp;gt;        .......    &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt;   &amp;lt;xs:complexType name=&quot;receiveB2COrder&quot;&amp;gt;         &amp;lt;xs:sequence&amp;gt;           &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;arg0&quot; type=&quot;tns:ReceB2COrderRequest&quot;/&amp;gt;         &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt;  Message通信消息的数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构。&amp;lt;wsdl:message name=&quot;receiveB2COrder&quot;&amp;gt;     &amp;lt;wsdl:part element=&quot;tns:receiveB2COrder&quot; name=&quot;parameters&quot;/&amp;gt; &amp;lt;/wsdl:message&amp;gt; Operation &amp;amp; PortTypeOperation 对服务中所支持的操作的抽象描述，一般单个Operation描述了一个访问入口的请求/响应消息对。 PortType 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持。&amp;lt;wsdl:portType name=&quot;ReceiveOrderAPI&quot;&amp;gt;     &amp;lt;wsdl:operation name=&quot;receiveB2COrder&quot;&amp;gt;       &amp;lt;wsdl:input message=&quot;tns:receiveB2COrder&quot; name=&quot;receiveB2COrder&quot;/&amp;gt;        &amp;lt;wsdl:output message=&quot;tns:receiveB2COrderResponse&quot; name=&quot;receiveB2COrderResponse&quot;/&amp;gt;        &amp;lt;wsdl:fault message=&quot;tns:MasAPIException&quot; name=&quot;MasAPIException&quot;/&amp;gt;     &amp;lt;/wsdl:operation&amp;gt; &amp;lt;/wsdl:portType&amp;gt;  Binding特定端口类型的具体协议和数据格式规范的绑定。&amp;lt;wsdl:binding name=&quot;ReceiveOrderAPIExplorterServiceSoapBinding&quot; type=&quot;tns:ReceiveOrderAPI&quot;&amp;gt;     &amp;lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&amp;gt;      &amp;lt;wsdl:operation name=&quot;receiveB2COrder&quot;&amp;gt;       &amp;lt;soap:operation soapAction=&quot;&quot; style=&quot;document&quot;/&amp;gt;        &amp;lt;wsdl:input name=&quot;receiveB2COrder&quot;&amp;gt;         &amp;lt;soap:body use=&quot;literal&quot;/&amp;gt;       &amp;lt;/wsdl:input&amp;gt;        &amp;lt;wsdl:output name=&quot;receiveB2COrderResponse&quot;&amp;gt;         &amp;lt;soap:body use=&quot;literal&quot;/&amp;gt;       &amp;lt;/wsdl:output&amp;gt;        &amp;lt;wsdl:fault name=&quot;MasAPIException&quot;&amp;gt;         &amp;lt;soap:fault name=&quot;MasAPIException&quot; use=&quot;literal&quot;/&amp;gt;       &amp;lt;/wsdl:fault&amp;gt;     &amp;lt;/wsdl:operation&amp;gt; &amp;lt;/wsdl:binding&amp;gt;  Port&amp;amp;ServicePort 定义为协议/数据格式绑定与具体Web访问地址组合的单个服务访问点。 Service 相关服务访问点的集合。&amp;lt;wsdl:service name=&quot;ReceiveOrderAPIExplorterService&quot;&amp;gt;     &amp;lt;wsdl:port binding=&quot;tns:ReceiveOrderAPIExplorterServiceSoapBinding&quot; name=&quot;ReceiveOrderAPIExplorterPort&quot;&amp;gt;       &amp;lt;soap:address location=&quot;http://cardpay.shengpay.com/api-acquire-channel/services/receiveOrderService&quot;/&amp;gt;     &amp;lt;/wsdl:port&amp;gt; &amp;lt;/wsdl:service&amp;gt;WS-AddressingWeb服务寻址（WS-Addressing）是一个W3C推荐标准，为Web服务提供一种与传输层无关的，传送寻址信息的机制。规范主要由两部分组成：传送Web服务端点的引用的数据结构，以及一套能够在特定的消息上关联寻址信息的消息寻址属性。WS-Addressing是将消息路由数据包含在SOAP头中的一种标准方法。利用WS-Addressing的消息可以在标准化的SOAP头中包含自己的包含发送元数据，而不是依赖于网络层传输来传送路由信息。网络级传输只负责将消息发送到能够读取WS-Addressing元数据的分配器那里。一旦消息抵达了URI所制定的分配器，网络层传输的工作就完成了。通过在标准的SOAP头中(wsa:ReplyTo)指定应答消息应该发送到哪里的端点引用，WS-Addressing可以支持异步交互方式。 服务提供者使用另一个连接，将应答消息发送给wsa:ReplyTo所指定的端点。这就将SOAP请求/应答消息的交互与HTTP请求/应答协议分离，这样，跨越任意时间的长时间运行的交互成为可能。端点引用端点引用（Endpoint Reference，速写EPR）是一个XML结构，封装了对访问Web服务的消息寻址有用的信息。这包括了消息的目的地地址，任何其他路由消息到目的地所需的参数（称作引用参数），以及有关服务的任选的元数据（例如WSDL或WS-Policy）。消息寻址属性消息寻址属性表明与将消息传送到Web服务有关的寻址信息，包括： 目的地(To) – 该消息的目的地的URI。 源端点(From) – 发出该消息的服务端点（EPR） 应答端点(ReplyTo) – 应答消息接收者的端点（EPR） 故障端点(FaultTo) – 故障消息接收者的端点（EPR） 动作(Action) – 指示该消息的语义（可能有助于该消息的寻址）的URI 消息ID(MessageID) – 唯一消息标识符URI 关系(RelatesTo) – 与之前消息的关系(一对URI)DSMR示例Example “Delete” operation:&amp;lt;s:Envelope xmlns:s=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:p32=&quot;http://www.energiened.nl/Content/Publications/dsmr/P32&quot;&amp;gt; &amp;lt;s:Header&amp;gt; &amp;lt;wsa:To&amp;gt; http://10.0.1.2/services/Resources &amp;lt;/wsa:To&amp;gt; &amp;lt;wsa:Action s:mustUnderstand=&quot;true&quot;&amp;gt; http://schemas.xmlsoap.org/ws/2004/09/transfer/Delete &amp;lt;/wsa:Action&amp;gt; &amp;lt;wsa:MessageID&amp;gt; uuid:ddacc64d-c64d-1dac-acbc-017f00000001 &amp;lt;/wsa:MessageID&amp;gt; &amp;lt;p32:ResourceURI wsa:IsReferenceParameter=&quot;true&quot;&amp;gt; http://www.energiened.nl/Content/Publications/dsmr/P32/meterAccess &amp;lt;/p32:ResourceURI&amp;gt; &amp;lt;p32:SelectorSet&amp;gt; &amp;lt;p32:Selector Name=&quot;ResourceID&quot;&amp;gt;MeterAccess-1&amp;lt;/p32:Selector&amp;gt; &amp;lt;/p32:SelectorSet&amp;gt; &amp;lt;/s:Header&amp;gt; &amp;lt;s:Body&amp;gt; &amp;lt;DeleteRequest xmlns=&quot;http://schemas.xmlsoap.org/ws/2004/09/transfer&quot;/&amp;gt; &amp;lt;/s:Body&amp;gt;&amp;lt;/s:Envelope&amp;gt;Example “Delete” response:&amp;lt;s:Envelope xmlns:s=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot;&amp;gt; &amp;lt;s:Header&amp;gt; &amp;lt;wsa:ReplyTo&amp;gt; &amp;lt;wsa:Address&amp;gt; http://www.w3.org/2005/08/addressing/anonymous &amp;lt;/wsa:Address&amp;gt; &amp;lt;/wsa:ReplyTo&amp;gt; &amp;lt;wsa:From&amp;gt; &amp;lt;wsa:Address&amp;gt; http://10.0.1.2/services/Resources &amp;lt;/wsa:Address&amp;gt; &amp;lt;wsa:ReferenceParameters/&amp;gt; &amp;lt;/wsa:From&amp;gt; &amp;lt;wsa:MessageID&amp;gt; uuid:C986EEAA-484B-4b94-AB46-743EE560B5F9 &amp;lt;/wsa:MessageID&amp;gt; &amp;lt;wsa:Action&amp;gt; http://schemas.xmlsoap.org/ws/2004/09/transfer/DeleteResponse &amp;lt;/wsa:Action&amp;gt; &amp;lt;wsa:RelatesTo wsa:RelationshipType=&quot;wsa:Reply&quot;&amp;gt; uuid:ddacc64d-c64d-1dac-acbc-017f00000001 &amp;lt;/wsa:RelatesTo&amp;gt; &amp;lt;/s:Header&amp;gt; &amp;lt;s:Body&amp;gt; &amp;lt;DeleteResponse xmlns=&quot;http://schemas.xmlsoap.org/ws/2004/09/transfer&quot;/&amp;gt; &amp;lt;/s:Body&amp;gt;&amp;lt;/s:Envelope&amp;gt;WS-RT (Web Services Resource Transfer)This specification defines extensions to WS-Transfer primarily to provide fragment-based access to resources.WS-RT是WS-Transfer的扩展，主要用于基于片段的资源的访问 官网：https://www.w3.org/TR/2010/NOTE-ws-resource-transfer-20100713/ 协议：http://schemas.xmlsoap.org/ws/2006/08/resourceTransfer/介绍This specification is intended to form an essential core component of a unified resource access protocol for the Web services space.The operations described in this specification constitute an extension to the WS-Transfer specification, which defines standard messages for controlling resources using the familiar paradigms of “get”, “put”, “create”, and “delete”. The extensions deal primarily with fragment-based access to resources.This document constitutes WS-ResourceTransfer, hereafter referred to as WS-RT.主要用于资源传输，定义了”get”, “put”, “create”, “delete“四个方法，类似于HTTP请求，包含了WSDL的说明更多内容详见官网WS-Transfer (Web Services Transfer) 官网：https://www.w3.org/Submission/WS-Transfer/ 协议：http://schemas.xmlsoap.org/ws/2004/09/transfer/介绍与WS-RT类似，不再过多介绍DSMRDSMR协议是由荷兰Energie-Nederland协会编写的能源管理与通信标准，以下是Energie-Nederland协会的简介： Energie-Nederland is de branchevereniging voor alle partijen die stroom, gas en warmte produceren, leveren en verhandelen. Samen vertegenwoordigen wij circa 80% van de markt. Onze ruim 60 leden zijn actief in zowel ‘groene’ als ‘grijze’ energie en allerlei soorten dienstverlening. Onder hen zijn ook veel nieuwkomers op de markt, innovatieve spelers en duurzame initiatieven. Energie-Nederland gaat voor een duurzame, betrouwbare en betaalbare energievoorziening; wij zijn een van de trekkers van het Klimaatakkoord.简介是荷兰语的，我也看不懂，只能找Google机翻一下： Energie-Nederland是所有生产，供应和贸易电，气和热的各方的贸易协会。 我们共同代表了约80％的市场。 我们的60多个成员活跃于“绿色”和“灰色”能源以及各种服务中。 他们还包括许多新进入市场的人，创新参与者和可持续发展倡议。 Energie-Nederland致力于可持续，可靠和负担得起的能源供应； 我们是《气候协定》的发起人之一。ScopeThis part provides a companion standard for an Automatic Meter Reading (AMR) system for electricity thermal, (heat &amp;amp; cold), gas and water meters.The scope of this standard is on: Residential electricity meters Residential thermal (heat &amp;amp; cold) meters Residential gas meters and gas valve Residential water metersThis companion standard focuses on the P3 interface for Electricity meters.System architectureThe P3.2 interface is introduced because a Data Concentrator (DC) can be placed between the CS and the meter(s). With this, the DC divides P3 into two parts, P3.1 and P3.2. However since P3 and P3.1 are functionally the same these terms are interchangeable. Where P3 is mentioned this can also be read as P3.1 (when a DC is involved). Where P3.2 is mentioned this deals exclusively with the interface between the CS and the DC. Where gas meters are mentioned this could also be replaced with thermal and water meters.The communication interface P3 and P3.1 (see figure 1.2) is based on the DLMS/COSEM standard. Communication interface P3.2 is based on Web Services standards compliant with WS-I Basic Profile 1.1 or WS-I Basic Profile 1.2.P3和P3.1基于DLMS/COSEM标准，P3.2基于Web Services标准，符合WS-I Basic Profile 1.1或WS-I Basic Profile 1.2。 本文主要介绍P3.2部分DSMR协议中的Resource TransferDSMR中的Resource Transfer符合WS-ResourceTransfer规范，WS-ResourceTransfer是WS-Transfer的扩展。WS-Transfer定义了Get，Put，Create和Delete资源表示形式的操作，而WS-ResourceTransfer扩展了这些操作，以增加对资源表示片段进行操作的能力。GetWS-Transfer Get操作用于整体检索现有资源表示。 WS-ResourceTransfer扩展了Get操作，以检索现有表示的片段。 可以返回其完整表示形式的资源还必须支持wxf:Get(即WS-Transfer Get操作)，而无需使用WS-ResourceTransfer扩展即可返回整个资源表示形式。wsrt:Get的[Body]包含一个标识目标片段的表达式。 按照我的理解，Get操作与HTTP中的GET请求类似，是通过UUID获取资源wsrt:Get的概述是：[Headers] &amp;lt;wsrt:ResourceTransfer s:mustUnderstand=&quot;true&quot;? /&amp;gt;[Action] http://schemas.xmlsoap.org/ws/2004/09/transfer/Get[Body] &amp;lt;wsrt:Get Dialect=&quot;xs:anyURI&quot;?&amp;gt; . &amp;lt;wsrt:Expression ...&amp;gt;xs:any&amp;lt;/wsrt:Expression&amp;gt; * &amp;lt;/wsrt:Get&amp;gt;PutWS-Transfer Put 操作用于通过提供替换XML表示(XML representation)来更新现有资源表示。 WS-ResourceTransfer扩展了 Put 操作，通过提供XML表示的片段(fragments of the XML representation)来更新现有资源表示。 可以更新其完整表示形式的资源还必须支持wxf:Put(即WS-Transfer Put操作)以更新整个资源表示形式，而无需使用WS-ResourceTransfer扩展。 按照我的理解，Put操作是SET操作Put操作的概括为：[Headers] &amp;lt;wsrt:ResourceTransfer s:mustUnderstand=&quot;true&quot;/&amp;gt;[Action] http://schemas.xmlsoap.org/ws/2004/09/transfer/Put[Body] &amp;lt;wsrt:Put Dialect=&quot;xs:anyURI&quot;?&amp;gt; &amp;lt;wsrt:Fragment Mode=&quot;xs:anyURI&quot;&amp;gt; &amp;lt;wsrt:Expression&amp;gt;xs:any&amp;lt;/wsrt:Expression&amp;gt; ? &amp;lt;wsrt:Value ...&amp;gt;xs:any&amp;lt;/wsrt:Value&amp;gt; ? &amp;lt;/wsrt:Fragment&amp;gt; + &amp;lt;/wsrt:Put&amp;gt;CreateWS-Transfer Create操作用于通过初始表示(initial representation)来创建资源。 接收到Create请求的资源工厂将分配一个新资源，该资源根据显示的表示(presented representation)进行了初始化。 将为新资源分配工厂服务(factory-service-determined)确定的端点引用，该端点引用在响应消息中返回。 在许多情况下，创建资源所需的信息可能与初始表示（通过随后的Get操作实现的值）明显不同，并且提供初始表示是不可行的。WS-ResourceTransfer扩展了Create操作，以从零个或多个指定的XML表示形式的片段中创建资源。 WS-ResourceTransfer进一步扩展了Create操作，从而可以在资源创建过程中创建任何资源元数据。 按照我的理解，Create操作是开辟资源存储的空间，创建资源对应的UUID，等待之后填充或获取Create操作的扩展概要为：[Headers] &amp;lt;wsrt:ResourceTransfer s:mustUnderstand=&quot;true&quot;/&amp;gt;[Action] http://schemas.xmlsoap.org/ws/2004/09/transfer/Create[Body] &amp;lt;wsrt:Create Dialect=&quot;xs:anyURI&quot;?&amp;gt; &amp;lt;wsmex:Metadata&amp;gt;resource metadata&amp;lt;/wsmex:Metadata&amp;gt; ? &amp;lt;wsrt:Fragment&amp;gt; &amp;lt;wsrt:Expression&amp;gt;xs:any&amp;lt;/wsrt:Expression&amp;gt; ? &amp;lt;wsrt:Value ...&amp;gt;xs:any&amp;lt;/wsrt:Value&amp;gt; &amp;lt;/wsrt:Fragment&amp;gt; * &amp;lt;/wsrt:Create&amp;gt;DeleteWS-Transfer Delete操作用于整体删除资源。 WSResourceTransfer没有单独定义或扩展WS-Transfer中的Delete操作，而是直接使用WS-Transfer定义的Delete。 按照我的理解，Delete操作与Create对应，为删除资源并释放空间Delete请求消息必须采用以下格式：&amp;lt;s:Envelope …&amp;gt; &amp;lt;s:Header …&amp;gt; &amp;lt;wsa:Action&amp;gt; http://schemas.xmlsoap.org/ws/2004/09/transfer/Delete &amp;lt;/wsa:Action&amp;gt; &amp;lt;wsa:MessageID&amp;gt;xs:anyURI&amp;lt;/wsa:MessageID&amp;gt; &amp;lt;wsa:To&amp;gt;xs:anyURI&amp;lt;/wsa:To&amp;gt; … &amp;lt;/s:Header&amp;gt; &amp;lt;s:Body … /&amp;gt;&amp;lt;/s:Envelope&amp;gt;示例本部分包含WS-RTGet，Put，Create和Delete操作的示例。 这些示例旨在举例说明MeterAccess资源的基本WS-RT操作。 MeterAccess资源是用于访问仪表对象的资源。 出于本示例的目的，MeterAccess资源模型访问单个能量寄存器COSEM对象。 表1显示了激活并填充结果后的MeterAccess资源。Web Service 安全原文： Security for Data Concentrator requires protection against attacks on the P3.2 Interface with providing Confidentiality, Integrity and Authentication for the services provided with Web Services. Authentication is required for communicating parties. WS-I Basic Profile 1.1 and 1.2 adopt HTTP secured with TLS 1.0 or SSL 3.0 (HTTPS) for security of Web Services. HTTPS is transport level of security and provides mature and most widely used standard for secured connections for HTTP based transports. Higher levels of Web Services Security defined with WS-Security are out of the scope of this specificationData Concentrator的安全性要求为Web服务提供的服务提供机密性，完整性和身份验证，以防止P3.2接口受到攻击。 通信方需要身份验证。WS-I基本配置文件1.1和1.2采用HTTP协议，该协议受TLS 1.0或SSL 3.0(HTTPS)保护，以确保Web服务的安全。 HTTPS是传输的安全级别，它为基于HTTP的传输的安全连接提供了成熟且使用最广泛的标准。用WS-Security定义的更高级别的Web服务安全性不在本规范范围内附录1：P3.2 XML Schema&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:wsa=&quot;http://schemas.xmlsoap.org/ws/2004/08/addressing&quot; elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&amp;gt; &amp;lt;xs:import namespace=&quot;http://schemas.xmlsoap.org/ws/2004/08/addressing&quot; schemaLocation=&quot;http://schemas.xmlsoap.org/ws/2004/08/addressing&quot;/&amp;gt; &amp;lt;xs:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; schemaLocation=&quot;http://www.w3.org/2001/xml.xsd&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;attributableURI&quot;&amp;gt; &amp;lt;xs:simpleContent&amp;gt; &amp;lt;xs:extension base=&quot;xs:anyURI&quot;&amp;gt; &amp;lt;xs:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&amp;gt; &amp;lt;/xs:extension&amp;gt; &amp;lt;/xs:simpleContent&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&quot;ResourceURI&quot; type=&quot;attributableURI&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;SelectorType&quot; mixed=&quot;true&quot;&amp;gt; &amp;lt;xs:annotation&amp;gt; &amp;lt;xs:documentation&amp;gt;Instances of this type can be only simple types or EPRs, not arbitrary mixed data.&amp;lt;/xs:documentation&amp;gt; &amp;lt;/xs:annotation&amp;gt; &amp;lt;xs:complexContent mixed=&quot;true&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:anyType&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element ref=&quot;wsa:EndpointReference&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:attribute name=&quot;Name&quot; type=&quot;xs:NCName&quot; use=&quot;required&quot;/&amp;gt; &amp;lt;xs:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:complexContent&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&quot;Selector&quot; type=&quot;SelectorType&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;SelectorSetType&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element ref=&quot;Selector&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;attributableAny&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ResourceURI&quot; type=&quot;xs:anyURI&quot;/&amp;gt; &amp;lt;xs:element name=&quot;SelectorSet&quot; type=&quot;SelectorSetType&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ResourceEventResult&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;ResourceEventType&quot;&amp;gt; &amp;lt;xs:complexContent&amp;gt; &amp;lt;xs:extension base=&quot;attributableAny&quot;/&amp;gt; &amp;lt;/xs:complexContent&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&quot;ResourceEvent&quot; type=&quot;ResourceEventType&quot;/&amp;gt; &amp;lt;xs:simpleType name=&quot;bitString&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;octetString&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:complexType name=&quot;NULL&quot; final=&quot;#all&quot;/&amp;gt; &amp;lt;xs:simpleType name=&quot;ISO646String&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:token&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;visibleString&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;ISO646String&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Integer8&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:byte&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Integer16&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:short&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Integer32&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:int&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Integer64&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:long&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Unsigned8&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:unsignedByte&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Unsigned16&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:unsignedShort&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Unsigned32&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:unsignedInt&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;Unsigned64&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;xs:unsignedLong&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;actionResult&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&quot;dataAccessResult&quot;&amp;gt; &amp;lt;xs:restriction base=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:complexType name=&quot;typeDescription&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;N&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;A&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;NumberOfElements&quot; type=&quot;Unsigned16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;TypeDescription&quot; type=&quot;typeDescription&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;S&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&amp;gt; &amp;lt;xs:element name=&quot;TypeDescription&quot; type=&quot;typeDescription&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;B&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;BS&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DL&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DLU&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;FP&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;OS&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;VS&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;BCD&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;I&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;L&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;U&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;LU&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;L64&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;L64U&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;E&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;F32&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;F64&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DT&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;D&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;T&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DC&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;sequenceOfData&quot;&amp;gt; &amp;lt;xs:choice maxOccurs=&quot;unbounded&quot;&amp;gt; &amp;lt;xs:element name=&quot;N&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;A&quot; type=&quot;sequenceOfData&quot;/&amp;gt; &amp;lt;xs:element name=&quot;S&quot; type=&quot;sequenceOfData&quot;/&amp;gt; &amp;lt;xs:element name=&quot;B&quot; type=&quot;xs:boolean&quot;/&amp;gt; &amp;lt;xs:element name=&quot;BS&quot; type=&quot;bitString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DL&quot; type=&quot;Integer32&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DLU&quot; type=&quot;Unsigned32&quot;/&amp;gt; &amp;lt;xs:element name=&quot;FP&quot; type=&quot;xs:float&quot;/&amp;gt; &amp;lt;xs:element name=&quot;OS&quot; type=&quot;octetString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;VS&quot; type=&quot;visibleString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;BCD&quot; type=&quot;Integer8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;I&quot; type=&quot;Integer8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;L&quot; type=&quot;Integer16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;U&quot; type=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;LU&quot; type=&quot;Unsigned16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;CA&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ContentsDescription&quot; type=&quot;typeDescription&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ArrayContents&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;L64&quot; type=&quot;Integer64&quot;/&amp;gt; &amp;lt;xs:element name=&quot;L64U&quot; type=&quot;Unsigned64&quot;/&amp;gt; &amp;lt;xs:element name=&quot;E&quot; type=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;F32&quot; type=&quot;xs:float&quot;/&amp;gt; &amp;lt;xs:element name=&quot;F64&quot; type=&quot;xs:double&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DT&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;xs:element name=&quot;D&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;xs:element name=&quot;T&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DC&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;data&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;N&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;xs:element name=&quot;A&quot; type=&quot;sequenceOfData&quot;/&amp;gt; &amp;lt;xs:element name=&quot;S&quot; type=&quot;sequenceOfData&quot;/&amp;gt; &amp;lt;xs:element name=&quot;B&quot; type=&quot;xs:boolean&quot;/&amp;gt; &amp;lt;xs:element name=&quot;BS&quot; type=&quot;bitString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DL&quot; type=&quot;Integer32&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DLU&quot; type=&quot;Unsigned32&quot;/&amp;gt; &amp;lt;xs:element name=&quot;FP&quot; type=&quot;xs:float&quot;/&amp;gt; &amp;lt;xs:element name=&quot;OS&quot; type=&quot;octetString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;VS&quot; type=&quot;visibleString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;BCD&quot; type=&quot;Integer8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;I&quot; type=&quot;Integer8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;L&quot; type=&quot;Integer16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;U&quot; type=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;LU&quot; type=&quot;Unsigned16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;CA&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ContentsDescription&quot; type=&quot;typeDescription&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ArrayContents&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;L64&quot; type=&quot;Integer64&quot;/&amp;gt; &amp;lt;xs:element name=&quot;L64U&quot; type=&quot;Unsigned64&quot;/&amp;gt; &amp;lt;xs:element name=&quot;E&quot; type=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;F32&quot; type=&quot;xs:float&quot;/&amp;gt; &amp;lt;xs:element name=&quot;F64&quot; type=&quot;xs:double&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DT&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;xs:element name=&quot;D&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;xs:element name=&quot;T&quot; type=&quot;xs:hexBinary&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DC&quot; type=&quot;NULL&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;actionAccessResult&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;Result&quot; type=&quot;actionResult&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ReturnParameters&quot; type=&quot;dataAccessResult&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;setAccessResult&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;Result&quot; type=&quot;dataAccessResult&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;getAccessResult&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;Data&quot; type=&quot;data&quot;/&amp;gt; &amp;lt;xs:element name=&quot;DataAccessResult&quot; type=&quot;dataAccessResult&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;imageTransferResult&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;Result&quot; type=&quot;xs:boolean&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ImageTransferStatus&quot; type=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;cosemAccessResult&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;GetAccessResult&quot; type=&quot;getAccessResult&quot;/&amp;gt; &amp;lt;xs:element name=&quot;SetAccessResult&quot; type=&quot;setAccessResult&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ActionAccessResult&quot; type=&quot;actionAccessResult&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ImageTransferResult&quot; type=&quot;imageTransferResult&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;selectiveAccessDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;AccessSelector&quot; type=&quot;Unsigned8&quot;/&amp;gt; &amp;lt;xs:element name=&quot;AccessParameters&quot; type=&quot;data&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;getAccessDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;CosemAttributeDescriptor&quot; type=&quot;cosemAttributeDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;AccessSelection&quot; type=&quot;selectiveAccessDescriptor&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;setAccessDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;CosemAttributeDescriptor&quot; type=&quot;cosemAttributeDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;AccessSelection&quot; type=&quot;selectiveAccessDescriptor&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Value&quot; type=&quot;data&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;actionAccessDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;CosemMethodDescriptor&quot; type=&quot;cosemMethodDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;MethodInvocationParameters&quot; type=&quot;data&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;imageTransferDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ImageReference&quot; type=&quot;imageReference&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ImageTransferObjectReference&quot; type=&quot;cosemObjectReference&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ImageTransferSchedule&quot; type=&quot;imageTransferSchedule&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;cosemMethodDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ClassId&quot; type=&quot;Unsigned16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;InstanceId&quot; type=&quot;octetString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;MethodId&quot; type=&quot;Integer8&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;cosemAttributeDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ClassId&quot; type=&quot;Unsigned16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;InstanceId&quot; type=&quot;octetString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;AttributeId&quot; type=&quot;Integer8&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;cosemObjectReference&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ClassId&quot; type=&quot;Unsigned16&quot;/&amp;gt; &amp;lt;xs:element name=&quot;InstanceId&quot; type=&quot;octetString&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;imageReference&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ImageIdentifier&quot; type=&quot;octetString&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ImageLocation&quot; type=&quot;xs:anyURI&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;imageTransferSchedule&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;Activation&quot; type=&quot;xs:dateTime&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ImageActivationObjectReference&quot; type=&quot;cosemObjectReference&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;cosemAccessDesciptor&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;GetAccessDescriptor&quot; type=&quot;getAccessDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;SetAccessDescriptor&quot; type=&quot;setAccessDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ActionAccessDescriptor&quot; type=&quot;actionAccessDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ImageTransferDescriptor&quot; type=&quot;imageTransferDescriptor&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;cosemAccess&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;CosemAccessDescriptor&quot; type=&quot;cosemAccessDesciptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;CosemAccessResult&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:complexContent&amp;gt; &amp;lt;xs:extension base=&quot;cosemAccessResult&quot;&amp;gt; &amp;lt;xs:attribute name=&quot;MeterID&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:attribute name=&quot;Activated&quot; type=&quot;xs:dateTime&quot;/&amp;gt; &amp;lt;/xs:extension&amp;gt; &amp;lt;/xs:complexContent&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;meterReference&quot;&amp;gt; &amp;lt;xs:attribute name=&quot;MeterID&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;meterAccess&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;MeterReferenceList&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;MeterReference&quot; type=&quot;meterReference&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;CosemAccessList&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;CosemAccess&quot; type=&quot;cosemAccess&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;Activates&quot; type=&quot;xs:dateTime&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Expires&quot; type=&quot;xs:dateTime&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Created&quot; type=&quot;xs:dateTime&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Updated&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;packageTransferResult&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;Result&quot; type=&quot;xs:boolean&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;packageTransferDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;PackageReference&quot; type=&quot;packageReference&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;keyValueType&quot;&amp;gt; &amp;lt;xs:simpleContent&amp;gt; &amp;lt;xs:extension base=&quot;xs:base64Binary&quot;/&amp;gt; &amp;lt;/xs:simpleContent&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;keyContextType&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:any namespace=&quot;##any&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:attribute name=&quot;Name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;meterSecurityKey&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;KeyValue&quot; type=&quot;keyValueType&quot;/&amp;gt; &amp;lt;xs:element name=&quot;KeyContext&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:attribute name=&quot;KeyIdent&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&amp;gt; &amp;lt;xs:attribute name=&quot;KeyType&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;meterSecurityTransferDescriptor&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;MeterReference&quot; type=&quot;meterReference&quot;/&amp;gt; &amp;lt;xs:element name=&quot;MeterSecurityKey&quot; type=&quot;meterSecurityKey&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;securityTransferResult&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;Result&quot; type=&quot;xs:boolean&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;securityTransferDescriptor&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;MeterSecurityTransferDescriptor&quot; type=&quot;meterSecurityTransferDescriptor&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;packageReference&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;PackageIdentifier&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element name=&quot;PackageLocation&quot; type=&quot;xs:anyURI&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;serviceAccessDescriptor&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;PackageTransferDescriptor&quot; type=&quot;packageTransferDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;SecurityTransferDescriptor&quot; type=&quot;securityTransferDescriptor&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;serviceAccessResult&quot;&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&quot;PackageTransferResult&quot; type=&quot;packageTransferResult&quot;/&amp;gt; &amp;lt;xs:element name=&quot;SecurityTransferResult&quot; type=&quot;securityTransferResult&quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;serviceAccess&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ServiceAccessDescriptor&quot; type=&quot;serviceAccessDescriptor&quot;/&amp;gt; &amp;lt;xs:element name=&quot;ServiceAccessResult&quot; type=&quot;serviceAccessResult&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;concentratorServiceAccess&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ServiceAccessList&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ServiceAccess&quot; type=&quot;serviceAccess&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;Activates&quot; type=&quot;xs:dateTime&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Expires&quot; type=&quot;xs:dateTime&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Created&quot; type=&quot;xs:dateTime&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Updated&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;eventLogEntry&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;EventSource&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:simpleContent&amp;gt; &amp;lt;xs:extension base=&quot;xs:string&quot;&amp;gt; &amp;lt;xs:attribute name=&quot;Name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&amp;gt; &amp;lt;xs:attribute name=&quot;Ident&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&amp;gt; &amp;lt;/xs:extension&amp;gt; &amp;lt;/xs:simpleContent&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;EventIdent&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element name=&quot;EventLevel&quot; type=&quot;xs:short&quot;/&amp;gt; &amp;lt;xs:element name=&quot;EventDateTime&quot; type=&quot;xs:dateTime&quot;/&amp;gt; &amp;lt;xs:element name=&quot;EventDetail&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;eventLog&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;EventLogEntry&quot; type=&quot;eventLogEntry&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;concentratorStatus&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;Ident&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Status&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;metersDirectory&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;RegisteredMetersList&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence maxOccurs=&quot;unbounded&quot;&amp;gt; &amp;lt;xs:element name=&quot;RegisteredMeter&quot; type=&quot;meterReference&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;RevokedMetersList&quot; minOccurs=&quot;0&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence maxOccurs=&quot;unbounded&quot;&amp;gt; &amp;lt;xs:element name=&quot;RevokedMeter&quot; type=&quot;meterReference&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;AllowedMetersList&quot; minOccurs=&quot;0&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence maxOccurs=&quot;unbounded&quot;&amp;gt; &amp;lt;xs:element name=&quot;AllowedMeter&quot; type=&quot;meterReference&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&quot;MeterAccess&quot; type=&quot;meterAccess&quot;&amp;gt; &amp;lt;xs:annotation&amp;gt; &amp;lt;xs:documentation&amp;gt;MeterAccess provides access to Meters registered on the Concentrator&amp;lt;/xs:documentation&amp;gt; &amp;lt;/xs:annotation&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;MetersDirectory&quot; type=&quot;metersDirectory&quot;&amp;gt; &amp;lt;xs:annotation&amp;gt; &amp;lt;xs:documentation&amp;gt;MetersDirectory provides acecss to Directory of Meters registered on the Concentrator&amp;lt;/xs:documentation&amp;gt; &amp;lt;/xs:annotation&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;ConcentratorAccess&quot;&amp;gt; &amp;lt;xs:annotation&amp;gt; &amp;lt;xs:documentation&amp;gt;ConcentratorAccess provides access to services of the Concentrator&amp;lt;/xs:documentation&amp;gt; &amp;lt;/xs:annotation&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ConcentratorService&quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&quot;ConcentratorServiceAccess&quot; type=&quot;concentratorServiceAccess&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&quot;EventLog&quot; type=&quot;eventLog&quot;/&amp;gt; &amp;lt;xs:element name=&quot;Status&quot; type=&quot;concentratorStatus&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt;&amp;lt;/xs:schema&amp;gt;附录2：盛付通接口实例&amp;lt;wsdl:definitions xmlns:ns1=&quot;http://schemas.xmlsoap.org/soap/http&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; xmlns:tns=&quot;http://www.sdo.com/mas/api/receive/&quot; xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; name=&quot;ReceiveOrderAPIExplorterService&quot; targetNamespace=&quot;http://www.sdo.com/mas/api/receive/&quot;&amp;gt; &amp;lt;wsdl:types&amp;gt; &amp;lt;xs:schema xmlns:tns=&quot;http://www.sdo.com/mas/api/receive/&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;unqualified&quot; targetNamespace=&quot;http://www.sdo.com/mas/api/receive/&quot;&amp;gt; &amp;lt;xs:element name=&quot;receB2COrderRequest&quot; type=&quot;tns:ReceB2COrderRequest&quot;/&amp;gt; &amp;lt;xs:element name=&quot;receB2COrderResponse&quot; type=&quot;tns:ReceB2COrderResponse&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;ReceB2COrderRequest&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;buyerContact&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;buyerId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;buyerIp&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;buyerName&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;cardPayInfo&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;cardValue&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;currency&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;depositId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;depositIdType&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;expireTime&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;extension&quot; type=&quot;tns:extension&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;header&quot; type=&quot;tns:header&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;instCode&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;language&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;notifyUrl&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;orderAmount&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;orderNo&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;orderTime&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;pageUrl&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;payChannel&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;payType&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;payeeId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;payerAuthTicket&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;payerId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;payerMobileNo&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;productDesc&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;productId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;productName&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;productNum&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;productUrl&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;sellerId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;signature&quot; type=&quot;tns:signature&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;terminalType&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;unitPrice&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;extension&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;ext1&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;ext2&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;ext3&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;header&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;charset&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;sendTime&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;sender&quot; type=&quot;tns:sender&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;service&quot; type=&quot;tns:service&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;traceNo&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;sender&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;senderId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;service&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;serviceCode&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;version&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;signature&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;signMsg&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;signType&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;ReceB2COrderResponse&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;customerLogoUrl&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;customerName&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;customerNo&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;extension&quot; type=&quot;tns:extension&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;header&quot; type=&quot;tns:header&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;orderAmount&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;orderNo&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;orderType&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;returnInfo&quot; type=&quot;tns:returnInfo&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;sessionId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;signature&quot; type=&quot;tns:signature&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;tokenId&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;transNo&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;transStatus&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;transTime&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&quot;returnInfo&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;errorCode&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;errorMsg&quot; type=&quot;xs:string&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&quot;MasAPIException&quot; type=&quot;tns:MasAPIException&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;MasAPIException&quot;&amp;gt; &amp;lt;xs:sequence/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&quot;receiveB2COrder&quot; type=&quot;tns:receiveB2COrder&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;receiveB2COrder&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;arg0&quot; type=&quot;tns:ReceB2COrderRequest&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&quot;receiveB2COrderResponse&quot; type=&quot;tns:receiveB2COrderResponse&quot;/&amp;gt; &amp;lt;xs:complexType name=&quot;receiveB2COrderResponse&quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element minOccurs=&quot;0&quot; name=&quot;return&quot; type=&quot;tns:ReceB2COrderResponse&quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:schema&amp;gt; &amp;lt;/wsdl:types&amp;gt; &amp;lt;wsdl:message name=&quot;receiveB2COrder&quot;&amp;gt; &amp;lt;wsdl:part element=&quot;tns:receiveB2COrder&quot; name=&quot;parameters&quot;&amp;gt;&amp;lt;/wsdl:part&amp;gt; &amp;lt;/wsdl:message&amp;gt; &amp;lt;wsdl:message name=&quot;receiveB2COrderResponse&quot;&amp;gt; &amp;lt;wsdl:part element=&quot;tns:receiveB2COrderResponse&quot; name=&quot;parameters&quot;&amp;gt;&amp;lt;/wsdl:part&amp;gt; &amp;lt;/wsdl:message&amp;gt; &amp;lt;wsdl:message name=&quot;MasAPIException&quot;&amp;gt; &amp;lt;wsdl:part element=&quot;tns:MasAPIException&quot; name=&quot;MasAPIException&quot;&amp;gt;&amp;lt;/wsdl:part&amp;gt; &amp;lt;/wsdl:message&amp;gt; &amp;lt;wsdl:portType name=&quot;ReceiveOrderAPI&quot;&amp;gt; &amp;lt;wsdl:operation name=&quot;receiveB2COrder&quot;&amp;gt; &amp;lt;wsdl:input message=&quot;tns:receiveB2COrder&quot; name=&quot;receiveB2COrder&quot;&amp;gt;&amp;lt;/wsdl:input&amp;gt; &amp;lt;wsdl:output message=&quot;tns:receiveB2COrderResponse&quot; name=&quot;receiveB2COrderResponse&quot;&amp;gt;&amp;lt;/wsdl:output&amp;gt; &amp;lt;wsdl:fault message=&quot;tns:MasAPIException&quot; name=&quot;MasAPIException&quot;&amp;gt;&amp;lt;/wsdl:fault&amp;gt; &amp;lt;/wsdl:operation&amp;gt; &amp;lt;/wsdl:portType&amp;gt; &amp;lt;wsdl:binding name=&quot;ReceiveOrderAPIExplorterServiceSoapBinding&quot; type=&quot;tns:ReceiveOrderAPI&quot;&amp;gt; &amp;lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&amp;gt; &amp;lt;wsdl:operation name=&quot;receiveB2COrder&quot;&amp;gt; &amp;lt;soap:operation soapAction=&quot;&quot; style=&quot;document&quot;/&amp;gt; &amp;lt;wsdl:input name=&quot;receiveB2COrder&quot;&amp;gt; &amp;lt;soap:body use=&quot;literal&quot;/&amp;gt; &amp;lt;/wsdl:input&amp;gt; &amp;lt;wsdl:output name=&quot;receiveB2COrderResponse&quot;&amp;gt; &amp;lt;soap:body use=&quot;literal&quot;/&amp;gt; &amp;lt;/wsdl:output&amp;gt; &amp;lt;wsdl:fault name=&quot;MasAPIException&quot;&amp;gt; &amp;lt;soap:fault name=&quot;MasAPIException&quot; use=&quot;literal&quot;/&amp;gt; &amp;lt;/wsdl:fault&amp;gt; &amp;lt;/wsdl:operation&amp;gt; &amp;lt;/wsdl:binding&amp;gt; &amp;lt;wsdl:service name=&quot;ReceiveOrderAPIExplorterService&quot;&amp;gt; &amp;lt;wsdl:port binding=&quot;tns:ReceiveOrderAPIExplorterServiceSoapBinding&quot; name=&quot;ReceiveOrderAPIExplorterPort&quot;&amp;gt; &amp;lt;soap:address location=&quot;http://cardpay.shengpay.com/api-acquire-channel/services/receiveOrderService&quot;/&amp;gt; &amp;lt;/wsdl:port&amp;gt; &amp;lt;/wsdl:service&amp;gt;&amp;lt;/wsdl:definitions&amp;gt;参考 SOAP与WSDL详解 WS-Addressing - 维基百科" }, { "title": "XML命名空间", "url": "/posts/xml-namespace/", "categories": "技术", "tags": "xml, namespace, 命名空间", "date": "2021-02-23 09:00:00 +0800", "snippet": "xmlns 属性当在 XML 中使用前缀时，一个所谓的用于前缀的命名空间必须被定义。命名空间是在元素的开始标签的 xmlns 属性中定义的。命名空间声明的语法如下。xmlns:前缀=&quot;URI&quot;。 示例：&amp;lt;root&amp;gt;&amp;lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&amp;gt;&amp;lt;h:tr&amp;gt;&amp;lt;h:td&amp;gt;Apples&amp;lt;/h:td&amp;gt;&amp;lt;h:td&amp;gt;Bananas&amp;lt;/h:td&amp;gt;&amp;lt;/h:tr&amp;gt;&amp;lt;/h:table&amp;gt;&amp;lt;f:table xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&amp;gt;&amp;lt;f:name&amp;gt;African Coffee Table&amp;lt;/f:name&amp;gt;&amp;lt;f:width&amp;gt;80&amp;lt;/f:width&amp;gt;&amp;lt;f:length&amp;gt;120&amp;lt;/f:length&amp;gt;&amp;lt;/f:table&amp;gt;&amp;lt;/root&amp;gt;在上面的实例中，&amp;lt;table&amp;gt; 标签的 xmlns 属性定义了 h: 和 f: 前缀的合格命名空间。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。命名空间，可以在他们被使用的元素中或者在 XML 根元素中声明：&amp;lt;root xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;xmlns:f=&quot;http://www.w3cschool.cc/furniture&quot;&amp;gt;&amp;lt;h:table&amp;gt;&amp;lt;h:tr&amp;gt;&amp;lt;h:td&amp;gt;Apples&amp;lt;/h:td&amp;gt;&amp;lt;h:td&amp;gt;Bananas&amp;lt;/h:td&amp;gt;&amp;lt;/h:tr&amp;gt;&amp;lt;/h:table&amp;gt;&amp;lt;f:table&amp;gt;&amp;lt;f:name&amp;gt;African Coffee Table&amp;lt;/f:name&amp;gt;&amp;lt;f:width&amp;gt;80&amp;lt;/f:width&amp;gt;&amp;lt;f:length&amp;gt;120&amp;lt;/f:length&amp;gt;&amp;lt;/f:table&amp;gt;&amp;lt;/root&amp;gt; 注释：命名空间 URI 不会被解析器用于查找信息。其目的是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。请访问 http://www.w3.org/TR/html4/。统一资源标识符统一资源标识符（URI，全称 Uniform Resource Identifier），是一串可以标识因特网资源的字符。最常用的 URI 是用来标识因特网域名地址的统一资源定位器（URL）。另一个不那么常用的 URI 是统一资源命名（URN）。在我们的实例中，我们仅使用 URL。 注意URI和URL是不同的概念，URI是用于标识的，URL是一串链接，只不过URI常用URL作为表示显示默认的命名空间为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。它的语法如下：xmlns=&quot;namespaceURI&quot; 使用默认命名空间时，xmlns就无需指定命名空间名称，也不用在对应的标签前添加命名空间名称这个 XML 携带 HTML 表格的信息：&amp;lt;table xmlns=&quot;http://www.w3.org/TR/html4/&quot;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Apples&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;Bananas&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;这个XML携带有关一件家具的信息：&amp;lt;table xmlns=&quot;http://www.w3schools.com/furniture&quot;&amp;gt;&amp;lt;name&amp;gt;African Coffee Table&amp;lt;/name&amp;gt;&amp;lt;width&amp;gt;80&amp;lt;/width&amp;gt;&amp;lt;length&amp;gt;120&amp;lt;/length&amp;gt;&amp;lt;/table&amp;gt;参考 XML 命名空间（XML Namespaces）" }, { "title": "在移动硬盘上使用btrfs文件系统", "url": "/posts/btrfs-harddisk/", "categories": "技术", "tags": "btrfs, linux, 文件系统", "date": "2021-02-22 09:00:00 +0800", "snippet": "前言对于移动硬盘，在空间和便携性上取舍是个比较麻烦的问题，即想要便携又要大的存储空间时怎么办？这时就要考虑带有透明压缩的文件系统，btrfs就是个很好的选择，在拥有诸多现代文件系统特性的基础上增加了透明压缩功能，压缩率能达到50%以上，让移动硬盘能塞下更多文件但同时btrfs也是有缺陷的，就是主流的操作系统支持性并不好，Windows和Macos需要安装驱动，Linux4.14后的版本才可支持zstd压缩算法。介绍Btrfs（B-tree文件系统，通常念成Butter FS，Better FS或B-tree FS），一种支持写入时复制（COW）的文件系统，运行在Linux操作系统，采用GPL授权。Oracle于2007年对外宣布这项计划，并发布源代码，在2014年8月发布稳定版。目标是取代Linux目前的ext3文件系统，改善ext3的限制，特别是单个文件的大小，总文件系统大小或文件检查和加入ext3未支持的功能，像是可写快照（writable snapshots）、快照的快照（snapshots of snapshots）、内建磁盘阵列（RAID），以及子卷（subvolumes）。Btrfs也宣称专注在“容错、修复及易于管理”。btrfs特性 联机碎片整理 联机卷生长和收缩 联机块设备增加和删除 联机负载均衡（块设备间的对象移动以达到平衡） 文件系统级的镜像（类RAID-1）、条带（类RAID-0） 子卷（一个或多个单独可挂载基于每个物流分区） 透明压缩（目前支持zlib、LZO和ZSTD (从 4.14 开始支持)） 快照（只读和可写，写复制，子卷复制） 文件克隆 数据和元数据的校验和（目前是CRC-32C） 就地转换（带回滚）ext3/4 文件系统种子 用户定义的事务 块丢弃支持分区fdisk /dev/sdb&amp;gt;Command (m for help): n&amp;gt;Command action #这里可以选择是作为扩展分区还是主分区。这里作为主分区，则选择pe extendedp primary partition (1-4)p&amp;gt;Partition number (1-4): 1 #做第一块主分区&amp;gt;First cylinder (1-130, default 1):Using default value 1&amp;gt;Last cylinder, +cylinders or +size{K,M,G} (1-130, default 130): +500M #分区大小为K，M，G。制作分区的大小，这里选择第一块分区大小为500M&amp;gt;Command (m for help): p #输入p可以查看刚才分区的情况Disk /dev/sdb: 1073 MB, 1073741824 bytes255 heads, 63 sectors/track, 130 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x06194404Device Boot Start End Blocks Id System/dev/sdb1 1 65 522081 83 Linux&amp;gt;Command (m for help): w # 最好输入w 保存我们刚才从sdb分区出来的sdb1The partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.格式化使用mkfs.btrfs命令格式化分区:mkfs.btrfs /dev/sdb1挂载获取UUID:lsblk -f修改/etc/fstab:UUID=f4f459e9-48df-445e-94f1-96c98a68e78e /mnt/btrfs btrfs defaults,noauto,nofail,noatime,compress-force=zstd:1 0 0 noatime已经包含了nodiratime，不用同时指定 zstd:1表示使用level1的zstd压缩算法，较为快速，不同level压缩率差距很小，详见BTRFS ZSTD level compression benchmark使用mount命令挂载:mount /mnt/btrfscompress-force与compress 使用compress-force可以带来更高的压缩比，但会影响性能 compress的采样算法在4.15有优化，但没有实质变化 经过实测，19092520KB的原始数据在两种策略下的压缩率实际表现如下: raw compress compress-force 19092520 11827572 11532752 压缩算法Btrfs文件系统目前支持ZLIB、LZO、ZSTD(从 4.14 开始支持)算法，ZSTD是目前btrfs最好的压缩策略参考 Btrfs (简体中文) - ArchWiki Linux使用fdisk创建分区详解" }, { "title": "HTTPS双向认证原理与测试环境搭建", "url": "/posts/mutual-authentication/", "categories": "技术", "tags": "SSL, 双向认证, goahead, HTTPS", "date": "2021-01-22 09:00:00 +0800", "snippet": "原理双向认证(mutual authentication)，顾名思义，客户端和服务器端都需要验证对方的身份，在建立 HTTPS 连接的过程中，握手的流程比单向认证多了几步。单向认证的过程，客户端从服务器端下载服务器端公钥证书进行验证，然后建立安全通信通道。双向通信流程，客户端除了需要从服务器端下载服务器的公钥证书进行验证外，还需要把客户端的公钥证书上传到服务器端给服务器端进行验证，等双方都认证通过了，才开始建立安全通信通道进行数据传输。本文所提到的认证流程都是基于RSA的方式，TLS1.0还支持DH(Diffie-Hellman)方式认证，详见《传输层安全(TLS)相关技术详解》单向认证流程(RSA)单向认证流程中，服务器端保存着公钥证书和私钥两个文件，整个握手过程如下： 客户端发起建立 HTTPS 连接请求，将 SSL 协议版本的信息发送给服务器端； 服务器端将本机的公钥证书（server.crt）发送给客户端； 客户端读取公钥证书 (server.crt)，取出了服务端公钥； 客户端生成一个随机数（密钥 R），用刚才得到的服务器公钥去加密这个随机数形成密文，发送给服务端； 服务端用自己的私钥 (server.key) 去解密这个密文，得到了密钥 R 服务端和客户端在后续通讯过程中就使用这个密钥R进行通信了双向认证流程(RSA) 客户端发起建立 HTTPS 连接请求，将 SSL 协议版本的信息发送给服务端； 服务器端将本机的公钥证书 (server.crt) 发送给客户端； 客户端读取公钥证书 (server.crt)，取出了服务端公钥； 客户端将客户端公钥证书 (client.crt) 发送给服务器端； 服务器端解密客户端公钥证书，拿到客户端公钥； 客户端发送自己支持的加密方案给服务器端； 服务器端根据自己和客户端的能力，选择一个双方都能接受的加密方案，使用客户端的公钥加密后发送给客户端； 客户端使用自己的私钥解密加密方案，生成一个随机数 R，使用服务器公钥加密后传给服务器端； 服务端用自己的私钥去解密这个密文，得到了密钥 R 服务端和客户端在后续通讯过程中就使用这个密钥R进行通信了。证书生成使用openssl生成CA自签名根证书 使用以下命令生成无密码的2048位rsa密钥 openssl genrsa -out ca.key 2048 或加上-des3命令生成使用des3算法加密的rsa密钥 openssl genrsa -des3 -out ca.key 2048 生成x509格式的CA自签名根证书 openssl req -new -x509 -days 365 -key ca.key -out ca.crt 依次填入csr信息，Common Name表示颁发者 Country Name (2 letter code) [AU]:CN State or Province Name (full name) [Some-State]:zhejiang Locality Name (eg, city) []:ningbo Organization Name (eg, company) [Internet Widgits Pty Ltd]:SX Organizational Unit Name (eg, section) []:tech Common Name (e.g. server FQDN or YOUR name) []:test Email Address []: 至此，CA自签名根证书已生成完成，后续需要用到CA密钥和证书签发子证书，注意密钥的保存与保密签发客户端证书 使用以下命令生成无密码的2048位rsa密钥 openssl genrsa -out client.key 2048 或加上-des3命令生成使用des3算法加密的rsa密钥 openssl genrsa -des3 -out client.key 2048 生成客户端csr文件 openssl req -new -key client.key -out client.csr 依次填入csr信息，Common Name表示使用者，不能与颁发者相同 Country Name (2 letter code) [AU]:CN State or Province Name (full name) [Some-State]:zhejiang Locality Name (eg, city) []:ningbo Organization Name (eg, company) [Internet Widgits Pty Ltd]:SX Organizational Unit Name (eg, section) []:tech Common Name (e.g. server FQDN or YOUR name) []:client1 Email Address []: Please enter the following &#39;extra&#39; attributes to be sent with your certificate request A challenge password []:147258369 An optional company name []:sanxing 使用CA签发客户端x509证书 openssl x509 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt 将客户端密钥和证书打包成pfx文件，用于浏览器或系统导入 openssl pkcs12 -export -out client.pfx -inkey client.key -in client.crt 或加上CA证书保证证书被信任 openssl pkcs12 -export -out client.pfx -inkey client.key -in client.crt -certfile ca.crt 签发服务端证书 服务端证书生成过程与客户端相同，此处不再赘述证书部署本次配置以GoAhead-openssl为例，GoAhead还能使用mbedtls实现https，这里不做介绍，关于GoAhead的介绍如下： GoAhead is the world’s most popular, tiny embedded web server. It is compact, secure and simple to use. GoAhead is deployed in hundreds of millions of devices and is ideal for the smallest of embedded devices.以上步骤完成后，将会生成如下文件：ca.key ca.crt client.crt client.key client.pfx server.key server.crt (可选)server.key和server.crt部署在服务器证书路径下 对于GoAhead，ca.crt需部署在服务器证书路径下，用于验证客户端证书 client.pfx安装到客户端，windows下直接下一步默认即可配置GoAhead客户端证书认证功能 将me.h中的宏ME_GOAHEAD_SSL_VERIFY_PEER置为1，启用客户端证书认证 将me.h中的宏ME_GOAHEAD_SSL_AUTHORITY配置为CA证书的绝对路径，用于校验客户端证书 重新编译GoAhead库与服务端程序测试windows客户端安装完客户端证书后访问服务端，此时浏览器会提示选择客户端证书，选择证书后能正常访问，如证书错误或未提供证书则访问失败，即测试通过参考 巧用 Nginx 快速实现 HTTPS 双向认证 Using Client-Certificate based authentication with NGINX on Ubuntu" }, { "title": "我的第一篇博客", "url": "/posts/first-blog/", "categories": "浮世杂谈", "tags": "生活", "date": "2021-01-21 00:00:00 +0800", "snippet": "此刻，新生" } ]
