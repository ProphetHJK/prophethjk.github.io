<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://hjk.life/</id><title>普通人</title><subtitle>技术类博客，[计算机]、[嵌入式]、[互联网]、[Linux]...</subtitle> <updated>2022-10-24T16:57:19+08:00</updated> <author> <name>Jinkai</name> <uri>https://hjk.life/</uri> </author><link rel="self" type="application/atom+xml" href="https://hjk.life/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://hjk.life/"/> <generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator> <rights> © 2022 Jinkai </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>C语言中的const</title><link href="https://hjk.life/posts/const-c/" rel="alternate" type="text/html" title="C语言中的const" /><published>2022-09-21T09:00:00+08:00</published> <updated>2022-10-11T17:28:07+08:00</updated> <id>https://hjk.life/posts/const-c/</id> <content src="https://hjk.life/posts/const-c/" /> <author> <name>Jinkai</name> </author> <category term="学习笔记" /> <summary> 定义 const 将修饰离它最近的对象（优先左边） 解释 Bjarne 在他的《The C++ Programming Language》里面给出过一个助记的方法 “以 * 分界，把一个声明从右向左读”。 注意语法，* 读作 pointer to (指向…的指针)，const (常量) 是形容词，char (变量类型) 和 p (变量名) 当然都是名词。 const char * p 读作：p is a pointer to a const char，译：p 是一个指针(变量)，它指向一个常量字符(const char)。就是 p 能修改，p 指向内容不能修改 char * const p 读作：p is a const pointer to a char，译：p 是一个常量指针(const p)，它指向一个字符(变量)。就是 p 不... </summary> </entry> <entry><title>面向对象编程(OOP)的C语言实现</title><link href="https://hjk.life/posts/c-oop/" rel="alternate" type="text/html" title="面向对象编程(OOP)的C语言实现" /><published>2022-09-05T09:00:00+08:00</published> <updated>2022-10-10T17:25:39+08:00</updated> <id>https://hjk.life/posts/c-oop/</id> <content src="https://hjk.life/posts/c-oop/" /> <author> <name>Jinkai</name> </author> <category term="学习笔记" /> <summary> 前言 阅读本文章前首先要具备一定的面向对象编程基础 面向对象特性 面向对象编程 （Object-oriented programming，OOP） 是一种基于以下三个基本概念的设计方式： 封装(Encapsulation) 将数据和函数打包到类中的能力 继承(Inheritance) 基于现有类定义新类的能力，以获得重用和代码组织 多态(Polymorphism) 在运行时将匹配接口的对象相互替换的能力 封装 即对调用者隐藏实现和非必要的内部属性 要点： 头文件(.h)与实现文件(.c)分离，调用者只需引入头文件 用函数封装对对象内部变量的修改和获取，调用者只需关注函数参数和返回值 shape.h: #ifndef SHAPE_H #define SHAPE_H /* Shape's attributes... */ ty... </summary> </entry> <entry><title>为ipv4 only设备添加ipv6支持</title><link href="https://hjk.life/posts/ipv6-over-ipv4/" rel="alternate" type="text/html" title="为ipv4 only设备添加ipv6支持" /><published>2022-08-08T09:00:00+08:00</published> <updated>2022-08-08T09:00:00+08:00</updated> <id>https://hjk.life/posts/ipv6-over-ipv4/</id> <content src="https://hjk.life/posts/ipv6-over-ipv4/" /> <author> <name>Jinkai</name> </author> <category term="学习笔记" /> <summary> HE-tunnel 使用HE的IPv6隧道解决访问谷歌Google时提示异常流量 CloudFlare-WARP WARP一键安装脚本 安装sock代理或ipv6隧道 WARP最强的地方在于网络环境非常好，远比HE-tunnel和Tor稳定 Tor apt install tor 默认开启sock代理，端口9050，可通过修改/etc/tor/torrc文件修改端口 如果无法连接tor服务器，需要修改/etc/tor/torrc文件添加代理 参考 使用HE的IPv6隧道解决访问谷歌Google时提示异常流量 WARP一键安装脚本 </summary> </entry> <entry><title>《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记</title><link href="https://hjk.life/posts/quantum-platform-1/" rel="alternate" type="text/html" title="《UML 状态图的实用 C/C++设计》(QP状态机)学习笔记" /><published>2022-07-27T09:00:00+08:00</published> <updated>2022-10-24T16:56:10+08:00</updated> <id>https://hjk.life/posts/quantum-platform-1/</id> <content src="https://hjk.life/posts/quantum-platform-1/" /> <author> <name>Jinkai</name> </author> <category term="学习笔记" /> <summary> 架构 控制的倒置 (Inversion of Control) UML 状态机速成 基本的状态机概念 状态 状态图 事件 (Event) 动作和转换 (Action and Transition) 运行-到-完成执行模型 (Run-to-Completion Execution Model, RTC) UML 对传统 FSM 方法的扩展 状态机分类 行为继承 (Behavioral Inheritance) 状态的 LISKOV 替换原则 (LSP) 正交区域... </summary> </entry> <entry><title>《Operating Systems: Three Easy Pieces》学习笔记(三十七) 分布式系统、远程过程调用（RPC）</title><link href="https://hjk.life/posts/operating-systems-37/" rel="alternate" type="text/html" title="《Operating Systems: Three Easy Pieces》学习笔记(三十七) 分布式系统、远程过程调用（RPC）" /><published>2022-06-20T09:00:00+08:00</published> <updated>2022-06-20T13:09:19+08:00</updated> <id>https://hjk.life/posts/operating-systems-37/</id> <content src="https://hjk.life/posts/operating-systems-37/" /> <author> <name>Jinkai</name> </author> <category term="学习笔记" /> <summary> 远程过程调用（RPC） 最主要的抽象是基于远程过程调用（Remote Procedure Call），或简称 RPC 远程过程调用包都有一个简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单直接 RPC 系统通常有两部分：存根生成器（stub generator，有时称为协议编译器，protocol compiler）和运行时库（run-time library）。 存根生成器 通过自动化，消除将函数参数和结果打包成消息的一些痛苦。 interface { int func1(int arg1); int func2(int arg1, int arg2); }; 存根生成器类似于写好接口文档，自动生成一个头文件，可以被其他函数调用。 在内部，客户端存根中的每个函数都执行远程过程调用所需的所有工作。对于客户端，代码只是作为函数调用出现（例... </summary> </entry> </feed>
